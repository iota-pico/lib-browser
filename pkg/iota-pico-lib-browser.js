(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("big-integer"));
	else if(typeof define === 'function' && define.amd)
		define("@iota-pico/lib-browser", ["big-integer"], factory);
	else if(typeof exports === 'object')
		exports["@iota-pico/lib-browser"] = factory(require("big-integer"));
	else
		root["IotaPico"] = factory(root["bigInt"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_38__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 52);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Object helper methods.
 */

var ObjectHelper =
/*#__PURE__*/
function () {
  function ObjectHelper() {
    _classCallCheck(this, ObjectHelper);
  }

  _createClass(ObjectHelper, null, [{
    key: "isEmpty",

    /**
     * Is the value empty.
     * @param value Object to test.
     * @returns True if the value is empty.
     */
    value: function isEmpty(value) {
      return value === null || value === undefined;
    }
    /**
     * Is the value an object.
     * @param value Object to test.
     * @returns True if the value is an object.
     */

  }, {
    key: "isObject",
    value: function isObject(value) {
      return value === null || value === undefined ? false : _typeof(value) === "object" && !Array.isArray(value);
    }
    /**
     * Is the value an object if given type.
     * @param value Object to test.
     * @param type The type of the object
     * @returns True if the value is an object of the specified type.
     */

  }, {
    key: "isType",
    value: function isType(value, typeConstructor) {
      var valueClassName = ObjectHelper.getClassName(value);
      return valueClassName !== undefined && valueClassName === ObjectHelper.getClassName(typeConstructor);
    }
    /**
     * Get the class name of an object if it has one.
     * @param object The object to get the class name for.
     * @returns The class name if it has one or undefined if not.
     */

  }, {
    key: "getClassName",
    value: function getClassName(object) {
      if (object === null || object === undefined) {
        return undefined;
      } else {
        var _constructor = typeof object === "function" ? object.toString() : object.constructor.toString();

        var results = _constructor.match(/\w+/g);

        return results && results.length > 1 ? results[1] : undefined;
      }
    }
  }]);

  return ObjectHelper;
}();

exports.ObjectHelper = ObjectHelper;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(2);

var stringHelper_1 = __webpack_require__(6);

var dataError_1 = __webpack_require__(3);
/**
 * A class for handling trytes.
 */


var Trytes =
/*#__PURE__*/
function () {
  /* @internal */
  function Trytes(trytes) {
    _classCallCheck(this, Trytes);

    this._trytes = trytes;
  }
  /**
   * Create trytes from a string.
   * @param value A string to create the trytes from.
   * @param length An optional validation length for the trytes, 0 means ignore length.
   * @returns An instance of Trytes.
   */


  _createClass(Trytes, [{
    key: "toString",

    /**
     * Convert the trytes to a string.
     * @returns String representation of the trytes.
     */
    value: function toString() {
      return this._trytes;
    }
    /**
     * Get the length of the trytes.
     * @returns The length of the trytes.
     */

  }, {
    key: "length",
    value: function length() {
      return this._trytes.length;
    }
    /**
     * Get a sub of the trytes.
     * @param start The start position to get the sub.
     * @param length The length of the sub.
     * @returns The trytes sub.
     */

  }, {
    key: "sub",
    value: function sub(start, length) {
      if (!numberHelper_1.NumberHelper.isInteger(start) || start < 0) {
        throw new dataError_1.DataError("The start must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || start + length > this._trytes.length) {
        throw new dataError_1.DataError("The start + length must <= ".concat(this._trytes.length));
      }

      return Trytes.fromString(this._trytes.substr(start, length));
    }
  }], [{
    key: "fromString",
    value: function fromString(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (!stringHelper_1.StringHelper.isString(value)) {
        throw new dataError_1.DataError("The value must be a non empty string");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new dataError_1.DataError("The length must be >= 0");
      }

      if (!Trytes.isValid(value, length)) {
        throw new dataError_1.DataError("The value and length do not contain valid trytes", {
          value: value,
          length: length
        });
      }

      return new Trytes(value);
    }
    /**
     * Does the value contain valid trytes.
     * @param value A string to validate as trytes.
     * @param length An optional validation length for the trytes, 0 means ignore length.
     * @returns True if the input was valid trytes.
     */

  }, {
    key: "isValid",
    value: function isValid(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (!stringHelper_1.StringHelper.isString(value)) {
        return false;
      } else {
        return new RegExp("^[9A-Z]{".concat(length ? length : "0,", "}$")).test(value);
      }
    }
  }]);

  return Trytes;
}();
/**
 * All the characters that can be used in trytes.
 */


Trytes.ALPHABET = "9ABCDEFGHIJKLMNOPQRSTUVWXYZ";
exports.Trytes = Trytes;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Number helper methods.
 */

var NumberHelper =
/*#__PURE__*/
function () {
  function NumberHelper() {
    _classCallCheck(this, NumberHelper);
  }

  _createClass(NumberHelper, null, [{
    key: "isInteger",

    /**
     * Is the value an integer.
     * @param value Object to test for its integerness.
     * @returns True if the object is a integer.
     */
    value: function isInteger(value) {
      return Number.isInteger(value) && !Number.isNaN(value) && Number.isFinite(value);
    }
    /**
     * Is the value a number.
     * @param value Object to test for its numberyness.
     * @returns True if the object is a number.
     */

  }, {
    key: "isNumber",
    value: function isNumber(value) {
      return value !== undefined && value !== null && typeof value === "number" && !Number.isNaN(value) && Number.isFinite(value);
    }
    /**
     * Is the value a float number formatted as a string, can be used for big numbers that would overflow parseFloat.
     * @param value The value to check
     * @return True if the number is formatted correctly.
     */

  }, {
    key: "isFloatString",
    value: function isFloatString(value) {
      return /^-?\d*\.?\d+$/.test(value);
    }
    /**
     * Is the value a integer number formatted as a string, can be used for big numbers that would overflow parseInt.
     * @param value The value to check
     * @return True if the number is formatted correctly.
     */

  }, {
    key: "isIntegerString",
    value: function isIntegerString(value) {
      return /^-?\d+$/.test(value);
    }
  }]);

  return NumberHelper;
}();

exports.NumberHelper = NumberHelper;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var coreError_1 = __webpack_require__(11);
/**
 * A data implementation of an error.
 */


var DataError =
/*#__PURE__*/
function (_coreError_1$CoreErro) {
  _inherits(DataError, _coreError_1$CoreErro);

  /**
   * Create an instance of DataError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function DataError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, DataError);

    _this = _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).call(this, message, additional, innerError));
    _this.domain = "Data";
    return _this;
  }

  return DataError;
}(coreError_1.CoreError);

exports.DataError = DataError;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(0);
/**
 * Array helper methods.
 */


var ArrayHelper =
/*#__PURE__*/
function () {
  function ArrayHelper() {
    _classCallCheck(this, ArrayHelper);
  }

  _createClass(ArrayHelper, null, [{
    key: "isArray",

    /**
     * Is the value an array.
     * @param value Object to test.
     * @returns True if the value is an array.
     */
    value: function isArray(value) {
      return value === null || value === undefined ? false : Array.isArray(value);
    }
    /**
     * Is the value a empty array.
     * @param value Object to test.
     * @returns True if the value is a empty array.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty(value) {
      return !ArrayHelper.isArray(value) || value.length === 0;
    }
    /**
     * Is the value a non empty array of specific type.
     * @param value Object to test.
     * @param type The type of the object
     * @returns True if the value is a non empty array of a specific type.
     */

  }, {
    key: "isTyped",
    value: function isTyped(value, type) {
      return !ArrayHelper.isEmpty(value) && !value.includes(undefined) && !value.includes(null) && value.every(function (a) {
        return objectHelper_1.ObjectHelper.isType(a, type);
      });
    }
  }]);

  return ArrayHelper;
}();

exports.ArrayHelper = ArrayHelper;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var coreError_1 = __webpack_require__(11);
/**
 * A crypto implementation of an error.
 */


var CryptoError =
/*#__PURE__*/
function (_coreError_1$CoreErro) {
  _inherits(CryptoError, _coreError_1$CoreErro);

  /**
   * Create an instance of CryptoError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function CryptoError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, CryptoError);

    _this = _possibleConstructorReturn(this, (CryptoError.__proto__ || Object.getPrototypeOf(CryptoError)).call(this, message, additional, innerError));
    _this.domain = "Crypto";
    return _this;
  }

  return CryptoError;
}(coreError_1.CoreError);

exports.CryptoError = CryptoError;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * String helper methods.
 */

var StringHelper =
/*#__PURE__*/
function () {
  function StringHelper() {
    _classCallCheck(this, StringHelper);
  }

  _createClass(StringHelper, null, [{
    key: "isString",

    /**
     * Is the value a string.
     * @param value Object to test for its stringyness.
     * @returns True if the object is a string.
     */
    value: function isString(value) {
      return value === null || value === undefined ? false : Object.prototype.toString.call(value) === "[object String]";
    }
    /**
     * Is the value a string that is empty.
     * @param value Object to test for its no emptyness.
     * @returns True if the object is an empty string.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty(value) {
      return !StringHelper.isString(value) || value.length === 0;
    }
    /**
     * Is the string all ASCII characters.
     * @param value string to test if is is ASCII.
     * @returns True if the object is all ASCII.
     */

  }, {
    key: "isAscii",
    value: function isAscii(value) {
      return value === null || value === undefined ? false : /^[\x00-\xFF]*$/.test(value);
    }
    /**
     * Encode non ASCII characters with control characters.
     * @param value The string value to escape.
     * @returns The escaped version of the string.
     */

  }, {
    key: "encodeNonASCII",
    value: function encodeNonASCII(value) {
      return StringHelper.isString(value) ? value.replace(/[\u007F-\uFFFF]/g, function (chr) {
        return "\\u".concat("0000".concat(chr.charCodeAt(0).toString(16)).substr(-4));
      }) : undefined;
    }
    /**
     * Decode control characters to ASCII.
     * @param value The encoded string to convert back to ASCII.
     * @returns The decoded version of the string.
     */

  }, {
    key: "decodeNonASCII",
    value: function decodeNonASCII(value) {
      return StringHelper.isString(value) ? value.replace(/\\u([\d\w]{4})/gi, function (match, grp) {
        return String.fromCharCode(parseInt(grp, 16));
      }) : undefined;
    }
  }]);

  return StringHelper;
}();

exports.StringHelper = StringHelper;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(4);

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var dataError_1 = __webpack_require__(3);

var trytes_1 = __webpack_require__(1);
/**
 * A class for handling trits.
 */


var Trits =
/*#__PURE__*/
function () {
  /* @internal */
  function Trits(trits) {
    _classCallCheck(this, Trits);

    this._trits = trits;
  }
  /**
   * Create instance of trits from Int8Array array.
   * @param value Trytes used to create trits.
   * @returns An instance of Trits.
   */


  _createClass(Trits, [{
    key: "toArray",

    /**
     * Get the value of the trits array.
     * @returns Array representation of the trits.
     */
    value: function toArray() {
      return this._trits;
    }
    /**
     * Get the value of the trits array as a number array.
     * @returns Array representation of the trits.
     */

  }, {
    key: "toNumberArray",
    value: function toNumberArray() {
      return Array.from(this._trits);
    }
    /**
     * Get the trits as trytes.
     * @returns Instance of Trytes.
     */

  }, {
    key: "toTrytes",
    value: function toTrytes() {
      var trytes = "";

      for (var i = 0; i < this._trits.length; i += 3) {
        // Iterate over all possible tryte values to find correct trit representation
        for (var j = 0; j < trytes_1.Trytes.ALPHABET.length; j++) {
          if (Trits.TRYTES_TRITS[j][0] === this._trits[i] && Trits.TRYTES_TRITS[j][1] === this._trits[i + 1] && Trits.TRYTES_TRITS[j][2] === this._trits[i + 2]) {
            trytes += trytes_1.Trytes.ALPHABET.charAt(j);
            break;
          }
        }
      }

      return trytes_1.Trytes.fromString(trytes);
    }
    /**
     * Get the trits as a number.
     * @returns The trits converted to a number.
     */

  }, {
    key: "toNumber",
    value: function toNumber() {
      var returnValue = 0;

      for (var i = this._trits.length - 1; i >= 0; i--) {
        returnValue = returnValue * 3 + this._trits[i];
      }

      return returnValue;
    }
    /**
     * What is the length of the trits.
     * @returns Length of the trits.
     */

  }, {
    key: "length",
    value: function length() {
      return this._trits.length;
    }
    /**
     * Get a sub of the trits.
     * @param start The start position to get the sub.
     * @param length The length of the sub.
     * @returns The trits sub.
     */

  }, {
    key: "sub",
    value: function sub(start, length) {
      if (!numberHelper_1.NumberHelper.isInteger(start) || start < 0) {
        throw new dataError_1.DataError("The start must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || start + length > this._trits.length) {
        throw new dataError_1.DataError("The start + length must <= ".concat(this._trits.length));
      }

      return Trits.fromArray(this._trits.slice(start, start + length));
    }
  }], [{
    key: "fromArray",
    value: function fromArray(value) {
      if (!objectHelper_1.ObjectHelper.isType(value, Int8Array)) {
        throw new dataError_1.DataError("The value does not contain valid trits");
      }

      return new Trits(value);
    }
    /**
     * Create instance of trits from number array.
     * @param value Trytes used to create trits.
     * @returns An instance of Trits.
     */

  }, {
    key: "fromNumberArray",
    value: function fromNumberArray(value) {
      if (!arrayHelper_1.ArrayHelper.isTyped(value, Number)) {
        throw new dataError_1.DataError("The value does not contain valid trits");
      }

      return new Trits(new Int8Array(value));
    }
    /**
     * Create instance of trits from trytes.
     * @param value Trytes used to create trits.
     * @returns An instance of Trits.
     */

  }, {
    key: "fromTrytes",
    value: function fromTrytes(value) {
      if (!objectHelper_1.ObjectHelper.isType(value, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The value should be a valid Trytes object");
      }

      var trytesString = value.toString();
      var trits = new Int8Array(trytesString.length * 3);

      for (var i = 0; i < trytesString.length; i++) {
        var idx = trytes_1.Trytes.ALPHABET.indexOf(trytesString.charAt(i));
        trits[i * 3] = Trits.TRYTES_TRITS[idx][0];
        trits[i * 3 + 1] = Trits.TRYTES_TRITS[idx][1];
        trits[i * 3 + 2] = Trits.TRYTES_TRITS[idx][2];
      }

      return new Trits(trits);
    }
    /**
     * Create instance of trits from number
     * @param value Number used to create trits.
     * @returns An instance of Trits.
     */

  }, {
    key: "fromNumber",
    value: function fromNumber(value) {
      if (!numberHelper_1.NumberHelper.isInteger(value)) {
        throw new dataError_1.DataError("The value is not an integer");
      }

      var trits = [];
      var absoluteValue = value < 0 ? -value : value;

      while (absoluteValue > 0) {
        var remainder = absoluteValue % 3;
        absoluteValue = Math.floor(absoluteValue / 3);

        if (remainder > 1) {
          remainder = -1;
          absoluteValue++;
        }

        trits[trits.length] = remainder;
      }

      if (value < 0) {
        for (var i = 0; i < trits.length; i++) {
          trits[i] = -trits[i];
        }
      }

      return new Trits(new Int8Array(trits));
    }
    /**
     * Add two trits together.
     * @param first The first trit.
     * @param second The second trit.
     * @return New trit which is the addition of the a + b.
     */

  }, {
    key: "add",
    value: function add(first, second) {
      if (!objectHelper_1.ObjectHelper.isType(first, Trits)) {
        throw new dataError_1.DataError("The first should be a valid Trits object");
      }

      if (!objectHelper_1.ObjectHelper.isType(second, Trits)) {
        throw new dataError_1.DataError("The seconds should be a valid Trits object");
      }

      var out = new Int8Array(Math.max(first._trits.length, second._trits.length));
      var carry = 0;
      var iA;
      var iB;

      for (var i = 0; i < out.length; i++) {
        iA = i < first._trits.length ? first._trits[i] : 0;
        iB = i < second._trits.length ? second._trits[i] : 0;
        var fA = Trits.fullAdd(iA, iB, carry);
        out[i] = fA[0];
        carry = fA[1];
      }

      return Trits.fromArray(out);
    }
    /* @internal */

  }, {
    key: "fullAdd",
    value: function fullAdd(a, b, c) {
      var sA = Trits.sum(a, b);
      var cA = Trits.cons(a, b);
      var cB = Trits.cons(sA, c);
      var cOut = Trits.any(cA, cB);
      var sOUt = Trits.sum(sA, c);
      return new Int8Array([sOUt, cOut]);
    }
    /* @internal */

  }, {
    key: "sum",
    value: function sum(a, b) {
      var s = a + b;

      switch (s) {
        case 2:
          return -1;

        case -2:
          return 1;

        default:
          return s;
      }
    }
    /* @internal */

  }, {
    key: "cons",
    value: function cons(a, b) {
      if (a === b) {
        return a;
      }

      return 0;
    }
    /* @internal */

  }, {
    key: "any",
    value: function any(a, b) {
      var s = a + b;

      if (s > 0) {
        return 1;
      } else if (s < 0) {
        return -1;
      }

      return 0;
    }
  }]);

  return Trits;
}();
/* @internal */


Trits.TRYTES_TRITS = [new Int8Array([0, 0, 0]), new Int8Array([1, 0, 0]), new Int8Array([-1, 1, 0]), new Int8Array([0, 1, 0]), new Int8Array([1, 1, 0]), new Int8Array([-1, -1, 1]), new Int8Array([0, -1, 1]), new Int8Array([1, -1, 1]), new Int8Array([-1, 0, 1]), new Int8Array([0, 0, 1]), new Int8Array([1, 0, 1]), new Int8Array([-1, 1, 1]), new Int8Array([0, 1, 1]), new Int8Array([1, 1, 1]), new Int8Array([-1, -1, -1]), new Int8Array([0, -1, -1]), new Int8Array([1, -1, -1]), new Int8Array([-1, 0, -1]), new Int8Array([0, 0, -1]), new Int8Array([1, 0, -1]), new Int8Array([-1, 1, -1]), new Int8Array([0, 1, -1]), new Int8Array([1, 1, -1]), new Int8Array([-1, -1, 0]), new Int8Array([0, -1, 0]), new Int8Array([1, -1, 0]), new Int8Array([-1, 0, 0])];
exports.Trits = Trits;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(0);

var dataError_1 = __webpack_require__(3);

var trytes_1 = __webpack_require__(1);
/**
 * A class for handling addresses.
 */


var Address =
/*#__PURE__*/
function () {
  /* @internal */
  function Address(addressTrytes, checksumTrytes) {
    _classCallCheck(this, Address);

    this._addressTrytes = addressTrytes;
    this._checksumTrytes = checksumTrytes;
  }
  /**
   * Create address from trytes.
   * @param address The trytes to create the address from.
   * @returns An instance of Address.
   */


  _createClass(Address, [{
    key: "toTrytes",

    /**
     * Convert the address to trytes with no checksum.
     * @returns Trytes version of the address with no checksum.
     */
    value: function toTrytes() {
      return trytes_1.Trytes.fromString(this._addressTrytes);
    }
    /**
     * Convert the address to trytes with a checksum, creating a blank one if needed.
     * @returns Trytes version of the address with checksu,.
     */

  }, {
    key: "toTrytesWithChecksum",
    value: function toTrytesWithChecksum() {
      if (!objectHelper_1.ObjectHelper.isEmpty(this._checksumTrytes)) {
        return trytes_1.Trytes.fromString(this._addressTrytes + this._checksumTrytes);
      } else {
        throw new dataError_1.DataError("This address has no checksum calculated for it");
      }
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      if (!objectHelper_1.ObjectHelper.isEmpty(this._checksumTrytes)) {
        return this._addressTrytes + this._checksumTrytes;
      } else {
        return this._addressTrytes;
      }
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(address) {
      if (!objectHelper_1.ObjectHelper.isType(address, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The address should be a valid Trytes object");
      }

      var trytesString = address.toString();

      if (trytesString.length !== Address.LENGTH && trytesString.length !== Address.LENGTH_WITH_CHECKSUM) {
        throw new dataError_1.DataError("The address should either be ".concat(Address.LENGTH, " or ").concat(Address.LENGTH_WITH_CHECKSUM, " characters in length"), {
          length: trytesString.length
        });
      }

      var addressTrytes = trytesString.substr(0, Address.LENGTH);
      var checksumTrytes;

      if (trytesString.length === Address.LENGTH_WITH_CHECKSUM) {
        checksumTrytes = trytesString.substr(Address.LENGTH);
      }

      return new Address(addressTrytes, checksumTrytes);
    }
  }]);

  return Address;
}();
/**
 * The length for a valid address without checksum (81).
 */


Address.LENGTH = 81;
/**
 * The length for an address checksum (9).
 */

Address.LENGTH_CHECKSUM = 9;
/**
 * The length for valid address with checksum (90).
 */

Address.LENGTH_WITH_CHECKSUM = Address.LENGTH + Address.LENGTH_CHECKSUM;
/**
 * An empty hash all 9s.
 */

Address.EMPTY = Address.fromTrytes(trytes_1.Trytes.fromString("9".repeat(Address.LENGTH)));
exports.Address = Address;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(0);

var dataError_1 = __webpack_require__(3);

var trytes_1 = __webpack_require__(1);
/**
 * A class for handling hashes.
 */


var Hash =
/*#__PURE__*/
function () {
  /* @internal */
  function Hash(trytes) {
    _classCallCheck(this, Hash);

    this._trytes = trytes;
  }
  /**
   * Create hash from trytes.
   * @param hash The trytes to create the hash from.
   * @returns An instance of Hash.
   */


  _createClass(Hash, [{
    key: "toTrytes",

    /**
     * Convert the hash to trytes.
     * @returns Trytes version of the hash.
     */
    value: function toTrytes() {
      return this._trytes;
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes.toString();
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(hash) {
      if (!objectHelper_1.ObjectHelper.isType(hash, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The hash should be a valid Trytes object");
      }

      var length = hash.length();

      if (length !== Hash.LENGTH) {
        throw new dataError_1.DataError("The hash should be ".concat(Hash.LENGTH, " characters in length"), {
          length: length
        });
      }

      return new Hash(hash);
    }
  }]);

  return Hash;
}();
/**
 * The length for a valid hash (81).
 */


Hash.LENGTH = 81;
/**
 * An empty hash all 9s.
 */

Hash.EMPTY = Hash.fromTrytes(trytes_1.Trytes.fromString("9".repeat(Hash.LENGTH)));
exports.Hash = Hash;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var factoryBase_1 = __webpack_require__(17);

var curl_1 = __webpack_require__(35);

var kerl_1 = __webpack_require__(36);
/**
 * Factory to generate sponges.
 */


var SpongeFactory =
/*#__PURE__*/
function (_factoryBase_1$Factor) {
  _inherits(SpongeFactory, _factoryBase_1$Factor);

  /**
   * Don't allow manual construction of the factory.
   * @internal
   */
  function SpongeFactory() {
    _classCallCheck(this, SpongeFactory);

    return _possibleConstructorReturn(this, (SpongeFactory.__proto__ || Object.getPrototypeOf(SpongeFactory)).call(this));
  }
  /**
   * Get the instance of the factory.
   * @returns The factory instance.
   */


  _createClass(SpongeFactory, [{
    key: "getInstance",

    /* @internal */
    value: function getInstance() {
      return SpongeFactory.instance();
    }
  }], [{
    key: "instance",
    value: function instance() {
      if (!SpongeFactory._instance) {
        SpongeFactory._instance = new SpongeFactory();

        SpongeFactory._instance.register("curl", function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return new (Function.prototype.bind.apply(curl_1.Curl, [null].concat(args)))();
        });

        SpongeFactory._instance.register("kerl", function () {
          return new kerl_1.Kerl();
        });
      }

      return SpongeFactory._instance;
    }
  }]);

  return SpongeFactory;
}(factoryBase_1.FactoryBase);

exports.SpongeFactory = SpongeFactory;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

var jsonHelper_1 = __webpack_require__(16);

var stringHelper_1 = __webpack_require__(6);
/**
 * A core implementation of an error.
 */


var CoreError =
/*#__PURE__*/
function (_extendableBuiltin2) {
  _inherits(CoreError, _extendableBuiltin2);

  /**
   * Create an instance of CoreError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function CoreError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, CoreError);

    _this = _possibleConstructorReturn(this, (CoreError.__proto__ || Object.getPrototypeOf(CoreError)).call(this, message));
    _this.additional = additional ? additional : {};
    _this.innerError = innerError;
    _this.domain = "Core";
    return _this;
  }
  /**
   * Check if an object could be a CoreError.
   * @param obj The object to check if it is a CoreError.
   * @returns true If the tested object is a CoreError.
   */


  _createClass(CoreError, [{
    key: "format",

    /**
     * Format the error to a readable version.
     */
    value: function format() {
      var _this2 = this;

      var out = "";

      if (!stringHelper_1.StringHelper.isEmpty(this.domain)) {
        out += "".concat(this.domain, ": ");
      }

      if (!stringHelper_1.StringHelper.isEmpty(this.message)) {
        out += "".concat(this.message);
      }

      var keys = Object.keys(this.additional);

      if (keys.length > 0) {
        if (out.length > 0) {
          out += "\n";
        }

        keys.forEach(function (key) {
          out += "\t".concat(key, ": ").concat(jsonHelper_1.JsonHelper.stringify(_this2.additional[key]), "\n");
        });
      }

      return out;
    }
  }], [{
    key: "isError",
    value: function isError(obj) {
      return obj !== undefined && obj !== null && _typeof(obj) === "object" && "message" in obj && "additional" in obj;
    }
  }]);

  return CoreError;
}(_extendableBuiltin(Error));

exports.CoreError = CoreError;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(0);

var dataError_1 = __webpack_require__(3);

var trytes_1 = __webpack_require__(1);
/**
 * A class for handling signature message fragments.
 */


var SignatureMessageFragment =
/*#__PURE__*/
function () {
  /* @internal */
  function SignatureMessageFragment(trytes) {
    _classCallCheck(this, SignatureMessageFragment);

    this._trytes = trytes;
  }
  /**
   * Create signature fragment from trytes.
   * @param signatureMessageFragment The trytes to create the signature fragment from.
   * @returns An instance of SignatureMessageFragment.
   */


  _createClass(SignatureMessageFragment, [{
    key: "toTrytes",

    /**
     * Convert the signature fragment to trytes.
     * @returns Trytes version of the signature fragment.
     */
    value: function toTrytes() {
      return this._trytes;
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes.toString();
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(signatureMessageFragment) {
      if (!objectHelper_1.ObjectHelper.isType(signatureMessageFragment, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The signatureMessageFragment should be a valid Trytes object");
      }

      var length = signatureMessageFragment.length();

      if (length !== SignatureMessageFragment.LENGTH) {
        throw new dataError_1.DataError("The signatureMessageFragment should be ".concat(SignatureMessageFragment.LENGTH, " characters in length"), {
          length: length
        });
      }

      return new SignatureMessageFragment(signatureMessageFragment);
    }
  }]);

  return SignatureMessageFragment;
}();
/**
 * The length of a valid signature message fragment (2187)
 */


SignatureMessageFragment.LENGTH = 2187;
/**
 * An empty signature message fragment all 9s.
 */

SignatureMessageFragment.EMPTY = SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString("9".repeat(SignatureMessageFragment.LENGTH)));
exports.SignatureMessageFragment = SignatureMessageFragment;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(0);

var dataError_1 = __webpack_require__(3);

var trytes_1 = __webpack_require__(1);
/**
 * A class for handling tags.
 */


var Tag =
/*#__PURE__*/
function () {
  /* @internal */
  function Tag(trytes) {
    _classCallCheck(this, Tag);

    this._trytes = trytes;
  }
  /**
   * Create tag from trytes.
   * @param tag The trytes to create the tag from.
   * @returns An instance of Tag.
   */


  _createClass(Tag, [{
    key: "toTrytes",

    /**
     * Convert the tag to trytes.
     * @returns Trytes version of the tag.
     */
    value: function toTrytes() {
      return trytes_1.Trytes.fromString(this._trytes);
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes;
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(tag) {
      if (!objectHelper_1.ObjectHelper.isType(tag, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The tag should be a valid Trytes object");
      }

      var trytesString = tag.toString();

      if (trytesString.length > Tag.LENGTH) {
        throw new dataError_1.DataError("The tag should be at most ".concat(Tag.LENGTH, " characters in length"), {
          length: trytesString.length
        });
      }

      while (trytesString.length < Tag.LENGTH) {
        trytesString += "9";
      }

      return new Tag(trytesString);
    }
  }]);

  return Tag;
}();
/**
 * The length of a valid tag (27).
 */


Tag.LENGTH = 27;
/**
 * An empty tag all 9s.
 */

Tag.EMPTY = Tag.fromTrytes(trytes_1.Trytes.fromString("9".repeat(Tag.LENGTH)));
exports.Tag = Tag;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(0);

var dataError_1 = __webpack_require__(3);

var address_1 = __webpack_require__(8);

var hash_1 = __webpack_require__(9);

var signatureMessageFragment_1 = __webpack_require__(12);

var tag_1 = __webpack_require__(13);

var tryteNumber_1 = __webpack_require__(15);

var trytes_1 = __webpack_require__(1);
/**
 * A class for handling transactions.
 */


var Transaction =
/*#__PURE__*/
function () {
  /* @internal */
  function Transaction() {
    _classCallCheck(this, Transaction);
  }
  /**
   * Create instance of transaction from parameters.
   * @param signatureMessageFragment The signature message fragment.
   * @param address The address.
   * @param value The value.
   * @param obsoleteTag Obsolete transaction tag.
   * @param timestamp The timestamp.
   * @param currentIndex The current index.
   * @param lastIndex The last index.
   * @param bundle The bundle.
   * @param trunkTransaction The trunk transaction.
   * @param branchTransaction The branch transaction.
   * @param tag The tag.
   * @param attachmentTimestamp The attachment timestamp.
   * @param attachmentTimestampLowerBound The attachment timestamp lower bound.
   * @param attachmentTimestampUpperBound  The attachment timestamp upper bound.
   * @param nonce The nonce.
   * @return New instance of transaction.
   */


  _createClass(Transaction, [{
    key: "toTrytes",

    /**
     * Convert the transaction to trytes.
     * @return The transaction as trytes.
     */
    value: function toTrytes() {
      if (!objectHelper_1.ObjectHelper.isType(this.signatureMessageFragment, signatureMessageFragment_1.SignatureMessageFragment)) {
        throw new dataError_1.DataError("The signatureMessageFragment must be set to create transaction trytes", {
          signatureMessageFragment: this.signatureMessageFragment
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.address, address_1.Address)) {
        throw new dataError_1.DataError("The address must be set to create transaction trytes", {
          address: this.address
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.obsoleteTag, tag_1.Tag)) {
        throw new dataError_1.DataError("The obsoleteTag must be set to create transaction trytes", {
          obsoleteTag: this.obsoleteTag
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.bundle, hash_1.Hash)) {
        throw new dataError_1.DataError("The bundle must be set to create transaction trytes", {
          bundle: this.bundle
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.trunkTransaction, hash_1.Hash)) {
        throw new dataError_1.DataError("The trunkTransaction must be set to create transaction trytes", {
          trunkTransaction: this.trunkTransaction
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.branchTransaction, hash_1.Hash)) {
        throw new dataError_1.DataError("The branchTransaction must be set to create transaction trytes", {
          branchTransaction: this.branchTransaction
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.nonce, tag_1.Tag)) {
        throw new dataError_1.DataError("The nonce must be set to create transaction trytes", {
          nonce: this.nonce
        });
      }

      var trytes = this.signatureMessageFragment.toTrytes().toString() + this.address.toTrytes().toString() + (this.value || Transaction.EMPTY_11).toTrytes().toString() + Transaction.CHECK_VALUE + this.obsoleteTag.toTrytes().toString() + (this.timestamp || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.currentIndex || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.lastIndex || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + this.bundle.toTrytes().toString() + this.trunkTransaction.toTrytes().toString() + this.branchTransaction.toTrytes().toString() + (this.tag || this.obsoleteTag).toTrytes().toString() + (this.attachmentTimestamp || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.attachmentTimestampLowerBound || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.attachmentTimestampUpperBound || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + this.nonce.toTrytes().toString();
      var length = trytes.length;

      if (length !== Transaction.LENGTH) {
        throw new dataError_1.DataError("The trytes must be ".concat(Transaction.LENGTH, " in length ").concat(length), {
          length: length
        });
      }

      return trytes_1.Trytes.fromString(trytes);
    }
    /**
     * Get the string view of the object.
     * @returns string view of the object.
     */

  }, {
    key: "toString",
    value: function toString() {
      return "{\n\tsignatureMessageFragment: \"".concat((this.signatureMessageFragment || signatureMessageFragment_1.SignatureMessageFragment.EMPTY).toTrytes().toString(), "\"\n\taddress: \"").concat((this.address || address_1.Address.EMPTY).toTrytes().toString(), "\"\n\tvalue: ").concat((this.value || Transaction.EMPTY_11).toNumber(), "\n\tobsoleteTag: \"").concat((this.obsoleteTag || tag_1.Tag.EMPTY).toTrytes().toString(), "\"\n\ttimestamp: ").concat((this.timestamp || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tcurrentIndex: ").concat((this.currentIndex || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tlastIndex: ").concat((this.lastIndex || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tbundle: \"").concat((this.bundle || hash_1.Hash.EMPTY).toTrytes().toString(), "\"\n\ttrunkTransaction: \"").concat((this.trunkTransaction || hash_1.Hash.EMPTY).toTrytes().toString(), "\"\n\tbranchTransaction: \"").concat((this.branchTransaction || hash_1.Hash.EMPTY).toTrytes().toString(), "\"\n\ttag: \"").concat((this.tag || this.obsoleteTag || tag_1.Tag.EMPTY).toTrytes().toString(), "\"\n\tattachmentTimestamp: ").concat((this.attachmentTimestamp || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tattachmentTimestampLowerBound: ").concat((this.attachmentTimestampLowerBound || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tattachmentTimestampUpperBound: ").concat((this.attachmentTimestampUpperBound || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tnonce: \"").concat((this.nonce || tag_1.Tag.EMPTY).toTrytes().toString(), "\"\n}");
    }
  }], [{
    key: "fromParams",
    value: function fromParams(signatureMessageFragment, address, value, obsoleteTag, timestamp, currentIndex, lastIndex, bundle, trunkTransaction, branchTransaction, tag, attachmentTimestamp, attachmentTimestampLowerBound, attachmentTimestampUpperBound, nonce) {
      var tx = new Transaction();
      tx.signatureMessageFragment = signatureMessageFragment;
      tx.address = address;
      tx.value = tryteNumber_1.TryteNumber.fromNumber(value, 11);
      tx.obsoleteTag = obsoleteTag;
      tx.timestamp = tryteNumber_1.TryteNumber.fromNumber(timestamp);
      tx.currentIndex = tryteNumber_1.TryteNumber.fromNumber(currentIndex);
      tx.lastIndex = tryteNumber_1.TryteNumber.fromNumber(lastIndex);
      tx.bundle = bundle;
      tx.trunkTransaction = trunkTransaction;
      tx.branchTransaction = branchTransaction;
      tx.tag = tag;
      tx.attachmentTimestamp = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestamp);
      tx.attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestampLowerBound);
      tx.attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestampUpperBound);
      tx.nonce = nonce;
      return tx;
    }
    /**
     * Create instance of transaction from trytes.
     * @param trytes The trytes for the this.
     * @returns An instance of this.
     */

  }, {
    key: "fromTrytes",
    value: function fromTrytes(trytes) {
      if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The trytes should be a valid Trytes object");
      }

      var length = trytes.length();

      if (length !== Transaction.LENGTH) {
        throw new dataError_1.DataError("The trytes must be ".concat(Transaction.LENGTH, " in length"), {
          length: length
        });
      }

      var checkIndexStart = 2279;
      var checkIndexLength = 16;
      var check = trytes.sub(checkIndexStart, checkIndexLength).toString();

      if (check !== Transaction.CHECK_VALUE) {
        throw new dataError_1.DataError("The trytes between ".concat(checkIndexStart, " and ").concat(checkIndexStart + checkIndexLength, " should be all 9s"), {
          check: check
        });
      }

      var tx = new Transaction();
      var startPos = 0;
      tx.signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes.sub(startPos, signatureMessageFragment_1.SignatureMessageFragment.LENGTH));
      startPos += signatureMessageFragment_1.SignatureMessageFragment.LENGTH;
      tx.address = address_1.Address.fromTrytes(trytes.sub(startPos, address_1.Address.LENGTH));
      startPos += address_1.Address.LENGTH;
      tx.value = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, 11), 11);
      startPos += 11;
      startPos += Transaction.CHECK_VALUE_LENGTH;
      tx.obsoleteTag = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));
      startPos += tag_1.Tag.LENGTH;
      tx.timestamp = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.currentIndex = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.lastIndex = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.bundle = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));
      startPos += hash_1.Hash.LENGTH;
      tx.trunkTransaction = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));
      startPos += hash_1.Hash.LENGTH;
      tx.branchTransaction = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));
      startPos += hash_1.Hash.LENGTH;
      tx.tag = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));
      startPos += tag_1.Tag.LENGTH;
      tx.attachmentTimestamp = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.nonce = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));
      return tx;
    }
  }]);

  return Transaction;
}();
/**
 * The length of a valid transaction (2673).
 */


Transaction.LENGTH = 2673;
/**
 * The length of a valid check value (16).
 */

Transaction.CHECK_VALUE_LENGTH = 16;
/**
 * The check value for bundles all 9s.
 */

Transaction.CHECK_VALUE = "9".repeat(Transaction.CHECK_VALUE_LENGTH);
/* @internal */

Transaction.EMPTY_11 = tryteNumber_1.TryteNumber.fromNumber(0, 11);
exports.Transaction = Transaction;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var dataError_1 = __webpack_require__(3);

var trits_1 = __webpack_require__(7);

var trytes_1 = __webpack_require__(1);
/**
 * A class for handling tryte number.
 */


var TryteNumber =
/*#__PURE__*/
function () {
  /* @internal */
  function TryteNumber(trytes) {
    _classCallCheck(this, TryteNumber);

    this._trytes = trytes;
  }
  /**
   * Create tryte number from number.
   * @param value The number value to create the object from.
   * @param length The tryte length to pad the number with.
   * @returns An instance of TryteNumber.
   */


  _createClass(TryteNumber, [{
    key: "toTrytes",

    /**
     * Convert the tryte number to trytes.
     * @returns Trytes version of the tryte number.
     */
    value: function toTrytes() {
      return trytes_1.Trytes.fromString(this._trytes);
    }
    /**
     * Convert the tryte number to number.
     * @returns number value of the tryte number.
     */

  }, {
    key: "toNumber",
    value: function toNumber() {
      return trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(this._trytes)).toNumber();
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes;
    }
    /**
     * Get the value of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.toNumber();
    }
  }], [{
    key: "fromNumber",
    value: function fromNumber(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TryteNumber.LENGTH_9;
      var trytes;

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new dataError_1.DataError("The length should be a number > 0", {
          length: length
        });
      }

      if (objectHelper_1.ObjectHelper.isEmpty(value)) {
        trytes = "9".repeat(length);
      } else {
        if (!numberHelper_1.NumberHelper.isInteger(value)) {
          throw new dataError_1.DataError("The value is not an integer", {
            value: value
          });
        }

        var trits = trits_1.Trits.fromNumber(value).toNumberArray();

        while (trits.length < length * 3) {
          trits.push(0);
        }

        trytes = trits_1.Trits.fromNumberArray(trits).toTrytes().toString();
      }

      return new TryteNumber(trytes);
    }
    /**
     * Create tryte number from trytes.
     * @param value The number value to create the object from.
     * @param length The tryte length to pad the number with.
     * @returns An instance of TryteNumber.
     */

  }, {
    key: "fromTrytes",
    value: function fromTrytes(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TryteNumber.LENGTH_9;

      if (!objectHelper_1.ObjectHelper.isType(value, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The value should be a valid Trytes object");
      }

      var tryteString = value.toString();

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new dataError_1.DataError("The length should be a number > 0", {
          length: length
        });
      }

      if (tryteString.length > length) {
        throw new dataError_1.DataError("The value contains too many characters", {
          length: tryteString.length
        });
      }

      while (tryteString.length < length) {
        tryteString += "9";
      }

      return new TryteNumber(tryteString);
    }
  }]);

  return TryteNumber;
}();
/**
 * Length of a number that uses 9 trytes.
 */


TryteNumber.LENGTH_9 = 9;
/**
 * An empty 9 length tryte number.
 */

TryteNumber.EMPTY_9 = TryteNumber.fromNumber(0, TryteNumber.LENGTH_9);
exports.TryteNumber = TryteNumber;

/***/ }),
/* 16 */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Json helper methods.
 */

var JsonHelper =
/*#__PURE__*/
function () {
  function JsonHelper() {
    _classCallCheck(this, JsonHelper);
  }

  _createClass(JsonHelper, null, [{
    key: "stringify",

    /**
     * Stringify an object with recursion breaking.
     * @param value A JavaScript value, usually an object or array, to be converted.
     * @param replacer A function that transforms the results.
     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
     * @returns String version of the object.
     */
    value: function stringify(value, replacer, space) {
      // eliminates any recursion in the stringify
      var cache = [];

      var recusionReplacer = function recusionReplacer(key, replaceValue) {
        if (_typeof(replaceValue) === "object" && value !== null && replaceValue !== undefined) {
          if (cache.indexOf(replaceValue) !== -1) {
            // circular reference found, discard key
            return;
          } else {
            cache.push(replaceValue);
          }
        }

        return replacer ? replacer(key, replaceValue) : replaceValue;
      };

      return JSON.stringify(value, recusionReplacer, space);
    }
  }]);

  return JsonHelper;
}();

exports.JsonHelper = JsonHelper;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Factory to generate types.
 * @typeparam T The generic type for the object types in the factory.
 */

var FactoryBase =
/*#__PURE__*/
function () {
  function FactoryBase() {
    _classCallCheck(this, FactoryBase);

    /* @internal */
    this._types = {};
  }
  /**
   * Register a new type with the factory.
   * @param name The name of the type to register.
   * @param typeConstructor The constructor for the type.
   */


  _createClass(FactoryBase, [{
    key: "register",
    value: function register(name, typeConstructor) {
      this.getInstance()._types[name] = typeConstructor;
    }
    /**
     * Unregister a type from the factory.
     * @param name The name of the type to unregister.
     */

  }, {
    key: "unregister",
    value: function unregister(name) {
      delete this.getInstance()._types[name];
    }
    /**
     * Does the factory contain a specific type.
     * @param name The name of the type to look for.
     * @returns True if the type exists.
     */

  }, {
    key: "exists",
    value: function exists(name) {
      return this.getInstance()._types[name] !== undefined;
    }
    /**
     * Create an instance of an object from the factory.
     * @param name The name of the type to create.
     * @param args Any parameters to pass to the constructor.
     * @returns A new instance of the type if it exists, or undefined if it does not.
     */

  }, {
    key: "create",
    value: function create(name) {
      var instance = this.getInstance();

      if (instance._types[name]) {
        var _instance$_types;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return (_instance$_types = instance._types)[name].apply(_instance$_types, args);
      } else {
        return undefined;
      }
    }
  }]);

  return FactoryBase;
}();

exports.FactoryBase = FactoryBase;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Implementation of ILogger which is silent.
 */

var NullLogger =
/*#__PURE__*/
function () {
  function NullLogger() {
    _classCallCheck(this, NullLogger);
  }

  _createClass(NullLogger, [{
    key: "banner",

    /**
     * Send banner to the logger.
     * @param message The message to log.
     * @param args Additional parameters to log.
     */
    value: function banner(message) {}
    /**
     * Send log to the logger.
     * @param message The message to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "log",
    value: function log(message) {}
    /**
     * Send information to the logger.
     * @param message The message to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "info",
    value: function info(message) {}
    /**
     * Send warning to the logger.
     * @param message The message to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "warning",
    value: function warning(message) {}
    /**
     * Send error to the logger.
     * @param message The message to log.
     * @param err An error object to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "error",
    value: function error(message, err) {}
  }]);

  return NullLogger;
}();

exports.NullLogger = NullLogger;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Represents an enum for the address security values.
 */

var AddressSecurity;

(function (AddressSecurity) {
  AddressSecurity[AddressSecurity["low"] = 1] = "low";
  AddressSecurity[AddressSecurity["medium"] = 2] = "medium";
  AddressSecurity[AddressSecurity["high"] = 3] = "high";
})(AddressSecurity = exports.AddressSecurity || (exports.AddressSecurity = {}));

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(0);

var dataError_1 = __webpack_require__(3);

var hash_1 = __webpack_require__(9);

var signatureMessageFragment_1 = __webpack_require__(12);

var tag_1 = __webpack_require__(13);

var transaction_1 = __webpack_require__(14);

var tryteNumber_1 = __webpack_require__(15);
/**
 * A class for handling bundles.
 */


var Bundle =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of Bundle.
   */
  function Bundle() {
    _classCallCheck(this, Bundle);

    this.transactions = [];
  }
  /**
   * Add new transactions to the bundle.
   * @param signatureMessageLength The number of transactions to add.
   * @param address The address for the transactions.
   * @param value The value for the first of the transactions.
   * @param tag The tag to include in the transactions.
   * @param timestamp The timestamp for the transactions.
   */


  _createClass(Bundle, [{
    key: "addTransactions",
    value: function addTransactions(signatureMessageLength, address, value, tag, timestamp) {
      for (var i = 0; i < signatureMessageLength; i++) {
        this.transactions.push(transaction_1.Transaction.fromParams(undefined, address, i === 0 ? value : 0, tag, timestamp, undefined, undefined, undefined, undefined, undefined, tag, undefined, undefined, undefined, undefined));
      }
    }
    /**
     * Add signature fragments to the bundle.
     * @param signatureMessageFragments The signature fragments to add to the bundle transactions.
     */

  }, {
    key: "addSignatureMessageFragments",
    value: function addSignatureMessageFragments(signatureMessageFragments) {
      if (objectHelper_1.ObjectHelper.isEmpty(signatureMessageFragments)) {
        throw new dataError_1.DataError("The signatureMessageFragments should be an array of SignatureMessageFragments");
      }

      for (var i = 0; i < this.transactions.length; i++) {
        this.transactions[i].signatureMessageFragment = signatureMessageFragments[i] || signatureMessageFragment_1.SignatureMessageFragment.EMPTY;
        this.transactions[i].trunkTransaction = hash_1.Hash.EMPTY;
        this.transactions[i].branchTransaction = hash_1.Hash.EMPTY;
        this.transactions[i].attachmentTimestamp = tryteNumber_1.TryteNumber.EMPTY_9;
        this.transactions[i].attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.EMPTY_9;
        this.transactions[i].attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.EMPTY_9;
        this.transactions[i].nonce = tag_1.Tag.EMPTY;
      }
    }
  }]);

  return Bundle;
}();

exports.Bundle = Bundle;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(4);

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var address_1 = __webpack_require__(8);

var addressSecurity_1 = __webpack_require__(19);

var hash_1 = __webpack_require__(9);

var signatureMessageFragment_1 = __webpack_require__(12);

var trits_1 = __webpack_require__(7);

var trytes_1 = __webpack_require__(1);

var cryptoError_1 = __webpack_require__(5);

var spongeFactory_1 = __webpack_require__(10);
/**
 * ISS Hashing functions.
 * Converted https://github.com/iotaledger/iri/src/main/java/com/iota/iri/hash/ISS.java
 */


var ISS =
/*#__PURE__*/
function () {
  function ISS() {
    _classCallCheck(this, ISS);
  }

  _createClass(ISS, null, [{
    key: "key",

    /**
     * Create the key for the seed.
     * @param seed The seed to create the key for.
     * @param index The index to use for the seed.
     * @param length The security level to create the key.
     * @returns the key.
     */
    value: function key(seed, index, security) {
      if (!objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
        throw new cryptoError_1.CryptoError("The seed must be of type Hash");
      }

      if (!numberHelper_1.NumberHelper.isInteger(index) || index < 0) {
        throw new cryptoError_1.CryptoError("The index must be an integer >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(security) || security < addressSecurity_1.AddressSecurity.low || security > addressSecurity_1.AddressSecurity.high) {
        throw new cryptoError_1.CryptoError("The security must be an integer >= 1 and <= 3");
      }

      var seedTrits = trits_1.Trits.fromTrytes(seed.toTrytes());
      var indexTrits = trits_1.Trits.fromNumber(index);
      var subseed = trits_1.Trits.add(seedTrits, indexTrits).toArray();
      var subseedLength = subseed.length;
      var kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
      var hashLength = kerl.getConstant("HASH_LENGTH");
      kerl.initialize();
      kerl.absorb(subseed, 0, subseedLength);
      kerl.squeeze(subseed, 0, subseedLength);
      kerl.reset();
      kerl.absorb(subseed, 0, subseedLength);
      var key = new Int8Array(ISS.NUMBER_OF_FRAGMENT_CHUNKS * hashLength * security);
      var offset = 0;
      var buffer = new Int8Array(subseedLength);
      var localLength = security;

      while (localLength-- > 0) {
        for (var i = 0; i < ISS.NUMBER_OF_FRAGMENT_CHUNKS; i++) {
          kerl.squeeze(buffer, 0, subseedLength);

          for (var j = 0; j < hashLength; j++) {
            key[offset++] = buffer[j];
          }
        }
      }

      return key;
    }
    /**
     * Create the digests for the given subseed.
     * @param subseed To create the digests for.
     * @returns The digests.
     */

  }, {
    key: "digests",
    value: function digests(subseed) {
      if (!objectHelper_1.ObjectHelper.isType(subseed, Int8Array)) {
        throw new cryptoError_1.CryptoError("The subseed must be of type Int8Array");
      }

      var hash = spongeFactory_1.SpongeFactory.instance().create("kerl");
      var hashLength = hash.getConstant("HASH_LENGTH");
      var fragmentLength = hashLength * ISS.NUMBER_OF_FRAGMENT_CHUNKS;

      if (subseed.length % fragmentLength !== 0) {
        throw new cryptoError_1.CryptoError("The subseed length must be a multiple of ".concat(fragmentLength));
      }

      var tryteRange = ISS.MAX_TRYTE_VALUE - ISS.MIN_TRYTE_VALUE;
      var keyLenDiv = subseed.length / fragmentLength;
      var digests = new Int8Array(keyLenDiv * hashLength);
      var buffer;

      for (var i = 0; i < keyLenDiv; i++) {
        var iMul = i * fragmentLength;
        var keyFragment = subseed.slice(iMul, iMul + fragmentLength);

        for (var j = 0; j < ISS.NUMBER_OF_FRAGMENT_CHUNKS; j++) {
          var jMul = j * hashLength;
          buffer = keyFragment.slice(jMul, jMul + hashLength);

          for (var k = 0; k < tryteRange; k++) {
            hash.reset();
            hash.absorb(buffer, 0, buffer.length);
            hash.squeeze(buffer, 0, hashLength);
          }

          for (var _k = 0; _k < hashLength; _k++) {
            keyFragment[jMul + _k] = buffer[_k];
          }
        }

        hash.reset();
        hash.absorb(keyFragment, 0, keyFragment.length);
        hash.squeeze(buffer, 0, hashLength);
        var iMul2 = i * hashLength;

        for (var _j = 0; _j < hashLength; _j++) {
          digests[iMul2 + _j] = buffer[_j];
        }
      }

      return digests;
    }
    /**
     * Create the address for the digests.
     * @param digests The digests to create the address for.
     * @returns the address trits.
     */

  }, {
    key: "address",
    value: function address(digests) {
      if (!objectHelper_1.ObjectHelper.isType(digests, Int8Array)) {
        throw new cryptoError_1.CryptoError("The digests must be of type Int8Array");
      }

      var kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
      var kerlHashLength = kerl.getConstant("HASH_LENGTH");

      if (digests.length % kerlHashLength !== 0) {
        throw new cryptoError_1.CryptoError("Invalid digests length, must be a multiple of ".concat(kerlHashLength));
      }

      kerl.initialize();
      kerl.absorb(digests, 0, digests.length);
      var addressTrits = new Int8Array(kerlHashLength);
      kerl.squeeze(addressTrits, 0, addressTrits.length);
      return addressTrits;
    }
    /**
     * Create digest of the normalized bundle fragment.
     * @param normalizedBundleFragment The fragment to create digest.
     * @param signatureMessageFragment The trits for signature message fragment.
     * @returns The digest of the bundle and signature message fragment.
     */

  }, {
    key: "digest",
    value: function digest(normalizedBundleFragment, signatureMessageFragment) {
      if (!objectHelper_1.ObjectHelper.isType(normalizedBundleFragment, Int8Array)) {
        throw new cryptoError_1.CryptoError("The normalizedBundleFragment must be of type Int8Array");
      }

      if (!objectHelper_1.ObjectHelper.isType(signatureMessageFragment, Int8Array)) {
        throw new cryptoError_1.CryptoError("The signatureMessageFragment must be of type Int8Array");
      }

      var buffer;
      var kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
      var hashLength = kerl.getConstant("HASH_LENGTH");
      kerl.initialize();

      for (var i = 0; i < ISS.NUMBER_OF_FRAGMENT_CHUNKS; i++) {
        buffer = new Int8Array(signatureMessageFragment.slice(i * hashLength, (i + 1) * hashLength));

        for (var j = normalizedBundleFragment[i] - ISS.MIN_TRYTE_VALUE; j > 0; j--) {
          var jKerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
          jKerl.initialize();
          jKerl.absorb(buffer, 0, buffer.length);
          jKerl.squeeze(buffer, 0, jKerl.getConstant("HASH_LENGTH"));
        }

        kerl.absorb(buffer, 0, buffer.length);
      }

      kerl.squeeze(buffer, 0, kerl.getConstant("HASH_LENGTH"));
      return buffer;
    }
    /**
     * Create a normalized bundle.
     * @param bundleHash The hash of the bundle.
     * @returns the normalized bundle.
     */

  }, {
    key: "normalizedBundle",
    value: function normalizedBundle(bundleHash) {
      if (!objectHelper_1.ObjectHelper.isType(bundleHash, hash_1.Hash)) {
        throw new cryptoError_1.CryptoError("The bundleHash must be of type Hash");
      }

      var curl = spongeFactory_1.SpongeFactory.instance().create("curl");
      var curlHashLength = curl.getConstant("HASH_LENGTH");
      var normalizedBundle = new Int8Array(ISS.NUMBER_OF_FRAGMENT_CHUNKS * ISS.NUMBER_OF_SECURITY_LEVELS);
      var hashString = bundleHash.toTrytes().toString();
      var normalizedFragmentLength = curlHashLength / ISS.TRYTE_WIDTH / ISS.NUMBER_OF_SECURITY_LEVELS;

      for (var i = 0; i < ISS.NUMBER_OF_SECURITY_LEVELS; i++) {
        var sum = 0;

        for (var j = 0; j < normalizedFragmentLength; j++) {
          var hashChar = hashString.charAt(i * normalizedFragmentLength + j);
          var val = trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(hashChar)).toNumber();
          normalizedBundle[i * normalizedFragmentLength + j] = val;
          sum += val;
        }

        if (sum >= 0) {
          while (sum-- > 0) {
            for (var _j2 = 0; _j2 < normalizedFragmentLength; _j2++) {
              if (normalizedBundle[i * normalizedFragmentLength + _j2] > ISS.MIN_TRYTE_VALUE) {
                normalizedBundle[i * normalizedFragmentLength + _j2]--;
                break;
              }
            }
          }
        } else {
          while (sum++ < 0) {
            for (var _j3 = 0; _j3 < normalizedFragmentLength; _j3++) {
              if (normalizedBundle[i * normalizedFragmentLength + _j3] < ISS.MAX_TRYTE_VALUE) {
                normalizedBundle[i * normalizedFragmentLength + _j3]++;
                break;
              }
            }
          }
        }
      }

      return normalizedBundle;
    }
    /**
     * Validate the signature fragments from the address.
     * @param expectedAddress The address.
     * @param signatureMessageFragments The signature message fragments.
     * @param bundleHash The hash for the bundle.
     * @returns True if the signature message fragment are signed by the expected address.
     */

  }, {
    key: "validateSignatures",
    value: function validateSignatures(expectedAddress, signatureMessageFragments, bundleHash) {
      if (!objectHelper_1.ObjectHelper.isType(expectedAddress, address_1.Address)) {
        throw new cryptoError_1.CryptoError("The expectedAddress must be of type Hash");
      }

      if (!arrayHelper_1.ArrayHelper.isTyped(signatureMessageFragments, signatureMessageFragment_1.SignatureMessageFragment)) {
        throw new cryptoError_1.CryptoError("The signatureMessageFragments must be an array of type SignatureMessageFragment");
      }

      if (!objectHelper_1.ObjectHelper.isType(bundleHash, hash_1.Hash)) {
        throw new cryptoError_1.CryptoError("The bundleHash must be of type Hash");
      }

      var normalizedBundleFragments = [];
      var normalizedBundleHash = ISS.normalizedBundle(bundleHash);
      var kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
      var hashLength = kerl.getConstant("HASH_LENGTH");

      for (var f = 0; f < 3; f++) {
        normalizedBundleFragments[f] = normalizedBundleHash.slice(f * ISS.NUMBER_OF_FRAGMENT_CHUNKS, (f + 1) * ISS.NUMBER_OF_FRAGMENT_CHUNKS);
      }

      var digests = new Int8Array(signatureMessageFragments.length * hashLength);

      for (var i = 0; i < signatureMessageFragments.length; i++) {
        var digestBuffer = ISS.digest(normalizedBundleFragments[i % 3], trits_1.Trits.fromTrytes(signatureMessageFragments[i].toTrytes()).toArray());

        for (var j = 0; j < hashLength; j++) {
          digests[i * hashLength + j] = digestBuffer[j];
        }
      }

      return expectedAddress.toTrytes().toString() === trits_1.Trits.fromArray(ISS.address(digests)).toTrytes().toString();
    }
  }]);

  return ISS;
}();
/* @internal */


ISS.NUMBER_OF_FRAGMENT_CHUNKS = 27;
/* @internal */

ISS.NUMBER_OF_SECURITY_LEVELS = 3;
/* @internal */

ISS.TRYTE_WIDTH = 3;
/* @internal */

ISS.MIN_TRYTE_VALUE = -13;
/* @internal */

ISS.MAX_TRYTE_VALUE = 13;
exports.ISS = ISS;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var coreError_1 = __webpack_require__(11);
/**
 * A business implementation of an error.
 */


var BusinessError =
/*#__PURE__*/
function (_coreError_1$CoreErro) {
  _inherits(BusinessError, _coreError_1$CoreErro);

  /**
   * Create an instance of BusinessError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function BusinessError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, BusinessError);

    _this = _possibleConstructorReturn(this, (BusinessError.__proto__ || Object.getPrototypeOf(BusinessError)).call(this, message, additional, innerError));
    _this.domain = "Business";
    return _this;
  }

  return BusinessError;
}(coreError_1.CoreError);

exports.BusinessError = BusinessError;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var coreError_1 = __webpack_require__(11);
/**
 * A network implementation of an error.
 */


var NetworkError =
/*#__PURE__*/
function (_coreError_1$CoreErro) {
  _inherits(NetworkError, _coreError_1$CoreErro);

  /**
   * Create an instance of NetworkError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function NetworkError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, NetworkError);

    _this = _possibleConstructorReturn(this, (NetworkError.__proto__ || Object.getPrototypeOf(NetworkError)).call(this, message, additional, innerError));
    _this.domain = "Network";
    return _this;
  }

  return NetworkError;
}(coreError_1.CoreError);

exports.NetworkError = NetworkError;

/***/ }),
/* 24 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Represents a class which can provide the time.
 */

var TimeService =
/*#__PURE__*/
function () {
  function TimeService() {
    _classCallCheck(this, TimeService);
  }

  _createClass(TimeService, [{
    key: "msSinceEpoch",

    /**
     * Returns the number of milliseconds since 1970/01/01.
     * @returns Number of milliseconds.
     */
    value: function msSinceEpoch() {
      return Date.now();
    }
  }]);

  return TimeService;
}();

exports.TimeService = TimeService;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var dataError_1 = __webpack_require__(3);

var address_1 = __webpack_require__(8);

var tag_1 = __webpack_require__(13);

var trytes_1 = __webpack_require__(1);
/**
 * A class for handling transfers.
 */


var Transfer =
/*#__PURE__*/
function () {
  /* @internal */
  function Transfer() {
    _classCallCheck(this, Transfer);
  }
  /**
   * Create instance of transfer from parameters.
   * @param address The address.
   * @param value The value.
   * @param messsage The message for the transfer.
   * @param tag The tag.
   * @return New instance of Transfer.
   */


  _createClass(Transfer, null, [{
    key: "fromParams",
    value: function fromParams(address, value, message, tag) {
      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {
        throw new dataError_1.DataError("The address should be a valid Address object");
      }

      if (!numberHelper_1.NumberHelper.isInteger(value) || value < 0) {
        throw new dataError_1.DataError("The value should be a number >= 0");
      }

      if (!objectHelper_1.ObjectHelper.isEmpty(message) && !objectHelper_1.ObjectHelper.isType(message, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The message should be a valid Trytes object");
      }

      if (!objectHelper_1.ObjectHelper.isEmpty(tag) && !objectHelper_1.ObjectHelper.isType(tag, tag_1.Tag)) {
        throw new dataError_1.DataError("The tag should be a valid Tag object");
      }

      var transfer = new Transfer();
      transfer.address = address;
      transfer.value = value;
      transfer.message = message;
      transfer.tag = tag;
      return transfer;
    }
  }]);

  return Transfer;
}();

exports.Transfer = Transfer;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(4);

var objectHelper_1 = __webpack_require__(0);

var spongeFactory_1 = __webpack_require__(10);

var iss_1 = __webpack_require__(21);

var address_1 = __webpack_require__(8);

var bundle_1 = __webpack_require__(20);

var hash_1 = __webpack_require__(9);

var signatureMessageFragment_1 = __webpack_require__(12);

var tag_1 = __webpack_require__(13);

var transaction_1 = __webpack_require__(14);

var trits_1 = __webpack_require__(7);

var trytes_1 = __webpack_require__(1);

var tryteNumber_1 = __webpack_require__(15);

var hmacCurl_1 = __webpack_require__(40);
/**
 * Helper class for signing bundles.
 * Converted https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/signing/signing.js
 */


var BundleHelper =
/*#__PURE__*/
function () {
  function BundleHelper() {
    _classCallCheck(this, BundleHelper);
  }

  _createClass(BundleHelper, null, [{
    key: "isValid",

    /**
     * Is the bundle valid.
     * @param bundle The bundle to check for validity.
     * @returns True if the bundle is valid.
     */
    value: function isValid(bundle) {
      var isValid = false;

      if (objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle) && arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {
        var totalSum = 0;
        var kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
        kerl.initialize(); // Prepare for signature validation

        var signaturesToValidate = [];
        isValid = true;

        for (var t = 0; t < bundle.transactions.length && isValid; t++) {
          var bundleTx = bundle.transactions[t];
          totalSum += bundleTx.value.toNumber(); // currentIndex has to be equal to the index in the array

          if (bundleTx.currentIndex.toNumber() !== t) {
            isValid = false;
          } else {
            // Get the transaction trytes
            var thisTxTrytes = bundleTx.toTrytes(); // Absorb bundle hash + value + timestamp + lastIndex + currentIndex trytes.

            var thisTxTrits = trits_1.Trits.fromTrytes(thisTxTrytes.sub(signatureMessageFragment_1.SignatureMessageFragment.LENGTH, 162)).toArray();
            kerl.absorb(thisTxTrits, 0, thisTxTrits.length); // Check if input transaction

            if (bundleTx.value.toNumber() < 0) {
              var newSignatureToValidate = {
                address: bundleTx.address,
                signatureMessageFragments: [bundleTx.signatureMessageFragment]
              }; // Find the subsequent txs with the remaining signature fragment

              for (var i = t; i < bundle.transactions.length - 1; i++) {
                var newBundleTx = bundle.transactions[i + 1]; // Check if new tx is part of the signature fragment

                if (newBundleTx.address.toTrytes().toString() === bundleTx.address.toTrytes().toString() && newBundleTx.value.toNumber() === 0) {
                  newSignatureToValidate.signatureMessageFragments.push(newBundleTx.signatureMessageFragment);
                }
              }

              signaturesToValidate.push(newSignatureToValidate);
            }
          }
        } // Check for total sum, if not equal 0 return error


        if (totalSum !== 0) {
          isValid = false;
        } else {
          // get the bundle hash from the bundle transactions
          var bundleFromTxs = new Int8Array(kerl.getConstant("HASH_LENGTH"));
          kerl.squeeze(bundleFromTxs, 0, bundleFromTxs.length);
          var bundleFromTxsTrytes = trits_1.Trits.fromArray(bundleFromTxs).toTrytes().toString(); // Check if bundle hash is the same as returned by tx object

          var bundleHash = bundle.transactions[0].bundle;

          if (bundleFromTxsTrytes !== bundleHash.toTrytes().toString()) {
            isValid = false;
          } else {
            // Last tx in the bundle should have currentIndex === lastIndex
            if (bundle.transactions[bundle.transactions.length - 1].currentIndex.toNumber() !== bundle.transactions[bundle.transactions.length - 1].lastIndex.toNumber()) {
              isValid = false;
            } else {
              // Validate the signatures
              for (var _i = 0; _i < signaturesToValidate.length && isValid; _i++) {
                var isValidSignature = iss_1.ISS.validateSignatures(signaturesToValidate[_i].address, signaturesToValidate[_i].signatureMessageFragments, bundleHash);

                if (!isValidSignature) {
                  isValid = false;
                }
              }
            }
          }
        }
      }

      return isValid;
    }
    /**
     * Validate signatures for each of the co-signers in the multi-signature to independently verify that a generated
     * transaction with the corresponding signatures of the co-signers is valid.
     * @param signedBundle The signed bundle to check the signatures.
     * @param inputAddress The address used to initiate the transfer.
     * @returns True is the signatures are valid.
     */

  }, {
    key: "validateSignatures",
    value: function validateSignatures(signedBundle, inputAddress) {
      var isValid = false;

      if (objectHelper_1.ObjectHelper.isType(signedBundle, bundle_1.Bundle) && arrayHelper_1.ArrayHelper.isTyped(signedBundle.transactions, transaction_1.Transaction) && objectHelper_1.ObjectHelper.isType(inputAddress, address_1.Address)) {
        var bundleHash;
        var signatureFragments = [];
        var inputAddressTrytes = inputAddress.toTrytes().toString();

        for (var i = 0; i < signedBundle.transactions.length; i++) {
          if (signedBundle.transactions[i].address.toTrytes().toString() === inputAddressTrytes) {
            bundleHash = signedBundle.transactions[i].bundle; // if we reached remainder bundle

            if (signedBundle.transactions[i].signatureMessageFragment.toTrytes().toString() === signatureMessageFragment_1.SignatureMessageFragment.EMPTY.toTrytes().toString()) {
              break;
            }

            signatureFragments.push(signedBundle.transactions[i].signatureMessageFragment);
          }
        }

        if (bundleHash) {
          isValid = iss_1.ISS.validateSignatures(inputAddress, signatureFragments, bundleHash);
        }
      }

      return isValid;
    }
  }, {
    key: "prepareBundle",
    value: function prepareBundle(timeService, transfers) {
      var bundle = new bundle_1.Bundle();
      var lastTag;
      var totalValue = 0;
      var signatureMessageFragments = []; //  Iterate over all transfers, get totalValue
      //  and prepare the Messages, message and tag

      for (var i = 0; i < transfers.length; i++) {
        var signatureMessageLength = 1; // If message longer than 2187 trytes, increase signatureMessageLength (add 2nd transaction)

        var messageString = transfers[i].message.toString();

        if (messageString.length > signatureMessageFragment_1.SignatureMessageFragment.LENGTH) {
          // Get total length, message / maxLength (2187 trytes)
          signatureMessageLength += Math.floor(messageString.length / signatureMessageFragment_1.SignatureMessageFragment.LENGTH);
          var msgCopy = messageString; // While there is still a message, copy it

          while (msgCopy) {
            var fragment = msgCopy.slice(0, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);
            msgCopy = msgCopy.slice(signatureMessageFragment_1.SignatureMessageFragment.LENGTH, msgCopy.length); // Pad remainder of fragment

            for (var j = 0; fragment.length < signatureMessageFragment_1.SignatureMessageFragment.LENGTH; j++) {
              fragment += "9";
            }

            signatureMessageFragments.push(signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(fragment)));
          }
        } else {
          // Else, get single fragment with 2187 of 9's trytes
          var _fragment = "";

          if (messageString) {
            _fragment = messageString.slice(0, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);
          }

          for (var _j = 0; _fragment.length < signatureMessageFragment_1.SignatureMessageFragment.LENGTH; _j++) {
            _fragment += "9";
          }

          signatureMessageFragments.push(signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(_fragment)));
        } // get current timestamp in seconds


        var timestamp = Math.floor(timeService.msSinceEpoch() / 1000);
        lastTag = transfers[i].tag; // Add first entries to the bundle

        bundle.addTransactions(signatureMessageLength, transfers[i].address, transfers[i].value, transfers[i].tag, timestamp); // Sum up total value

        totalValue += transfers[i].value;
      }

      return {
        bundle: bundle,
        totalValue: totalValue,
        lastTag: lastTag,
        signatureMessageFragments: signatureMessageFragments
      };
    }
    /* @internal */

  }, {
    key: "signInputs",
    value: function signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC) {
      BundleHelper.finalizeBundle(bundle);
      bundle.addSignatureMessageFragments(signatureMessageFragments); //  Here we do the actual signing of the inputs
      //  Iterate over all bundle transactions, find the inputs
      //  Get the corresponding private key and calculate the signatureMessageFragment

      for (var i = 0; i < bundle.transactions.length; i++) {
        if (bundle.transactions[i].value.toNumber() < 0) {
          var addressTrytes = bundle.transactions[i].address.toTrytes().toString(); // Get the corresponding keyIndex and security of the address

          var keyIndex = void 0;
          var keySecurity = void 0;

          for (var k = 0; k < inputs.length; k++) {
            if (inputs[k].address.toTrytes().toString() === addressTrytes) {
              keyIndex = inputs[k].keyIndex;
              keySecurity = inputs[k].security ? inputs[k].security : transferOptions.security;
              break;
            }
          } // Get corresponding private key of address


          var key = iss_1.ISS.key(seed, keyIndex, keySecurity);
          BundleHelper.signTransactions(bundle, i, 0, key, addressTrytes, keySecurity);
        }
      }

      if (addedHMAC) {
        var hmac = new hmacCurl_1.HmacCurl(transferOptions.hmacKey);
        hmac.addHMAC(bundle);
      }
    }
    /* @internal */

  }, {
    key: "signTransactions",
    value: function signTransactions(bundle, index, firstUnsignedIndex, keyTrits, addressTrytes, security) {
      var bundleHash = bundle.transactions[index].bundle; //  Get the normalized bundle hash

      var normalizedBundleHash = iss_1.ISS.normalizedBundle(bundleHash);
      var normalizedBundleFragments = []; // Split hash into 3 fragments

      for (var l = 0; l < 3; l++) {
        normalizedBundleFragments[l] = normalizedBundleHash.slice(l * 27, (l + 1) * 27);
      } //  First 6561 trits for the firstFragment


      var firstFragment = keyTrits.slice(0, 6561); //  First bundle fragment uses the first 27 trytes

      var firstBundleFragment = normalizedBundleFragments[firstUnsignedIndex]; //  Calculate the new signatureMessageFragment with the first bundle fragment

      var firstSignedFragment = BundleHelper.signatureMessageFragment(firstBundleFragment, firstFragment); //  Convert signature to trytes and assign the new signatureMessageFragment

      bundle.transactions[index].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trits_1.Trits.fromArray(firstSignedFragment).toTrytes()); // if user chooses higher than 27-tryte security
      // for each security level, add an additional signature

      for (var j = 1; j < security; j++) {
        //  Because the signature is > 2187 trytes, we need to
        //  find the subsequent transaction to add the remainder of the signature
        //  Same address as well as value = 0 (as we already spent the input)
        if (bundle.transactions[index + j].address.toTrytes().toString() === addressTrytes && bundle.transactions[index + j].value.toNumber() === 0) {
          // Use the next 6561 trits
          var nextFragment = keyTrits.slice(6561 * j, (j + 1) * 6561);
          var nextBundleFragment = normalizedBundleFragments[j]; //  Calculate the new signature

          var nextSignedFragment = BundleHelper.signatureMessageFragment(nextBundleFragment, nextFragment); //  Convert signature to trytes and assign it again to this bundle entry

          bundle.transactions[index + j].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trits_1.Trits.fromArray(nextSignedFragment).toTrytes());
        }
      }
    }
    /* @internal */

  }, {
    key: "finalizeBundle",
    value: function finalizeBundle(bundle) {
      if (bundle.transactions.length > 0) {
        var validBundle = false;

        while (!validBundle) {
          var kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
          kerl.initialize();

          for (var i = 0; i < bundle.transactions.length; i++) {
            bundle.transactions[i].currentIndex = tryteNumber_1.TryteNumber.fromNumber(i);
            bundle.transactions[i].lastIndex = tryteNumber_1.TryteNumber.fromNumber(bundle.transactions.length - 1);
            var bundleEssence = trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(bundle.transactions[i].address.toTrytes().toString() + bundle.transactions[i].value.toTrytes().toString() + transaction_1.Transaction.CHECK_VALUE + bundle.transactions[i].obsoleteTag.toTrytes().toString() + bundle.transactions[i].timestamp.toTrytes().toString() + bundle.transactions[i].currentIndex.toTrytes().toString() + bundle.transactions[i].lastIndex.toTrytes().toString())).toArray();
            kerl.absorb(bundleEssence, 0, bundleEssence.length);
          }

          var hashTrits = new Int8Array(kerl.getConstant("HASH_LENGTH"));
          kerl.squeeze(hashTrits, 0, hashTrits.length);
          var hash = hash_1.Hash.fromTrytes(trits_1.Trits.fromArray(hashTrits).toTrytes());

          for (var _i2 = 0; _i2 < bundle.transactions.length; _i2++) {
            bundle.transactions[_i2].bundle = hash;
          }

          var normalizedHash = iss_1.ISS.normalizedBundle(hash);

          if (normalizedHash.indexOf(13
          /* = M */
          ) !== -1) {
            // Insecure bundle. Increment Tag and recompute bundle hash.
            var increasedTag = trits_1.Trits.add(trits_1.Trits.fromTrytes(bundle.transactions[0].obsoleteTag.toTrytes()), trits_1.Trits.fromNumberArray([1]));
            bundle.transactions[0].obsoleteTag = tag_1.Tag.fromTrytes(increasedTag.toTrytes());
          } else {
            validBundle = true;
          }
        }
      }
    }
    /* @internal */

  }, {
    key: "transactionHash",
    value: function transactionHash(transaction) {
      var curl = spongeFactory_1.SpongeFactory.instance().create("curl");
      var transactionTrits = trits_1.Trits.fromTrytes(transaction.toTrytes()).toArray();
      curl.initialize();
      curl.absorb(transactionTrits, 0, transactionTrits.length);
      var hashTrits = new Int8Array(curl.getConstant("HASH_LENGTH"));
      curl.squeeze(hashTrits, 0, hashTrits.length);
      return hash_1.Hash.fromTrytes(trits_1.Trits.fromArray(hashTrits).toTrytes());
    }
    /* @internal */

  }, {
    key: "signatureMessageFragment",
    value: function signatureMessageFragment(normalizedBundleFragment, keyFragment) {
      var signatureMessageFragment = keyFragment.slice();
      var hash;
      var kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
      var hashLength = kerl.getConstant("HASH_LENGTH");

      for (var i = 0; i < 27; i++) {
        hash = signatureMessageFragment.slice(i * hashLength, (i + 1) * hashLength);

        for (var j = 0; j < 13 - normalizedBundleFragment[i]; j++) {
          kerl.initialize();
          kerl.reset();
          kerl.absorb(hash, 0, hashLength);
          kerl.squeeze(hash, 0, hashLength);
        }

        for (var _j2 = 0; _j2 < hashLength; _j2++) {
          signatureMessageFragment[i * hashLength + _j2] = hash[_j2];
        }
      }

      return signatureMessageFragment;
    }
  }]);

  return BundleHelper;
}();

BundleHelper.NUMBER_OF_FRAGMENT_CHUNKS = 27;
exports.BundleHelper = BundleHelper;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var factoryBase_1 = __webpack_require__(17);
/**
 * Factory to generate network clients.
 */


var NetworkClientFactory =
/*#__PURE__*/
function (_factoryBase_1$Factor) {
  _inherits(NetworkClientFactory, _factoryBase_1$Factor);

  /**
   * Don't allow manual construction of the factory.
   * @internal
   */
  function NetworkClientFactory() {
    _classCallCheck(this, NetworkClientFactory);

    return _possibleConstructorReturn(this, (NetworkClientFactory.__proto__ || Object.getPrototypeOf(NetworkClientFactory)).call(this));
  }
  /**
   * Get the instance of the factory.
   * @returns The factory instance.
   */


  _createClass(NetworkClientFactory, [{
    key: "getInstance",

    /* @internal */
    value: function getInstance() {
      return NetworkClientFactory.instance();
    }
  }], [{
    key: "instance",
    value: function instance() {
      if (!NetworkClientFactory._instance) {
        NetworkClientFactory._instance = new NetworkClientFactory();
      }

      return NetworkClientFactory._instance;
    }
  }]);

  return NetworkClientFactory;
}(factoryBase_1.FactoryBase);

exports.NetworkClientFactory = NetworkClientFactory;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var coreError_1 = __webpack_require__(11);

var jsonHelper_1 = __webpack_require__(16);

var objectHelper_1 = __webpack_require__(0);

var stringHelper_1 = __webpack_require__(6);
/**
 * Handle errors as gracefully as possible.
 */


var ErrorHelper =
/*#__PURE__*/
function () {
  function ErrorHelper() {
    _classCallCheck(this, ErrorHelper);
  }

  _createClass(ErrorHelper, null, [{
    key: "format",

    /**
     * Format an error object into something readable.
     * @param err The object to format.
     * @param includeStack Include the stack trace if there is one.
     * @returns Formatted version of the error object.
     */
    value: function format(err, includeStack) {
      if (err === null || err === undefined) {
        return "unknown error";
      } else if (coreError_1.CoreError.isError(err)) {
        var ret = err.format();

        if (includeStack && err.stack) {
          ret += "\nStack Trace";
          var parts = err.stack.split("\n");
          parts.shift();
          ret += "\n".concat(parts.join("\n"));
        }

        if (!objectHelper_1.ObjectHelper.isEmpty(err.innerError)) {
          if (includeStack && !objectHelper_1.ObjectHelper.isEmpty(err.innerError.stack)) {
            ret += "\n\n-----------------------------------------------";
            ret += "\nInner Stack Trace\n";
            ret += err.innerError.stack;
          } else {
            ret += "\nInner Error: ".concat(err.innerError.message, "\n");
          }
        }

        return ret;
      } else if (err instanceof Error) {
        var _ret = "";

        if (includeStack && !objectHelper_1.ObjectHelper.isEmpty(err.stack)) {
          _ret += err.stack;
        } else {
          _ret += err.message;
        }

        return _ret;
      } else {
        if (stringHelper_1.StringHelper.isString(err)) {
          return err;
        } else {
          return jsonHelper_1.JsonHelper.stringify(err, undefined, "\t");
        }
      }
    }
  }]);

  return ErrorHelper;
}();

exports.ErrorHelper = ErrorHelper;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(60);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Default implementation of background task service.
 */

var BackgroundTaskService =
/*#__PURE__*/
function () {
  function BackgroundTaskService() {
    _classCallCheck(this, BackgroundTaskService);
  }

  _createClass(BackgroundTaskService, [{
    key: "create",

    /**
     * Create a background task.
     * @param task The task to run in the background.
     * @param delay The delay before running the task.
     */
    value: function () {
      var _create = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee(task, delay) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  setTimeout(function () {
                    try {
                      resolve(task());
                    } catch (err) {
                      reject(err);
                    }
                  }, delay);
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function create(_x, _x2) {
        return _create.apply(this, arguments);
      };
    }()
  }]);

  return BackgroundTaskService;
}();

exports.BackgroundTaskService = BackgroundTaskService;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(0);

var stringHelper_1 = __webpack_require__(6);

var trytes_1 = __webpack_require__(1);

var dataError_1 = __webpack_require__(3);
/**
 * Trytes converter that converts to and from a string.
 */


var AsciiTrytesConverter =
/*#__PURE__*/
function () {
  function AsciiTrytesConverter() {
    _classCallCheck(this, AsciiTrytesConverter);
  }

  _createClass(AsciiTrytesConverter, [{
    key: "to",

    /**
     * Convert a string value into trytes.
     * @param string value to convert into trytes.
     * @returns The trytes representation of the value.
     */
    value: function to(value) {
      if (!stringHelper_1.StringHelper.isString(value)) {
        throw new dataError_1.DataError("The value must not be string", {
          value: value
        });
      }

      if (!stringHelper_1.StringHelper.isAscii(value)) {
        throw new dataError_1.DataError("The value contains non ASCII characters", {
          value: value
        });
      }

      var trytes = "";

      for (var i = 0; i < value.length; i++) {
        var asciiValue = value.charCodeAt(i);
        var firstValue = asciiValue % 27;
        var secondValue = (asciiValue - firstValue) / 27;
        trytes += trytes_1.Trytes.ALPHABET[firstValue] + trytes_1.Trytes.ALPHABET[secondValue];
      }

      return trytes_1.Trytes.fromString(trytes);
    }
    /**
     * Convert trytes into a string value.
     * @param trytes to convert into a string value.
     * @returns The string value converted from the trytes.
     */

  }, {
    key: "from",
    value: function from(trytes) {
      if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The trytes parameter is empty or not the correct type");
      }

      var trytesString = trytes.toString();

      if (trytesString.length % 2 === 1) {
        throw new dataError_1.DataError("The trytes length must be an even number");
      }

      var ascii = "";

      for (var i = 0; i < trytesString.length; i += 2) {
        var trytesPair = trytesString[i] + trytesString[i + 1];
        var firstValue = trytes_1.Trytes.ALPHABET.indexOf(trytesPair[0]);
        var secondValue = trytes_1.Trytes.ALPHABET.indexOf(trytesPair[1]);
        var decimalValue = firstValue + secondValue * 27;
        ascii += String.fromCharCode(decimalValue);
      }

      return ascii;
    }
  }]);

  return AsciiTrytesConverter;
}();

exports.AsciiTrytesConverter = AsciiTrytesConverter;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var dataError_1 = __webpack_require__(3);

var address_1 = __webpack_require__(8);

var addressSecurity_1 = __webpack_require__(19);
/**
 * A class for handling inputs.
 */


var Input =
/*#__PURE__*/
function () {
  /* @internal */
  function Input() {
    _classCallCheck(this, Input);
  }
  /**
   * Create instance of input from parameters.
   * @param address The address.
   * @param security The address security.
   * @param keyIndex The key index.
   * @param balance The balance of the address.
   * @return New instance of Input.
   */


  _createClass(Input, null, [{
    key: "fromParams",
    value: function fromParams(address, security, keyIndex, balance) {
      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {
        throw new dataError_1.DataError("The address should be a valid Address object");
      }

      if (!numberHelper_1.NumberHelper.isInteger(security) || security < addressSecurity_1.AddressSecurity.low || security > addressSecurity_1.AddressSecurity.high) {
        throw new dataError_1.DataError("The security should be a number between ".concat(addressSecurity_1.AddressSecurity.low, " and ").concat(addressSecurity_1.AddressSecurity.high));
      }

      if (!numberHelper_1.NumberHelper.isInteger(keyIndex) || keyIndex < 0) {
        throw new dataError_1.DataError("The keyIndex should be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(balance) || balance < 0) {
        throw new dataError_1.DataError("The balance should be a number >= 0");
      }

      var input = new Input();
      input.address = address;
      input.security = security;
      input.keyIndex = keyIndex;
      input.balance = balance;
      return input;
    }
  }]);

  return Input;
}();

exports.Input = Input;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var coreError_1 = __webpack_require__(11);
/**
 * An api implementation of an error.
 */


var ApiError =
/*#__PURE__*/
function (_coreError_1$CoreErro) {
  _inherits(ApiError, _coreError_1$CoreErro);

  /**
   * Create an instance of ApiError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function ApiError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, ApiError);

    _this = _possibleConstructorReturn(this, (ApiError.__proto__ || Object.getPrototypeOf(ApiError)).call(this, message, additional, innerError));
    _this.domain = "API";
    return _this;
  }

  return ApiError;
}(coreError_1.CoreError);

exports.ApiError = ApiError;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(34));

__export(__webpack_require__(5));

__export(__webpack_require__(70));

__export(__webpack_require__(10));

__export(__webpack_require__(21));

__export(__webpack_require__(37));

__export(__webpack_require__(35));

__export(__webpack_require__(36));

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(0);

var cryptoError_1 = __webpack_require__(5);
/**
 * Sha3 implementation.
 */


var Sha3 =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of SHA3.
   * @param bits The number of input bits.
   * @param padding The padding to use.
   * @param outputBits The number of output bits.
   */
  function Sha3(bits, padding, outputBits) {
    _classCallCheck(this, Sha3);

    this._padding = padding;
    this._outputBits = outputBits;
    this._blockCount = 1600 - (bits << 1) >> 5;
    this._byteCount = this._blockCount << 2;
    this._outputBlocks = outputBits >> 5;
    this._extraBytes = (outputBits & 31) >> 3;
    this.reset();
  }
  /**
   * Reset the digest.
   */


  _createClass(Sha3, [{
    key: "reset",
    value: function reset() {
      this._reset = true;
      this._block = 0;
      this._start = 0;
      this._blocks = new Uint32Array(this._blockCount + 1);
      this._state = new Uint32Array(50);
    }
    /**
     * Update the digest.
     * @param input Array of data to use in the update.
     */

  }, {
    key: "update",
    value: function update(input) {
      if (!objectHelper_1.ObjectHelper.isType(input, ArrayBuffer)) {
        throw new cryptoError_1.CryptoError("Input is not of type ArrayBuffer");
      }

      var message = new Uint8Array(input);
      var length = message.length;
      var index = 0;
      var i;

      while (index < length) {
        if (this._reset) {
          this._reset = false;
          this._blocks[0] = this._block;

          for (i = 1; i < this._blockCount + 1; ++i) {
            this._blocks[i] = 0;
          }
        }

        for (i = this._start; index < length && i < this._byteCount; ++index) {
          this._blocks[i >> 2] |= message[index] << Sha3.SHIFT[i++ & 3];
        }

        this._lastByteIndex = i;

        if (i >= this._byteCount) {
          this._start = i - this._byteCount;
          this._block = this._blocks[this._blockCount];

          for (i = 0; i < this._blockCount; ++i) {
            this._state[i] ^= this._blocks[i];
          }

          this.keccakPermutation(this._state);
          this._reset = true;
        } else {
          this._start = i;
        }
      }
    }
    /**
     * Finalize and return the hash for the digest, will also reset the state.
     * @return Array buffer containing the digest.
     */

  }, {
    key: "digest",
    value: function digest() {
      this.finalize();
      var i = 0;
      var j = 0;
      var bytes = this._outputBits >> 3;
      var buffer;

      if (this._extraBytes) {
        buffer = new ArrayBuffer(this._outputBlocks + 1 << 2);
      } else {
        buffer = new ArrayBuffer(bytes);
      }

      var array = new Uint32Array(buffer);

      while (j < this._outputBlocks) {
        for (i = 0; i < this._blockCount && j < this._outputBlocks; ++i, ++j) {
          array[j] = this._state[i];
        }
      }

      if (this._extraBytes) {
        array[i] = this._state[i];
        buffer = buffer.slice(0, bytes);
      }

      this.reset();
      return buffer;
    }
    /* @internal */

  }, {
    key: "finalize",
    value: function finalize() {
      var i = this._lastByteIndex;
      this._blocks[i >> 2] |= this._padding[i & 3];

      if (this._lastByteIndex === this._byteCount) {
        this._blocks[0] = this._blocks[this._blockCount];

        for (i = 1; i < this._blockCount + 1; ++i) {
          this._blocks[i] = 0;
        }
      }

      this._blocks[this._blockCount - 1] |= 0x80000000;

      for (i = 0; i < this._blockCount; ++i) {
        this._state[i] ^= this._blocks[i];
      }

      this.keccakPermutation(this._state);
    }
    /* @internal */

  }, {
    key: "keccakPermutation",
    value: function keccakPermutation(s) {
      // tslint:disable-next-line:one-variable-per-declaration
      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;

      for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
        h = c8 ^ (c2 << 1 | c3 >>> 31);
        l = c9 ^ (c3 << 1 | c2 >>> 31);
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ (c4 << 1 | c5 >>> 31);
        l = c1 ^ (c5 << 1 | c4 >>> 31);
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ (c6 << 1 | c7 >>> 31);
        l = c3 ^ (c7 << 1 | c6 >>> 31);
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ (c8 << 1 | c9 >>> 31);
        l = c5 ^ (c9 << 1 | c8 >>> 31);
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ (c0 << 1 | c1 >>> 31);
        l = c7 ^ (c1 << 1 | c0 >>> 31);
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;
        b0 = s[0];
        b1 = s[1];
        b32 = s[11] << 4 | s[10] >>> 28;
        b33 = s[10] << 4 | s[11] >>> 28;
        b14 = s[20] << 3 | s[21] >>> 29;
        b15 = s[21] << 3 | s[20] >>> 29;
        b46 = s[31] << 9 | s[30] >>> 23;
        b47 = s[30] << 9 | s[31] >>> 23;
        b28 = s[40] << 18 | s[41] >>> 14;
        b29 = s[41] << 18 | s[40] >>> 14;
        b20 = s[2] << 1 | s[3] >>> 31;
        b21 = s[3] << 1 | s[2] >>> 31;
        b2 = s[13] << 12 | s[12] >>> 20;
        b3 = s[12] << 12 | s[13] >>> 20;
        b34 = s[22] << 10 | s[23] >>> 22;
        b35 = s[23] << 10 | s[22] >>> 22;
        b16 = s[33] << 13 | s[32] >>> 19;
        b17 = s[32] << 13 | s[33] >>> 19;
        b48 = s[42] << 2 | s[43] >>> 30;
        b49 = s[43] << 2 | s[42] >>> 30;
        b40 = s[5] << 30 | s[4] >>> 2;
        b41 = s[4] << 30 | s[5] >>> 2;
        b22 = s[14] << 6 | s[15] >>> 26;
        b23 = s[15] << 6 | s[14] >>> 26;
        b4 = s[25] << 11 | s[24] >>> 21;
        b5 = s[24] << 11 | s[25] >>> 21;
        b36 = s[34] << 15 | s[35] >>> 17;
        b37 = s[35] << 15 | s[34] >>> 17;
        b18 = s[45] << 29 | s[44] >>> 3;
        b19 = s[44] << 29 | s[45] >>> 3;
        b10 = s[6] << 28 | s[7] >>> 4;
        b11 = s[7] << 28 | s[6] >>> 4;
        b42 = s[17] << 23 | s[16] >>> 9;
        b43 = s[16] << 23 | s[17] >>> 9;
        b24 = s[26] << 25 | s[27] >>> 7;
        b25 = s[27] << 25 | s[26] >>> 7;
        b6 = s[36] << 21 | s[37] >>> 11;
        b7 = s[37] << 21 | s[36] >>> 11;
        b38 = s[47] << 24 | s[46] >>> 8;
        b39 = s[46] << 24 | s[47] >>> 8;
        b30 = s[8] << 27 | s[9] >>> 5;
        b31 = s[9] << 27 | s[8] >>> 5;
        b12 = s[18] << 20 | s[19] >>> 12;
        b13 = s[19] << 20 | s[18] >>> 12;
        b44 = s[29] << 7 | s[28] >>> 25;
        b45 = s[28] << 7 | s[29] >>> 25;
        b26 = s[38] << 8 | s[39] >>> 24;
        b27 = s[39] << 8 | s[38] >>> 24;
        b8 = s[48] << 14 | s[49] >>> 18;
        b9 = s[49] << 14 | s[48] >>> 18;
        s[0] = b0 ^ ~b2 & b4;
        s[1] = b1 ^ ~b3 & b5;
        s[10] = b10 ^ ~b12 & b14;
        s[11] = b11 ^ ~b13 & b15;
        s[20] = b20 ^ ~b22 & b24;
        s[21] = b21 ^ ~b23 & b25;
        s[30] = b30 ^ ~b32 & b34;
        s[31] = b31 ^ ~b33 & b35;
        s[40] = b40 ^ ~b42 & b44;
        s[41] = b41 ^ ~b43 & b45;
        s[2] = b2 ^ ~b4 & b6;
        s[3] = b3 ^ ~b5 & b7;
        s[12] = b12 ^ ~b14 & b16;
        s[13] = b13 ^ ~b15 & b17;
        s[22] = b22 ^ ~b24 & b26;
        s[23] = b23 ^ ~b25 & b27;
        s[32] = b32 ^ ~b34 & b36;
        s[33] = b33 ^ ~b35 & b37;
        s[42] = b42 ^ ~b44 & b46;
        s[43] = b43 ^ ~b45 & b47;
        s[4] = b4 ^ ~b6 & b8;
        s[5] = b5 ^ ~b7 & b9;
        s[14] = b14 ^ ~b16 & b18;
        s[15] = b15 ^ ~b17 & b19;
        s[24] = b24 ^ ~b26 & b28;
        s[25] = b25 ^ ~b27 & b29;
        s[34] = b34 ^ ~b36 & b38;
        s[35] = b35 ^ ~b37 & b39;
        s[44] = b44 ^ ~b46 & b48;
        s[45] = b45 ^ ~b47 & b49;
        s[6] = b6 ^ ~b8 & b0;
        s[7] = b7 ^ ~b9 & b1;
        s[16] = b16 ^ ~b18 & b10;
        s[17] = b17 ^ ~b19 & b11;
        s[26] = b26 ^ ~b28 & b20;
        s[27] = b27 ^ ~b29 & b21;
        s[36] = b36 ^ ~b38 & b30;
        s[37] = b37 ^ ~b39 & b31;
        s[46] = b46 ^ ~b48 & b40;
        s[47] = b47 ^ ~b49 & b41;
        s[8] = b8 ^ ~b0 & b2;
        s[9] = b9 ^ ~b1 & b3;
        s[18] = b18 ^ ~b10 & b12;
        s[19] = b19 ^ ~b11 & b13;
        s[28] = b28 ^ ~b20 & b22;
        s[29] = b29 ^ ~b21 & b23;
        s[38] = b38 ^ ~b30 & b32;
        s[39] = b39 ^ ~b31 & b33;
        s[48] = b48 ^ ~b40 & b42;
        s[49] = b49 ^ ~b41 & b43;
        s[0] ^= Sha3.ROUND_CONSTANTS[n];
        s[1] ^= Sha3.ROUND_CONSTANTS[n + 1];
      }
    }
  }]);

  return Sha3;
}();
/* Padding to use for Keccak */


Sha3.KECCAK_PADDING = new Uint32Array([1, 256, 65536, 16777216]);
/* @internal */

Sha3.SHIFT = new Uint8Array([0, 8, 16, 24]);
/* @internal */

Sha3.ROUND_CONSTANTS = new Uint32Array([1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]);
exports.Sha3 = Sha3;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var cryptoError_1 = __webpack_require__(5);
/**
 * Implementation of ISponge using Curl algorithm.
 * https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/curl/curl.js
 */


var Curl =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of Curl.
   * @param rounds The number of rounds to use.
   */
  function Curl() {
    var rounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Curl.NUMBER_OF_ROUNDS;

    _classCallCheck(this, Curl);

    this._numberOfRounds = rounds;
  }
  /**
   * Get the constant for the spone.
   * @name The name of the contant to get.
   * @returns The constant.
   */


  _createClass(Curl, [{
    key: "getConstant",
    value: function getConstant(name) {
      switch (name) {
        case "NUMBER_OF_ROUNDS":
          {
            return this._numberOfRounds;
          }

        case "HASH_LENGTH":
        case "STATE_LENGTH":
          {
            return Curl[name];
          }

        default:
          throw new cryptoError_1.CryptoError("Unknown constant requested ".concat(name));
      }
    }
    /**
     * Get the state.
     * @returns The state.
     */

  }, {
    key: "getState",
    value: function getState() {
      return this._state;
    }
    /**
     * Initialise the hasher.
     * @param state The initial state for the hasher.
     */

  }, {
    key: "initialize",
    value: function initialize(state) {
      if (state) {
        this._state = state;
      } else {
        this._state = new Int8Array(Curl.STATE_LENGTH);
      }
    }
    /**
     * Reset the hasher.
     */

  }, {
    key: "reset",
    value: function reset() {
      this.initialize();
    }
    /**
     * Absorb trits into the hash.
     * @param trits The trits to absorb.
     * @param offset The offset into the trits to absorb from.
     * @param length The number of trits to absorb.
     */

  }, {
    key: "absorb",
    value: function absorb(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var i = 0;
        var limit = localLength < Curl.HASH_LENGTH ? localLength : Curl.HASH_LENGTH;

        while (i < limit) {
          this._state[i++] = trits[localOffset++];
        }

        this.transform();
        localLength -= Curl.HASH_LENGTH;
      } while (localLength > 0);
    }
    /**
     * Squeeze trits into the hash.
     * @param trits The trits to squeeze.
     * @param offset The offset into the trits to squeeze from.
     * @param length The number of trits to squeeze.
     */

  }, {
    key: "squeeze",
    value: function squeeze(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var i = 0;
        var limit = localLength < Curl.HASH_LENGTH ? length : Curl.HASH_LENGTH;

        while (i < limit) {
          trits[localOffset++] = this._state[i++];
        }

        this.transform();
        localLength -= Curl.HASH_LENGTH;
      } while (localLength > 0);
    }
    /**
     * Transform the hash.
     * @internal
     */

  }, {
    key: "transform",
    value: function transform() {
      var stateCopy;
      var index = 0;

      for (var round = 0; round < this._numberOfRounds; round++) {
        stateCopy = new Int8Array(this._state.slice());

        for (var i = 0; i < Curl.STATE_LENGTH; i++) {
          this._state[i] = Curl.TRUTH_TABLE[stateCopy[index] + (stateCopy[index += index < 365 ? 364 : -365] << 2) + 5];
        }
      }
    }
  }]);

  return Curl;
}();

Curl.HASH_LENGTH = 243;
Curl.NUMBER_OF_ROUNDS = 81;
Curl.STATE_LENGTH = Curl.HASH_LENGTH * 3;
/* @internal */

Curl.TRUTH_TABLE = new Int8Array([1, 0, -1, 2, 1, -1, 0, 2, -1, 1, 0]);
exports.Curl = Curl;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var sha3_1 = __webpack_require__(34);

var cryptoError_1 = __webpack_require__(5);

var bigIntegerHelper_1 = __webpack_require__(37);
/**
 * Implementation of ISponge using Kerl algorithm.
 * https://github.com/iotaledger/iri/blob/dev/src/main/java/com/iota/iri/hash/Kerl.java
 */


var Kerl =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of Kerl.
   */
  function Kerl() {
    _classCallCheck(this, Kerl);

    this._keccak = new sha3_1.Sha3(384, sha3_1.Sha3.KECCAK_PADDING, 384);
  }
  /**
   * Get the constant for the spone.
   * @name The name of the contant to get.
   * @returns The constant.
   */


  _createClass(Kerl, [{
    key: "getConstant",
    value: function getConstant(name) {
      switch (name) {
        case "HASH_LENGTH":
        case "BIT_HASH_LENGTH":
        case "BYTE_HASH_LENGTH":
          {
            return Kerl[name];
          }

        default:
          throw new cryptoError_1.CryptoError("Unknown constant requested ".concat(name));
      }
    }
    /**
     * Get the state.
     * @returns The state.
     */

  }, {
    key: "getState",
    value: function getState() {
      return undefined;
    }
    /**
     * Initialise the hasher.
     * @param state The initial state for the hasher.
     */

  }, {
    key: "initialize",
    value: function initialize(state) {}
    /**
     * Reset the hasher.
     */

  }, {
    key: "reset",
    value: function reset() {
      this._keccak.reset();
    }
    /**
     * Absorb trits into the hash.
     * @param trits The trits to absorb.
     * @param offset The offset into the trits to absorb from.
     * @param length The number of trits to absorb.
     */

  }, {
    key: "absorb",
    value: function absorb(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      if (length % 243 !== 0) {
        throw new cryptoError_1.CryptoError("Length must be a multiple of ".concat(Kerl.HASH_LENGTH), {
          length: length
        });
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var tritState = trits.slice(localOffset, localOffset + Kerl.HASH_LENGTH);
        tritState[Kerl.HASH_LENGTH - 1] = 0;
        var bigInt = bigIntegerHelper_1.BigIntegerHelper.tritsToBigInteger(tritState, 0, tritState.length);
        var byteState = new ArrayBuffer(Kerl.BYTE_HASH_LENGTH);
        bigIntegerHelper_1.BigIntegerHelper.bigIntegerToBytes(bigInt, byteState, 0);

        this._keccak.update(byteState);

        localOffset += Kerl.HASH_LENGTH;
        localLength -= Kerl.HASH_LENGTH;
      } while (localLength > 0);
    }
    /**
     * Squeeze trits into the hash.
     * @param trits The trits to squeeze.
     * @param offset The offset into the trits to squeeze from.
     * @param length The number of trits to squeeze.
     */

  }, {
    key: "squeeze",
    value: function squeeze(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      if (length % 243 !== 0) {
        throw new cryptoError_1.CryptoError("Length must be a multiple of ".concat(Kerl.HASH_LENGTH), {
          length: length
        });
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var byteStateBuffer = this._keccak.digest();

        var bigInt = bigIntegerHelper_1.BigIntegerHelper.bytesToBigInteger(byteStateBuffer, 0, Kerl.BYTE_HASH_LENGTH);
        var tritState = new Int8Array(Kerl.HASH_LENGTH);
        bigIntegerHelper_1.BigIntegerHelper.bigIntegerToTrits(bigInt, tritState, 0, Kerl.HASH_LENGTH);
        tritState[Kerl.HASH_LENGTH - 1] = 0;
        var i = 0;

        while (i < Kerl.HASH_LENGTH) {
          trits[localOffset++] = tritState[i++];
        }

        var dv = new DataView(byteStateBuffer);

        for (i = 0; i < dv.byteLength; i++) {
          dv.setUint8(i, dv.getUint8(i) ^ 0xFF);
        }

        this._keccak.update(byteStateBuffer);

        localLength -= Kerl.HASH_LENGTH;
      } while (localLength > 0);
    }
  }]);

  return Kerl;
}();
/* @internal */


Kerl.HASH_LENGTH = 243;
/* @internal */

Kerl.BIT_HASH_LENGTH = 384;
/* @internal */

Kerl.BYTE_HASH_LENGTH = Kerl.BIT_HASH_LENGTH / 8;
exports.Kerl = Kerl;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0); // tslint:disable-next-line:import-name


var big_integer_1 = __importDefault(__webpack_require__(38));

var cryptoError_1 = __webpack_require__(5);
/**
 * Helper class to convert between BigInteger and other types.
 * Converted from https://github.com/iotaledger/iri/blob/dev/src/main/java/com/iota/iri/hash/Kerl.java
 */


var BigIntegerHelper =
/*#__PURE__*/
function () {
  function BigIntegerHelper() {
    _classCallCheck(this, BigIntegerHelper);
  }

  _createClass(BigIntegerHelper, null, [{
    key: "tritsToBigInteger",

    /**
     * Convert trits to a bigInteger.
     * @param trits The trits to convert.
     * @param offset Offset within the array to start.
     * @param length The length of the trits array to convert.
     */
    value: function tritsToBigInteger(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("The trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new cryptoError_1.CryptoError("The length must be a number > 0");
      }

      if (offset + length > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the array");
      }

      var value = big_integer_1.default.zero;

      for (var i = length - 1; i >= 0; i--) {
        value = value.multiply(BigIntegerHelper.RADIX).add(big_integer_1.default(trits[offset + i]));
      }

      return value;
    }
    /**
     * Convert bigInteger to trits.
     * @param value The bigInteger to convert to trits.
     * @param trits The array to receive the trits.
     * @param offset The offset to place the trits in the array.
     * @param length The length of the array.
     */

  }, {
    key: "bigIntegerToTrits",
    value: function bigIntegerToTrits(value, trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(value, big_integer_1.default)) {
        throw new cryptoError_1.CryptoError("The value must be a bigInteger type");
      }

      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array)) {
        throw new cryptoError_1.CryptoError("The trits must be an Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new cryptoError_1.CryptoError("The length must be a number > 0");
      }

      if (offset + length > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the array");
      }

      var absoluteValue = value.compareTo(big_integer_1.default.zero) < 0 ? value.negate() : value;

      for (var i = 0; i < length; i++) {
        var divRemainder = absoluteValue.divmod(BigIntegerHelper.RADIX);
        absoluteValue = divRemainder.quotient;
        var remainder = divRemainder.remainder;

        if (remainder > BigIntegerHelper.MAX_TRIT_VALUE) {
          remainder = BigIntegerHelper.MIN_TRIT_VALUE;
          absoluteValue = absoluteValue.add(big_integer_1.default["1"]);
        }

        trits[offset + i] = remainder.toJSNumber();
      }

      if (value.compareTo(big_integer_1.default.zero) < 0) {
        for (var _i = 0; _i < length; _i++) {
          // Avoid negative zero
          trits[offset + _i] = trits[offset + _i] === 0 ? 0 : -trits[offset + _i];
        }
      }
    }
    /**
     * Convert the bigInteger into bytes.
     * @param value The value to convert.
     * @param destination The destination array to store the bytes.
     * @param offset The offset within the array to store the bytes.
     */

  }, {
    key: "bigIntegerToBytes",
    value: function bigIntegerToBytes(value, destination, offset) {
      if (!objectHelper_1.ObjectHelper.isType(value, big_integer_1.default)) {
        throw new cryptoError_1.CryptoError("The value must be a bigInteger type");
      }

      if (!objectHelper_1.ObjectHelper.isType(destination, ArrayBuffer) || destination.byteLength === 0) {
        throw new cryptoError_1.CryptoError("The destination must be an array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (destination.byteLength - offset < BigIntegerHelper.BYTE_HASH_LENGTH) {
        throw new cryptoError_1.CryptoError("Destination array has invalid size, it must be at least ".concat(BigIntegerHelper.BYTE_HASH_LENGTH));
      } // Remember if it is negative for later


      var isNeg = value.isNegative() ? -1 : 0;
      var hexString = value.toString(16);

      if (isNeg === -1) {
        // But remove it for now
        hexString = hexString.slice(1);
      } // Now make sure the hex string is an even length so the regex works


      if (hexString.length % 2 === 1) {
        hexString = "0".concat(hexString);
      }

      var matches = hexString.match(/[0-9a-f]{2}/g); // Convert the hex to numbers

      var signedBytes = new Int8Array(matches.map(function (hex) {
        return parseInt("0x".concat(hex), 16);
      }));

      if (isNeg === -1) {
        BigIntegerHelper.twosComplement(signedBytes);
      }

      var dataView = new DataView(destination); // Pad the start of the buffer with the neg value

      var i = offset;

      while (i + signedBytes.length < BigIntegerHelper.BYTE_HASH_LENGTH) {
        dataView.setInt8(i++, isNeg);
      } // And copy in the actual bytes


      for (var j = signedBytes.length; j-- > 0;) {
        dataView.setInt8(i++, signedBytes[signedBytes.length - 1 - j]);
      }
    }
    /**
     * Convert bytes to a bigInteger.
     * @param source The source bytes.
     * @param offset The offset within the bytes to start conversion.
     * @param length The length of the bytes to use for conversion.
     */

  }, {
    key: "bytesToBigInteger",
    value: function bytesToBigInteger(source, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(source, ArrayBuffer) || source.byteLength === 0) {
        throw new cryptoError_1.CryptoError("The source must be a non empty number array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new cryptoError_1.CryptoError("The length must be a number > 0");
      }

      if (source.byteLength - offset < BigIntegerHelper.BYTE_HASH_LENGTH) {
        throw new cryptoError_1.CryptoError("Source array has invalid size, it must be at least ".concat(BigIntegerHelper.BYTE_HASH_LENGTH));
      }

      var dataView = new DataView(source);
      var signedBytes = new Int8Array(dataView.byteLength);

      for (var b = 0; b < dataView.byteLength; b++) {
        signedBytes[b] = dataView.getInt8(b + offset);
      } // Remove the initial padding leaving at least one byte


      var paddingOffset = 0;
      var firstByte = signedBytes[0];
      var isNeg = firstByte < 0; // If the first padding character is negative then reverse the 2s complement
      // but first strip of the leading padding

      if (firstByte === 0 || firstByte === -1) {
        while (signedBytes[paddingOffset] === firstByte && paddingOffset < signedBytes.length - 1) {
          paddingOffset++;
        } // Strip any padding


        signedBytes = signedBytes.slice(paddingOffset);
      }

      if (isNeg) {
        BigIntegerHelper.twosComplement(signedBytes);
      }

      var hexString = isNeg ? "-" : "";
      var dv = new DataView(signedBytes.buffer);

      for (var h = 0; h < dv.byteLength; h++) {
        hexString += "00".concat(dv.getUint8(h).toString(16)).slice(-2);
      }

      return big_integer_1.default(hexString, 16);
    }
    /* @internal */

  }, {
    key: "twosComplement",
    value: function twosComplement(signedBytes) {
      // if the whole number is negative then
      // change to 2's complements by noting all the numbers
      // and adding 1 to the last i.e. ~bignum+1
      for (var b = 0; b < signedBytes.length; b++) {
        signedBytes[b] = ~signedBytes[b];
      } // Add 1 to last number, if the number is 0xFF continue to carry


      var c = signedBytes.length - 1;

      do {
        signedBytes[c]++;
      } while (signedBytes[c--] === 0 && c > 0);
    }
  }]);

  return BigIntegerHelper;
}();
/* @internal */


BigIntegerHelper.RADIX = big_integer_1.default(3);
/* @internal */

BigIntegerHelper.MAX_TRIT_VALUE = BigIntegerHelper.RADIX.minus(1).divide(2);
/* @internal */

BigIntegerHelper.MIN_TRIT_VALUE = BigIntegerHelper.MAX_TRIT_VALUE.negate();
/* @internal */

BigIntegerHelper.BIT_HASH_LENGTH = 384;
/* @internal */

BigIntegerHelper.BYTE_HASH_LENGTH = BigIntegerHelper.BIT_HASH_LENGTH / 8;
exports.BigIntegerHelper = BigIntegerHelper;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_38__;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var spongeFactory_1 = __webpack_require__(10);

var trits_1 = __webpack_require__(7);
/**
 * Helper class for address signing.
 * Original https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/signing/signing.js
 * @internal
 */


var AddressHelper =
/*#__PURE__*/
function () {
  function AddressHelper() {
    _classCallCheck(this, AddressHelper);
  }

  _createClass(AddressHelper, null, [{
    key: "createChecksum",

    /**
     * Create a checksum for the trits.
     * @param trits The trits to create the checksum for.
     * @param checksumLength The length of the checksum.
     * @returns the checksum as trytes.
     */
    value: function createChecksum(trits, checksumLength) {
      var kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
      kerl.initialize();
      kerl.absorb(trits, 0, trits.length);
      var checksumTrits = new Int8Array(kerl.getConstant("HASH_LENGTH"));
      kerl.squeeze(checksumTrits, 0, checksumTrits.length);
      return trits_1.Trits.fromArray(checksumTrits).toTrytes().toString().substring(81 - checksumLength, 81);
    }
  }]);

  return AddressHelper;
}();

exports.AddressHelper = AddressHelper;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var spongeFactory_1 = __webpack_require__(10);

var signatureMessageFragment_1 = __webpack_require__(12);

var trits_1 = __webpack_require__(7);

var trytes_1 = __webpack_require__(1);
/**
 * Hashed Message Authentication Code using Curl.
 */


var HmacCurl =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of the HmacCurl.
   * @param key The key to seed with.
   */
  function HmacCurl(key) {
    _classCallCheck(this, HmacCurl);

    this._keyTrits = trits_1.Trits.fromTrytes(key).toArray();
  }
  /**
   * Add bundle to the HMAC.
   */


  _createClass(HmacCurl, [{
    key: "addHMAC",
    value: function addHMAC(bundle) {
      var curl = spongeFactory_1.SpongeFactory.instance().create("curl", HmacCurl.HMAC_ROUNDS);
      var hashLength = curl.getConstant("HASH_LENGTH");
      var key = this._keyTrits;

      for (var i = 0; i < bundle.transactions.length; i++) {
        if (bundle.transactions[i].value.toNumber() > 0) {
          var bundleHashTrits = trits_1.Trits.fromTrytes(bundle.transactions[i].bundle.toTrytes()).toArray();
          var hmac = new Int8Array(hashLength);
          curl.initialize();
          curl.absorb(key, 0, key.length);
          curl.absorb(bundleHashTrits, 0, bundleHashTrits.length);
          curl.squeeze(hmac, 0, hmac.length);
          var hmacTrytes = trits_1.Trits.fromArray(hmac).toTrytes().toString();
          var rest = bundle.transactions[i].signatureMessageFragment.toTrytes().toString().substring(81, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);
          bundle.transactions[i].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(hmacTrytes + rest));
        }
      }
    }
  }]);

  return HmacCurl;
}();
/* @internal */


HmacCurl.HMAC_ROUNDS = 27;
exports.HmacCurl = HmacCurl;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(4);

var objectHelper_1 = __webpack_require__(0);

var spongeFactory_1 = __webpack_require__(10);

var address_1 = __webpack_require__(8);

var trits_1 = __webpack_require__(7);

var trytes_1 = __webpack_require__(1);

var businessError_1 = __webpack_require__(22);
/**
 * Address using multiple signatures.
 */


var MultiSigAddress =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of the MultiSigAddress.
   */
  function MultiSigAddress() {
    _classCallCheck(this, MultiSigAddress);

    this._kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
    this._hashLength = this._kerl.getConstant("HASH_LENGTH");

    this._kerl.initialize();
  }
  /**
   * Absorb key digests.
   * @param digests The digests hashes to absorb.
   */


  _createClass(MultiSigAddress, [{
    key: "absorb",
    value: function absorb(digests) {
      if (!arrayHelper_1.ArrayHelper.isTyped(digests, trytes_1.Trytes)) {
        throw new businessError_1.BusinessError("The digests should be an array of type Trytes");
      }

      for (var i = 0; i < digests.length; i++) {
        var digestTrits = trits_1.Trits.fromTrytes(digests[i]).toArray();

        this._kerl.absorb(digestTrits, 0, digestTrits.length);
      }
    }
    /**
     * Finalizes and returns the multisig address in trytes.
     * @param digests The final digests hashes to absorb.
     * @returns The multi signature address.
     */

  }, {
    key: "finalize",
    value: function finalize(digests) {
      if (!objectHelper_1.ObjectHelper.isEmpty(digests)) {
        this.absorb(digests);
      }

      var addressTrits = new Int8Array(this._hashLength);

      this._kerl.squeeze(addressTrits, 0, addressTrits.length);

      return address_1.Address.fromTrytes(trits_1.Trits.fromArray(addressTrits).toTrytes());
    }
  }]);

  return MultiSigAddress;
}();

exports.MultiSigAddress = MultiSigAddress;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(73);


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(76));

__export(__webpack_require__(45));

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(77);


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(44);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var networkError_1 = __webpack_require__(23);

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var stringHelper_1 = __webpack_require__(6);

var nullLogger_1 = __webpack_require__(18);
/**
 * Implementation of a node client for use in the browser.
 */


var NetworkClient =
/*#__PURE__*/
function () {
  /**
   * Create an instance of NetworkClient.
   * @param networkEndPoint The endpoint to use for the client.
   * @param logger Logger to send communication info to.
   * @param timeoutMs The timeout in ms before aborting.
   */
  function NetworkClient(networkEndPoint, logger) {
    var timeoutMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, NetworkClient);

    if (objectHelper_1.ObjectHelper.isEmpty(networkEndPoint)) {
      throw new networkError_1.NetworkError("The networkEndPoint must be defined");
    }

    if (!numberHelper_1.NumberHelper.isInteger(timeoutMs) || timeoutMs < 0) {
      throw new networkError_1.NetworkError("The timeoutMs must be >= 0");
    }

    this._networkEndPoint = networkEndPoint;
    this._timeoutMs = timeoutMs;
    this._logger = logger || new nullLogger_1.NullLogger();

    this._logger.banner("Network Client", {
      endPoint: this._networkEndPoint
    });
  }
  /**
   * Get data asynchronously.
   * @param additionalPath An additional path append to the endpoint path.
   * @param additionalHeaders Extra headers to send with the request.
   * @returns Promise which resolves to the object returned or rejects with error.
   */


  _createClass(NetworkClient, [{
    key: "get",
    value: function () {
      var _get = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee(additionalPath, additionalHeaders) {
        var resp;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this._logger.info("===> NetworkClient::GET Send");

                _context.next = 3;
                return this.doRequest("GET", undefined, additionalPath, additionalHeaders);

              case 3:
                resp = _context.sent;

                this._logger.info("<=== NetworkClient::GET Received", resp);

                return _context.abrupt("return", resp);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function get(_x, _x2) {
        return _get.apply(this, arguments);
      };
    }()
    /**
     * Post data asynchronously.
     * @param additionalPath An additional path append to the endpoint path.
     * @param data The data to send.
     * @param additionalHeaders Extra headers to send with the request.
     * @returns Promise which resolves to the object returned or rejects with error.
     */

  }, {
    key: "post",
    value: function () {
      var _post = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2(data, additionalPath, additionalHeaders) {
        var resp;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this._logger.info("===> NetworkClient::POST Send", data);

                _context2.next = 3;
                return this.doRequest("POST", data, additionalPath, additionalHeaders);

              case 3:
                resp = _context2.sent;

                this._logger.info("<=== NetworkClient::POST Received", resp);

                return _context2.abrupt("return", resp);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function post(_x3, _x4, _x5) {
        return _post.apply(this, arguments);
      };
    }()
    /**
     * Get data as JSON asynchronously.
     * @typeparam U The generic type for the returned object.
     * @param additionalPath An additional path append to the endpoint path.
     * @param additionalHeaders Extra headers to send with the request.
     * @returns Promise which resolves to the object returned or rejects with error.
     */

  }, {
    key: "getJson",
    value: function () {
      var _getJson = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee3(additionalPath, additionalHeaders) {
        var _this = this;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._logger.info("===> NetworkClient::GET Send");

                return _context3.abrupt("return", this.doRequest("GET", undefined, additionalPath, additionalHeaders).then(function (responseData) {
                  try {
                    var response = JSON.parse(responseData);

                    _this._logger.info("===> NetworkClient::GET Received", response);

                    return response;
                  } catch (err) {
                    _this._logger.info("===> NetworkClient::GET Parse Failed", responseData);

                    throw new networkError_1.NetworkError("Failed GET request, unable to parse response", {
                      endPoint: _this._networkEndPoint.getUri(),
                      response: responseData
                    });
                  }
                }));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function getJson(_x6, _x7) {
        return _getJson.apply(this, arguments);
      };
    }()
    /**
     * Post data as JSON asynchronously.
     * @typeparam T The generic type for the object to send.
     * @typeparam U The generic type for the returned object.
     * @param data The data to send.
     * @param additionalPath An additional path append to the endpoint path.
     * @param additionalHeaders Extra headers to send with the request.
     * @returns Promise which resolves to the object returned or rejects with error.
     */

  }, {
    key: "postJson",
    value: function () {
      var _postJson = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee4(data, additionalPath, additionalHeaders) {
        var _this2 = this;

        var headers;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this._logger.info("===> NetworkClient::POST Send");

                headers = additionalHeaders || {};
                headers["Content-Type"] = "application/json";
                return _context4.abrupt("return", this.doRequest("POST", JSON.stringify(data), additionalPath, headers).then(function (responseData) {
                  try {
                    var response = JSON.parse(responseData);

                    _this2._logger.info("===> NetworkClient::POST Received", response);

                    return response;
                  } catch (err) {
                    _this2._logger.info("===> NetworkClient::GET Parse Failed", responseData);

                    throw new networkError_1.NetworkError("Failed POST request, unable to parse response", {
                      endPoint: _this2._networkEndPoint.getUri(),
                      response: responseData
                    });
                  }
                }));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function postJson(_x8, _x9, _x10) {
        return _postJson.apply(this, arguments);
      };
    }()
    /* @internal */

  }, {
    key: "doRequest",
    value: function () {
      var _doRequest = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee5(method, data, additionalPath, additionalHeaders) {
        var _this3 = this;

        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", new Promise(function (resolve, reject) {
                  var headers = additionalHeaders || {};

                  var uri = _this3._networkEndPoint.getUri();

                  if (!stringHelper_1.StringHelper.isEmpty(additionalPath)) {
                    var stripped = "/".concat(additionalPath.replace(/^\/*/, ""));
                    uri += stripped;
                  }

                  var req = new XMLHttpRequest();

                  if (_this3._timeoutMs > 0) {
                    req.timeout = _this3._timeoutMs;
                  }

                  req.ontimeout = function () {
                    _this3._logger.error("<=== NetworkClient::Timed Out");

                    reject(new networkError_1.NetworkError("Failed ".concat(method, " request, timed out"), {
                      endPoint: uri,
                      errorResponseCode: req.status,
                      errorResponse: req.responseText || req.statusText
                    }));
                  };

                  req.onerror = function (err) {
                    _this3._logger.error("<=== NetworkClient::Errored");

                    reject(new networkError_1.NetworkError("Failed ".concat(method, " request"), {
                      endPoint: uri,
                      errorResponseCode: req.status,
                      errorResponse: req.responseText || req.statusText
                    }));
                  };

                  req.onload = function () {
                    if (req.status === 200) {
                      resolve(req.responseText);
                    } else {
                      _this3._logger.info("<=== NetworkClient::Received Fail", {
                        code: req.status,
                        data: req.responseText
                      });

                      reject(new networkError_1.NetworkError("Failed ".concat(method, " request"), {
                        endPoint: uri,
                        errorResponseCode: req.status,
                        errorResponse: req.responseText || req.statusText
                      }));
                    }
                  };

                  req.open(method, uri, true);

                  for (var key in headers) {
                    req.setRequestHeader(key, headers[key]);
                  }

                  _this3._logger.info("===> NetworkClient::Send", {
                    data: data
                  });

                  req.send(data);
                }));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function doRequest(_x11, _x12, _x13, _x14) {
        return _doRequest.apply(this, arguments);
      };
    }()
  }]);

  return NetworkClient;
}();

exports.NetworkClient = NetworkClient;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(79));

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(83));

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(88));

/***/ }),
/* 49 */
/***/ (function(module, exports) {



/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(94));

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(95);


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

exports.default = __webpack_require__(53);

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(54);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(57));

__export(__webpack_require__(63));

__export(__webpack_require__(65));

__export(__webpack_require__(33));

__export(__webpack_require__(71));

__export(__webpack_require__(43));

__export(__webpack_require__(46));

__export(__webpack_require__(47));

__export(__webpack_require__(48));

__export(__webpack_require__(50));

var pal_browser_1 = __webpack_require__(43);

var crypto_1 = __webpack_require__(33);

var pow_js_1 = __webpack_require__(47);

var pow_box_1 = __webpack_require__(46);

var pow_webgl_1 = __webpack_require__(50);

var pow_wasm_1 = __webpack_require__(48);

_asyncToGenerator(
/*#__PURE__*/
_regeneratorRuntime.mark(function _callee() {
  return _regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return pal_browser_1.PAL.initialize();

        case 2:
          crypto_1.ProofOfWorkFactory.instance().register("js", function () {
            return new pow_js_1.ProofOfWorkJs();
          });
          crypto_1.ProofOfWorkFactory.instance().register("webgl", function () {
            return new pow_webgl_1.ProofOfWorkWebGl(arguments.length <= 0 ? undefined : arguments[0]);
          });
          crypto_1.ProofOfWorkFactory.instance().register("box", function () {
            return new pow_box_1.ProofOfWorkBox(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);
          });
          crypto_1.ProofOfWorkFactory.instance().register("wasm", function () {
            return new pow_wasm_1.ProofOfWorkWasm(arguments.length <= 0 ? undefined : arguments[0]);
          });

        case 6:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, this);
}))();

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(55);


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(56);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 56 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(11));

__export(__webpack_require__(23));

__export(__webpack_require__(17));

__export(__webpack_require__(27));

__export(__webpack_require__(4));

__export(__webpack_require__(28));

__export(__webpack_require__(16));

__export(__webpack_require__(2));

__export(__webpack_require__(6));

__export(__webpack_require__(0));

__export(__webpack_require__(58));

__export(__webpack_require__(18));

__export(__webpack_require__(59));

__export(__webpack_require__(29));

__export(__webpack_require__(24));

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(4);

var errorHelper_1 = __webpack_require__(28);

var objectHelper_1 = __webpack_require__(0);

var stringHelper_1 = __webpack_require__(6);
/**
 * Implementation of ILogger which sends to the this._loggingObject.
 */
// tslint:disable:no-console


var ConsoleLogger =
/*#__PURE__*/
function () {
  /**
   * Create and instance of the console logger.
   */
  function ConsoleLogger(loggingObject) {
    _classCallCheck(this, ConsoleLogger);

    this._loggingObject = loggingObject || console;
  }
  /**
   * Send banner to the logger.
   * @param message The message to log.
   * @param args Additional parameters to log.
   */


  _createClass(ConsoleLogger, [{
    key: "banner",
    value: function banner(message) {
      this._loggingObject.log("=".repeat(80));

      this._loggingObject.log(message);

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.logArgs(this._loggingObject.log, args);

      this._loggingObject.log("=".repeat(80));
    }
    /**
     * Send log to the logger.
     * @param message The message to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "log",
    value: function log(message) {
      this._loggingObject.log(message);

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      this.logArgs(this._loggingObject.log, args);
    }
    /**
     * Send information to the logger.
     * @param message The message to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "info",
    value: function info(message) {
      this._loggingObject.info(message);

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      this.logArgs(this._loggingObject.info, args);
    }
    /**
     * Send warning to the logger.
     * @param message The message to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "warning",
    value: function warning(message) {
      this._loggingObject.warn(message);

      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      this.logArgs(this._loggingObject.warn, args);
    }
    /**
     * Send error to the logger.
     * @param message The message to log.
     * @param err An error object to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "error",
    value: function error(message, err) {
      var _this = this;

      this._loggingObject.error(message);

      if (!objectHelper_1.ObjectHelper.isEmpty(err)) {
        var lines = errorHelper_1.ErrorHelper.format(err, true).split("\n");
        lines.forEach(function (line) {
          _this._loggingObject.error("\t".concat(line));
        });
      }

      for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
        args[_key5 - 2] = arguments[_key5];
      }

      this.logArgs(this._loggingObject.error, args);
    }
    /* @internal */

  }, {
    key: "logArgs",
    value: function logArgs(logMethod, args) {
      var _this2 = this;

      if (!arrayHelper_1.ArrayHelper.isEmpty(args)) {
        var indent = "\t";
        var output = "";
        args.forEach(function (arg, index) {
          output += _this2.createItem(indent, "", arg);

          if (index < args.length - 1) {
            output += "".concat(indent).concat("-".repeat(70), "\n");
          }
        });
        logMethod(output);
      }
    }
    /* @internal */

  }, {
    key: "createItem",
    value: function createItem(indent, key, item) {
      var _this3 = this;

      var singleItemLineBreak = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "\n";
      var output = "";

      if (arrayHelper_1.ArrayHelper.isArray(item)) {
        var newIndent = "".concat(indent, "\t");

        if (stringHelper_1.StringHelper.isEmpty(key)) {
          output += "".concat(indent, "[\n");
        } else {
          output += "".concat(indent).concat(key, ": [\n");
        }

        item.forEach(function (element, index) {
          output += _this3.createItem(newIndent, "", element, "".concat(index < item.length - 1 ? "," : "", "\n"));
        });
        output += "".concat(indent, "]\n");
      } else if (objectHelper_1.ObjectHelper.isObject(item)) {
        var obString = item.toString();

        if (obString === "[object Object]") {
          var _newIndent = "".concat(indent, "\t");

          if (stringHelper_1.StringHelper.isEmpty(key)) {
            output += "".concat(indent, "{\n");
          } else {
            output += "".concat(indent).concat(key, ": {\n");
          }

          var keys = Object.keys(item);
          keys.forEach(function (itemKey, index) {
            output += _this3.createItem(_newIndent, itemKey, item[itemKey], "".concat(index < keys.length - 1 ? "," : "", "\n"));
          });
          output += "".concat(indent, "}\n");
        } else {
          output += this.createItem(indent, key, obString.replace(/\n/g, "\n".concat(indent)), singleItemLineBreak);
        }
      } else {
        if (stringHelper_1.StringHelper.isEmpty(key)) {
          output += "".concat(indent).concat(objectHelper_1.ObjectHelper.isEmpty(item) ? item : item.toString()).concat(singleItemLineBreak);
        } else {
          output += "".concat(indent).concat(key, ": ").concat(objectHelper_1.ObjectHelper.isEmpty(item) ? item : item.toString()).concat(singleItemLineBreak);
        }
      }

      return output;
    }
  }]);

  return ConsoleLogger;
}();

exports.ConsoleLogger = ConsoleLogger;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var networkError_1 = __webpack_require__(23);

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var stringHelper_1 = __webpack_require__(6);
/**
 * Default implementation of a network endpoint.
 */


var NetworkEndPoint =
/*#__PURE__*/
function () {
  /**
   * Create an instance of NetworkEndPoint.
   * @param protocol The protocol to access the endpoint with.
   * @param host The host name or ip of the endpoint.
   * @param port The port of the endpoint.
   * @param rootPath The path to the endpoint.
   */
  function NetworkEndPoint(protocol, host, port, rootPath) {
    _classCallCheck(this, NetworkEndPoint);

    if (!stringHelper_1.StringHelper.isString(protocol) || !/http|https/.test(protocol)) {
      throw new networkError_1.NetworkError("The protocol must be defined as http or https");
    }

    if (!stringHelper_1.StringHelper.isString(host)) {
      throw new networkError_1.NetworkError("The host must be defined");
    }

    if (!numberHelper_1.NumberHelper.isInteger(port) || port <= 0) {
      throw new networkError_1.NetworkError("The port must be a number greater than zero");
    }

    if (!objectHelper_1.ObjectHelper.isEmpty(rootPath) && !stringHelper_1.StringHelper.isString(rootPath)) {
      throw new networkError_1.NetworkError("The rootPath must be a valid string");
    }

    this._protocol = protocol;
    this._host = host.replace(/^\/*/, "").replace(/\/*$/, "");
    this._port = port;
    this._rootPath = (rootPath || "").replace(/^\/*/, "").replace(/\/*$/, "");
  }
  /**
   * The protocol to access the endpoint with.
   * @return The protocol.
   */


  _createClass(NetworkEndPoint, [{
    key: "getProtocol",
    value: function getProtocol() {
      return this._protocol;
    }
    /**
     * The host name or ip of the endpoint.
     * @returns The host.
     */

  }, {
    key: "getHost",
    value: function getHost() {
      return this._host;
    }
    /**
     * The path to the endpoint.
     * @returns The path.
     */

  }, {
    key: "getRootPath",
    value: function getRootPath() {
      return this._rootPath;
    }
    /**
     * The port of the endpoint.
     * @returns The port.
     */

  }, {
    key: "getPort",
    value: function getPort() {
      return this._port;
    }
    /**
     * The complete uri.
     * @returns The uri.
     */

  }, {
    key: "getUri",
    value: function getUri() {
      return "".concat(this._protocol, "://").concat(this._host, ":").concat(this._port, "/").concat(this._rootPath);
    }
  }]);

  return NetworkEndPoint;
}();

exports.NetworkEndPoint = NetworkEndPoint;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(61);


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(62);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 62 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(30));

__export(__webpack_require__(64));

__export(__webpack_require__(8));

__export(__webpack_require__(19));

__export(__webpack_require__(20));

__export(__webpack_require__(9));

__export(__webpack_require__(31));

__export(__webpack_require__(12));

__export(__webpack_require__(13));

__export(__webpack_require__(14));

__export(__webpack_require__(25));

__export(__webpack_require__(7));

__export(__webpack_require__(15));

__export(__webpack_require__(1));

__export(__webpack_require__(3));

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var jsonHelper_1 = __webpack_require__(16);

var objectHelper_1 = __webpack_require__(0);

var stringHelper_1 = __webpack_require__(6);

var trytes_1 = __webpack_require__(1);

var dataError_1 = __webpack_require__(3);

var asciiTrytesConverter_1 = __webpack_require__(30);
/**
 * Trytes converter that converts to and from an object.
 * @typeparam T The generic type for the conversion methods.
 */


var ObjectTrytesConverter =
/*#__PURE__*/
function () {
  function ObjectTrytesConverter() {
    _classCallCheck(this, ObjectTrytesConverter);
  }

  _createClass(ObjectTrytesConverter, [{
    key: "to",

    /**
     * Convert an object value into trytes.
     * @param object to convert into trytes.
     * @returns The trytes representation of the object.
     */
    value: function to(value) {
      if (objectHelper_1.ObjectHelper.isEmpty(value)) {
        throw new dataError_1.DataError("The value can not be empty");
      }

      var json;

      try {
        json = jsonHelper_1.JsonHelper.stringify(value);
      } catch (err) {
        throw new dataError_1.DataError("There was a problem converting the object to JSON", {
          err: err
        });
      }

      return new asciiTrytesConverter_1.AsciiTrytesConverter().to(stringHelper_1.StringHelper.encodeNonASCII(json));
    }
    /**
     * Convert trytes into a string value.
     * @param trytes to convert into a string value.
     * @returns The string value converted from the trytes.
     */

  }, {
    key: "from",
    value: function from(trytes) {
      if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The trytes parameter is empty or not the correct type");
      }

      var ascii = new asciiTrytesConverter_1.AsciiTrytesConverter().from(trytes); // Must have a a start and closing pairs

      if (ascii.length < 2) {
        throw new dataError_1.DataError("The trytes do not represent an object");
      } // The start and end must be either {} or "" to represent a JSON object


      if (!(ascii[0] === "{" && ascii[ascii.length - 1] === "}" || ascii[0] === "\"" && ascii[ascii.length - 1] === "\"")) {
        throw new dataError_1.DataError("The trytes do not represent an object");
      }

      var decoded = stringHelper_1.StringHelper.decodeNonASCII(ascii);
      var obj;

      try {
        obj = JSON.parse(decoded);
      } catch (err) {
        throw new dataError_1.DataError("There was a problem converting the object from JSON", {
          err: err
        });
      }

      return obj;
    }
  }]);

  return ObjectTrytesConverter;
}();

exports.ObjectTrytesConverter = ObjectTrytesConverter;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(66));

__export(__webpack_require__(32));

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(67);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(4);

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var stringHelper_1 = __webpack_require__(6);

var nullLogger_1 = __webpack_require__(18);

var apiError_1 = __webpack_require__(32);
/**
 * Default implementation of an api client.
 */


var ApiClient =
/*#__PURE__*/
function () {
  /**
   * Create an instance of ApiClient.
   * @param networkClient The network client to communicate through.
   * @param apiVersion The API version to send with the requests
   * @param additionalHeaders Extra headers to send with the requests.
   * @param logger Logger to send communication info to.
   */
  function ApiClient(networkClient) {
    var apiVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "1";
    var additionalHeaders = arguments.length > 2 ? arguments[2] : undefined;
    var logger = arguments.length > 3 ? arguments[3] : undefined;

    _classCallCheck(this, ApiClient);

    if (objectHelper_1.ObjectHelper.isEmpty(networkClient)) {
      throw new apiError_1.ApiError("The networkClient must be defined");
    }

    if (stringHelper_1.StringHelper.isEmpty(apiVersion)) {
      throw new apiError_1.ApiError("The apiVersion must not be empty");
    }

    this._networkClient = networkClient;
    this._apiVersion = apiVersion;
    this._additionalHeaders = additionalHeaders;
    this._logger = logger || new nullLogger_1.NullLogger();
  }
  /**
   * Returns information about your node.
   * @returns Promise which resolves to the getNodeInfo response object or rejects with error.
   */


  _createClass(ApiClient, [{
    key: "getNodeInfo",
    value: function () {
      var _getNodeInfo = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.sendCommand("getNodeInfo", {}));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function getNodeInfo() {
        return _getNodeInfo.apply(this, arguments);
      };
    }()
    /**
     * Returns the set of neighbors you are connected with, as well as their activity count.
     * The activity counter is reset after restarting IRI.
     * @returns Promise which resolves to the getNeighbors response object or rejects with error.
     */

  }, {
    key: "getNeighbors",
    value: function () {
      var _getNeighbors = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2() {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.sendCommand("getNeighbors", {}));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function getNeighbors() {
        return _getNeighbors.apply(this, arguments);
      };
    }()
    /**
     * Add a list of neighbors to your node. It should be noted that this is only temporary,
     * and the added neighbors will be removed from your set of neighbors after you relaunch IRI.
     * @returns Promise which resolves to the addNeighbors response object or rejects with error.
     */

  }, {
    key: "addNeighbors",
    value: function () {
      var _addNeighbors = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee3(request) {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context3.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                if (!arrayHelper_1.ArrayHelper.isEmpty(request.uris)) {
                  _context3.next = 4;
                  break;
                }

                throw new apiError_1.ApiError("The request.uris must not be empty");

              case 4:
                return _context3.abrupt("return", this.sendCommand("addNeighbors", request));

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function addNeighbors(_x) {
        return _addNeighbors.apply(this, arguments);
      };
    }()
    /**
     * Removes a list of neighbors from your node. This is only temporary, and if you have your
     * neighbors added via the command line, they will be retained after you restart your node.
     * @returns Promise which resolves to the removeNeighbors response object or rejects with error.
     */

  }, {
    key: "removeNeighbors",
    value: function () {
      var _removeNeighbors = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee4(request) {
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context4.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                if (!arrayHelper_1.ArrayHelper.isEmpty(request.uris)) {
                  _context4.next = 4;
                  break;
                }

                throw new apiError_1.ApiError("The request.uris must not be empty");

              case 4:
                return _context4.abrupt("return", this.sendCommand("removeNeighbors", request));

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function removeNeighbors(_x2) {
        return _removeNeighbors.apply(this, arguments);
      };
    }()
    /**
     * Returns the list of tips.
     * @returns Promise which resolves to the getTips response object or rejects with error.
     */

  }, {
    key: "getTips",
    value: function () {
      var _getTips = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee5() {
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.sendCommand("getTips", {}));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function getTips() {
        return _getTips.apply(this, arguments);
      };
    }()
    /**
     * Find the transactions which match the specified input and return. All input values are lists,
     * for which a list of return values (transaction hashes), in the same order, is returned for all
     * individual elements. The input fields can either be bundles, addresses, tags or approvees.
     * Using multiple of these input fields returns the intersection of the values.
     * @returns Promise which resolves to the findTransactions response object or rejects with error.
     */

  }, {
    key: "findTransactions",
    value: function () {
      var _findTransactions = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee6(request) {
        var bundlesEmpty, addressesEmpty, tagsEmpty, approveesEmpty;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context6.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                bundlesEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.bundles);
                addressesEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.addresses);
                tagsEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.tags);
                approveesEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.approvees);

                if (!(bundlesEmpty && addressesEmpty && tagsEmpty && approveesEmpty)) {
                  _context6.next = 8;
                  break;
                }

                throw new apiError_1.ApiError("One of the bundle, addresses, tags or approvees must not be empty");

              case 8:
                return _context6.abrupt("return", this.sendCommand("findTransactions", request));

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function findTransactions(_x3) {
        return _findTransactions.apply(this, arguments);
      };
    }()
    /**
     * Returns the raw transaction data (trytes) of a specific transaction.
     * These trytes can then be easily converted into the actual transaction object.
     * @returns Promise which resolves to the findTransactions response object or rejects with error.
     */

  }, {
    key: "getTrytes",
    value: function () {
      var _getTrytes = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee7(request) {
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context7.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                if (!arrayHelper_1.ArrayHelper.isEmpty(request.hashes)) {
                  _context7.next = 4;
                  break;
                }

                throw new apiError_1.ApiError("The request.hashes must not be empty");

              case 4:
                return _context7.abrupt("return", this.sendCommand("getTrytes", request));

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function getTrytes(_x4) {
        return _getTrytes.apply(this, arguments);
      };
    }()
    /**
     * Get the inclusion states of a set of transactions. This is for determining if a transaction
     * was accepted and confirmed by the network or not. You can search for multiple tips (and thus,
     * milestones) to get past inclusion states of transactions.
     * @returns Promise which resolves to the getInclusionStates response object or rejects with error.
     */

  }, {
    key: "getInclusionStates",
    value: function () {
      var _getInclusionStates = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee8(request) {
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context8.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                if (!arrayHelper_1.ArrayHelper.isEmpty(request.transactions)) {
                  _context8.next = 4;
                  break;
                }

                throw new apiError_1.ApiError("The request.transactions must not be empty");

              case 4:
                if (!arrayHelper_1.ArrayHelper.isEmpty(request.tips)) {
                  _context8.next = 6;
                  break;
                }

                throw new apiError_1.ApiError("The request.tips must not be empty");

              case 6:
                return _context8.abrupt("return", this.sendCommand("getInclusionStates", request));

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      return function getInclusionStates(_x5) {
        return _getInclusionStates.apply(this, arguments);
      };
    }()
    /**
     * Returns the confirmed balance which a list of addresses have at the latest confirmed milestone.
     * In addition to the balances, it also returns the milestone as well as the index with which the
     * confirmed balance was determined. The balances is returned as a list in the same order as the
     * addresses were provided as input.
     * @param request The getBalances request object.
     * @returns Promise which resolves to the getBalances response object or rejects with error.
     */

  }, {
    key: "getBalances",
    value: function () {
      var _getBalances = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee9(request) {
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context9.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                if (!arrayHelper_1.ArrayHelper.isEmpty(request.addresses)) {
                  _context9.next = 4;
                  break;
                }

                throw new apiError_1.ApiError("The request.addresses must not be empty");

              case 4:
                if (numberHelper_1.NumberHelper.isInteger(request.threshold)) {
                  _context9.next = 6;
                  break;
                }

                throw new apiError_1.ApiError("The request.threshold must be a valid number");

              case 6:
                return _context9.abrupt("return", this.sendCommand("getBalances", request));

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      return function getBalances(_x6) {
        return _getBalances.apply(this, arguments);
      };
    }()
    /**
     * Tip selection which returns trunkTransaction and branchTransaction. The input value is depth,
     * which basically determines how many bundles to go back to for finding the transactions to approve.
     * The higher your depth value, the more "babysitting" you do for the network (as you have to confirm more transactions).
     * @param request The getTransactionsToApprove request object.
     * @returns Promise which resolves to the getTransactionsToApprove response object or rejects with error.
     */

  }, {
    key: "getTransactionsToApprove",
    value: function () {
      var _getTransactionsToApprove = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee10(request) {
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context10.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                if (numberHelper_1.NumberHelper.isInteger(request.depth)) {
                  _context10.next = 4;
                  break;
                }

                throw new apiError_1.ApiError("The request.depth must be a valid number");

              case 4:
                if (!(!objectHelper_1.ObjectHelper.isEmpty(request.reference) && stringHelper_1.StringHelper.isEmpty(request.reference))) {
                  _context10.next = 6;
                  break;
                }

                throw new apiError_1.ApiError("The request.reference must be a non empty string");

              case 6:
                if (!(!objectHelper_1.ObjectHelper.isEmpty(request.numWalks) && !numberHelper_1.NumberHelper.isInteger(request.numWalks))) {
                  _context10.next = 8;
                  break;
                }

                throw new apiError_1.ApiError("The request.numWalks must be a valid number");

              case 8:
                return _context10.abrupt("return", this.sendCommand("getTransactionsToApprove", request));

              case 9:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      return function getTransactionsToApprove(_x7) {
        return _getTransactionsToApprove.apply(this, arguments);
      };
    }()
    /**
     * Attaches the specified transactions (trytes) to the Tangle by doing Proof of Work. You need to supply
     * branchTransaction as well as trunkTransaction (basically the tips which you're going to validate and
     * reference with this transaction) - both of which you'll get through the getTransactionsToApprove API call.
     * @param request The attachToTangle request object.
     * @returns Promise which resolves to the attachToTangle response object or rejects with error.
     */

  }, {
    key: "attachToTangle",
    value: function () {
      var _attachToTangle = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee11(request) {
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context11.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                if (!stringHelper_1.StringHelper.isEmpty(request.trunkTransaction)) {
                  _context11.next = 4;
                  break;
                }

                throw new apiError_1.ApiError("The request.trunkTransaction must not be empty");

              case 4:
                if (!stringHelper_1.StringHelper.isEmpty(request.branchTransaction)) {
                  _context11.next = 6;
                  break;
                }

                throw new apiError_1.ApiError("The request.branchTransaction must not be empty");

              case 6:
                if (numberHelper_1.NumberHelper.isInteger(request.minWeightMagnitude)) {
                  _context11.next = 8;
                  break;
                }

                throw new apiError_1.ApiError("The request.minWeightMagnitude must be a valid number");

              case 8:
                if (!arrayHelper_1.ArrayHelper.isEmpty(request.trytes)) {
                  _context11.next = 10;
                  break;
                }

                throw new apiError_1.ApiError("The request.trytes must not be empty");

              case 10:
                return _context11.abrupt("return", this.sendCommand("attachToTangle", request));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      return function attachToTangle(_x8) {
        return _attachToTangle.apply(this, arguments);
      };
    }()
    /**
     * Interrupts and completely aborts the attachToTangle process
     * @returns Promise which resolves with empty response object or rejects with error.
     */

  }, {
    key: "interruptAttachingToTangle",
    value: function () {
      var _interruptAttachingToTangle = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee12() {
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                return _context12.abrupt("return", this.sendCommand("interruptAttachingToTangle", {}));

              case 1:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      return function interruptAttachingToTangle() {
        return _interruptAttachingToTangle.apply(this, arguments);
      };
    }()
    /**
     * Broadcast a list of transactions to all neighbors. The input trytes for this call are provided by attachToTangle.
     * @param request The broadcastTransactions request object.
     * @returns Promise which resolves with empty response object or rejects with error.
     */

  }, {
    key: "broadcastTransactions",
    value: function () {
      var _broadcastTransactions = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee13(request) {
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context13.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                if (!arrayHelper_1.ArrayHelper.isEmpty(request.trytes)) {
                  _context13.next = 4;
                  break;
                }

                throw new apiError_1.ApiError("The request.trytes must not be empty");

              case 4:
                return _context13.abrupt("return", this.sendCommand("broadcastTransactions", request));

              case 5:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      return function broadcastTransactions(_x9) {
        return _broadcastTransactions.apply(this, arguments);
      };
    }()
    /**
     * Store transactions into the local storage. The trytes to be used for this call are returned by attachToTangle.
     * @param request The storeTransactions request object.
     * @returns Promise which resolves with empty response object or rejects with error.
     */

  }, {
    key: "storeTransactions",
    value: function () {
      var _storeTransactions = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee14(request) {
        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context14.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                if (!arrayHelper_1.ArrayHelper.isEmpty(request.trytes)) {
                  _context14.next = 4;
                  break;
                }

                throw new apiError_1.ApiError("The request.trytes must not be empty");

              case 4:
                return _context14.abrupt("return", this.sendCommand("storeTransactions", request));

              case 5:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      return function storeTransactions(_x10) {
        return _storeTransactions.apply(this, arguments);
      };
    }()
    /**
     * Get transactions with missing references.
     * @param request The getMissingTransactions request object.
     * @returns Promise which resolves to the getMissingTransactions response object or rejects with error.
     */

  }, {
    key: "getMissingTransactions",
    value: function () {
      var _getMissingTransactions = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee15() {
        return _regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                return _context15.abrupt("return", this.sendCommand("getMissingTransactions", {}));

              case 1:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      return function getMissingTransactions() {
        return _getMissingTransactions.apply(this, arguments);
      };
    }()
    /**
     * Check the consistency of tail hashes.
     * @param request The checkConsistency request object.
     * @returns Promise which resolves to the checkConsistency response object or rejects with error.
     */

  }, {
    key: "checkConsistency",
    value: function () {
      var _checkConsistency = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee16(request) {
        return _regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context16.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                if (!arrayHelper_1.ArrayHelper.isEmpty(request.tails)) {
                  _context16.next = 4;
                  break;
                }

                throw new apiError_1.ApiError("The request.tails must not be empty");

              case 4:
                return _context16.abrupt("return", this.sendCommand("checkConsistency", request));

              case 5:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      return function checkConsistency(_x11) {
        return _checkConsistency.apply(this, arguments);
      };
    }()
    /**
     * Have the requested addresses been spent from already.
     * @param request The wereAddressesSpentFrom request object.
     * @returns Promise which resolves to the wereAddressesSpentFrom response object or rejects with error.
     */

  }, {
    key: "wereAddressesSpentFrom",
    value: function () {
      var _wereAddressesSpentFrom = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee17(request) {
        return _regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {
                  _context17.next = 2;
                  break;
                }

                throw new apiError_1.ApiError("The request must be defined");

              case 2:
                if (!arrayHelper_1.ArrayHelper.isEmpty(request.addresses)) {
                  _context17.next = 4;
                  break;
                }

                throw new apiError_1.ApiError("The request.addresses must not be empty");

              case 4:
                return _context17.abrupt("return", this.sendCommand("wereAddressesSpentFrom", request));

              case 5:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      return function wereAddressesSpentFrom(_x12) {
        return _wereAddressesSpentFrom.apply(this, arguments);
      };
    }()
    /* @internal */

  }, {
    key: "sendCommand",
    value: function () {
      var _sendCommand = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee18(command, request) {
        var _this = this;

        return _regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                this._logger.info("===> ApiClient::".concat(command), request);

                Object.defineProperty(request, "command", {
                  value: command,
                  enumerable: true
                });
                return _context18.abrupt("return", this._networkClient.postJson(request, undefined, this.createHeaders()).then(function (response) {
                  _this._logger.info("===> ".concat(command), response);

                  return response;
                }).catch(function (err) {
                  _this._logger.error("===> ".concat(command, " Error"), err);

                  if (err.additional && err.additional.errorResponse) {
                    try {
                      var apiError = JSON.parse(err.additional.errorResponse);

                      if (apiError.error) {
                        delete err.additional.errorResponse;
                        err.additional.apiError = apiError.error;
                      } else if (apiError.exception) {
                        delete err.additional.errorResponse;
                        err.additional.apiError = apiError.exception;
                      }
                    } catch (e) {}
                  }

                  throw err;
                }));

              case 3:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      return function sendCommand(_x13, _x14) {
        return _sendCommand.apply(this, arguments);
      };
    }()
    /* @internal */

  }, {
    key: "createHeaders",
    value: function createHeaders() {
      var headers = this._additionalHeaders || {};
      headers["X-IOTA-API-Version"] = this._apiVersion;
      return headers;
    }
  }]);

  return ApiClient;
}();

exports.ApiClient = ApiClient;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(68);


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(69);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 69 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var factoryBase_1 = __webpack_require__(17);
/**
 * Factory to generate proof of work.
 */


var ProofOfWorkFactory =
/*#__PURE__*/
function (_factoryBase_1$Factor) {
  _inherits(ProofOfWorkFactory, _factoryBase_1$Factor);

  /**
   * Don't allow manual construction of the factory.
   * @internal
   */
  function ProofOfWorkFactory() {
    _classCallCheck(this, ProofOfWorkFactory);

    return _possibleConstructorReturn(this, (ProofOfWorkFactory.__proto__ || Object.getPrototypeOf(ProofOfWorkFactory)).call(this));
  }
  /**
   * Get the instance of the factory.
   * @returns The factory instance.
   */


  _createClass(ProofOfWorkFactory, [{
    key: "getInstance",

    /* @internal */
    value: function getInstance() {
      return ProofOfWorkFactory.instance();
    }
  }], [{
    key: "instance",
    value: function instance() {
      if (!ProofOfWorkFactory._instance) {
        ProofOfWorkFactory._instance = new ProofOfWorkFactory();
      }

      return ProofOfWorkFactory._instance;
    }
  }]);

  return ProofOfWorkFactory;
}(factoryBase_1.FactoryBase);

exports.ProofOfWorkFactory = ProofOfWorkFactory;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(22));

__export(__webpack_require__(39));

__export(__webpack_require__(26));

__export(__webpack_require__(41));

__export(__webpack_require__(72));

__export(__webpack_require__(40));

__export(__webpack_require__(75));

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(42);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(4);

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var timeService_1 = __webpack_require__(24);

var iss_1 = __webpack_require__(21);

var address_1 = __webpack_require__(8);

var bundle_1 = __webpack_require__(20);

var hash_1 = __webpack_require__(9);

var signatureMessageFragment_1 = __webpack_require__(12);

var tag_1 = __webpack_require__(13);

var transaction_1 = __webpack_require__(14);

var transfer_1 = __webpack_require__(25);

var trits_1 = __webpack_require__(7);

var trytes_1 = __webpack_require__(1);

var businessError_1 = __webpack_require__(22);

var bundleHelper_1 = __webpack_require__(26);

var multiSigAddress_1 = __webpack_require__(41);
/**
 * Multiple signatures.
 * Converted https://github.com/iotaledger/iota.lib.js/blob/master/lib/multisig/multisig.js
 */


var MultiSigClient =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of the MultiSigClient.
   * @param apiClient An API Client to communicate through.
   * @param timeService A class which can provide the time.
   */
  function MultiSigClient(apiClient) {
    var timeService = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new timeService_1.TimeService();

    _classCallCheck(this, MultiSigClient);

    this._apiClient = apiClient;
    this._timeService = timeService;
  }
  /**
   * Get the key value of a seed.
   * @param seed The seed to get the key for.
   * @param index The address index to use.
   * @param security The security level to use.
   * @returns The trytes for the key.
   */


  _createClass(MultiSigClient, [{
    key: "prepareTransfer",

    /**
     * Initiates the creation of a new transfer by generating an empty bundle with the correct number
     * of bundle entries to be later used for the signing process.
     * @param address Address which has sufficient balance and is controlled by the co-signers.
     * @param securitySum the sum of the security levels from all cosigners chosen during the private key generation (getKey / getDigest)
     * @param balance The balance available for the transfer, if 0 will call getBalances to lookup available.
     * @param transfers The transfers to perform.
     * @param remainderAddress If there is a remainder after the transfer then send the amount to this address.
     */
    value: function () {
      var _prepareTransfer = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee(address, securitySum, balance, transfers, remainderAddress) {
        var emptyTrytes, prepared, totalBalance, request, response, timestamp;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {
                  _context.next = 2;
                  break;
                }

                throw new businessError_1.BusinessError("The address should be an object of type Address");

              case 2:
                if (!(!numberHelper_1.NumberHelper.isInteger(securitySum) || securitySum < 0)) {
                  _context.next = 4;
                  break;
                }

                throw new businessError_1.BusinessError("The securitySum should be a number >= 0");

              case 4:
                if (!(!numberHelper_1.NumberHelper.isInteger(balance) || balance < 0)) {
                  _context.next = 6;
                  break;
                }

                throw new businessError_1.BusinessError("The balance should be a number >= 0");

              case 6:
                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {
                  _context.next = 8;
                  break;
                }

                throw new businessError_1.BusinessError("The transfers should be an array of type Transfer");

              case 8:
                if (!(!objectHelper_1.ObjectHelper.isEmpty(remainderAddress) && !objectHelper_1.ObjectHelper.isType(remainderAddress, address_1.Address))) {
                  _context.next = 10;
                  break;
                }

                throw new businessError_1.BusinessError("The remainderAddress should be an object of type Address");

              case 10:
                emptyTrytes = trytes_1.Trytes.fromString(""); // If message or tag is not supplied, provide it

                transfers.forEach(function (transfer) {
                  transfer.message = transfer.message ? transfer.message : emptyTrytes;
                  transfer.tag = transfer.tag || tag_1.Tag.EMPTY;
                });
                prepared = bundleHelper_1.BundleHelper.prepareBundle(this._timeService, transfers);

                if (!(prepared.totalValue === 0)) {
                  _context.next = 17;
                  break;
                }

                throw new businessError_1.BusinessError("The total transfer value is 0, the transfer does not require a signature");

              case 17:
                totalBalance = balance;

                if (!(totalBalance === 0)) {
                  _context.next = 24;
                  break;
                }

                request = {
                  addresses: [address.toTrytes().toString()],
                  threshold: 100
                };
                _context.next = 22;
                return this._apiClient.getBalances(request);

              case 22:
                response = _context.sent;
                totalBalance = parseInt(response.balances[0], 10);

              case 24:
                if (!(prepared.totalValue > totalBalance)) {
                  _context.next = 26;
                  break;
                }

                throw new businessError_1.BusinessError("Not enough balance to satisfy the value", {
                  totalValue: prepared.totalValue,
                  totalBalance: totalBalance
                });

              case 26:
                timestamp = Math.floor(this._timeService.msSinceEpoch() / 1000); // Add input as bundle entry
                // Only a single entry, signatures will be added later

                prepared.bundle.addTransactions(securitySum, address, -totalBalance, prepared.lastTag, timestamp); // If there is a remainder value
                // Add extra output to send remaining funds to

                if (!(totalBalance > prepared.totalValue)) {
                  _context.next = 32;
                  break;
                }

                if (!objectHelper_1.ObjectHelper.isEmpty(remainderAddress)) {
                  _context.next = 31;
                  break;
                }

                throw new businessError_1.BusinessError("Transfer has remainder but no remainder address was provided");

              case 31:
                prepared.bundle.addTransactions(1, remainderAddress, totalBalance - prepared.totalValue, prepared.lastTag, timestamp);

              case 32:
                bundleHelper_1.BundleHelper.finalizeBundle(prepared.bundle);
                prepared.bundle.addSignatureMessageFragments(prepared.signatureMessageFragments);

              case 34:
                return _context.abrupt("return", prepared.bundle);

              case 35:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function prepareTransfer(_x, _x2, _x3, _x4, _x5) {
        return _prepareTransfer.apply(this, arguments);
      };
    }()
  }], [{
    key: "getKey",
    value: function getKey(seed, index, security) {
      if (!objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
        throw new businessError_1.BusinessError("The seed should be an object of type Hash");
      }

      if (!numberHelper_1.NumberHelper.isInteger(index) || index < 0) {
        throw new businessError_1.BusinessError("The index should be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3) {
        throw new businessError_1.BusinessError("The security must be between 1 and 3", {
          security: security
        });
      }

      return trits_1.Trits.fromArray(iss_1.ISS.key(seed, index, security)).toTrytes();
    }
    /**
     * Get the digest value of a seed.
     * @param seed The seed to get the digest for.
     * @param index The address index to use.
     * @param security The security level to use.
     * @returns The trytes for the digest.
     */

  }, {
    key: "getDigest",
    value: function getDigest(seed, index, security) {
      if (!objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
        throw new businessError_1.BusinessError("The seed should be an object of type Hash");
      }

      if (!numberHelper_1.NumberHelper.isInteger(index) || index < 0) {
        throw new businessError_1.BusinessError("The index should be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3) {
        throw new businessError_1.BusinessError("The security must be between 1 and 3", {
          security: security
        });
      }

      var key = iss_1.ISS.key(seed, index, security);
      return trits_1.Trits.fromArray(iss_1.ISS.digests(key)).toTrytes();
    }
    /**
     * Validate address.
     * @param address The address to validate against the digests.
     * @param digests The digests to use to validate the address.
     * @returns True if the address matches the digests.
     */

  }, {
    key: "validateAddress",
    value: function validateAddress(address, digests) {
      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {
        throw new businessError_1.BusinessError("The address should be an object of type Address");
      }

      if (!arrayHelper_1.ArrayHelper.isTyped(digests, trytes_1.Trytes)) {
        throw new businessError_1.BusinessError("The digests should be an array of type Trytes");
      }

      return address.toTrytes().toString() === new multiSigAddress_1.MultiSigAddress().finalize(digests).toTrytes().toString();
    }
    /**
     * Adds the cosigner signatures to the corresponding bundle transactions.
     * @param bundle The bundle to sign.
     * @param address The address to match the transactions.
     * @param key The key to sign the transactions with.
     */

  }, {
    key: "addSignature",
    value: function addSignature(bundle, address, key) {
      if (!objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle)) {
        throw new businessError_1.BusinessError("The bundle should be an object of type Bundle");
      }

      if (!arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {
        throw new businessError_1.BusinessError("The bundle.transactions should be an array of type Transaction");
      }

      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {
        throw new businessError_1.BusinessError("The address should be an object of type Address");
      }

      if (!objectHelper_1.ObjectHelper.isType(key, trytes_1.Trytes)) {
        throw new businessError_1.BusinessError("The key should be an object of type Trytes");
      }

      var keyTrits = trits_1.Trits.fromTrytes(key).toArray(); // Get the security used for the private key
      // 1 security level = 2187 trytes

      var security = keyTrits.length / 3 / 2187; // First get the total number of already signed transactions
      // use that for the bundle hash calculation as well as knowing
      // where to add the signature

      var numSignedTxs = 0;
      var addressTrytes = address.toTrytes().toString();

      for (var i = 0; i < bundle.transactions.length; i++) {
        if (bundle.transactions[i].address.toTrytes().toString() === addressTrytes) {
          if (bundle.transactions[i].signatureMessageFragment.toTrytes().toString() !== signatureMessageFragment_1.SignatureMessageFragment.EMPTY.toTrytes().toString()) {
            // If transaction is already signed, increase counter
            numSignedTxs++;
          } else {
            bundleHelper_1.BundleHelper.signTransactions(bundle, i, numSignedTxs % 3, keyTrits, addressTrytes, security);
            break;
          }
        }
      }
    }
  }]);

  return MultiSigClient;
}();

exports.MultiSigClient = MultiSigClient;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(74);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 74 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(42);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(4);

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var nullLogger_1 = __webpack_require__(18);

var backgroundTaskService_1 = __webpack_require__(29);

var timeService_1 = __webpack_require__(24);

var iss_1 = __webpack_require__(21);

var address_1 = __webpack_require__(8);

var addressSecurity_1 = __webpack_require__(19);

var bundle_1 = __webpack_require__(20);

var hash_1 = __webpack_require__(9);

var input_1 = __webpack_require__(31);

var tag_1 = __webpack_require__(13);

var transaction_1 = __webpack_require__(14);

var transfer_1 = __webpack_require__(25);

var trits_1 = __webpack_require__(7);

var tryteNumber_1 = __webpack_require__(15);

var trytes_1 = __webpack_require__(1);

var businessError_1 = __webpack_require__(22);

var addressHelper_1 = __webpack_require__(39);

var bundleHelper_1 = __webpack_require__(26);
/**
 * Default implementation of the ITransactionClient.
 */


var TransactionClient =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of the TransactionClient.
   * @param apiClient An API Client to communicate through.
   * @param proofOfWork Proof of work module to use, if undefined will use remote.
   * @param timeService A class which can provide the time.
   * @param backgroundTaskService A class which can provide background tasks.
   * @param logger Logger to send transaction info to.
   */
  function TransactionClient(apiClient, proofOfWork, timeService, backgroundTaskService, logger) {
    _classCallCheck(this, TransactionClient);

    this._apiClient = apiClient;
    this._proofOfWork = proofOfWork;
    this._timeService = timeService || new timeService_1.TimeService();
    this._backgroundTaskService = backgroundTaskService || new backgroundTaskService_1.BackgroundTaskService();
    this._logger = logger || new nullLogger_1.NullLogger();
  }
  /**
   * Returns the list of transaction in progress.
   * @returns Promise which resolves to a list of hashes or rejects with error.
   */


  _createClass(TransactionClient, [{
    key: "getTransactionsInProgress",
    value: function () {
      var _getTransactionsInProgress = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee() {
        var response, resp;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this._logger.info("===> TransactionClient::getTransactionsInProgress");

                _context.next = 3;
                return this._apiClient.getTips();

              case 3:
                response = _context.sent;

                if (!(response && response.hashes)) {
                  _context.next = 10;
                  break;
                }

                resp = response.hashes.map(function (hash) {
                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));
                });

                this._logger.info("<=== TransactionClient::getTransactionsInProgress", resp);

                return _context.abrupt("return", resp);

              case 10:
                this._logger.info("<=== TransactionClient::getTransactionsInProgress", []);

                return _context.abrupt("return", []);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function getTransactionsInProgress() {
        return _getTransactionsInProgress.apply(this, arguments);
      };
    }()
    /**
     * Find the transactions which match the specified input and return. All input values are lists,
     * for which a list of return values (transaction hashes), in the same order, is returned for all
     * individual elements. Using multiple of these input fields returns the intersection of the values.
     * @param bundles Bundles to lookup transaction hashes for.
     * @param addresses Addresses to lookup transaction hashes for.
     * @param tags Tags to lookup transaction hashes for.
     * @param approvees Approvees to lookup transaction hashes for.
     * @returns Promise which resolves with a list of hashes or rejects with error.
     */

  }, {
    key: "findTransactions",
    value: function () {
      var _findTransactions = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2(bundles, addresses, tags, approvees) {
        var hasBundle, hasAddresses, hasTags, hasApprovees, request, response, resp;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this._logger.info("===> TransactionClient::findTransactions", bundles, addresses, tags, approvees);

                hasBundle = bundles !== undefined && bundles !== null && bundles.length > 0;
                hasAddresses = addresses !== undefined && addresses !== null && addresses.length > 0;
                hasTags = tags !== undefined && tags !== null && tags.length > 0;
                hasApprovees = approvees !== undefined && approvees !== null && approvees.length > 0;

                if (!(hasBundle && !arrayHelper_1.ArrayHelper.isTyped(bundles, hash_1.Hash))) {
                  _context2.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The bundles must be an array of type Hash");

              case 7:
                if (!(hasAddresses && !arrayHelper_1.ArrayHelper.isTyped(addresses, address_1.Address))) {
                  _context2.next = 9;
                  break;
                }

                throw new businessError_1.BusinessError("The addresses must be an array of type Address");

              case 9:
                if (!(hasTags && !arrayHelper_1.ArrayHelper.isTyped(tags, tag_1.Tag))) {
                  _context2.next = 11;
                  break;
                }

                throw new businessError_1.BusinessError("The tags must be an array of type Tag");

              case 11:
                if (!(hasApprovees && !arrayHelper_1.ArrayHelper.isTyped(approvees, hash_1.Hash))) {
                  _context2.next = 13;
                  break;
                }

                throw new businessError_1.BusinessError("The approvees must be an array of type Hash");

              case 13:
                if (!(!hasBundle && !hasAddresses && !hasTags && !hasApprovees)) {
                  _context2.next = 15;
                  break;
                }

                throw new businessError_1.BusinessError("You must provide bundles, addresses, tags or approvees");

              case 15:
                request = {
                  bundles: hasBundle ? bundles.map(function (bundle) {
                    return bundle.toTrytes().toString();
                  }) : undefined,
                  addresses: hasAddresses ? addresses.map(function (address) {
                    return address.toTrytes().toString();
                  }) : undefined,
                  tags: hasTags ? tags.map(function (tag) {
                    return tag.toTrytes().toString();
                  }) : undefined,
                  approvees: hasApprovees ? approvees.map(function (approvee) {
                    return approvee.toTrytes().toString();
                  }) : undefined
                };
                _context2.next = 18;
                return this._apiClient.findTransactions(request);

              case 18:
                response = _context2.sent;

                if (!(response && response.hashes)) {
                  _context2.next = 25;
                  break;
                }

                resp = response.hashes.map(function (hash) {
                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));
                });

                this._logger.info("<=== TransactionClient::findTransactions", resp);

                return _context2.abrupt("return", resp);

              case 25:
                this._logger.info("<=== TransactionClient::findTransactions", []);

                return _context2.abrupt("return", []);

              case 27:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function findTransactions(_x, _x2, _x3, _x4) {
        return _findTransactions.apply(this, arguments);
      };
    }()
    /**
     * Get the transaction details of specific transactions.
     * @returns Promise which resolves to the list of transactions or rejects with error.
     */

  }, {
    key: "getTransactionsObjects",
    value: function () {
      var _getTransactionsObjects = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee3(transactionHashes) {
        var request, response, resp;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._logger.info("===> TransactionClient::getTransactionsObjects", transactionHashes);

                if (arrayHelper_1.ArrayHelper.isTyped(transactionHashes, hash_1.Hash)) {
                  _context3.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The transactionHashes must be an array of type Hash");

              case 3:
                request = {
                  hashes: transactionHashes.map(function (hash) {
                    return hash.toTrytes().toString();
                  })
                };
                _context3.next = 6;
                return this._apiClient.getTrytes(request);

              case 6:
                response = _context3.sent;

                if (!(response && response.trytes)) {
                  _context3.next = 13;
                  break;
                }

                resp = response.trytes.map(function (trytes) {
                  return transaction_1.Transaction.fromTrytes(trytes_1.Trytes.fromString(trytes));
                });

                this._logger.info("<=== TransactionClient::getTransactionsObjects", resp);

                return _context3.abrupt("return", resp);

              case 13:
                this._logger.info("<=== TransactionClient::getTransactionsObjects", []);

                return _context3.abrupt("return", []);

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function getTransactionsObjects(_x5) {
        return _getTransactionsObjects.apply(this, arguments);
      };
    }()
    /**
     * Get the inclusion states of a list of transaction hashes.
     * @returns Promise which resolves to the list of inclusion states or rejects with error.
     */

  }, {
    key: "getLatestInclusion",
    value: function () {
      var _getLatestInclusion = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee4(transactionHashes) {
        var nodeInfo, request, response;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this._logger.info("===> TransactionClient::transactionHashes");

                if (arrayHelper_1.ArrayHelper.isTyped(transactionHashes, hash_1.Hash)) {
                  _context4.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The transactionHashes must be an array of type Hash");

              case 3:
                _context4.next = 5;
                return this._apiClient.getNodeInfo();

              case 5:
                nodeInfo = _context4.sent;

                if (!(nodeInfo && numberHelper_1.NumberHelper.isInteger(nodeInfo.latestSolidSubtangleMilestone))) {
                  _context4.next = 20;
                  break;
                }

                request = {
                  transactions: transactionHashes.map(function (hash) {
                    return hash.toTrytes().toString();
                  }),
                  tips: [nodeInfo.latestSolidSubtangleMilestone]
                };
                _context4.next = 10;
                return this._apiClient.getInclusionStates(request);

              case 10:
                response = _context4.sent;

                if (!(response && response.states)) {
                  _context4.next = 16;
                  break;
                }

                this._logger.info("<=== TransactionClient::transactionHashes", response.states);

                return _context4.abrupt("return", response.states);

              case 16:
                this._logger.info("<=== TransactionClient::transactionHashes", []);

                return _context4.abrupt("return", []);

              case 18:
                _context4.next = 21;
                break;

              case 20:
                throw new businessError_1.BusinessError("The node could not provide the latestSolidSubtangleMilestone");

              case 21:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function getLatestInclusion(_x6) {
        return _getLatestInclusion.apply(this, arguments);
      };
    }()
    /**
     * Generates addresses with index-based or using apis.
     * @param seed The seed to generate the addresses from.
     * @param startIndex The start index to generate addresses.
     * @param endIndex The end index to generate addresses.
     * @param includeChecksum Includes the checksum on addresses.
     * @param security The security level at which to create the addresses.
     * @returns Promise which resolves to the list of addresses or rejects with error.
     */

  }, {
    key: "getNewAddress",
    value: function () {
      var _getNewAddress = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee5(seed, startIndex, endIndex, includeChecksum, security) {
        var localStartIndex, hasEndIndex, localSecurity, addresses, total;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this._logger.info("===> TransactionClient::getNewAddress", seed, startIndex, endIndex, includeChecksum, security);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context5.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                if (!(!objectHelper_1.ObjectHelper.isEmpty(startIndex) && !objectHelper_1.ObjectHelper.isType(startIndex, Number))) {
                  _context5.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The startIndex must be an integer", {
                  startIndex: startIndex
                });

              case 5:
                localStartIndex = startIndex || 0;

                if (!(localStartIndex < 0)) {
                  _context5.next = 8;
                  break;
                }

                throw new businessError_1.BusinessError("The startIndex must be >= 0", {
                  localStartIndex: localStartIndex
                });

              case 8:
                hasEndIndex = numberHelper_1.NumberHelper.isInteger(endIndex);
                localSecurity = security || addressSecurity_1.AddressSecurity.medium;

                if (!hasEndIndex) {
                  _context5.next = 19;
                  break;
                }

                total = endIndex - startIndex + 1;

                if (!(total <= 0 || total > TransactionClient.MAX_INPUTS)) {
                  _context5.next = 14;
                  break;
                }

                throw new businessError_1.BusinessError("The total must be > 0 and <= ".concat(TransactionClient.MAX_INPUTS), {
                  total: total
                });

              case 14:
                _context5.next = 16;
                return this.getAddressesByIndex(seed, startIndex, endIndex, includeChecksum, localSecurity);

              case 16:
                addresses = _context5.sent;
                _context5.next = 22;
                break;

              case 19:
                _context5.next = 21;
                return this.getAddressesToUnused(seed, startIndex, includeChecksum, localSecurity);

              case 21:
                addresses = _context5.sent;

              case 22:
                this._logger.info("<=== TransactionClient::getNewAddress", addresses);

                return _context5.abrupt("return", addresses);

              case 24:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function getNewAddress(_x7, _x8, _x9, _x10, _x11) {
        return _getNewAddress.apply(this, arguments);
      };
    }()
    /**
     * Generates new addresses index-based.
     * @param seed The seed to generate the addresses from.
     * @param startIndex The start index to generate addresses.
     * @param endIndex The end index to generate addresses.
     * @param includeChecksum Includes the checksum on addresses.
     * @param security The security level at which to create the addresses.
     * @returns Promise which resolves to the list of addresses or rejects with error.
     */

  }, {
    key: "getAddressesByIndex",
    value: function () {
      var _getAddressesByIndex = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee6(seed, startIndex, endIndex, includeChecksum, security) {
        var total, addresses, i;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this._logger.info("===> TransactionClient::getAddressesByIndex", seed, startIndex, endIndex, includeChecksum, security);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context6.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {
                  _context6.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The startIndex must be a number >= 0", {
                  startIndex: startIndex
                });

              case 5:
                if (!(!numberHelper_1.NumberHelper.isInteger(endIndex) || endIndex <= 0)) {
                  _context6.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The endIndex must be a number > 0", {
                  endIndex: endIndex
                });

              case 7:
                total = endIndex - startIndex + 1;

                if (!(total <= 0 || total > TransactionClient.MAX_INPUTS)) {
                  _context6.next = 10;
                  break;
                }

                throw new businessError_1.BusinessError("The total must be > 0 and <= ".concat(TransactionClient.MAX_INPUTS), {
                  total: total
                });

              case 10:
                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {
                  _context6.next = 12;
                  break;
                }

                throw new businessError_1.BusinessError("The security must be between 1 and 3", {
                  security: security
                });

              case 12:
                addresses = [];

                for (i = 0; i < total; i++) {
                  addresses.push(this.generateAddress(seed, startIndex + i, security, includeChecksum));
                }

                this._logger.info("<=== TransactionClient::getAddressesByIndex", addresses);

                return _context6.abrupt("return", Promise.resolve(addresses));

              case 16:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function getAddressesByIndex(_x12, _x13, _x14, _x15, _x16) {
        return _getAddressesByIndex.apply(this, arguments);
      };
    }()
    /**
     * Generates new address which havent been used using apis.
     * @param seed The seed to generate the addresses from.
     * @param startIndex The start index to generate addresses.
     * @param includeChecksum Includes the checksum on addresses.
     * @param security The security level at which to create the addresses.
     * @returns Promise which resolves to an addresses list, the first unused address is the last in the list or rejects with error.
     */

  }, {
    key: "getAddressesToUnused",
    value: function () {
      var _getAddressesToUnused = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee7(seed, startIndex, includeChecksum, security) {
        var localStartIndex, isUsed, addresses, address, addressNoChecksum, spentFromRequest, spentFromResponse, findTransactionsRequest, findResponse;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this._logger.info("===> TransactionClient::getAddressesToUnused", seed, startIndex, includeChecksum, security);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context7.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {
                  _context7.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The startIndex must be a number >= 0", {
                  startIndex: startIndex
                });

              case 5:
                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {
                  _context7.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The security must be between 1 and 3", {
                  security: security
                });

              case 7:
                localStartIndex = startIndex;
                addresses = [];

              case 9:
                address = this.generateAddress(seed, localStartIndex++, security, includeChecksum);
                addresses.push(address);
                addressNoChecksum = address.toTrytes().toString();
                spentFromRequest = {
                  addresses: [addressNoChecksum]
                };
                _context7.next = 15;
                return this._apiClient.wereAddressesSpentFrom(spentFromRequest);

              case 15:
                spentFromResponse = _context7.sent;
                isUsed = spentFromResponse && spentFromResponse.states && spentFromResponse.states.length > 0 ? spentFromResponse.states[0] : false;

                if (isUsed) {
                  _context7.next = 23;
                  break;
                }

                findTransactionsRequest = {
                  addresses: [addressNoChecksum]
                };
                _context7.next = 21;
                return this._apiClient.findTransactions(findTransactionsRequest);

              case 21:
                findResponse = _context7.sent;
                isUsed = findResponse && findResponse.hashes && findResponse.hashes.length > 0;

              case 23:
                if (isUsed) {
                  _context7.next = 9;
                  break;
                }

              case 24:
                this._logger.info("<=== TransactionClient::getAddressesToUnused", addresses);

                return _context7.abrupt("return", Promise.resolve(addresses));

              case 26:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function getAddressesToUnused(_x17, _x18, _x19, _x20) {
        return _getAddressesToUnused.apply(this, arguments);
      };
    }()
    /**
     * Get the input data for a range of addresses.
     * @param seed The seed to get the input data for.
     * @param startIndex The start index to get the addresses.
     * @param endIndex The end index to get the addresses.
     * @param security The security level used to create the addresses.
     * @param totalRequired The threshold at which total balance to stop gathering addresses.
     * @returns Promise which resolves to the inputs for each address or rejects with error.
     */

  }, {
    key: "getInputs",
    value: function () {
      var _getInputs = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee8(seed, startIndex, endIndex, security, totalRequired) {
        var addresses, request, response, inputs, totalBalance, i, balance, resp;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this._logger.info("===> TransactionClient::getInputs", seed, startIndex, endIndex, security, totalRequired);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context8.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {
                  _context8.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The startIndex must be a number >= 0", {
                  startIndex: startIndex
                });

              case 5:
                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {
                  _context8.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The security must be between 1 and 3", {
                  security: security
                });

              case 7:
                if (!(!numberHelper_1.NumberHelper.isInteger(totalRequired) || totalRequired < 0)) {
                  _context8.next = 9;
                  break;
                }

                throw new businessError_1.BusinessError("The totalRequired must be >= 0", {
                  totalRequired: totalRequired
                });

              case 9:
                _context8.next = 11;
                return this.getNewAddress(seed, startIndex, endIndex, false, security);

              case 11:
                addresses = _context8.sent;
                request = {
                  addresses: addresses.map(function (add) {
                    return add.toTrytes().toString();
                  }),
                  threshold: 100
                };
                _context8.next = 15;
                return this._apiClient.getBalances(request);

              case 15:
                response = _context8.sent;
                inputs = [];
                totalBalance = 0;

                if (!response) {
                  _context8.next = 30;
                  break;
                }

                i = 0;

              case 20:
                if (!(i < addresses.length)) {
                  _context8.next = 30;
                  break;
                }

                balance = parseInt(response.balances[i], 10);

                if (!(balance > 0)) {
                  _context8.next = 27;
                  break;
                }

                inputs.push(input_1.Input.fromParams(addresses[i], security, startIndex + i, balance));
                totalBalance += balance;

                if (!(totalRequired > 0 && totalBalance >= totalRequired)) {
                  _context8.next = 27;
                  break;
                }

                return _context8.abrupt("break", 30);

              case 27:
                i++;
                _context8.next = 20;
                break;

              case 30:
                resp = {
                  inputs: inputs,
                  totalBalance: totalBalance
                };

                this._logger.info("<=== TransactionClient::getInputs", resp);

                if (!(totalRequired > 0 && totalBalance < totalRequired)) {
                  _context8.next = 34;
                  break;
                }

                throw new businessError_1.BusinessError("Not enough combined balance in the addresses to satisfy the total required", {
                  totalRequired: totalRequired,
                  totalBalance: totalBalance
                });

              case 34:
                return _context8.abrupt("return", resp);

              case 35:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      return function getInputs(_x21, _x22, _x23, _x24, _x25) {
        return _getInputs.apply(this, arguments);
      };
    }()
    /**
     * Prepares transfer by generating bundle, finding and signing inputs.
     * @param seed The seed to prepare the transfer for.
     * @param transfers The transfers to prepare.
     * @param transferOptions
     *      @property inputs List of inputs used for funding the transfer.
     *      @property security Security level to be used for the private key / addresses.
     *      @property remainderAddress If defined, this address will be used for sending the remainder value (of the inputs) to.
     *      @property hmacKey Hmac key to sign the bundle.
     *      @property reference The transaction to reference.
     * @returns Promise which resolves to the array of Trytes for the transfer or rejects with error.
     */

  }, {
    key: "prepareTransfers",
    value: function () {
      var _prepareTransfers = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee9(seed, transfers, transferOptions) {
        var localTransferOptions, emptyTrytes, addHMAC, addedHMAC, prepared, bundle, lastTag, totalValue, signatureMessageFragments, request, balances, confirmedInputs, totalBalance, i, balance, inputsResponse;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this._logger.info("===> TransactionClient::prepareTransfers", seed, transfers, transferOptions);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context9.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {
                  _context9.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The transfers must be an array of Transfer objects");

              case 5:
                localTransferOptions = transferOptions || {};
                localTransferOptions.security = localTransferOptions.security || addressSecurity_1.AddressSecurity.medium;
                emptyTrytes = trytes_1.Trytes.fromString("");
                addHMAC = !objectHelper_1.ObjectHelper.isEmpty(localTransferOptions.hmacKey);
                addedHMAC = false; // If message or tag is not supplied, provide it

                transfers.forEach(function (transfer) {
                  transfer.message = transfer.message ? transfer.message : emptyTrytes;
                  transfer.tag = transfer.tag || tag_1.Tag.EMPTY;

                  if (addHMAC && transfer.value > 0) {
                    transfer.message = trytes_1.Trytes.fromString(TransactionClient.NULL_HASH_TRYTES + transfer.message.toString());
                    addedHMAC = true;
                  }
                }); // Create a new bundle

                prepared = bundleHelper_1.BundleHelper.prepareBundle(this._timeService, transfers);
                bundle = prepared.bundle;
                lastTag = prepared.lastTag;
                totalValue = prepared.totalValue;
                signatureMessageFragments = prepared.signatureMessageFragments; // Get inputs if we are sending tokens

                if (!totalValue) {
                  _context9.next = 49;
                  break;
                }

                if (!localTransferOptions.inputs) {
                  _context9.next = 42;
                  break;
                }

                request = {
                  addresses: localTransferOptions.inputs.map(function (input) {
                    return input.address.toTrytes().toString();
                  }),
                  threshold: 100
                };
                _context9.next = 21;
                return this._apiClient.getBalances(request);

              case 21:
                balances = _context9.sent;
                confirmedInputs = [];
                totalBalance = 0;
                i = 0;

              case 25:
                if (!(i < balances.balances.length)) {
                  _context9.next = 36;
                  break;
                }

                balance = parseInt(balances.balances[i], 10); // If input has balance, add it to confirmedInputs

                if (!(balance > 0)) {
                  _context9.next = 33;
                  break;
                }

                totalBalance += balance;
                localTransferOptions.inputs[i].balance = balance;
                confirmedInputs.push(localTransferOptions.inputs[i]); // if we've already reached the intended input value, break out of loop

                if (!(totalBalance >= totalValue)) {
                  _context9.next = 33;
                  break;
                }

                return _context9.abrupt("break", 36);

              case 33:
                i++;
                _context9.next = 25;
                break;

              case 36:
                if (!(totalValue > totalBalance)) {
                  _context9.next = 38;
                  break;
                }

                throw new businessError_1.BusinessError("Not enough balance in the input addresses to satisfy the total for the transfer");

              case 38:
                _context9.next = 40;
                return this.addRemainder(seed, bundle, localTransferOptions, confirmedInputs, signatureMessageFragments, totalValue, lastTag, addedHMAC);

              case 40:
                _context9.next = 47;
                break;

              case 42:
                _context9.next = 44;
                return this.getInputs(seed, 0, undefined, localTransferOptions.security, totalValue);

              case 44:
                inputsResponse = _context9.sent;
                _context9.next = 47;
                return this.addRemainder(seed, bundle, localTransferOptions, inputsResponse.inputs, signatureMessageFragments, totalValue, lastTag, addedHMAC);

              case 47:
                _context9.next = 51;
                break;

              case 49:
                // If no input required, don't sign and simply finalize the bundle
                bundleHelper_1.BundleHelper.finalizeBundle(bundle);
                bundle.addSignatureMessageFragments(signatureMessageFragments);

              case 51:
                bundle.transactions = bundle.transactions.reverse();

                this._logger.info("<=== TransactionClient::prepareTransfers", bundle);

                return _context9.abrupt("return", bundle);

              case 54:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      return function prepareTransfers(_x26, _x27, _x28) {
        return _prepareTransfers.apply(this, arguments);
      };
    }()
    /**
     * Attach the transactions to the tangle by doing proof of work.
     * @param bundle The bundle of transactions to attach.
     * @param depth Value that determines how far to go for tip selection.
     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.
     * @param reference The reference to send with the transactions.
     * @returns Promise which resolves to the bundle of transactions created or rejects with an error.
     */

  }, {
    key: "attachToTangle",
    value: function () {
      var _attachToTangle = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee10(bundle, depth, minWeightMagnitude, reference) {
        var transactionsToApproveRequest, transactionsToApprove, powTransactions, allTrytes, attachToTangleRequest, attachToTangleResponse, newBundle;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this._logger.info("===> TransactionClient::attachToTangle", bundle, depth, minWeightMagnitude, reference);

                if (objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle)) {
                  _context10.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The bundle must be an array of type Bundle");

              case 3:
                if (arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {
                  _context10.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The bundle.transactions must be an array of type Transaction");

              case 5:
                if (!(!numberHelper_1.NumberHelper.isInteger(depth) || depth <= 0)) {
                  _context10.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The depth must be a number > 0", {
                  depth: depth
                });

              case 7:
                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {
                  _context10.next = 9;
                  break;
                }

                throw new businessError_1.BusinessError("The minWeightMagnitude must be a number > 0", {
                  minWeightMagnitude: minWeightMagnitude
                });

              case 9:
                transactionsToApproveRequest = {
                  depth: depth,
                  reference: reference ? reference.toTrytes().toString() : undefined
                };
                _context10.next = 12;
                return this._apiClient.getTransactionsToApprove(transactionsToApproveRequest);

              case 12:
                transactionsToApprove = _context10.sent;

                if (!this._proofOfWork) {
                  _context10.next = 26;
                  break;
                }

                if (!this._proofOfWork.performsSingle()) {
                  _context10.next = 20;
                  break;
                }

                _context10.next = 17;
                return this.proofOfWorkIterate(hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.trunkTransaction)), hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.branchTransaction)), bundle.transactions, minWeightMagnitude);

              case 17:
                powTransactions = _context10.sent;
                _context10.next = 24;
                break;

              case 20:
                _context10.next = 22;
                return this._proofOfWork.pow(hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.trunkTransaction)), hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.branchTransaction)), bundle.transactions.map(function (t) {
                  return t.toTrytes();
                }), minWeightMagnitude);

              case 22:
                allTrytes = _context10.sent;
                powTransactions = allTrytes.map(function (returnTrytes) {
                  return transaction_1.Transaction.fromTrytes(returnTrytes);
                });

              case 24:
                _context10.next = 31;
                break;

              case 26:
                attachToTangleRequest = {
                  trunkTransaction: transactionsToApprove.trunkTransaction,
                  branchTransaction: transactionsToApprove.branchTransaction,
                  minWeightMagnitude: minWeightMagnitude,
                  trytes: bundle.transactions.map(function (t) {
                    return t.toTrytes().toString();
                  })
                };
                _context10.next = 29;
                return this._apiClient.attachToTangle(attachToTangleRequest);

              case 29:
                attachToTangleResponse = _context10.sent;
                powTransactions = attachToTangleResponse.trytes.map(function (returnTrytes) {
                  return transaction_1.Transaction.fromTrytes(trytes_1.Trytes.fromString(returnTrytes));
                });

              case 31:
                newBundle = new bundle_1.Bundle();
                newBundle.transactions = powTransactions;

                this._logger.info("<=== TransactionClient::attachToTangle", newBundle);

                return _context10.abrupt("return", newBundle);

              case 35:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      return function attachToTangle(_x29, _x30, _x31, _x32) {
        return _attachToTangle.apply(this, arguments);
      };
    }()
    /**
     * Wrapper function that does attachToTangle and then stores and broadcasts the transactions.
     * @param bundle The bundle of transactions to send.
     * @param depth Value that determines how far to go for tip selection.
     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.
     * @param reference The reference to send with the transactions.
     * @returns Promise which resolves to the bundle of transactions created or rejects with an error.
     */

  }, {
    key: "sendTransactions",
    value: function () {
      var _sendTransactions = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee11(bundle, depth, minWeightMagnitude, reference) {
        var attachedTransactionsBundle, storeTransactionsRequest, broadcastTransactionsRequest;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this._logger.info("===> TransactionClient::sendTransactions", bundle, depth, minWeightMagnitude, reference);

                _context11.next = 3;
                return this.attachToTangle(bundle, depth, minWeightMagnitude, reference);

              case 3:
                attachedTransactionsBundle = _context11.sent;
                storeTransactionsRequest = {
                  trytes: attachedTransactionsBundle.transactions.map(function (t) {
                    return t.toTrytes().toString();
                  })
                };
                _context11.next = 7;
                return this._apiClient.storeTransactions(storeTransactionsRequest);

              case 7:
                broadcastTransactionsRequest = {
                  trytes: storeTransactionsRequest.trytes
                };
                _context11.next = 10;
                return this._apiClient.broadcastTransactions(broadcastTransactionsRequest);

              case 10:
                this._logger.info("<=== TransactionClient::sendTransactions", attachedTransactionsBundle);

                return _context11.abrupt("return", attachedTransactionsBundle);

              case 12:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      return function sendTransactions(_x33, _x34, _x35, _x36) {
        return _sendTransactions.apply(this, arguments);
      };
    }()
    /**
     * Wrapper function that does prepareTransfers and then sendTransactions.
     * @param seed The seed to send the transfer for.
     * @param depth Value that determines how far to go for tip selection.
     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.
     * @param transfers The transfers to send.
     * @param transferOptions Additional options for the transfer.
     *      @property inputs List of inputs used for funding the transfer.
     *      @property security Security level to be used for the private key / addresses.
     *      @property remainderAddress If defined, this address will be used for sending the remainder value (of the inputs) to.
     *      @property hmacKey Hmac key to sign the bundle.
     * @param reference The reference to send with the transactions.
     * @returns Promise which resolves to the list of transactions created or rejects with an error.
     */

  }, {
    key: "sendTransfer",
    value: function () {
      var _sendTransfer = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee12(seed, depth, minWeightMagnitude, transfers, transferOptions, reference) {
        var transferTrytes, sentBundle;
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this._logger.info("===> TransactionClient::sendTransfer", seed, depth, minWeightMagnitude, transfers, transferOptions, reference);

                _context12.next = 3;
                return this.prepareTransfers(seed, transfers, transferOptions);

              case 3:
                transferTrytes = _context12.sent;
                _context12.next = 6;
                return this.sendTransactions(transferTrytes, depth, minWeightMagnitude, reference);

              case 6:
                sentBundle = _context12.sent;

                this._logger.info("<=== TransactionClient::sendTransfer", sentBundle);

                return _context12.abrupt("return", sentBundle);

              case 9:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      return function sendTransfer(_x37, _x38, _x39, _x40, _x41, _x42) {
        return _sendTransfer.apply(this, arguments);
      };
    }()
    /**
     * Find out if a transaction is promotable.
     * @param transactionTail The hash of the transaction to be promoted.
     * @returns Promise which resolves to true if the transaction is promotable rejects with an error.
     */

  }, {
    key: "isPromotable",
    value: function () {
      var _isPromotable = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee13(transactionTail) {
        var checkConsistencyRequest, checkConsistencyResponse;
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                this._logger.info("===> TransactionClient::isPromotable", transactionTail);

                if (objectHelper_1.ObjectHelper.isType(transactionTail, hash_1.Hash)) {
                  _context13.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The transactionTail must be an object of type Hash");

              case 3:
                checkConsistencyRequest = {
                  tails: [transactionTail.toTrytes().toString()]
                };
                _context13.next = 6;
                return this._apiClient.checkConsistency(checkConsistencyRequest);

              case 6:
                checkConsistencyResponse = _context13.sent;

                this._logger.info("<=== TransactionClient::isPromotable", checkConsistencyResponse.state);

                return _context13.abrupt("return", checkConsistencyResponse.state);

              case 9:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      return function isPromotable(_x43) {
        return _isPromotable.apply(this, arguments);
      };
    }()
    /**
     * Determines whether you should replay a transaction or make a new one (either with the same input, or a different one).
     * @param addresses Input address you want to have tested.
     * @returns Promise which resolves to true if the addresses are reattachable or rejects with an error.
     */

  }, {
    key: "isReattachable",
    value: function () {
      var _isReattachable = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee14(addresses) {
        var addrsTxsMap, i, addressString, transactions, valueTransactions, results, inclusionStates, _i2;

        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                this._logger.info("===> TransactionClient::isReattachable", addresses);

                if (arrayHelper_1.ArrayHelper.isTyped(addresses, address_1.Address)) {
                  _context14.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The addresses must be an object of type Address");

              case 3:
                addrsTxsMap = {};

                for (i = 0; i < addresses.length; i++) {
                  addressString = addresses[i].toTrytes().toString();
                  addrsTxsMap[addressString] = [];
                }

                _context14.next = 7;
                return this.findTransactionObjects(undefined, addresses);

              case 7:
                transactions = _context14.sent;
                valueTransactions = [];
                transactions.forEach(function (transaction) {
                  if (transaction.value.toNumber() < 0) {
                    var txAddress = transaction.address;
                    var txHash = bundleHelper_1.BundleHelper.transactionHash(transaction);
                    addrsTxsMap[txAddress.toTrytes().toString()].push(txHash);
                    valueTransactions.push(txHash);
                  }
                });

                if (!(valueTransactions.length > 0)) {
                  _context14.next = 17;
                  break;
                }

                _context14.next = 13;
                return this.getLatestInclusion(valueTransactions);

              case 13:
                inclusionStates = _context14.sent;
                results = addresses.map(function (address) {
                  var shouldReattach = true;
                  var txs = addrsTxsMap[address.toTrytes().toString()];

                  for (var _i = 0; _i < txs.length; _i++) {
                    var txIndex = valueTransactions.indexOf(txs[_i]);
                    shouldReattach = !inclusionStates[txIndex];

                    if (!shouldReattach) {
                      break;
                    }
                  }

                  return shouldReattach;
                });
                _context14.next = 19;
                break;

              case 17:
                results = [];

                for (_i2 = 0; _i2 < addresses.length; _i2++) {
                  results.push(true);
                }

              case 19:
                this._logger.info("<=== TransactionClient::isReattachable", results);

                return _context14.abrupt("return", results);

              case 21:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      return function isReattachable(_x44) {
        return _isReattachable.apply(this, arguments);
      };
    }()
    /**
     * Promotes a transaction by adding spam on top of it, as long as it is promotable.
     * Will promote by adding transfers on top of the current one with delay interval.
     * Use promoteOptions.interrupt to terminate the promotion.
     * If promoteOptions.delay is set to 0 only one promotion transfer will be sent.
     * @param transactionTail The hash of the transaction to be promoted.
     * @param depth Value that determines how far to go for tip selection.
     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.
     * @param transfers The transfers to send.
     * @param promoteOptions Additional options for the promote.
     *      @property delay Delay between promotion transfers
     *      @property interrupt Flag or method to terminate promotion.
     * @returns Promise which resolves to the list of transactions created or rejects with an error.
     */

  }, {
    key: "promoteTransaction",
    value: function () {
      var _promoteTransaction = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee16(transactionTail, depth, minWeightMagnitude, transfers, promoteOptions) {
        var _this = this;

        var localPromoteOptions, isPromotable, sendTransferResponse;
        return _regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                this._logger.info("===> TransactionClient::promoteTransaction", transactionTail, depth, minWeightMagnitude, transfers, promoteOptions);

                if (objectHelper_1.ObjectHelper.isType(transactionTail, hash_1.Hash)) {
                  _context16.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The transactionTail must be an object of type Hash");

              case 3:
                if (!(!numberHelper_1.NumberHelper.isInteger(depth) || depth <= 0)) {
                  _context16.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The depth must be a number > 0", {
                  depth: depth
                });

              case 5:
                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {
                  _context16.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The minWeightMagnitude must be a number > 0", {
                  minWeightMagnitude: minWeightMagnitude
                });

              case 7:
                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {
                  _context16.next = 9;
                  break;
                }

                throw new businessError_1.BusinessError("The transfers must an array of Transfer objects");

              case 9:
                localPromoteOptions = promoteOptions || {};

                if (objectHelper_1.ObjectHelper.isEmpty(localPromoteOptions.interrupt)) {
                  localPromoteOptions.interrupt = false;
                }

                if (!(localPromoteOptions.interrupt === false || typeof localPromoteOptions.interrupt === "function" && !localPromoteOptions.interrupt())) {
                  _context16.next = 30;
                  break;
                }

                _context16.next = 14;
                return this.isPromotable(transactionTail);

              case 14:
                isPromotable = _context16.sent;

                if (!isPromotable) {
                  _context16.next = 27;
                  break;
                }

                _context16.next = 18;
                return this.sendTransfer(hash_1.Hash.fromTrytes(transfers[0].address.toTrytes()), depth, minWeightMagnitude, transfers, undefined, transactionTail);

              case 18:
                sendTransferResponse = _context16.sent;

                if (!numberHelper_1.NumberHelper.isInteger(localPromoteOptions.delay)) {
                  _context16.next = 23;
                  break;
                }

                return _context16.abrupt("return", this._backgroundTaskService.create(
                /*#__PURE__*/
                _asyncToGenerator(
                /*#__PURE__*/
                _regeneratorRuntime.mark(function _callee15() {
                  return _regeneratorRuntime.wrap(function _callee15$(_context15) {
                    while (1) {
                      switch (_context15.prev = _context15.next) {
                        case 0:
                          return _context15.abrupt("return", _this.promoteTransaction(transactionTail, depth, minWeightMagnitude, transfers, localPromoteOptions));

                        case 1:
                        case "end":
                          return _context15.stop();
                      }
                    }
                  }, _callee15, this);
                })), localPromoteOptions.delay));

              case 23:
                this._logger.info("<=== TransactionClient::promoteTransaction", sendTransferResponse);

                return _context16.abrupt("return", sendTransferResponse);

              case 25:
                _context16.next = 28;
                break;

              case 27:
                throw new businessError_1.BusinessError("Transaction is not promotable");

              case 28:
                _context16.next = 32;
                break;

              case 30:
                this._logger.info("<=== TransactionClient::promoteTransaction", undefined);

                return _context16.abrupt("return", undefined);

              case 32:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      return function promoteTransaction(_x45, _x46, _x47, _x48, _x49) {
        return _promoteTransaction.apply(this, arguments);
      };
    }()
    /**
     * Gets the associated bundle transactions of a single transaction.
     * Does validation of signatures, total sum as well as bundle order.
     * @param transactionHash Hash of a trunk or a tail transaction of a bundle.
     * @returns Promise which resolves to the bundle transactions or rejects with an error.
     */

  }, {
    key: "getBundle",
    value: function () {
      var _getBundle = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee17(transactionHash) {
        var transactions, bundle, isValid;
        return _regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                this._logger.info("===> TransactionClient::getBundle", transactionHash);

                if (objectHelper_1.ObjectHelper.isType(transactionHash, hash_1.Hash)) {
                  _context17.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The transactionHash must be an object of type Hash");

              case 3:
                _context17.next = 5;
                return this.traverseBundle(transactionHash);

              case 5:
                transactions = _context17.sent;
                bundle = new bundle_1.Bundle();
                bundle.transactions = transactions;
                isValid = bundleHelper_1.BundleHelper.isValid(bundle);

                if (isValid) {
                  _context17.next = 11;
                  break;
                }

                throw new businessError_1.BusinessError("Invalid bundle provided");

              case 11:
                this._logger.info("<=== TransactionClient::getBundle", bundle);

                return _context17.abrupt("return", bundle);

              case 13:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      return function getBundle(_x50) {
        return _getBundle.apply(this, arguments);
      };
    }()
    /**
     * Traverse the Bundle by going down the trunkTransactions until
     * the bundle hash of the transaction is no longer the same.
     * @param trunkTransaction Hash of a trunk or a tail transaction of a bundle.
     * @param bundleHash The bundle hash to match.
     * @returns Promise which resolves to the bundle transactions or rejects with an error.
     */

  }, {
    key: "traverseBundle",
    value: function () {
      var _traverseBundle = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee18(trunkTransaction, bundleHash) {
        var allBundleTransactions, newTrunkTransaction, newBundleHash, getTrytesRequest, getTrytesResponse, trytes, transactionObject, hasHash, localBundleHash;
        return _regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                this._logger.info("===> TransactionClient::traverseBundle", trunkTransaction, bundleHash);

                if (objectHelper_1.ObjectHelper.isType(trunkTransaction, hash_1.Hash)) {
                  _context18.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The trunkTransaction must be an object of type Hash");

              case 3:
                allBundleTransactions = [];
                newTrunkTransaction = trunkTransaction;
                newBundleHash = bundleHash;

              case 6:
                getTrytesRequest = {
                  hashes: [newTrunkTransaction.toTrytes().toString()]
                };
                _context18.next = 9;
                return this._apiClient.getTrytes(getTrytesRequest);

              case 9:
                getTrytesResponse = _context18.sent;
                trytes = !objectHelper_1.ObjectHelper.isEmpty(getTrytesResponse) && !objectHelper_1.ObjectHelper.isEmpty(getTrytesResponse.trytes) && getTrytesResponse.trytes.length > 0 ? getTrytesResponse.trytes[0] : undefined;

                if (!objectHelper_1.ObjectHelper.isEmpty(trytes)) {
                  _context18.next = 15;
                  break;
                }

                throw new businessError_1.BusinessError("Bundle transactions not visible");

              case 15:
                transactionObject = transaction_1.Transaction.fromTrytes(trytes_1.Trytes.fromString(trytes)); // If first transaction to search is not a tail, return error

                hasHash = !objectHelper_1.ObjectHelper.isEmpty(newBundleHash);

                if (!(!hasHash && transactionObject.currentIndex.toNumber() !== 0)) {
                  _context18.next = 19;
                  break;
                }

                throw new businessError_1.BusinessError("Invalid tail transaction supplied");

              case 19:
                // If no bundle hash, define it
                localBundleHash = hasHash ? newBundleHash : transactionObject.bundle;
                newTrunkTransaction = undefined;
                newBundleHash = undefined; // If same bundle hash continue

                if (localBundleHash.toTrytes().toString() === transactionObject.bundle.toTrytes().toString()) {
                  // Add transaction object to bundle
                  allBundleTransactions.push(transactionObject); // If more than one element then continue

                  if (transactionObject.lastIndex.toNumber() !== 0 || transactionObject.currentIndex.toNumber() !== 0) {
                    newTrunkTransaction = transactionObject.trunkTransaction;
                    newBundleHash = localBundleHash;
                  }
                }

              case 23:
                if (newTrunkTransaction !== undefined) {
                  _context18.next = 6;
                  break;
                }

              case 24:
                this._logger.info("<=== TransactionClient::traverseBundle", allBundleTransactions);

                return _context18.abrupt("return", allBundleTransactions);

              case 26:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      return function traverseBundle(_x51, _x52) {
        return _traverseBundle.apply(this, arguments);
      };
    }()
    /**
     * Wrapper which gets a bundle and then replays a transfer by doing Proof of Work again.
     * @param transactionHash The hash of the transaction to be promoted.
     * @param depth Value that determines how far to go for tip selection.
     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.
     * @returns Promise which resolves to the list of transactions created or rejects with an error.
     */

  }, {
    key: "reattachBundle",
    value: function () {
      var _reattachBundle = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee19(transactionHash, depth, minWeightMagnitude) {
        var bundle, sendTransactionsResponse;
        return _regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                this._logger.info("===> TransactionClient::reattachBundle", transactionHash, depth, minWeightMagnitude);

                _context19.next = 3;
                return this.getBundle(transactionHash);

              case 3:
                bundle = _context19.sent;
                bundle.transactions = bundle.transactions.reverse();
                _context19.next = 7;
                return this.sendTransactions(bundle, depth, minWeightMagnitude);

              case 7:
                sendTransactionsResponse = _context19.sent;

                this._logger.info("<=== TransactionClient::reattachBundle", sendTransactionsResponse);

                return _context19.abrupt("return", sendTransactionsResponse);

              case 10:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      return function reattachBundle(_x53, _x54, _x55) {
        return _reattachBundle.apply(this, arguments);
      };
    }()
    /**
     * Wrapper which gets a bundle and then broadcasts it.
     * @param transactionHash The hash of the transaction to be re-broadcast.
     * @returns Promise which resolves or rejects with an error.
     */

  }, {
    key: "rebroadcastBundle",
    value: function () {
      var _rebroadcastBundle = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee20(transactionHash) {
        var bundle, broadcastTransactionsRequest;
        return _regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                this._logger.info("===> TransactionClient::rebroadcastBundle", transactionHash);

                _context20.next = 3;
                return this.getBundle(transactionHash);

              case 3:
                bundle = _context20.sent;
                broadcastTransactionsRequest = {
                  trytes: bundle.transactions.reverse().map(function (bt) {
                    return bt.toTrytes().toString();
                  })
                };
                _context20.next = 7;
                return this._apiClient.broadcastTransactions(broadcastTransactionsRequest);

              case 7:
                this._logger.info("<=== TransactionClient::rebroadcastBundle", bundle);

                return _context20.abrupt("return", bundle);

              case 9:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      return function rebroadcastBundle(_x56) {
        return _rebroadcastBundle.apply(this, arguments);
      };
    }()
    /**
     * Get transaction objects by fist performing a findTransactions call.
     * @param addresses The addresses to get the transaction objects for.
     * @param bundles Bundles to lookup transactions for.
     * @param addresses Addresses to lookup transactions for.
     * @param tags Tags to lookup transactions for.
     * @param approvees Approvees to lookup transactions for.
     * @returns Promise which resolves to the list of transactions or rejects with an error.
     */

  }, {
    key: "findTransactionObjects",
    value: function () {
      var _findTransactionObjects = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee21(bundles, addresses, tags, approvees) {
        var transactions, resp;
        return _regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                this._logger.info("===> TransactionClient::findTransactionObjects", bundles, addresses, tags, approvees);

                _context21.next = 3;
                return this.findTransactions(bundles, addresses, tags, approvees);

              case 3:
                transactions = _context21.sent;

                if (!(transactions.length > 0)) {
                  _context21.next = 12;
                  break;
                }

                _context21.next = 7;
                return this.getTransactionsObjects(transactions);

              case 7:
                resp = _context21.sent;

                this._logger.info("<=== TransactionClient::findTransactionObjects", resp);

                return _context21.abrupt("return", resp);

              case 12:
                this._logger.info("<=== TransactionClient::findTransactionObjects", []);

                return _context21.abrupt("return", []);

              case 14:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      return function findTransactionObjects(_x57, _x58, _x59, _x60) {
        return _findTransactionObjects.apply(this, arguments);
      };
    }()
    /**
     * The transfers which are associated with a seed. The transfers are determined by either calculating
     * deterministically which addresses were already used, or by providing a list of indexes to get the
     * addresses and the associated transfers from. The transfers are sorted by their timestamp.
     * @param seed The seed to get the transfers for
     * @param startIndex The start index to get the transfers for.
     * @param endIndex The end index to get the transfers for.
     * @param security The security level for the transfers.
     * @param inclusionStates Do you want inclusion states in the bundles.
     * @returns Promise which resolves to the requested bundles or rejects with an error.
     */

  }, {
    key: "getTransfers",
    value: function () {
      var _getTransfers = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee22(seed, startIndex, endIndex, security, inclusionStates) {
        var localStartIndex, addresses, bundles;
        return _regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                this._logger.info("===> TransactionClient::getTransfers", seed, startIndex, endIndex, security, inclusionStates);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context22.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                localStartIndex = startIndex;

                if (!numberHelper_1.NumberHelper.isInteger(localStartIndex)) {
                  localStartIndex = 0;
                }

                _context22.next = 7;
                return this.getNewAddress(seed, localStartIndex, endIndex, false, security);

              case 7:
                addresses = _context22.sent;
                _context22.next = 10;
                return this.bundlesFromAddresses(addresses, inclusionStates);

              case 10:
                bundles = _context22.sent;

                this._logger.info("<=== TransactionClient::getTransfers", bundles);

                return _context22.abrupt("return", bundles);

              case 13:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      return function getTransfers(_x61, _x62, _x63, _x64, _x65) {
        return _getTransfers.apply(this, arguments);
      };
    }()
    /**
     * Similar to getTransfers, just that it returns additional account data.
     * @param seed The seed to get the transfers for
     * @param startIndex The start index to get the transfers for.
     * @param endIndex The end index to get the transfers for.
     * @param security The security level for the transfers.
     * @returns Promise which resolves to the account data or rejects with an error.
     */

  }, {
    key: "getAccountData",
    value: function () {
      var _getAccountData = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee23(seed, startIndex, endIndex, security) {
        var localStartIndex, addresses, bundles, accountData, balanceRequest, balanceResponse, i, balance;
        return _regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                this._logger.info("===> TransactionClient::getAccountData", seed, startIndex, endIndex, security);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context23.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                localStartIndex = startIndex;

                if (!numberHelper_1.NumberHelper.isInteger(localStartIndex)) {
                  localStartIndex = 0;
                }

                _context23.next = 7;
                return this.getNewAddress(seed, localStartIndex, endIndex, false, security || addressSecurity_1.AddressSecurity.medium);

              case 7:
                addresses = _context23.sent;
                _context23.next = 10;
                return this.bundlesFromAddresses(addresses, true);

              case 10:
                bundles = _context23.sent;
                accountData = {
                  latestAddress: addresses.pop(),
                  addresses: addresses,
                  transfers: bundles,
                  inputs: [],
                  balance: 0
                };
                balanceRequest = {
                  addresses: accountData.addresses.map(function (add) {
                    return add.toTrytes().toString();
                  }),
                  threshold: 100
                };
                _context23.next = 15;
                return this._apiClient.getBalances(balanceRequest);

              case 15:
                balanceResponse = _context23.sent;

                for (i = 0; i < balanceResponse.balances.length; i++) {
                  balance = parseInt(balanceResponse.balances[i], 10);

                  if (balance > 0) {
                    accountData.inputs.push(input_1.Input.fromParams(accountData.addresses[i], security || addressSecurity_1.AddressSecurity.medium, localStartIndex + i, balance));
                    accountData.balance += balance;
                  }
                }

                this._logger.info("<=== TransactionClient::getAccountData", accountData);

                return _context23.abrupt("return", accountData);

              case 19:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      return function getAccountData(_x66, _x67, _x68, _x69) {
        return _getAccountData.apply(this, arguments);
      };
    }()
    /* @internal */

  }, {
    key: "bundlesFromAddresses",
    value: function () {
      var _bundlesFromAddresses = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee24(addresses, inclusionStates) {
        var transactionObjects, tailTransactions, nonTailBundleHashes, nonTailBundleTransactions, finalBundles, tailTxArray, tailTxStates, i, bundle;
        return _regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.findTransactionObjects(undefined, addresses, undefined, undefined);

              case 2:
                transactionObjects = _context24.sent;
                // set of tail transactions
                tailTransactions = new Set();
                nonTailBundleHashes = new Set();
                transactionObjects.forEach(function (transaction) {
                  // Sort tail and nonTails
                  if (transaction.currentIndex.toNumber() === 0) {
                    tailTransactions.add(bundleHelper_1.BundleHelper.transactionHash(transaction).toTrytes().toString());
                  } else {
                    nonTailBundleHashes.add(transaction.bundle.toTrytes().toString());
                  }
                });

                if (!(nonTailBundleHashes.size > 0)) {
                  _context24.next = 11;
                  break;
                }

                _context24.next = 9;
                return this.findTransactionObjects(Array.from(nonTailBundleHashes).map(function (hash) {
                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));
                }));

              case 9:
                nonTailBundleTransactions = _context24.sent;
                nonTailBundleTransactions.forEach(function (transaction) {
                  if (transaction.currentIndex.toNumber() === 0) {
                    tailTransactions.add(bundleHelper_1.BundleHelper.transactionHash(transaction).toTrytes().toString());
                  }
                });

              case 11:
                finalBundles = [];
                tailTxArray = Array.from(tailTransactions); // If inclusionStates, get the confirmation status
                // of the tail transactions, and thus the bundles

                if (!inclusionStates) {
                  _context24.next = 17;
                  break;
                }

                _context24.next = 16;
                return this.getLatestInclusion(tailTxArray.map(function (tail) {
                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(tail));
                }));

              case 16:
                tailTxStates = _context24.sent;

              case 17:
                i = 0;

              case 18:
                if (!(i < tailTxArray.length)) {
                  _context24.next = 27;
                  break;
                }

                _context24.next = 21;
                return this.getBundle(hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(tailTxArray[i])));

              case 21:
                bundle = _context24.sent;
                bundle.inclusionState = tailTxStates ? tailTxStates[i] : undefined;
                finalBundles.push(bundle);

              case 24:
                i++;
                _context24.next = 18;
                break;

              case 27:
                // Sort bundles by timestamp
                finalBundles.sort(function (a, b) {
                  var x = a.transactions[0].attachmentTimestamp.toNumber();
                  var y = b.transactions[0].attachmentTimestamp.toNumber();
                  return x < y ? -1 : x > y ? 1 : 0;
                });
                return _context24.abrupt("return", finalBundles);

              case 29:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      return function bundlesFromAddresses(_x70, _x71) {
        return _bundlesFromAddresses.apply(this, arguments);
      };
    }()
    /* @internal */

  }, {
    key: "generateAddress",
    value: function generateAddress(seed, index, security, includeChecksum) {
      var key = iss_1.ISS.key(seed, index, security);
      var digests = iss_1.ISS.digests(key);
      var addressTrits = iss_1.ISS.address(digests);
      var addressTrytesString = trits_1.Trits.fromArray(addressTrits).toTrytes().toString();

      if (includeChecksum) {
        addressTrytesString += addressHelper_1.AddressHelper.createChecksum(addressTrits, 9);
      }

      return address_1.Address.fromTrytes(trytes_1.Trytes.fromString(addressTrytesString));
    }
    /* @internal */

  }, {
    key: "addRemainder",
    value: function () {
      var _addRemainder = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee25(seed, bundle, transferOptions, inputs, signatureMessageFragments, totalValue, tag, addedHMAC) {
        var totalTransferValue, i, timestamp, remainder, startIndex, k, addresses, ts;
        return _regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                totalTransferValue = totalValue;
                i = 0;

              case 2:
                if (!(i < inputs.length)) {
                  _context25.next = 31;
                  break;
                }

                timestamp = Math.floor(this._timeService.msSinceEpoch() / 1000); // Add input as bundle entry

                bundle.addTransactions(inputs[i].security, inputs[i].address, -inputs[i].balance, tag, timestamp); // If there is a remainder value
                // Add extra output to send remaining funds to

                if (!(inputs[i].balance >= totalTransferValue)) {
                  _context25.next = 27;
                  break;
                }

                remainder = inputs[i].balance - totalTransferValue; // If user has provided remainder address use it to send remaining funds to

                if (!(remainder > 0 && !objectHelper_1.ObjectHelper.isEmpty(transferOptions) && objectHelper_1.ObjectHelper.isType(transferOptions.remainderAddress, address_1.Address))) {
                  _context25.next = 12;
                  break;
                }

                // Remainder bundle entry
                bundle.addTransactions(1, transferOptions.remainderAddress, remainder, tag, timestamp); // Final function for signing inputs

                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);
                _context25.next = 25;
                break;

              case 12:
                if (!(remainder > 0)) {
                  _context25.next = 24;
                  break;
                }

                startIndex = 0;

                for (k = 0; k < inputs.length; k++) {
                  startIndex = Math.max(inputs[k].keyIndex, startIndex);
                }

                startIndex++;
                _context25.next = 18;
                return this.getAddressesToUnused(seed, startIndex, false, transferOptions.security);

              case 18:
                addresses = _context25.sent;
                ts = Math.floor(this._timeService.msSinceEpoch() / 1000); // Remainder bundle entry

                bundle.addTransactions(1, addresses[addresses.length - 1], remainder, tag, ts); // Final function for signing inputs

                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);
                _context25.next = 25;
                break;

              case 24:
                // If there is no remainder, do not add transaction to bundle
                // simply sign and return
                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);

              case 25:
                _context25.next = 28;
                break;

              case 27:
                // If multiple inputs provided, subtract the totalTransferValue by
                // the inputs balance
                totalTransferValue -= inputs[i].balance;

              case 28:
                i++;
                _context25.next = 2;
                break;

              case 31:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      return function addRemainder(_x72, _x73, _x74, _x75, _x76, _x77, _x78, _x79) {
        return _addRemainder.apply(this, arguments);
      };
    }()
    /* @internal */

  }, {
    key: "proofOfWorkIterate",
    value: function () {
      var _proofOfWorkIterate = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee26(trunkTransaction, branchTransaction, transactions, minWeightMagnitude) {
        var finalTransactions, previousTransactionHash, i, newTrytes, returnedTrytes, returnTransaction;
        return _regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                finalTransactions = [];
                i = 0;

              case 2:
                if (!(i < transactions.length)) {
                  _context26.next = 26;
                  break;
                }

                // Start with last index transaction
                // Assign it the trunk / branch which the user has supplied
                // If there is a bundle, chain the bundle transactions via
                // trunkTransaction together
                transactions[i].attachmentTimestamp = tryteNumber_1.TryteNumber.fromNumber(this._timeService.msSinceEpoch());
                transactions[i].attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromNumber(0);
                transactions[i].attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromNumber(TransactionClient.MAX_TIMESTAMP_VALUE); // If this is the first transaction, to be processed
                // Make sure that it's the last in the bundle and then
                // assign it the supplied trunk and branch transactions

                if (!objectHelper_1.ObjectHelper.isEmpty(previousTransactionHash)) {
                  _context26.next = 13;
                  break;
                }

                if (!(transactions[i].lastIndex.toNumber() !== transactions[i].currentIndex.toNumber())) {
                  _context26.next = 9;
                  break;
                }

                throw new businessError_1.BusinessError("Wrong bundle order. The bundle should be ordered in descending order from currentIndex");

              case 9:
                transactions[i].trunkTransaction = trunkTransaction;
                transactions[i].branchTransaction = branchTransaction;
                _context26.next = 15;
                break;

              case 13:
                transactions[i].trunkTransaction = previousTransactionHash;
                transactions[i].branchTransaction = trunkTransaction;

              case 15:
                newTrytes = transactions[i].toTrytes();
                _context26.next = 18;
                return this._proofOfWork.pow(trunkTransaction, branchTransaction, [newTrytes], minWeightMagnitude);

              case 18:
                returnedTrytes = _context26.sent;
                transactions[i].nonce = tag_1.Tag.fromTrytes(returnedTrytes[0].sub(transaction_1.Transaction.LENGTH - tag_1.Tag.LENGTH, tag_1.Tag.LENGTH)); // Calculate the hash of the new transaction with nonce and use that as the previous hash for next entry

                returnTransaction = transaction_1.Transaction.fromTrytes(returnedTrytes[0]);
                previousTransactionHash = bundleHelper_1.BundleHelper.transactionHash(returnTransaction);
                finalTransactions.push(returnTransaction);

              case 23:
                i++;
                _context26.next = 2;
                break;

              case 26:
                return _context26.abrupt("return", Promise.resolve(finalTransactions.reverse()));

              case 27:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      return function proofOfWorkIterate(_x80, _x81, _x82, _x83) {
        return _proofOfWorkIterate.apply(this, arguments);
      };
    }()
  }]);

  return TransactionClient;
}();
/* @internal */


TransactionClient.NULL_HASH_TRYTES = "9".repeat(243);
/* @internal */

TransactionClient.MAX_TIMESTAMP_VALUE = (Math.pow(3, 27) - 1) / 2;
/* @internal */

TransactionClient.MAX_INPUTS = 500;
exports.TransactionClient = TransactionClient;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(44);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var networkClientFactory_1 = __webpack_require__(27);

var networkClient_1 = __webpack_require__(45);
/**
 * Platform abstraction layer for Browser.
 */


var PAL =
/*#__PURE__*/
function () {
  function PAL() {
    _classCallCheck(this, PAL);
  }

  _createClass(PAL, null, [{
    key: "initialize",

    /**
     * Perform any initialization for the PAL.
     */
    value: function () {
      var _initialize = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!PAL._isInitialized) {
                  PAL._isInitialized = true;
                  networkClientFactory_1.NetworkClientFactory.instance().register("default", function (networkEndpoint) {
                    return new networkClient_1.NetworkClient(networkEndpoint);
                  });
                }

                return _context.abrupt("return", Promise.resolve());

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function initialize() {
        return _initialize.apply(this, arguments);
      };
    }()
  }]);

  return PAL;
}();
/* @internal */


PAL._isInitialized = false;
exports.PAL = PAL;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(78);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 78 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(80);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(4);

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var stringHelper_1 = __webpack_require__(6);

var cryptoError_1 = __webpack_require__(5);

var hash_1 = __webpack_require__(9);

var trytes_1 = __webpack_require__(1);
/**
 * ProofOfWork implementation using Remote PowBox.
 */


var ProofOfWorkBox =
/*#__PURE__*/
function () {
  /**
   * Create an instance of ProofOfWork.
   * @param networkClient The network client to communicate through.
   * @param apiKey The API key to access the pow box.
   */
  function ProofOfWorkBox(networkClient, apiKey) {
    var pollIntervalMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;

    _classCallCheck(this, ProofOfWorkBox);

    if (objectHelper_1.ObjectHelper.isEmpty(networkClient)) {
      throw new cryptoError_1.CryptoError("The networkClient must be defined");
    }

    if (stringHelper_1.StringHelper.isEmpty(apiKey)) {
      throw new cryptoError_1.CryptoError("The apiKey must not be empty");
    }

    if (!numberHelper_1.NumberHelper.isInteger(pollIntervalMs) || pollIntervalMs <= 0) {
      throw new cryptoError_1.CryptoError("The pollIntervalMs must be > 0");
    }

    this._networkClient = networkClient;
    this._apiKey = apiKey;
    this._pollIntervalMs = pollIntervalMs;
  }
  /**
   * Allow the proof of work to perform any initialization.
   * Will throw an exception if the implementation is not supported.
   */


  _createClass(ProofOfWorkBox, [{
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.resolve());

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function initialize() {
        return _initialize.apply(this, arguments);
      };
    }()
    /**
     * Performs single conversion per pow call.
     * @returns True if pow only does one conversion.
     */

  }, {
    key: "performsSingle",
    value: function performsSingle() {
      return false;
    }
    /**
     * Perform a proof of work on the data.
     * @param trunkTransaction The trunkTransaction to use for the pow.
     * @param branchTransaction The branchTransaction to use for the pow.
     * @param trytes The trytes to perform the pow on.
     * @param minWeightMagnitude The minimum weight magnitude.
     * @returns The trytes produced by the proof of work.
     */

  }, {
    key: "pow",
    value: function () {
      var _pow = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {
        var attachToTangleRequest, additionalHeaders, attachToTangleResponse;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (objectHelper_1.ObjectHelper.isType(trunkTransaction, hash_1.Hash)) {
                  _context2.next = 2;
                  break;
                }

                throw new cryptoError_1.CryptoError("The trunkTransaction must be an object of type Hash");

              case 2:
                if (objectHelper_1.ObjectHelper.isType(branchTransaction, hash_1.Hash)) {
                  _context2.next = 4;
                  break;
                }

                throw new cryptoError_1.CryptoError("The branchTransaction must be an object of type Hash");

              case 4:
                if (arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {
                  _context2.next = 6;
                  break;
                }

                throw new cryptoError_1.CryptoError("The trytes must be an array of type Trytes");

              case 6:
                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {
                  _context2.next = 8;
                  break;
                }

                throw new cryptoError_1.CryptoError("The minWeightMagnitude must be > 0");

              case 8:
                attachToTangleRequest = {
                  command: "attachToTangle",
                  trunkTransaction: trunkTransaction.toTrytes().toString(),
                  branchTransaction: branchTransaction.toTrytes().toString(),
                  minWeightMagnitude: minWeightMagnitude,
                  trytes: trytes.map(function (t) {
                    return t.toString();
                  })
                };
                additionalHeaders = {
                  Authorization: this._apiKey
                };
                _context2.next = 12;
                return this._networkClient.postJson(attachToTangleRequest, "commands", additionalHeaders);

              case 12:
                attachToTangleResponse = _context2.sent;

                if (!(objectHelper_1.ObjectHelper.isEmpty(attachToTangleResponse) || stringHelper_1.StringHelper.isEmpty(attachToTangleResponse.jobId))) {
                  _context2.next = 17;
                  break;
                }

                throw new cryptoError_1.CryptoError("The attachToTangleRequest did not return a jobId");

              case 17:
                return _context2.abrupt("return", this.waitForJobCompletion(attachToTangleResponse.jobId, trytes));

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function pow(_x, _x2, _x3, _x4) {
        return _pow.apply(this, arguments);
      };
    }()
    /* @internal */

  }, {
    key: "waitForJobCompletion",
    value: function () {
      var _waitForJobCompletion = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee4(jobId, sourceTrytes) {
        var _this = this;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", new Promise(function (resolve, reject) {
                  var intervalId = setInterval(
                  /*#__PURE__*/
                  _asyncToGenerator(
                  /*#__PURE__*/
                  _regeneratorRuntime.mark(function _callee3() {
                    var jobResponse;
                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.prev = 0;
                            _context3.next = 3;
                            return _this._networkClient.getJson("jobs/".concat(jobId));

                          case 3:
                            jobResponse = _context3.sent;

                            if (jobResponse.error) {
                              clearInterval(intervalId);
                              reject(new cryptoError_1.CryptoError(jobResponse.errorMessage));
                            } else if (jobResponse.progress === "100") {
                              clearInterval(intervalId);

                              if (jobResponse && jobResponse.response && jobResponse.response.trytes && jobResponse.response.trytes.length === sourceTrytes.length) {
                                resolve(jobResponse.response.trytes.map(function (t) {
                                  return trytes_1.Trytes.fromString(t);
                                }));
                              } else {
                                reject(new cryptoError_1.CryptoError("The response did not contain enough trytes"));
                              }
                            }

                            _context3.next = 11;
                            break;

                          case 7:
                            _context3.prev = 7;
                            _context3.t0 = _context3["catch"](0);
                            clearInterval(intervalId);
                            reject(_context3.t0);

                          case 11:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3, this, [[0, 7]]);
                  })), _this._pollIntervalMs);
                }));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function waitForJobCompletion(_x5, _x6) {
        return _waitForJobCompletion.apply(this, arguments);
      };
    }()
  }]);

  return ProofOfWorkBox;
}();

exports.ProofOfWorkBox = ProofOfWorkBox;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(81);


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(82);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 82 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(84);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(4);

var numberHelper_1 = __webpack_require__(2);

var cryptoError_1 = __webpack_require__(5);

var trytes_1 = __webpack_require__(1);

var pearlDiver_1 = __webpack_require__(87);
/**
 * ProofOfWork implementation using JavaScript.
 */


var ProofOfWorkJs =
/*#__PURE__*/
function () {
  function ProofOfWorkJs() {
    _classCallCheck(this, ProofOfWorkJs);
  }

  _createClass(ProofOfWorkJs, [{
    key: "initialize",

    /**
     * Allow the proof of work to perform any initialization.
     * Will throw an exception if the implementation is not supported.
     */
    value: function () {
      var _initialize = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.resolve());

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function initialize() {
        return _initialize.apply(this, arguments);
      };
    }()
    /**
     * Performs single conversion per pow call.
     * @returns True if pow only does one conversion.
     */

  }, {
    key: "performsSingle",
    value: function performsSingle() {
      return true;
    }
    /**
     * Perform a proof of work on the data.
     * @param trunkTransaction The trunkTransaction to use for the pow.
     * @param branchTransaction The branchTransaction to use for the pow.
     * @param trytes The trytes to perform the pow on.
     * @param minWeightMagnitude The minimum weight magnitude.
     * @returns The trytes produced by the proof of work.
     */

  }, {
    key: "pow",
    value: function () {
      var _pow = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {
        var nonce, nonceString, trytesString;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {
                  _context2.next = 2;
                  break;
                }

                throw new cryptoError_1.CryptoError("The trytes must be an array of type Trytes");

              case 2:
                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {
                  _context2.next = 4;
                  break;
                }

                throw new cryptoError_1.CryptoError("The minWeightMagnitude must be > 0");

              case 4:
                nonce = new pearlDiver_1.PearlDiver().searchWithTrytes(trytes[0], minWeightMagnitude);
                nonceString = nonce.toString();
                trytesString = trytes.toString();
                return _context2.abrupt("return", [trytes_1.Trytes.fromString(trytesString.substr(0, trytesString.length - nonceString.length) + nonceString)]);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function pow(_x, _x2, _x3, _x4) {
        return _pow.apply(this, arguments);
      };
    }()
  }]);

  return ProofOfWorkJs;
}();

exports.ProofOfWorkJs = ProofOfWorkJs;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(85);


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(86);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 86 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var spongeFactory_1 = __webpack_require__(10);

var trits_1 = __webpack_require__(7); // tslint:disable-next-line:import-name


var big_integer_1 = __importDefault(__webpack_require__(38));
/**
 * PearlDiver implementation in plain JavaScript.
 */


var PearlDiver =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of PearlDiver.
   */
  function PearlDiver() {
    _classCallCheck(this, PearlDiver);

    var curl = spongeFactory_1.SpongeFactory.instance().create("curl");
    this._hashLength = curl.getConstant("HASH_LENGTH");
    this._stateLength = curl.getConstant("STATE_LENGTH");
    this._numberRounds = curl.getConstant("NUMBER_OF_ROUNDS");
    this._transactionLength = this._hashLength * 33;
    this._nonceLength = this._hashLength / 3;
    this._nonceStart = this._hashLength - this._nonceLength;
    var OFFSET_LENGTH = 4;
    this._nonceInitStart = this._nonceStart + OFFSET_LENGTH;
    var INT_LENGTH = this._nonceLength / 3;
    this._nonceIncrementStart = this._nonceInitStart + INT_LENGTH;
  }
  /**
   * Perform a proof of work on the data.
   * @param trytes The trytes to perform the pow on.
   * @param minWeightMagnitude The minimum weight magnitude.
   * @returns The trytes produced by the proof of work.
   */


  _createClass(PearlDiver, [{
    key: "searchWithTrytes",
    value: function searchWithTrytes(trytes, minWeightMagnitude) {
      var curlState = this.prepare(trytes);
      var searchStates = this.searchInit(curlState);
      return this.search(searchStates, minWeightMagnitude);
    }
  }, {
    key: "search",
    value: function search(searchStates, minWeightMagnitude) {
      var searching = true;
      var trits = new Int8Array(this._hashLength);
      var midStateCopy = {
        low: searchStates.low.slice(),
        high: searchStates.high.slice()
      };

      while (searching) {
        this.increment(midStateCopy, this._nonceIncrementStart, this._hashLength);
        var state = {
          low: midStateCopy.low.slice(),
          high: midStateCopy.high.slice()
        };
        this.transform(state);
        var nonceProbe = this.isFoundFast(state, minWeightMagnitude);

        if (nonceProbe.toJSNumber() === 0) {
          continue;
        }

        var nonceOutput = big_integer_1.default(1); // Bit scan forward

        while (nonceOutput.and(nonceProbe).toJSNumber() === 0) {
          nonceOutput = nonceOutput.shiftLeft(1);
        }

        searching = false;

        for (var i = 0; i < this._hashLength; i++) {
          trits[i] = midStateCopy.low[i].and(nonceOutput).toJSNumber() === 0 ? 1 : midStateCopy.high[i].and(nonceOutput).toJSNumber() === 0 ? -1 : 0;
        }
      }

      return trits_1.Trits.fromArray(trits).toTrytes();
    }
  }, {
    key: "transform",
    value: function transform(searchStates) {
      var curlScratchpadIndex = 0;

      for (var round = 0; round < this._numberRounds; round++) {
        var curlScratchpad = {
          low: searchStates.low.slice(),
          high: searchStates.high.slice()
        };

        for (var stateIndex = 0; stateIndex < this._stateLength; stateIndex++) {
          var alpha = curlScratchpad.low[curlScratchpadIndex];
          var beta = curlScratchpad.high[curlScratchpadIndex];

          if (curlScratchpadIndex < 365) {
            curlScratchpadIndex += 364;
          } else {
            curlScratchpadIndex += -365;
          }

          var gamma = curlScratchpad.high[curlScratchpadIndex];
          var lowXorBeta = curlScratchpad.low[curlScratchpadIndex].xor(beta);
          var notGamma = gamma.not();
          var alphaOrNotGamma = alpha.or(notGamma);
          var delta = alphaOrNotGamma.and(lowXorBeta);
          searchStates.low[stateIndex] = delta.not();
          var alphaXorGamma = alpha.xor(gamma);
          searchStates.high[stateIndex] = alphaXorGamma.or(delta);
        }
      }
    }
  }, {
    key: "increment",
    value: function increment(searchStates, fromIndex, toIndex) {
      for (var i = fromIndex; i < toIndex; i++) {
        if (searchStates.low[i].toJSNumber() === PearlDiver.LOW_BITS) {
          searchStates.low[i] = big_integer_1.default(PearlDiver.HIGH_BITS);
          searchStates.high[i] = big_integer_1.default(PearlDiver.LOW_BITS);
        } else {
          if (searchStates.high[i].toJSNumber() === PearlDiver.LOW_BITS) {
            searchStates.high[i] = big_integer_1.default(PearlDiver.HIGH_BITS);
          } else {
            searchStates.low[i] = big_integer_1.default(PearlDiver.LOW_BITS);
          }

          break;
        }
      }
    }
  }, {
    key: "prepare",
    value: function prepare(transactionTrytes) {
      var curl = spongeFactory_1.SpongeFactory.instance().create("curl");
      curl.initialize();
      var transactionTrits = trits_1.Trits.fromTrytes(transactionTrytes).toArray();
      curl.absorb(transactionTrits, 0, this._transactionLength - this._hashLength);
      var curlState = curl.getState();
      transactionTrits.slice(this._transactionLength - this._hashLength, this._transactionLength).forEach(function (value, index) {
        curlState[index] = value;
      });
      return curlState;
    }
  }, {
    key: "searchInit",
    value: function searchInit(curlState) {
      var states = {
        low: [],
        high: []
      };
      curlState.forEach(function (trit, index) {
        switch (trit) {
          case 0:
            states.low[index] = big_integer_1.default(PearlDiver.HIGH_BITS);
            states.high[index] = big_integer_1.default(PearlDiver.HIGH_BITS);
            break;

          case 1:
            states.low[index] = big_integer_1.default(PearlDiver.LOW_BITS);
            states.high[index] = big_integer_1.default(PearlDiver.HIGH_BITS);
            break;

          default:
            states.low[index] = big_integer_1.default(PearlDiver.HIGH_BITS);
            states.high[index] = big_integer_1.default(PearlDiver.LOW_BITS);
        }
      });
      this.searchOffset(states, this._nonceStart);
      return states;
    }
  }, {
    key: "searchOffset",
    value: function searchOffset(states, offset) {
      states.low[offset + 0] = big_integer_1.default("-2635249153387078803", 10);
      states.high[offset + 0] = big_integer_1.default("-5270498306774157605", 10);
      states.low[offset + 1] = big_integer_1.default("-1010780497189564473", 10);
      states.high[offset + 1] = big_integer_1.default("-8086243977516515777", 10);
      states.low[offset + 2] = big_integer_1.default("9223336921201902079", 10);
      states.high[offset + 2] = big_integer_1.default("-17979214271348737", 10);
      states.low[offset + 3] = big_integer_1.default("-18014398375264257", 10);
      states.high[offset + 3] = big_integer_1.default("18014398509481983", 10);
    }
  }, {
    key: "isFoundFast",
    value: function isFoundFast(searchStates, minWeightMagnitude) {
      var lastMeasurement = big_integer_1.default(PearlDiver.HIGH_BITS);

      for (var i = minWeightMagnitude - 1; i >= 0; i--) {
        var low = searchStates.low[this._hashLength - 1 - i];
        var high = searchStates.high[this._hashLength - 1 - i];
        var lowXorHigh = low.xor(high);
        var notLowXorHigh = lowXorHigh.not();
        lastMeasurement = lastMeasurement.and(notLowXorHigh);

        if (lastMeasurement.toJSNumber() === 0) {
          break;
        }
      }

      return lastMeasurement;
    }
  }]);

  return PearlDiver;
}();
/* @internal */


PearlDiver.HIGH_BITS = -1;
/* @internal */

PearlDiver.LOW_BITS = 0;
exports.PearlDiver = PearlDiver;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(89);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
}); /// <reference types="emscripten" />

var arrayHelper_1 = __webpack_require__(4);

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var cryptoError_1 = __webpack_require__(5);

var trytes_1 = __webpack_require__(1); // @ts-ignore


var iota_pico_pow_wasm_1 = __importDefault(__webpack_require__(92));
/**
 * ProofOfWork implementation using WebAssembly.
 */


var ProofOfWorkWasm =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of ProofOfWork.
   * @param webPlatform Provides platform specific functions, optional mostly used for testing.
   */
  function ProofOfWorkWasm(webPlatform) {
    _classCallCheck(this, ProofOfWorkWasm);

    if (objectHelper_1.ObjectHelper.isEmpty(webPlatform)) {
      this._webPlatform = {
        webAssemblyType: typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly),
        wasmModuleLoader: iota_pico_pow_wasm_1.default
      };
    } else {
      this._webPlatform = webPlatform;
    }
  }
  /**
   * Allow the proof of work to perform any initialization.
   * Will throw an exception if the implementation is not supported.
   */


  _createClass(ProofOfWorkWasm, [{
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee() {
        var _this = this;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  if (objectHelper_1.ObjectHelper.isEmpty(_this._webPlatform.webAssemblyType) || _this._webPlatform.webAssemblyType === "undefined") {
                    reject(new cryptoError_1.CryptoError("No WebAssembly support detected"));
                  }

                  var module = {};

                  module.onRuntimeInitialized = function () {
                    _this._ccurlPow = module.cwrap("ccurl_pow", "string", ["string", "number"]);
                    resolve();
                  };

                  try {
                    _this._webPlatform.wasmModuleLoader(module);
                  } catch (err) {
                    reject(new cryptoError_1.CryptoError("There was a problem intializing the WebAssembly Module", undefined, err));
                  }
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function initialize() {
        return _initialize.apply(this, arguments);
      };
    }()
    /**
     * Performs single conversion per pow call.
     * @returns True if pow only does one conversion.
     */

  }, {
    key: "performsSingle",
    value: function performsSingle() {
      return true;
    }
    /**
     * Perform a proof of work on the data.
     * @param trunkTransaction The trunkTransaction to use for the pow.
     * @param branchTransaction The branchTransaction to use for the pow.
     * @param trytes The trytes to perform the pow on.
     * @param minWeightMagnitude The minimum weight magnitude.
     * @returns The trytes produced by the proof of work.
     */

  }, {
    key: "pow",
    value: function () {
      var _pow = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {
        var _this2 = this;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  if (objectHelper_1.ObjectHelper.isEmpty(_this2._ccurlPow)) {
                    throw new cryptoError_1.CryptoError("WebAssembly not loaded, have you called initialize");
                  }

                  if (!arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {
                    throw new cryptoError_1.CryptoError("The trytes must be an array of type Trytes");
                  }

                  if (!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0) {
                    throw new cryptoError_1.CryptoError("The minWeightMagnitude must be > 0");
                  }

                  try {
                    var result = _this2._ccurlPow(trytes[0].toString(), minWeightMagnitude);

                    resolve([trytes_1.Trytes.fromString(result)]);
                  } catch (err) {
                    reject(err);
                  }
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function pow(_x, _x2, _x3, _x4) {
        return _pow.apply(this, arguments);
      };
    }()
  }]);

  return ProofOfWorkWasm;
}();

exports.ProofOfWorkWasm = ProofOfWorkWasm;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(90);


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(91);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 91 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Module = function Module(_Module) {
  _Module = _Module || {}; // The Module object: Our interface to the outside world. We import
  // and export values on it. There are various ways Module can be used:
  // 1. Not defined. We create it here
  // 2. A function parameter, function(Module) { ..generated code.. }
  // 3. pre-run appended it, var Module = {}; ..generated code..
  // 4. External script tag defines var Module.
  // We need to check if Module already exists (e.g. case 3 above).
  // Substitution will be replaced with actual code on later stage of the build,
  // this way Closure Compiler will not mangle it (e.g. case 4. above).
  // Note that if you want to run closure, and also to use Module
  // after the generated code, you will need to define   var Module = {};
  // before the code. Then that object will be used in the code, and you
  // can continue to use Module afterwards as well.

  var _Module = typeof _Module !== 'undefined' ? _Module : {}; // --pre-jses are emitted after the Module integration code, so that they can
  // refer to Module (if they choose; they can also define Module)
  // {{PRE_JSES}}
  // Sometimes an existing Module object exists with properties
  // meant to overwrite the default module functionality. Here
  // we collect those properties and reapply _after_ we configure
  // the current environment's defaults to avoid having to be so
  // defensive during initialization.


  var moduleOverrides = {};
  var key;

  for (key in _Module) {
    if (_Module.hasOwnProperty(key)) {
      moduleOverrides[key] = _Module[key];
    }
  }

  _Module['arguments'] = [];
  _Module['thisProgram'] = './this.program';

  _Module['quit'] = function (status, toThrow) {
    throw toThrow;
  };

  _Module['preRun'] = [];
  _Module['postRun'] = []; // The environment setup code below is customized to use Module.
  // *** Environment setup code ***

  var ENVIRONMENT_IS_WEB = false;
  var ENVIRONMENT_IS_WORKER = false;
  var ENVIRONMENT_IS_NODE = false;
  var ENVIRONMENT_IS_SHELL = false; // Three configurations we can be running in:
  // 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)
  // 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)
  // 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)

  if (_Module['ENVIRONMENT']) {
    if (_Module['ENVIRONMENT'] === 'WEB') {
      ENVIRONMENT_IS_WEB = true;
    } else if (_Module['ENVIRONMENT'] === 'WORKER') {
      ENVIRONMENT_IS_WORKER = true;
    } else if (_Module['ENVIRONMENT'] === 'NODE') {
      ENVIRONMENT_IS_NODE = true;
    } else if (_Module['ENVIRONMENT'] === 'SHELL') {
      ENVIRONMENT_IS_SHELL = true;
    } else {
      throw new Error('Module[\'ENVIRONMENT\'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.');
    }
  } else {
    ENVIRONMENT_IS_WEB = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object';
    ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
    ENVIRONMENT_IS_NODE = (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && "function" === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
  }

  if (ENVIRONMENT_IS_NODE) {
    // Expose functionality in the same simple way that the shells work
    // Note that we pollute the global namespace here, otherwise we break in node
    var nodeFS;
    var nodePath;

    _Module['read'] = function shell_read(filename, binary) {
      var ret;
      ret = tryParseAsDataURI(filename);

      if (!ret) {
        if (!nodeFS) nodeFS = __webpack_require__(49);
        if (!nodePath) nodePath = __webpack_require__(49);
        filename = nodePath['normalize'](filename);
        ret = nodeFS['readFileSync'](filename);
      }

      return binary ? ret : ret.toString();
    };

    _Module['readBinary'] = function readBinary(filename) {
      var ret = _Module['read'](filename, true);

      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }

      assert(ret.buffer);
      return ret;
    };

    if (process['argv'].length > 1) {
      _Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
    }

    _Module['arguments'] = process['argv'].slice(2); // MODULARIZE will export the module in the proper place outside, we don't need to export here

    process['on']('uncaughtException', function (ex) {
      // suppress ExitStatus exceptions from showing an error
      if (!(ex instanceof ExitStatus)) {
        throw ex;
      }
    }); // Currently node will swallow unhandled rejections, but this behavior is
    // deprecated, and in the future it will exit with error status.

    process['on']('unhandledRejection', function (reason, p) {
      _Module['printErr']('node.js exiting due to unhandled promise rejection');

      process['exit'](1);
    });

    _Module['inspect'] = function () {
      return '[Emscripten Module object]';
    };
  } else if (ENVIRONMENT_IS_SHELL) {
    if (typeof read != 'undefined') {
      _Module['read'] = function shell_read(f) {
        var data = tryParseAsDataURI(f);

        if (data) {
          return intArrayToString(data);
        }

        return read(f);
      };
    }

    _Module['readBinary'] = function readBinary(f) {
      var data;
      data = tryParseAsDataURI(f);

      if (data) {
        return data;
      }

      if (typeof readbuffer === 'function') {
        return new Uint8Array(readbuffer(f));
      }

      data = read(f, 'binary');
      assert(_typeof(data) === 'object');
      return data;
    };

    if (typeof scriptArgs != 'undefined') {
      _Module['arguments'] = scriptArgs;
    } else if (typeof arguments != 'undefined') {
      _Module['arguments'] = arguments;
    }

    if (typeof quit === 'function') {
      _Module['quit'] = function (status, toThrow) {
        quit(status);
      };
    }
  } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    _Module['read'] = function shell_read(url) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.send(null);
        return xhr.responseText;
      } catch (err) {
        var data = tryParseAsDataURI(url);

        if (data) {
          return intArrayToString(data);
        }

        throw err;
      }
    };

    if (ENVIRONMENT_IS_WORKER) {
      _Module['readBinary'] = function readBinary(url) {
        try {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, false);
          xhr.responseType = 'arraybuffer';
          xhr.send(null);
          return new Uint8Array(xhr.response);
        } catch (err) {
          var data = tryParseAsDataURI(url);

          if (data) {
            return data;
          }

          throw err;
        }
      };
    }

    _Module['readAsync'] = function readAsync(url, onload, onerror) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.responseType = 'arraybuffer';

      xhr.onload = function xhr_onload() {
        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
          // file URLs can return 0
          onload(xhr.response);
          return;
        }

        var data = tryParseAsDataURI(url);

        if (data) {
          onload(data.buffer);
          return;
        }

        onerror();
      };

      xhr.onerror = onerror;
      xhr.send(null);
    };

    if (typeof arguments != 'undefined') {
      _Module['arguments'] = arguments;
    }

    _Module['setWindowTitle'] = function (title) {
      document.title = title;
    };
  } else {
    // Unreachable because SHELL is dependent on the others
    throw new Error('unknown runtime environment');
  } // console.log is checked first, as 'print' on the web will open a print dialogue
  // printErr is preferable to console.warn (works better in shells)


  _Module['print'] = typeof console !== 'undefined' ? console.log : typeof print !== 'undefined' ? print : null;
  _Module['printErr'] = typeof printErr !== 'undefined' ? printErr : typeof console !== 'undefined' && console.warn || _Module['print']; // *** Environment setup code ***
  // Closure helpers

  _Module.print = _Module['print'];
  _Module.printErr = _Module['printErr']; // Merge back in the overrides

  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      _Module[key] = moduleOverrides[key];
    }
  } // Free the object hierarchy contained in the overrides, this lets the GC
  // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.


  moduleOverrides = undefined; // {{PREAMBLE_ADDITIONS}}

  var STACK_ALIGN = 16; // stack management, and other functionality that is provided by the compiled code,
  // should not be used before it is ready

  _stackSave = _stackRestore = stackAlloc = setTempRet0 = getTempRet0 = function getTempRet0() {
    abort('cannot use the stack before compiled code is ready to run, and has provided stack access');
  };

  function staticAlloc(size) {
    assert(!staticSealed);
    var ret = STATICTOP;
    STATICTOP = STATICTOP + size + 15 & -16;
    return ret;
  }

  function dynamicAlloc(size) {
    assert(DYNAMICTOP_PTR);
    var ret = HEAP32[DYNAMICTOP_PTR >> 2];
    var end = ret + size + 15 & -16;
    HEAP32[DYNAMICTOP_PTR >> 2] = end;

    if (end >= TOTAL_MEMORY) {
      var success = enlargeMemory();

      if (!success) {
        HEAP32[DYNAMICTOP_PTR >> 2] = ret;
        return 0;
      }
    }

    return ret;
  }

  function alignMemory(size, factor) {
    if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default

    var ret = size = Math.ceil(size / factor) * factor;
    return ret;
  }

  function getNativeTypeSize(type) {
    switch (type) {
      case 'i1':
      case 'i8':
        return 1;

      case 'i16':
        return 2;

      case 'i32':
        return 4;

      case 'i64':
        return 8;

      case 'float':
        return 4;

      case 'double':
        return 8;

      default:
        {
          if (type[type.length - 1] === '*') {
            return 4; // A pointer
          } else if (type[0] === 'i') {
            var bits = parseInt(type.substr(1));
            assert(bits % 8 === 0);
            return bits / 8;
          } else {
            return 0;
          }
        }
    }
  }

  function warnOnce(text) {
    if (!warnOnce.shown) warnOnce.shown = {};

    if (!warnOnce.shown[text]) {
      warnOnce.shown[text] = 1;

      _Module.printErr(text);
    }
  }

  var functionPointers = new Array(0);

  function addFunction(func) {
    for (var i = 0; i < functionPointers.length; i++) {
      if (!functionPointers[i]) {
        functionPointers[i] = func;
        return 1 + i;
      }
    }

    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';
  }

  function removeFunction(index) {
    functionPointers[index - 1] = null;
  }

  var funcWrappers = {};

  function getFuncWrapper(func, sig) {
    if (!func) return; // on null pointer, return undefined

    assert(sig);

    if (!funcWrappers[sig]) {
      funcWrappers[sig] = {};
    }

    var sigCache = funcWrappers[sig];

    if (!sigCache[func]) {
      // optimize away arguments usage in common cases
      if (sig.length === 1) {
        sigCache[func] = function dynCall_wrapper() {
          return dynCall(sig, func);
        };
      } else if (sig.length === 2) {
        sigCache[func] = function dynCall_wrapper(arg) {
          return dynCall(sig, func, [arg]);
        };
      } else {
        // general case
        sigCache[func] = function dynCall_wrapper() {
          return dynCall(sig, func, Array.prototype.slice.call(arguments));
        };
      }
    }

    return sigCache[func];
  }

  function makeBigInt(low, high, unsigned) {
    return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296.0 : +(low >>> 0) + +(high | 0) * 4294967296.0;
  }

  function dynCall(sig, ptr, args) {
    if (args && args.length) {
      assert(args.length == sig.length - 1);
      assert('dynCall_' + sig in _Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
      return _Module['dynCall_' + sig].apply(null, [ptr].concat(args));
    } else {
      assert(sig.length == 1);
      assert('dynCall_' + sig in _Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
      return _Module['dynCall_' + sig].call(null, ptr);
    }
  }

  function getCompilerSetting(name) {
    throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';
  }

  var Runtime = {
    // FIXME backwards compatibility layer for ports. Support some Runtime.*
    //       for now, fix it there, then remove it from here. That way we
    //       can minimize any period of breakage.
    dynCall: dynCall,
    // for SDL2 port
    // helpful errors
    getTempRet0: function getTempRet0() {
      abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove "Runtime."');
    },
    staticAlloc: function staticAlloc() {
      abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."');
    },
    stackAlloc: function stackAlloc() {
      abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."');
    }
  }; // The address globals begin at. Very low in memory, for code size and optimization opportunities.
  // Above 0 is static memory, starting with globals.
  // Then the stack.
  // Then 'dynamic' memory for sbrk.

  var GLOBAL_BASE = 1024; // === Preamble library stuff ===
  // Documentation for the public APIs defined in this file must be updated in:
  //    site/source/docs/api_reference/preamble.js.rst
  // A prebuilt local version of the documentation is available at:
  //    site/build/text/docs/api_reference/preamble.js.txt
  // You can also build docs locally as HTML or other formats in site/
  // An online HTML version (which may be of a different version of Emscripten)
  //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html
  //========================================
  // Runtime essentials
  //========================================

  var ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()

  var EXITSTATUS = 0;
  /** @type {function(*, string=)} */

  function assert(condition, text) {
    if (!condition) {
      abort('Assertion failed: ' + text);
    }
  }

  var globalScope = this; // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)

  function getCFunc(ident) {
    var func = _Module['_' + ident]; // closure exported function

    assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
    return func;
  }

  var JSfuncs = {
    // Helpers for cwrap -- it can't refer to Runtime directly because it might
    // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find
    // out what the minified function name is.
    'stackSave': function stackSave() {
      _stackSave();
    },
    'stackRestore': function stackRestore() {
      _stackRestore();
    },
    // type conversion from js to c
    'arrayToC': function arrayToC(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    },
    'stringToC': function stringToC(str) {
      var ret = 0;

      if (str !== null && str !== undefined && str !== 0) {
        // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }

      return ret;
    }
  }; // For fast lookup of conversion functions

  var toC = {
    'string': JSfuncs['stringToC'],
    'array': JSfuncs['arrayToC']
  }; // C calling interface.

  function ccall(ident, returnType, argTypes, args, opts) {
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    assert(returnType !== 'array', 'Return type should not be "array".');

    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];

        if (converter) {
          if (stack === 0) stack = _stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }

    var ret = func.apply(null, cArgs);
    if (returnType === 'string') ret = Pointer_stringify(ret);

    if (stack !== 0) {
      _stackRestore(stack);
    }

    return ret;
  }

  function cwrap(ident, returnType, argTypes) {
    argTypes = argTypes || [];
    var cfunc = getCFunc(ident); // When the function takes numbers and returns a number, we can just return
    // the original function

    var numericArgs = argTypes.every(function (type) {
      return type === 'number';
    });
    var numericRet = returnType !== 'string';

    if (numericRet && numericArgs) {
      return cfunc;
    }

    return function () {
      return ccall(ident, returnType, argTypes, arguments);
    };
  }
  /** @type {function(number, number, string, boolean=)} */


  function setValue(ptr, value, type, noSafe) {
    type = type || 'i8';
    if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit

    switch (type) {
      case 'i1':
        HEAP8[ptr >> 0] = value;
        break;

      case 'i8':
        HEAP8[ptr >> 0] = value;
        break;

      case 'i16':
        HEAP16[ptr >> 1] = value;
        break;

      case 'i32':
        HEAP32[ptr >> 2] = value;
        break;

      case 'i64':
        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
        break;

      case 'float':
        HEAPF32[ptr >> 2] = value;
        break;

      case 'double':
        HEAPF64[ptr >> 3] = value;
        break;

      default:
        abort('invalid type for setValue: ' + type);
    }
  }
  /** @type {function(number, string, boolean=)} */


  function getValue(ptr, type, noSafe) {
    type = type || 'i8';
    if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit

    switch (type) {
      case 'i1':
        return HEAP8[ptr >> 0];

      case 'i8':
        return HEAP8[ptr >> 0];

      case 'i16':
        return HEAP16[ptr >> 1];

      case 'i32':
        return HEAP32[ptr >> 2];

      case 'i64':
        return HEAP32[ptr >> 2];

      case 'float':
        return HEAPF32[ptr >> 2];

      case 'double':
        return HEAPF64[ptr >> 3];

      default:
        abort('invalid type for getValue: ' + type);
    }

    return null;
  }

  var ALLOC_NORMAL = 0; // Tries to use _malloc()

  var ALLOC_STACK = 1; // Lives for the duration of the current function call

  var ALLOC_STATIC = 2; // Cannot be freed

  var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk

  var ALLOC_NONE = 4; // Do not allocate
  // allocate(): This is for internal use. You can use it yourself as well, but the interface
  //             is a little tricky (see docs right below). The reason is that it is optimized
  //             for multiple syntaxes to save space in generated code. So you should
  //             normally not use allocate(), and instead allocate memory using _malloc(),
  //             initialize it with setValue(), and so forth.
  // @slab: An array of data, or a number. If a number, then the size of the block to allocate,
  //        in *bytes* (note that this is sometimes confusing: the next parameter does not
  //        affect this!)
  // @types: Either an array of types, one for each byte (or 0 if no type at that position),
  //         or a single type which is used for the entire block. This only matters if there
  //         is initial data - if @slab is a number, then this does not matter at all and is
  //         ignored.
  // @allocator: How to allocate memory, see ALLOC_*

  /** @type {function((TypedArray|Array<number>|number), string, number, number=)} */

  function allocate(slab, types, allocator, ptr) {
    var zeroinit, size;

    if (typeof slab === 'number') {
      zeroinit = true;
      size = slab;
    } else {
      zeroinit = false;
      size = slab.length;
    }

    var singleType = typeof types === 'string' ? types : null;
    var ret;

    if (allocator == ALLOC_NONE) {
      ret = ptr;
    } else {
      ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
    }

    if (zeroinit) {
      var stop;
      ptr = ret;
      assert((ret & 3) == 0);
      stop = ret + (size & ~3);

      for (; ptr < stop; ptr += 4) {
        HEAP32[ptr >> 2] = 0;
      }

      stop = ret + size;

      while (ptr < stop) {
        HEAP8[ptr++ >> 0] = 0;
      }

      return ret;
    }

    if (singleType === 'i8') {
      if (slab.subarray || slab.slice) {
        HEAPU8.set(
        /** @type {!Uint8Array} */
        slab, ret);
      } else {
        HEAPU8.set(new Uint8Array(slab), ret);
      }

      return ret;
    }

    var i = 0,
        type,
        typeSize,
        previousType;

    while (i < size) {
      var curr = slab[i];
      type = singleType || types[i];

      if (type === 0) {
        i++;
        continue;
      }

      assert(type, 'Must know what type to store in allocate!');
      if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

      setValue(ret + i, curr, type); // no need to look up size unless type changes, so cache it

      if (previousType !== type) {
        typeSize = getNativeTypeSize(type);
        previousType = type;
      }

      i += typeSize;
    }

    return ret;
  } // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready


  function getMemory(size) {
    if (!staticSealed) return staticAlloc(size);
    if (!runtimeInitialized) return dynamicAlloc(size);
    return _malloc(size);
  }
  /** @type {function(number, number=)} */


  function Pointer_stringify(ptr, length) {
    if (length === 0 || !ptr) return ''; // TODO: use TextDecoder
    // Find the length, and check for UTF while doing so

    var hasUtf = 0;
    var t;
    var i = 0;

    while (1) {
      assert(ptr + i < TOTAL_MEMORY);
      t = HEAPU8[ptr + i >> 0];
      hasUtf |= t;
      if (t == 0 && !length) break;
      i++;
      if (length && i == length) break;
    }

    if (!length) length = i;
    var ret = '';

    if (hasUtf < 128) {
      var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack

      var curr;

      while (length > 0) {
        curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
        ret = ret ? ret + curr : curr;
        ptr += MAX_CHUNK;
        length -= MAX_CHUNK;
      }

      return ret;
    }

    return UTF8ToString(ptr);
  } // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
  // a copy of that string as a Javascript String object.


  function AsciiToString(ptr) {
    var str = '';

    while (1) {
      var ch = HEAP8[ptr++ >> 0];
      if (!ch) return str;
      str += String.fromCharCode(ch);
    }
  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
  // null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.


  function stringToAscii(str, outPtr) {
    return writeAsciiToMemory(str, outPtr, false);
  } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
  // a copy of that string as a Javascript String object.


  var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

  function UTF8ArrayToString(u8Array, idx) {
    var endPtr = idx; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
    // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.

    while (u8Array[endPtr]) {
      ++endPtr;
    }

    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
    } else {
      var u0, u1, u2, u3, u4, u5;
      var str = '';

      while (1) {
        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
        u0 = u8Array[idx++];
        if (!u0) return str;

        if (!(u0 & 0x80)) {
          str += String.fromCharCode(u0);
          continue;
        }

        u1 = u8Array[idx++] & 63;

        if ((u0 & 0xE0) == 0xC0) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }

        u2 = u8Array[idx++] & 63;

        if ((u0 & 0xF0) == 0xE0) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u3 = u8Array[idx++] & 63;

          if ((u0 & 0xF8) == 0xF0) {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3;
          } else {
            u4 = u8Array[idx++] & 63;

            if ((u0 & 0xFC) == 0xF8) {
              u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4;
            } else {
              u5 = u8Array[idx++] & 63;
              u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5;
            }
          }
        }

        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);
        }
      }
    }
  } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns
  // a copy of that string as a Javascript String object.


  function UTF8ToString(ptr) {
    return UTF8ArrayToString(HEAPU8, ptr);
  } // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
  // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
  // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
  // Parameters:
  //   str: the Javascript string to copy.
  //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
  //   outIdx: The starting offset in the array to begin the copying.
  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
  //                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
  //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
  // Returns the number of bytes written, EXCLUDING the null terminator.


  function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.

    for (var i = 0; i < str.length; ++i) {
      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
      // See http://unicode.org/faq/utf_bom.html#utf16-3
      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
      var u = str.charCodeAt(i); // possibly a lead surrogate

      if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;

      if (u <= 0x7F) {
        if (outIdx >= endIdx) break;
        outU8Array[outIdx++] = u;
      } else if (u <= 0x7FF) {
        if (outIdx + 1 >= endIdx) break;
        outU8Array[outIdx++] = 0xC0 | u >> 6;
        outU8Array[outIdx++] = 0x80 | u & 63;
      } else if (u <= 0xFFFF) {
        if (outIdx + 2 >= endIdx) break;
        outU8Array[outIdx++] = 0xE0 | u >> 12;
        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;
        outU8Array[outIdx++] = 0x80 | u & 63;
      } else if (u <= 0x1FFFFF) {
        if (outIdx + 3 >= endIdx) break;
        outU8Array[outIdx++] = 0xF0 | u >> 18;
        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;
        outU8Array[outIdx++] = 0x80 | u & 63;
      } else if (u <= 0x3FFFFFF) {
        if (outIdx + 4 >= endIdx) break;
        outU8Array[outIdx++] = 0xF8 | u >> 24;
        outU8Array[outIdx++] = 0x80 | u >> 18 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;
        outU8Array[outIdx++] = 0x80 | u & 63;
      } else {
        if (outIdx + 5 >= endIdx) break;
        outU8Array[outIdx++] = 0xFC | u >> 30;
        outU8Array[outIdx++] = 0x80 | u >> 24 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 18 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;
        outU8Array[outIdx++] = 0x80 | u & 63;
      }
    } // Null-terminate the pointer to the buffer.


    outU8Array[outIdx] = 0;
    return outIdx - startIdx;
  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
  // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
  // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
  // Returns the number of bytes written, EXCLUDING the null terminator.


  function stringToUTF8(str, outPtr, maxBytesToWrite) {
    assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.


  function lengthBytesUTF8(str) {
    var len = 0;

    for (var i = 0; i < str.length; ++i) {
      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
      // See http://unicode.org/faq/utf_bom.html#utf16-3
      var u = str.charCodeAt(i); // possibly a lead surrogate

      if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;

      if (u <= 0x7F) {
        ++len;
      } else if (u <= 0x7FF) {
        len += 2;
      } else if (u <= 0xFFFF) {
        len += 3;
      } else if (u <= 0x1FFFFF) {
        len += 4;
      } else if (u <= 0x3FFFFFF) {
        len += 5;
      } else {
        len += 6;
      }
    }

    return len;
  } // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
  // a copy of that string as a Javascript String object.


  var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

  function UTF16ToString(ptr) {
    assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
    var endPtr = ptr; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
    // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.

    var idx = endPtr >> 1;

    while (HEAP16[idx]) {
      ++idx;
    }

    endPtr = idx << 1;

    if (endPtr - ptr > 32 && UTF16Decoder) {
      return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
    } else {
      var i = 0;
      var str = '';

      while (1) {
        var codeUnit = HEAP16[ptr + i * 2 >> 1];
        if (codeUnit == 0) return str;
        ++i; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.

        str += String.fromCharCode(codeUnit);
      }
    }
  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
  // null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
  // Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
  // Parameters:
  //   str: the Javascript string to copy.
  //   outPtr: Byte address in Emscripten HEAP where to write the string to.
  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
  //                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
  //                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
  // Returns the number of bytes written, EXCLUDING the null terminator.


  function stringToUTF16(str, outPtr, maxBytesToWrite) {
    assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
    assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.

    if (maxBytesToWrite === undefined) {
      maxBytesToWrite = 0x7FFFFFFF;
    }

    if (maxBytesToWrite < 2) return 0;
    maxBytesToWrite -= 2; // Null terminator.

    var startPtr = outPtr;
    var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;

    for (var i = 0; i < numCharsToWrite; ++i) {
      // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
      var codeUnit = str.charCodeAt(i); // possibly a lead surrogate

      HEAP16[outPtr >> 1] = codeUnit;
      outPtr += 2;
    } // Null-terminate the pointer to the HEAP.


    HEAP16[outPtr >> 1] = 0;
    return outPtr - startPtr;
  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.


  function lengthBytesUTF16(str) {
    return str.length * 2;
  }

  function UTF32ToString(ptr) {
    assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
    var i = 0;
    var str = '';

    while (1) {
      var utf32 = HEAP32[ptr + i * 4 >> 2];
      if (utf32 == 0) return str;
      ++i; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
      // See http://unicode.org/faq/utf_bom.html#utf16-3

      if (utf32 >= 0x10000) {
        var ch = utf32 - 0x10000;
        str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);
      } else {
        str += String.fromCharCode(utf32);
      }
    }
  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
  // null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
  // Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
  // Parameters:
  //   str: the Javascript string to copy.
  //   outPtr: Byte address in Emscripten HEAP where to write the string to.
  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
  //                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
  //                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
  // Returns the number of bytes written, EXCLUDING the null terminator.


  function stringToUTF32(str, outPtr, maxBytesToWrite) {
    assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
    assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.

    if (maxBytesToWrite === undefined) {
      maxBytesToWrite = 0x7FFFFFFF;
    }

    if (maxBytesToWrite < 4) return 0;
    var startPtr = outPtr;
    var endPtr = startPtr + maxBytesToWrite - 4;

    for (var i = 0; i < str.length; ++i) {
      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
      // See http://unicode.org/faq/utf_bom.html#utf16-3
      var codeUnit = str.charCodeAt(i); // possibly a lead surrogate

      if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
        var trailSurrogate = str.charCodeAt(++i);
        codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;
      }

      HEAP32[outPtr >> 2] = codeUnit;
      outPtr += 4;
      if (outPtr + 4 > endPtr) break;
    } // Null-terminate the pointer to the HEAP.


    HEAP32[outPtr >> 2] = 0;
    return outPtr - startPtr;
  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.


  function lengthBytesUTF32(str) {
    var len = 0;

    for (var i = 0; i < str.length; ++i) {
      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
      // See http://unicode.org/faq/utf_bom.html#utf16-3
      var codeUnit = str.charCodeAt(i);
      if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.

      len += 4;
    }

    return len;
  } // Allocate heap space for a JS string, and write it there.
  // It is the responsibility of the caller to free() that memory.


  function allocateUTF8(str) {
    var size = lengthBytesUTF8(str) + 1;

    var ret = _malloc(size);

    if (ret) stringToUTF8Array(str, HEAP8, ret, size);
    return ret;
  } // Allocate stack space for a JS string, and write it there.


  function allocateUTF8OnStack(str) {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8Array(str, HEAP8, ret, size);
    return ret;
  }

  function demangle(func) {
    warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
    return func;
  }

  function demangleAll(text) {
    var regex = /__Z[\w\d_]+/g;
    return text.replace(regex, function (x) {
      var y = demangle(x);
      return x === y ? x : x + ' [' + y + ']';
    });
  }

  function jsStackTrace() {
    var err = new Error();

    if (!err.stack) {
      // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
      // so try that as a special-case.
      try {
        throw new Error(0);
      } catch (e) {
        err = e;
      }

      if (!err.stack) {
        return '(no stack trace available)';
      }
    }

    return err.stack.toString();
  }

  function stackTrace() {
    var js = jsStackTrace();
    if (_Module['extraStackTrace']) js += '\n' + _Module['extraStackTrace']();
    return demangleAll(js);
  } // Memory management


  var PAGE_SIZE = 16384;
  var WASM_PAGE_SIZE = 65536;
  var ASMJS_PAGE_SIZE = 16777216;
  var MIN_TOTAL_MEMORY = 16777216;

  function alignUp(x, multiple) {
    if (x % multiple > 0) {
      x += multiple - x % multiple;
    }

    return x;
  }

  var HEAP,
  /** @type {ArrayBuffer} */
  buffer,
  /** @type {Int8Array} */
  HEAP8,
  /** @type {Uint8Array} */
  HEAPU8,
  /** @type {Int16Array} */
  HEAP16,
  /** @type {Uint16Array} */
  HEAPU16,
  /** @type {Int32Array} */
  HEAP32,
  /** @type {Uint32Array} */
  HEAPU32,
  /** @type {Float32Array} */
  HEAPF32,
  /** @type {Float64Array} */
  HEAPF64;

  function updateGlobalBuffer(buf) {
    _Module['buffer'] = buffer = buf;
  }

  function updateGlobalBufferViews() {
    _Module['HEAP8'] = HEAP8 = new Int8Array(buffer);
    _Module['HEAP16'] = HEAP16 = new Int16Array(buffer);
    _Module['HEAP32'] = HEAP32 = new Int32Array(buffer);
    _Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);
    _Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);
    _Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);
    _Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);
    _Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);
  }

  var STATIC_BASE, STATICTOP, staticSealed; // static area

  var STACK_BASE, STACKTOP, STACK_MAX; // stack area

  var DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk

  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;
  staticSealed = false; // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.

  function writeStackCookie() {
    assert((STACK_MAX & 3) == 0);
    HEAPU32[(STACK_MAX >> 2) - 1] = 0x02135467;
    HEAPU32[(STACK_MAX >> 2) - 2] = 0x89BACDFE;
  }

  function checkStackCookie() {
    if (HEAPU32[(STACK_MAX >> 2) - 1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2) - 2] != 0x89BACDFE) {
      abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2) - 2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2) - 1].toString(16));
    } // Also test the global address 0 for integrity. This check is not compatible with SAFE_SPLIT_MEMORY though, since that mode already tests all address 0 accesses on its own.


    if (HEAP32[0] !== 0x63736d65
    /* 'emsc' */
    ) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';
  }

  function abortStackOverflow(allocSize) {
    abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - _stackSave() + allocSize) + ' bytes available!');
  }

  function abortOnCannotGrowMemory() {
    abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
  }

  function enlargeMemory() {
    abortOnCannotGrowMemory();
  }

  var TOTAL_STACK = _Module['TOTAL_STACK'] || 5242880;
  var TOTAL_MEMORY = _Module['TOTAL_MEMORY'] || 16777216;
  if (TOTAL_MEMORY < TOTAL_STACK) _Module.printErr('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); // Initialize the runtime's memory
  // check for full engine support (use string 'subarray' to avoid closure compiler confusion)

  assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, 'JS engine does not provide full typed array support'); // Use a provided buffer, if there is one, or else allocate a new one

  if (_Module['buffer']) {
    buffer = _Module['buffer'];
    assert(buffer.byteLength === TOTAL_MEMORY, 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);
  } else {
    // Use a WebAssembly memory where available
    if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) === 'object' && typeof WebAssembly.Memory === 'function') {
      assert(TOTAL_MEMORY % WASM_PAGE_SIZE === 0);
      _Module['wasmMemory'] = new WebAssembly.Memory({
        'initial': TOTAL_MEMORY / WASM_PAGE_SIZE,
        'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE
      });
      buffer = _Module['wasmMemory'].buffer;
    } else {
      buffer = new ArrayBuffer(TOTAL_MEMORY);
    }

    assert(buffer.byteLength === TOTAL_MEMORY);
    _Module['buffer'] = buffer;
  }

  updateGlobalBufferViews();

  function getTotalMemory() {
    return TOTAL_MEMORY;
  } // Endianness check (note: assumes compiler arch was little-endian)


  HEAP32[0] = 0x63736d65;
  /* 'emsc' */

  HEAP16[1] = 0x6373;
  if (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';

  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      var callback = callbacks.shift();

      if (typeof callback == 'function') {
        callback();
        continue;
      }

      var func = callback.func;

      if (typeof func === 'number') {
        if (callback.arg === undefined) {
          _Module['dynCall_v'](func);
        } else {
          _Module['dynCall_vi'](func, callback.arg);
        }
      } else {
        func(callback.arg === undefined ? null : callback.arg);
      }
    }
  }

  var __ATPRERUN__ = []; // functions called before the runtime is initialized

  var __ATINIT__ = []; // functions called during startup

  var __ATMAIN__ = []; // functions called when main() is to be run

  var __ATEXIT__ = []; // functions called during shutdown

  var __ATPOSTRUN__ = []; // functions called after the runtime has exited

  var runtimeInitialized = false;
  var runtimeExited = false;

  function preRun() {
    // compatibility - merge in anything from Module['preRun'] at this time
    if (_Module['preRun']) {
      if (typeof _Module['preRun'] == 'function') _Module['preRun'] = [_Module['preRun']];

      while (_Module['preRun'].length) {
        addOnPreRun(_Module['preRun'].shift());
      }
    }

    callRuntimeCallbacks(__ATPRERUN__);
  }

  function ensureInitRuntime() {
    checkStackCookie();
    if (runtimeInitialized) return;
    runtimeInitialized = true;
    callRuntimeCallbacks(__ATINIT__);
  }

  function preMain() {
    checkStackCookie();
    callRuntimeCallbacks(__ATMAIN__);
  }

  function exitRuntime() {
    checkStackCookie();
    callRuntimeCallbacks(__ATEXIT__);
    runtimeExited = true;
  }

  function postRun() {
    checkStackCookie(); // compatibility - merge in anything from Module['postRun'] at this time

    if (_Module['postRun']) {
      if (typeof _Module['postRun'] == 'function') _Module['postRun'] = [_Module['postRun']];

      while (_Module['postRun'].length) {
        addOnPostRun(_Module['postRun'].shift());
      }
    }

    callRuntimeCallbacks(__ATPOSTRUN__);
  }

  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }

  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }

  function addOnPreMain(cb) {
    __ATMAIN__.unshift(cb);
  }

  function addOnExit(cb) {
    __ATEXIT__.unshift(cb);
  }

  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  } // Deprecated: This function should not be called because it is unsafe and does not provide
  // a maximum length limit of how many bytes it is allowed to write. Prefer calling the
  // function stringToUTF8Array() instead, which takes in a maximum length that can be used
  // to be secure from out of bounds writes.

  /** @deprecated */


  function writeStringToMemory(string, buffer, dontAddNull) {
    warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');
    var
    /** @type {number} */
    lastChar,
    /** @type {number} */
    end;

    if (dontAddNull) {
      // stringToUTF8Array always appends null. If we don't want to do that, remember the
      // character that existed at the location where the null will be placed, and restore
      // that after the write (below).
      end = buffer + lengthBytesUTF8(string);
      lastChar = HEAP8[end];
    }

    stringToUTF8(string, buffer, Infinity);
    if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
  }

  function writeArrayToMemory(array, buffer) {
    assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');
    HEAP8.set(array, buffer);
  }

  function writeAsciiToMemory(str, buffer, dontAddNull) {
    for (var i = 0; i < str.length; ++i) {
      assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
    } // Null-terminate the pointer to the HEAP.


    if (!dontAddNull) HEAP8[buffer >> 0] = 0;
  }

  function unSign(value, bits, ignore) {
    if (value >= 0) {
      return value;
    }

    return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
    : Math.pow(2, bits) + value;
  }

  function reSign(value, bits, ignore) {
    if (value <= 0) {
      return value;
    }

    var half = bits <= 32 ? Math.abs(1 << bits - 1) // abs is needed if bits == 32
    : Math.pow(2, bits - 1);

    if (value >= half && (bits <= 32 || value > half)) {
      // for huge values, we can hit the precision limit and always get true here. so don't do that
      // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
      // TODO: In i64 mode 1, resign the two parts separately and safely
      value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
    }

    return value;
  }

  assert(Math['imul'] && Math['fround'] && Math['clz32'] && Math['trunc'], 'this is a legacy browser, build with LEGACY_VM_SUPPORT');
  var Math_abs = Math.abs;
  var Math_cos = Math.cos;
  var Math_sin = Math.sin;
  var Math_tan = Math.tan;
  var Math_acos = Math.acos;
  var Math_asin = Math.asin;
  var Math_atan = Math.atan;
  var Math_atan2 = Math.atan2;
  var Math_exp = Math.exp;
  var Math_log = Math.log;
  var Math_sqrt = Math.sqrt;
  var Math_ceil = Math.ceil;
  var Math_floor = Math.floor;
  var Math_pow = Math.pow;
  var Math_imul = Math.imul;
  var Math_fround = Math.fround;
  var Math_round = Math.round;
  var Math_min = Math.min;
  var Math_max = Math.max;
  var Math_clz32 = Math.clz32;
  var Math_trunc = Math.trunc; // A counter of dependencies for calling run(). If we need to
  // do asynchronous work before running, increment this and
  // decrement it. Incrementing must happen in a place like
  // PRE_RUN_ADDITIONS (used by emcc to add file preloading).
  // Note that you can add dependencies in preRun, even though
  // it happens right before run - run will be postponed until
  // the dependencies are met.

  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

  var runDependencyTracking = {};

  function getUniqueRunDependency(id) {
    var orig = id;

    while (1) {
      if (!runDependencyTracking[id]) return id;
      id = orig + Math.random();
    }

    return id;
  }

  function addRunDependency(id) {
    runDependencies++;

    if (_Module['monitorRunDependencies']) {
      _Module['monitorRunDependencies'](runDependencies);
    }

    if (id) {
      assert(!runDependencyTracking[id]);
      runDependencyTracking[id] = 1;

      if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
        // Check for missing dependencies every few seconds
        runDependencyWatcher = setInterval(function () {
          if (ABORT) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
            return;
          }

          var shown = false;

          for (var dep in runDependencyTracking) {
            if (!shown) {
              shown = true;

              _Module.printErr('still waiting on run dependencies:');
            }

            _Module.printErr('dependency: ' + dep);
          }

          if (shown) {
            _Module.printErr('(end of list)');
          }
        }, 10000);
      }
    } else {
      _Module.printErr('warning: run dependency added without ID');
    }
  }

  function removeRunDependency(id) {
    runDependencies--;

    if (_Module['monitorRunDependencies']) {
      _Module['monitorRunDependencies'](runDependencies);
    }

    if (id) {
      assert(runDependencyTracking[id]);
      delete runDependencyTracking[id];
    } else {
      _Module.printErr('warning: run dependency removed without ID');
    }

    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }

      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback(); // can add another dependenciesFulfilled
      }
    }
  }

  _Module["preloadedImages"] = {}; // maps url to image data

  _Module["preloadedAudios"] = {}; // maps url to audio data

  var memoryInitializer = null;
  var
  /* show errors on likely calls to FS when it was not included */
  FS = {
    error: function error() {
      abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');
    },
    init: function init() {
      FS.error();
    },
    createDataFile: function createDataFile() {
      FS.error();
    },
    createPreloadedFile: function createPreloadedFile() {
      FS.error();
    },
    createLazyFile: function createLazyFile() {
      FS.error();
    },
    open: function open() {
      FS.error();
    },
    mkdev: function mkdev() {
      FS.error();
    },
    registerDevice: function registerDevice() {
      FS.error();
    },
    analyzePath: function analyzePath() {
      FS.error();
    },
    loadFilesFromDB: function loadFilesFromDB() {
      FS.error();
    },
    ErrnoError: function ErrnoError() {
      FS.error();
    }
  };
  _Module['FS_createDataFile'] = FS.createDataFile;
  _Module['FS_createPreloadedFile'] = FS.createPreloadedFile; // Prefix of data URIs emitted by SINGLE_FILE and related options.

  var dataURIPrefix = 'data:application/octet-stream;base64,'; // Indicates whether filename is a base64 data URI.

  function isDataURI(filename) {
    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
  }

  function integrateWasmJS() {
    // wasm.js has several methods for creating the compiled code module here:
    //  * 'native-wasm' : use native WebAssembly support in the browser
    //  * 'interpret-s-expr': load s-expression code from a .wast and interpret
    //  * 'interpret-binary': load binary wasm and interpret
    //  * 'interpret-asm2wasm': load asm.js code, translate to wasm, and interpret
    //  * 'asmjs': no wasm, just load the asm.js code and use that (good for testing)
    // The method is set at compile time (BINARYEN_METHOD)
    // The method can be a comma-separated list, in which case, we will try the
    // options one by one. Some of them can fail gracefully, and then we can try
    // the next.
    // inputs
    var method = 'native-wasm';
    var wasmTextFile = '';
    var wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAABchJgA39/fwF/YAF/AX9gAAF/YAF/AGACf38Bf2AEf39/fwF/YAJ/fwBgA39/fwBgBH9/f38AYAN/f38BfmAAAGAFf39/f38Bf2ADfn9/AX9gAn5/AX9gBX9/f39/AGAGf3x/f39/AX9gAXwBfmACfH8BfAKXBSEDZW52Bm1lbW9yeQIBgAKAAgNlbnYFdGFibGUBcAEQEANlbnYKbWVtb3J5QmFzZQN/AANlbnYJdGFibGVCYXNlA38AA2Vudg5EWU5BTUlDVE9QX1BUUgN/AANlbnYNdGVtcERvdWJsZVB0cgN/AANlbnYFQUJPUlQDfwADZW52CFNUQUNLVE9QA38AA2VudglTVEFDS19NQVgDfwADZW52B2N0dHpfaTgDfwAGZ2xvYmFsA05hTgN8AAZnbG9iYWwISW5maW5pdHkDfAADZW52DWVubGFyZ2VNZW1vcnkAAgNlbnYOZ2V0VG90YWxNZW1vcnkAAgNlbnYXYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkAAgNlbnYSYWJvcnRTdGFja092ZXJmbG93AAMDZW52C251bGxGdW5jX2lpAAMDZW52DW51bGxGdW5jX2lpaWkAAwNlbnYHX19fbG9jawADA2VudgtfX19zZXRFcnJObwADA2Vudg1fX19zeXNjYWxsMTQwAAQDZW52DV9fX3N5c2NhbGwxNDYABANlbnYMX19fc3lzY2FsbDU0AAQDZW52C19fX3N5c2NhbGw2AAQDZW52CV9fX3VubG9jawADA2VudiFfZW1zY3JpcHRlbl9oYXNfdGhyZWFkaW5nX3N1cHBvcnQAAgNlbnYWX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZwAAA2VudhJfbGx2bV9zdGFja3Jlc3RvcmUAAwNlbnYPX2xsdm1fc3RhY2tzYXZlAAIDZW52D19wdGhyZWFkX2NyZWF0ZQAFA2Vudg1fcHRocmVhZF9qb2luAAQDZW52E19wdGhyZWFkX211dGV4X2luaXQABANlbnYIX3N5c2NvbmYAAQNSUQECAwYGAwIEAwcDCAcBCAAICQQACgYBAwEAAAECAQAEAAsBAwcBBwwNDQEADgQPEBERAAICAgQEBAAEAAEEAQQEAgoBAQAKAQAAAQEBBAUBAAZyFH8BIwILfwEjAwt/ASMEC38BIwULfwEj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IQQgBA8L9BEDC38EfgV8Iw0hDCAAvSEPIA9CNIghECAQp0H//wNxIQkgCUH/D3EhCgJAAkACQAJAIApBEHRBEHVBAGsOgBAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAQILAkAgAEQAAAAAAAAAAGIhBCAEBEAgAEQAAAAAAADwQ6IhFCAUIAEQRiEVIAEoAgAhBSAFQUBqIQYgFSESIAYhCAUgACESQQAhCAsgASAINgIAIBIhEQwDAAsACwJAIAAhEQwCAAsACwJAIBCnIQcgB0H/D3EhAiACQYJ4aiEDIAEgAzYCACAPQv////////+HgH+DIQ0gDUKAgICAgICA8D+EIQ4gDr8hEyATIRELCyARDwvkBAE7fyMNIT0gAEEARiEYAkAgGARAQQEhAwUgAUGAAUkhIyAjBEAgAUH/AXEhLiAAIC46AABBASEDDAILEEghNyA3QbwBaiE4IDgoAgAhOSA5KAIAITogOkEARiEEIAQEQCABQYB/cSEFIAVBgL8DRiEGIAYEQCABQf8BcSEIIAAgCDoAAEEBIQMMAwUQMSEHIAdB1AA2AgBBfyEDDAMLAAsgAUGAEEkhCSAJBEAgAUEGdiEKIApBwAFyIQsgC0H/AXEhDCAAQQFqIQ0gACAMOgAAIAFBP3EhDiAOQYABciEPIA9B/wFxIRAgDSAQOgAAQQIhAwwCCyABQYCwA0khESABQYBAcSESIBJBgMADRiETIBEgE3IhOyA7BEAgAUEMdiEUIBRB4AFyIRUgFUH/AXEhFiAAQQFqIRcgACAWOgAAIAFBBnYhGSAZQT9xIRogGkGAAXIhGyAbQf8BcSEcIABBAmohHSAXIBw6AAAgAUE/cSEeIB5BgAFyIR8gH0H/AXEhICAdICA6AABBAyED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ADYCACAPQQA2AgAgAkEANgIAIAVBADYCACADQQA2AgBBACEBCyABDws3AQR/Iw0hBiMNQRBqJA0jDSMOTgRAQRAQAwsgBiEDIAMgAjYCACAAIAEgAxA1IQQgBiQNIAQPCwMAAQssACAAQf8BcUEYdCAAQQh1Qf8BcUEQdHIgAEEQdUH/AXFBCHRyIABBGHZyDwvkBAEEfyACQYDAAE4EQCAAIAEgAhAODwsgACEDIAAgAmohBiAAQQNxIAFBA3FGBEADQAJAIABBA3FFBEAMAQsCQCACQQBGBEAgAw8LIAAgASwAADoAACAAQQFqIQAgAUEBaiEBIAJBAWshAgsMAQsLIAZBfHEhBCAEQcAAayEFA0ACQCAAIAVMRQRADAELAkAgACABKAIANgIAIABBBGogAUEEaigCADYCACAAQQhqIAFBCGooAgA2AgAgAEEMaiABQQxqKAIANgIAIABBEGogAUEQaigCADYCACAAQRRqIAFBFGooAgA2AgAgAEEYaiABQRhqKAIANgIAIABBHGogAUEcaigCADYCACAAQSBqIAFBIGooAgA2AgAgAEEkaiABQSRqKAIANgIAIABBKGogAUEoaigCADYCACAAQSxqIAFBLGooAgA2AgAgAEEwaiABQTBqKAIANgIAIABBNGogAUE0aigCADYCACAAQThqIAFBOGooAgA2AgAgAEE8aiABQTxqKAIANgIAIABBwABqIQAgAUHAAGohAQsMAQsLA0ACQCAAIARIRQRADAELAkAgACABKAIANgIAIABBBGohACABQQRqIQELDAELCwUgBkEEayEEA0ACQCAAIARIRQRADAELAkAgACABLAAAOgAAIABBAWogAUEBaiwAADoAACAAQQJqIAFBAmosAAA6AAAgAEEDaiABQQNqLAAAOgAAIABBBGohACABQQRqIQELDAELCwsDQAJAIAAgBkhFBEAMAQsCQCAAIAEsAAA6AAAgAEEBaiEAIAFBAWohAQsMAQsLIAMPC/ECAQR/IAAgAmohAyABQf8BcSEBIAJBwwBOBEADQAJAIABBA3FBAEdFBEAMAQsCQCAAIAE6AAAgAEEBaiEACwwBCwsgA0F8cSEEIARBwABrIQUgASABQQh0ciABQRB0ciABQRh0ciEGA0ACQCAAIAVMRQRADAELAkAgACAGNgIAIABBBGogBjYCACAA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ExQVGggWBygkFxgJCg4bHyUjg4J9JiorPD0+P0NHSk1YWVpbXF1eX2BhY2RlZmdpamtscnN0eXp7fABJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBObyBlcnJvciBpbmZvcm1hdGlvbg==';
    var asmjsCodeFile = '';

    if (typeof _Module['locateFile'] === 'function') {
      if (!isDataURI(wasmTextFile)) {
        wasmTextFile = _Module['locateFile'](wasmTextFile);
      }

      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = _Module['locateFile'](wasmBinaryFile);
      }

      if (!isDataURI(asmjsCodeFile)) {
        asmjsCodeFile = _Module['locateFile'](asmjsCodeFile);
      }
    } // utilities


    var wasmPageSize = 64 * 1024;
    var info = {
      'global': null,
      'env': null,
      'asm2wasm': {
        // special asm2wasm imports
        "f64-rem": function f64Rem(x, y) {
          return x % y;
        },
        "debugger": function _debugger() {
          debugger;
        }
      },
      'parent': _Module // Module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.

    };
    var exports = null;

    function mergeMemory(newBuffer) {
      // The wasm instance creates its memory. But static init code might have written to
      // buffer already, including the mem init file, and we must copy it over in a proper merge.
      // TODO: avoid this copy, by avoiding such static init writes
      // TODO: in shorter term, just copy up to the last static init write
      var oldBuffer = _Module['buffer'];

      if (newBuffer.byteLength < oldBuffer.byteLength) {
        _Module['printErr']('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here');
      }

      var oldView = new Int8Array(oldBuffer);
      var newView = new Int8Array(newBuffer);
      newView.set(oldView);
      updateGlobalBuffer(newBuffer);
      updateGlobalBufferViews();
    }

    function fixImports(imports) {
      return imports;
    }

    function getBinary() {
      try {
        if (_Module['wasmBinary']) {
          return new Uint8Array(_Module['wasmBinary']);
        }

        var binary = tryParseAsDataURI(wasmBinaryFile);

        if (binary) {
          return binary;
        }

        if (_Module['readBinary']) {
          return _Module['readBinary'](wasmBinaryFile);
        } else {
          throw "on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)";
        }
      } catch (err) {
        abort(err);
      }
    }

    function getBinaryPromise() {
      // if we don't have the binary yet, and have the Fetch api, use that
      // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web
      if (!_Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {
        return fetch(wasmBinaryFile, {
          credentials: 'same-origin'
        }).then(function (response) {
          if (!response['ok']) {
            throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
          }

          return response['arrayBuffer']();
        }).catch(function () {
          return getBinary();
        });
      } // Otherwise, getBinary should be able to get it synchronously


      return new Promise(function (resolve, reject) {
        resolve(getBinary());
      });
    } // do-method functions


    function doNativeWasm(global, env, providedBuffer) {
      if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) !== 'object') {
        _Module['printErr']('no native wasm support detected');

        return false;
      } // prepare memory import


      if (!(_Module['wasmMemory'] instanceof WebAssembly.Memory)) {
        _Module['printErr']('no native wasm Memory in use');

        return false;
      }

      env['memory'] = _Module['wasmMemory']; // Load the wasm module and create an instance of using native support in the JS engine.

      info['global'] = {
        'NaN': NaN,
        'Infinity': Infinity
      };
      info['global.Math'] = Math;
      info['env'] = env; // handle a generated wasm instance, receiving its exports and
      // performing other necessary setup

      function receiveInstance(instance, module) {
        exports = instance.exports;
        if (exports.memory) mergeMemory(exports.memory);
        _Module['asm'] = exports;
        _Module["usingWasm"] = true;
        removeRunDependency('wasm-instantiate');
      }

      addRunDependency('wasm-instantiate'); // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
      // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
      // to any other async startup actions they are performing.

      if (_Module['instantiateWasm']) {
        try {
          return _Module['instantiateWasm'](info, receiveInstance);
        } catch (e) {
          _Module['printErr']('Module.instantiateWasm callback failed with error: ' + e);

          return false;
        }
      } // Async compilation can be confusing when an error on the page overwrites Module
      // (for example, if the order of elements is wrong, and the one defining Module is
      // later), so we save Module and check it later.


      var trueModule = _Module;

      function receiveInstantiatedSource(output) {
        // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
        // receiveInstance() will swap in the exports (to Module.asm) so they can be called
        assert(_Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
        trueModule = null;
        receiveInstance(output['instance'], output['module']);
      }

      function instantiateArrayBuffer(receiver) {
        getBinaryPromise().then(function (binary) {
          return WebAssembly.instantiate(binary, info);
        }).then(receiver).catch(function (reason) {
          _Module['printErr']('failed to asynchronously prepare wasm: ' + reason);

          abort(reason);
        });
      } // Prefer streaming instantiation if available.


      if (!_Module['wasmBinary'] && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') {
        WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {
          credentials: 'same-origin'
        }), info).then(receiveInstantiatedSource).catch(function (reason) {
          // We expect the most common failure cause to be a bad MIME type for the binary,
          // in which case falling back to ArrayBuffer instantiation should work.
          _Module['printErr']('wasm streaming compile failed: ' + reason);

          _Module['printErr']('falling back to ArrayBuffer instantiation');

          instantiateArrayBuffer(receiveInstantiatedSource);
        });
      } else {
        instantiateArrayBuffer(receiveInstantiatedSource);
      }

      return {}; // no exports yet; we'll fill them in later
    } // We may have a preloaded value in Module.asm, save it


    _Module['asmPreload'] = _Module['asm']; // Memory growth integration code

    var asmjsReallocBuffer = _Module['reallocBuffer'];

    var wasmReallocBuffer = function wasmReallocBuffer(size) {
      var PAGE_MULTIPLE = _Module["usingWasm"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.

      size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size

      var old = _Module['buffer'];
      var oldSize = old.byteLength;

      if (_Module["usingWasm"]) {
        // native wasm support
        try {
          var result = _Module['wasmMemory'].grow((size - oldSize) / wasmPageSize); // .grow() takes a delta compared to the previous size


          if (result !== (-1 | 0)) {
            // success in native wasm memory growth, get the buffer from the memory
            return _Module['buffer'] = _Module['wasmMemory'].buffer;
          } else {
            return null;
          }
        } catch (e) {
          console.error('Module.reallocBuffer: Attempted to grow from ' + oldSize + ' bytes to ' + size + ' bytes, but got error: ' + e);
          return null;
        }
      }
    };

    _Module['reallocBuffer'] = function (size) {
      if (finalMethod === 'asmjs') {
        return asmjsReallocBuffer(size);
      } else {
        return wasmReallocBuffer(size);
      }
    }; // we may try more than one; this is the final one, that worked and we are using


    var finalMethod = ''; // Provide an "asm.js function" for the application, called to "link" the asm.js module. We instantiate
    // the wasm module at that time, and it receives imports and provides exports and so forth, the app
    // doesn't need to care that it is wasm or olyfilled wasm or asm.js.

    _Module['asm'] = function (global, env, providedBuffer) {
      env = fixImports(env); // import table

      if (!env['table']) {
        var TABLE_SIZE = _Module['wasmTableSize'];
        if (TABLE_SIZE === undefined) TABLE_SIZE = 1024; // works in binaryen interpreter at least

        var MAX_TABLE_SIZE = _Module['wasmMaxTableSize'];

        if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) === 'object' && typeof WebAssembly.Table === 'function') {
          if (MAX_TABLE_SIZE !== undefined) {
            env['table'] = new WebAssembly.Table({
              'initial': TABLE_SIZE,
              'maximum': MAX_TABLE_SIZE,
              'element': 'anyfunc'
            });
          } else {
            env['table'] = new WebAssembly.Table({
              'initial': TABLE_SIZE,
              element: 'anyfunc'
            });
          }
        } else {
          env['table'] = new Array(TABLE_SIZE); // works in binaryen interpreter at least
        }

        _Module['wasmTable'] = env['table'];
      }

      if (!env['memoryBase']) {
        env['memoryBase'] = _Module['STATIC_BASE']; // tell the memory segments where to place themselves
      }

      if (!env['tableBase']) {
        env['tableBase'] = 0; // table starts at 0 by default, in dynamic linking this will change
      } // try the methods. each should return the exports if it succeeded


      var exports;
      exports = doNativeWasm(global, env, providedBuffer);
      if (!exports) abort('no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods');
      return exports;
    };

    var methodHandler = _Module['asm']; // note our method handler, as we may modify Module['asm'] later
  }

  integrateWasmJS(); // === Body ===

  var ASM_CONSTS = [];
  STATIC_BASE = GLOBAL_BASE;
  STATICTOP = STATIC_BASE + 9888;
  /* global initializers */

  __ATINIT__.push();

  var STATIC_BUMP = 9888;
  _Module["STATIC_BASE"] = STATIC_BASE;
  _Module["STATIC_BUMP"] = STATIC_BUMP;
  /* no memory initializer */

  var tempDoublePtr = STATICTOP;
  STATICTOP += 16;
  assert(tempDoublePtr % 8 == 0);

  function copyTempFloat(ptr) {
    // functions, because inlining this code increases code size too much
    HEAP8[tempDoublePtr] = HEAP8[ptr];
    HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];
    HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];
    HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];
  }

  function copyTempDouble(ptr) {
    HEAP8[tempDoublePtr] = HEAP8[ptr];
    HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];
    HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];
    HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];
    HEAP8[tempDoublePtr + 4] = HEAP8[ptr + 4];
    HEAP8[tempDoublePtr + 5] = HEAP8[ptr + 5];
    HEAP8[tempDoublePtr + 6] = HEAP8[ptr + 6];
    HEAP8[tempDoublePtr + 7] = HEAP8[ptr + 7];
  } // {{PRE_LIBRARY}}


  function ___lock() {}

  var SYSCALLS = {
    varargs: 0,
    get: function get(varargs) {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr: function getStr() {
      var ret = Pointer_stringify(SYSCALLS.get());
      return ret;
    },
    get64: function get64() {
      var low = SYSCALLS.get(),
          high = SYSCALLS.get();
      if (low >= 0) assert(high === 0);else assert(high === -1);
      return low;
    },
    getZero: function getZero() {
      assert(SYSCALLS.get() === 0);
    }
  };

  function ___syscall140(which, varargs) {
    SYSCALLS.varargs = varargs;

    try {
      // llseek
      var stream = SYSCALLS.getStreamFromFD(),
          offset_high = SYSCALLS.get(),
          offset_low = SYSCALLS.get(),
          result = SYSCALLS.get(),
          whence = SYSCALLS.get(); // NOTE: offset_high is unused - Emscripten's off_t is 32-bit

      var offset = offset_low;
      FS.llseek(stream, offset, whence);
      HEAP32[result >> 2] = stream.position;
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state

      return 0;
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
  }

  function flush_NO_FILESYSTEM() {
    // flush anything remaining in the buffers during shutdown
    var fflush = _Module["_fflush"];
    if (fflush) fflush(0);
    var printChar = ___syscall146.printChar;
    if (!printChar) return;
    var buffers = ___syscall146.buffers;
    if (buffers[1].length) printChar(1, 10);
    if (buffers[2].length) printChar(2, 10);
  }

  function ___syscall146(which, varargs) {
    SYSCALLS.varargs = varargs;

    try {
      // writev
      // hack to support printf in NO_FILESYSTEM
      var stream = SYSCALLS.get(),
          iov = SYSCALLS.get(),
          iovcnt = SYSCALLS.get();
      var ret = 0;

      if (!___syscall146.buffers) {
        ___syscall146.buffers = [null, [], []]; // 1 => stdout, 2 => stderr

        ___syscall146.printChar = function (stream, curr) {
          var buffer = ___syscall146.buffers[stream];
          assert(buffer);

          if (curr === 0 || curr === 10) {
            (stream === 1 ? _Module['print'] : _Module['printErr'])(UTF8ArrayToString(buffer, 0));
            buffer.length = 0;
          } else {
            buffer.push(curr);
          }
        };
      }

      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAP32[iov + i * 8 >> 2];
        var len = HEAP32[iov + (i * 8 + 4) >> 2];

        for (var j = 0; j < len; j++) {
          ___syscall146.printChar(stream, HEAPU8[ptr + j]);
        }

        ret += len;
      }

      return ret;
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
  }

  function ___syscall54(which, varargs) {
    SYSCALLS.varargs = varargs;

    try {
      // ioctl
      return 0;
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
  }

  function ___syscall6(which, varargs) {
    SYSCALLS.varargs = varargs;

    try {
      // close
      var stream = SYSCALLS.getStreamFromFD();
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
  }

  function ___unlock() {}

  function _emscripten_has_threading_support() {
    return 0;
  }

  var cttz_i8 = allocate([8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0], "i8", ALLOC_STATIC);

  function _llvm_cttz_i32(x) {
    x = x | 0;
    var ret = 0;
    ret = HEAP8[cttz_i8 + (x & 0xff) >> 0] | 0;
    if ((ret | 0) < 8) return ret | 0;
    ret = HEAP8[cttz_i8 + (x >> 8 & 0xff) >> 0] | 0;
    if ((ret | 0) < 8) return ret + 8 | 0;
    ret = HEAP8[cttz_i8 + (x >> 16 & 0xff) >> 0] | 0;
    if ((ret | 0) < 8) return ret + 16 | 0;
    return (HEAP8[cttz_i8 + (x >>> 24) >> 0] | 0) + 24 | 0;
  }

  function _llvm_cttz_i64(l, h) {
    var ret = _llvm_cttz_i32(l);

    if (ret == 32) ret += _llvm_cttz_i32(h);
    return (setTempRet0(0), ret) | 0;
  }

  function _llvm_stackrestore(p) {
    var self = _llvm_stacksave;
    var ret = self.LLVM_SAVEDSTACKS[p];
    self.LLVM_SAVEDSTACKS.splice(p, 1);

    _stackRestore(ret);
  }

  function _llvm_stacksave() {
    var self = _llvm_stacksave;

    if (!self.LLVM_SAVEDSTACKS) {
      self.LLVM_SAVEDSTACKS = [];
    }

    self.LLVM_SAVEDSTACKS.push(_stackSave());
    return self.LLVM_SAVEDSTACKS.length - 1;
  }

  function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
    return dest;
  }

  function _pthread_create() {
    return 11;
  }

  function _pthread_join() {}

  function _pthread_mutex_init() {}

  function ___setErrNo(value) {
    if (_Module['___errno_location']) HEAP32[_Module['___errno_location']() >> 2] = value;else _Module.printErr('failed to set errno from JS');
    return value;
  }

  var ERRNO_CODES = {
    EPERM: 1,
    ENOENT: 2,
    ESRCH: 3,
    EINTR: 4,
    EIO: 5,
    ENXIO: 6,
    E2BIG: 7,
    ENOEXEC: 8,
    EBADF: 9,
    ECHILD: 10,
    EAGAIN: 11,
    EWOULDBLOCK: 11,
    ENOMEM: 12,
    EACCES: 13,
    EFAULT: 14,
    ENOTBLK: 15,
    EBUSY: 16,
    EEXIST: 17,
    EXDEV: 18,
    ENODEV: 19,
    ENOTDIR: 20,
    EISDIR: 21,
    EINVAL: 22,
    ENFILE: 23,
    EMFILE: 24,
    ENOTTY: 25,
    ETXTBSY: 26,
    EFBIG: 27,
    ENOSPC: 28,
    ESPIPE: 29,
    EROFS: 30,
    EMLINK: 31,
    EPIPE: 32,
    EDOM: 33,
    ERANGE: 34,
    ENOMSG: 42,
    EIDRM: 43,
    ECHRNG: 44,
    EL2NSYNC: 45,
    EL3HLT: 46,
    EL3RST: 47,
    ELNRNG: 48,
    EUNATCH: 49,
    ENOCSI: 50,
    EL2HLT: 51,
    EDEADLK: 35,
    ENOLCK: 37,
    EBADE: 52,
    EBADR: 53,
    EXFULL: 54,
    ENOANO: 55,
    EBADRQC: 56,
    EBADSLT: 57,
    EDEADLOCK: 35,
    EBFONT: 59,
    ENOSTR: 60,
    ENODATA: 61,
    ETIME: 62,
    ENOSR: 63,
    ENONET: 64,
    ENOPKG: 65,
    EREMOTE: 66,
    ENOLINK: 67,
    EADV: 68,
    ESRMNT: 69,
    ECOMM: 70,
    EPROTO: 71,
    EMULTIHOP: 72,
    EDOTDOT: 73,
    EBADMSG: 74,
    ENOTUNIQ: 76,
    EBADFD: 77,
    EREMCHG: 78,
    ELIBACC: 79,
    ELIBBAD: 80,
    ELIBSCN: 81,
    ELIBMAX: 82,
    ELIBEXEC: 83,
    ENOSYS: 38,
    ENOTEMPTY: 39,
    ENAMETOOLONG: 36,
    ELOOP: 40,
    EOPNOTSUPP: 95,
    EPFNOSUPPORT: 96,
    ECONNRESET: 104,
    ENOBUFS: 105,
    EAFNOSUPPORT: 97,
    EPROTOTYPE: 91,
    ENOTSOCK: 88,
    ENOPROTOOPT: 92,
    ESHUTDOWN: 108,
    ECONNREFUSED: 111,
    EADDRINUSE: 98,
    ECONNABORTED: 103,
    ENETUNREACH: 101,
    ENETDOWN: 100,
    ETIMEDOUT: 110,
    EHOSTDOWN: 112,
    EHOSTUNREACH: 113,
    EINPROGRESS: 115,
    EALREADY: 114,
    EDESTADDRREQ: 89,
    EMSGSIZE: 90,
    EPROTONOSUPPORT: 93,
    ESOCKTNOSUPPORT: 94,
    EADDRNOTAVAIL: 99,
    ENETRESET: 102,
    EISCONN: 106,
    ENOTCONN: 107,
    ETOOMANYREFS: 109,
    EUSERS: 87,
    EDQUOT: 122,
    ESTALE: 116,
    ENOTSUP: 95,
    ENOMEDIUM: 123,
    EILSEQ: 84,
    EOVERFLOW: 75,
    ECANCELED: 125,
    ENOTRECOVERABLE: 131,
    EOWNERDEAD: 130,
    ESTRPIPE: 86
  };

  function _sysconf(name) {
    // long sysconf(int name);
    // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
    switch (name) {
      case 30:
        return PAGE_SIZE;

      case 85:
        var maxHeapSize = 2 * 1024 * 1024 * 1024 - 65536;
        maxHeapSize = HEAPU8.length;
        return maxHeapSize / PAGE_SIZE;

      case 132:
      case 133:
      case 12:
      case 137:
      case 138:
      case 15:
      case 235:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 149:
      case 13:
      case 10:
      case 236:
      case 153:
      case 9:
      case 21:
      case 22:
      case 159:
      case 154:
      case 14:
      case 77:
      case 78:
      case 139:
      case 80:
      case 81:
      case 82:
      case 68:
      case 67:
      case 164:
      case 11:
      case 29:
      case 47:
      case 48:
      case 95:
      case 52:
      case 51:
      case 46:
        return 200809;

      case 79:
        return 0;

      case 27:
      case 246:
      case 127:
      case 128:
      case 23:
      case 24:
      case 160:
      case 161:
      case 181:
      case 182:
      case 242:
      case 183:
      case 184:
      case 243:
      case 244:
      case 245:
      case 165:
      case 178:
      case 179:
      case 49:
      case 50:
      case 168:
      case 169:
      case 175:
      case 170:
      case 171:
      case 172:
      case 97:
      case 76:
      case 32:
      case 173:
      case 35:
        return -1;

      case 176:
      case 177:
      case 7:
      case 155:
      case 8:
      case 157:
      case 125:
      case 126:
      case 92:
      case 93:
      case 129:
      case 130:
      case 131:
      case 94:
      case 91:
        return 1;

      case 74:
      case 60:
      case 69:
      case 70:
      case 4:
        return 1024;

      case 31:
      case 42:
      case 72:
        return 32;

      case 87:
      case 26:
      case 33:
        return 2147483647;

      case 34:
      case 1:
        return 47839;

      case 38:
      case 36:
        return 99;

      case 43:
      case 37:
        return 2048;

      case 0:
        return 2097152;

      case 3:
        return 65536;

      case 28:
        return 32768;

      case 44:
        return 32767;

      case 75:
        return 16384;

      case 39:
        return 1000;

      case 89:
        return 700;

      case 71:
        return 256;

      case 40:
        return 255;

      case 2:
        return 100;

      case 180:
        return 64;

      case 25:
        return 20;

      case 5:
        return 16;

      case 6:
        return 6;

      case 73:
        return 4;

      case 84:
        {
          if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object') return navigator['hardwareConcurrency'] || 1;
          return 1;
        }
    }

    ___setErrNo(ERRNO_CODES.EINVAL);

    return -1;
  }

  DYNAMICTOP_PTR = staticAlloc(4);
  STACK_BASE = STACKTOP = alignMemory(STATICTOP);
  STACK_MAX = STACK_BASE + TOTAL_STACK;
  DYNAMIC_BASE = alignMemory(STACK_MAX);
  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  staticSealed = true; // seal the static portion of memory

  assert(DYNAMIC_BASE < TOTAL_MEMORY, "TOTAL_MEMORY not big enough for stack");
  var ASSERTIONS = true;
  /** @type {function(string, boolean=, number=)} */

  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull) u8array.length = numBytesWritten;
    return u8array;
  }

  function intArrayToString(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      var chr = array[i];

      if (chr > 0xFF) {
        if (ASSERTIONS) {
          assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
        }

        chr &= 0xFF;
      }

      ret.push(String.fromCharCode(chr));
    }

    return ret.join('');
  } // Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149
  // This code was written by Tyler Akins and has been placed in the
  // public domain.  It would be nice if you left this header intact.
  // Base64 code from Tyler Akins -- http://rumkin.com

  /**
   * Decodes a base64 string.
   * @param {String} input The string to decode.
   */


  var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
    var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var output = '';
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0; // remove all characters that are not A-Z, a-z, 0-9, +, /, or =

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

    do {
      enc1 = keyStr.indexOf(input.charAt(i++));
      enc2 = keyStr.indexOf(input.charAt(i++));
      enc3 = keyStr.indexOf(input.charAt(i++));
      enc4 = keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);

      if (enc3 !== 64) {
        output = output + String.fromCharCode(chr2);
      }

      if (enc4 !== 64) {
        output = output + String.fromCharCode(chr3);
      }
    } while (i < input.length);

    return output;
  }; // Converts a string of base64 into a byte array.
  // Throws error on invalid input.

  function intArrayFromBase64(s) {
    if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
      var buf;

      try {
        buf = Buffer.from(s, 'base64');
      } catch (_) {
        buf = new Buffer(s, 'base64');
      }

      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }

    try {
      var decoded = decodeBase64(s);
      var bytes = new Uint8Array(decoded.length);

      for (var i = 0; i < decoded.length; ++i) {
        bytes[i] = decoded.charCodeAt(i);
      }

      return bytes;
    } catch (_) {
      throw new Error('Converting base64 string to bytes failed.');
    }
  } // If filename is a base64 data URI, parses and returns data (Buffer on node,
  // Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.


  function tryParseAsDataURI(filename) {
    if (!isDataURI(filename)) {
      return;
    }

    return intArrayFromBase64(filename.slice(dataURIPrefix.length));
  }

  function nullFunc_ii(x) {
    _Module["printErr"]("Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");

    _Module["printErr"]("Build with ASSERTIONS=2 for more info.");

    abort(x);
  }

  function nullFunc_iiii(x) {
    _Module["printErr"]("Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");

    _Module["printErr"]("Build with ASSERTIONS=2 for more info.");

    abort(x);
  }

  _Module['wasmTableSize'] = 16;
  _Module['wasmMaxTableSize'] = 16;

  function invoke_ii(index, a1) {
    try {
      return _Module["dynCall_ii"](index, a1);
    } catch (e) {
      if (typeof e !== 'number' && e !== 'longjmp') throw e;

      _Module["setThrew"](1, 0);
    }
  }

  function invoke_iiii(index, a1, a2, a3) {
    try {
      return _Module["dynCall_iiii"](index, a1, a2, a3);
    } catch (e) {
      if (typeof e !== 'number' && e !== 'longjmp') throw e;

      _Module["setThrew"](1, 0);
    }
  }

  _Module.asmGlobalArg = {};
  _Module.asmLibraryArg = {
    "abort": abort,
    "assert": assert,
    "enlargeMemory": enlargeMemory,
    "getTotalMemory": getTotalMemory,
    "abortOnCannotGrowMemory": abortOnCannotGrowMemory,
    "abortStackOverflow": abortStackOverflow,
    "nullFunc_ii": nullFunc_ii,
    "nullFunc_iiii": nullFunc_iiii,
    "invoke_ii": invoke_ii,
    "invoke_iiii": invoke_iiii,
    "___lock": ___lock,
    "___setErrNo": ___setErrNo,
    "___syscall140": ___syscall140,
    "___syscall146": ___syscall146,
    "___syscall54": ___syscall54,
    "___syscall6": ___syscall6,
    "___unlock": ___unlock,
    "_emscripten_has_threading_support": _emscripten_has_threading_support,
    "_emscripten_memcpy_big": _emscripten_memcpy_big,
    "_llvm_cttz_i32": _llvm_cttz_i32,
    "_llvm_cttz_i64": _llvm_cttz_i64,
    "_llvm_stackrestore": _llvm_stackrestore,
    "_llvm_stacksave": _llvm_stacksave,
    "_pthread_create": _pthread_create,
    "_pthread_join": _pthread_join,
    "_pthread_mutex_init": _pthread_mutex_init,
    "_sysconf": _sysconf,
    "flush_NO_FILESYSTEM": flush_NO_FILESYSTEM,
    "DYNAMICTOP_PTR": DYNAMICTOP_PTR,
    "tempDoublePtr": tempDoublePtr,
    "ABORT": ABORT,
    "STACKTOP": STACKTOP,
    "STACK_MAX": STACK_MAX,
    "cttz_i8": cttz_i8
  }; // EMSCRIPTEN_START_ASM

  var asm = _Module["asm"] // EMSCRIPTEN_END_ASM
  (_Module.asmGlobalArg, _Module.asmLibraryArg, buffer);

  var real____errno_location = asm["___errno_location"];

  asm["___errno_location"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real____errno_location.apply(null, arguments);
  };

  var real__ccurl_pow = asm["_ccurl_pow"];

  asm["_ccurl_pow"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__ccurl_pow.apply(null, arguments);
  };

  var real__fflush = asm["_fflush"];

  asm["_fflush"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__fflush.apply(null, arguments);
  };

  var real__free = asm["_free"];

  asm["_free"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__free.apply(null, arguments);
  };

  var real__llvm_bswap_i32 = asm["_llvm_bswap_i32"];

  asm["_llvm_bswap_i32"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__llvm_bswap_i32.apply(null, arguments);
  };

  var real__malloc = asm["_malloc"];

  asm["_malloc"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__malloc.apply(null, arguments);
  };

  var real__pthread_mutex_lock = asm["_pthread_mutex_lock"];

  asm["_pthread_mutex_lock"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__pthread_mutex_lock.apply(null, arguments);
  };

  var real__pthread_mutex_unlock = asm["_pthread_mutex_unlock"];

  asm["_pthread_mutex_unlock"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__pthread_mutex_unlock.apply(null, arguments);
  };

  var real__sbrk = asm["_sbrk"];

  asm["_sbrk"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__sbrk.apply(null, arguments);
  };

  var real_establishStackSpace = asm["establishStackSpace"];

  asm["establishStackSpace"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_establishStackSpace.apply(null, arguments);
  };

  var real_getTempRet0 = asm["getTempRet0"];

  asm["getTempRet0"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_getTempRet0.apply(null, arguments);
  };

  var real_setTempRet0 = asm["setTempRet0"];

  asm["setTempRet0"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_setTempRet0.apply(null, arguments);
  };

  var real_setThrew = asm["setThrew"];

  asm["setThrew"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_setThrew.apply(null, arguments);
  };

  var real_stackAlloc = asm["stackAlloc"];

  asm["stackAlloc"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_stackAlloc.apply(null, arguments);
  };

  var real_stackRestore = asm["stackRestore"];

  asm["stackRestore"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_stackRestore.apply(null, arguments);
  };

  var real_stackSave = asm["stackSave"];

  asm["stackSave"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_stackSave.apply(null, arguments);
  };

  _Module["asm"] = asm;

  var ___errno_location = _Module["___errno_location"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["___errno_location"].apply(null, arguments);
  };

  var _ccurl_pow = _Module["_ccurl_pow"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_ccurl_pow"].apply(null, arguments);
  };

  var _fflush = _Module["_fflush"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_fflush"].apply(null, arguments);
  };

  var _free = _Module["_free"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_free"].apply(null, arguments);
  };

  var _llvm_bswap_i32 = _Module["_llvm_bswap_i32"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_llvm_bswap_i32"].apply(null, arguments);
  };

  var _malloc = _Module["_malloc"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_malloc"].apply(null, arguments);
  };

  var _memcpy = _Module["_memcpy"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_memcpy"].apply(null, arguments);
  };

  var _memset = _Module["_memset"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_memset"].apply(null, arguments);
  };

  var _pthread_mutex_lock = _Module["_pthread_mutex_lock"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_pthread_mutex_lock"].apply(null, arguments);
  };

  var _pthread_mutex_unlock = _Module["_pthread_mutex_unlock"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_pthread_mutex_unlock"].apply(null, arguments);
  };

  var _sbrk = _Module["_sbrk"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_sbrk"].apply(null, arguments);
  };

  var establishStackSpace = _Module["establishStackSpace"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["establishStackSpace"].apply(null, arguments);
  };

  var getTempRet0 = _Module["getTempRet0"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["getTempRet0"].apply(null, arguments);
  };

  var runPostSets = _Module["runPostSets"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["runPostSets"].apply(null, arguments);
  };

  var setTempRet0 = _Module["setTempRet0"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["setTempRet0"].apply(null, arguments);
  };

  var setThrew = _Module["setThrew"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["setThrew"].apply(null, arguments);
  };

  var stackAlloc = _Module["stackAlloc"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["stackAlloc"].apply(null, arguments);
  };

  var _stackRestore = _Module["stackRestore"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["stackRestore"].apply(null, arguments);
  };

  var _stackSave = _Module["stackSave"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["stackSave"].apply(null, arguments);
  };

  var dynCall_ii = _Module["dynCall_ii"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["dynCall_ii"].apply(null, arguments);
  };

  var dynCall_iiii = _Module["dynCall_iiii"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["dynCall_iiii"].apply(null, arguments);
  };

  ; // === Auto-generated postamble setup entry stuff ===

  _Module['asm'] = asm;
  if (!_Module["intArrayFromString"]) _Module["intArrayFromString"] = function () {
    abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["intArrayToString"]) _Module["intArrayToString"] = function () {
    abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  _Module["ccall"] = ccall;
  _Module["cwrap"] = cwrap;
  if (!_Module["setValue"]) _Module["setValue"] = function () {
    abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getValue"]) _Module["getValue"] = function () {
    abort("'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["allocate"]) _Module["allocate"] = function () {
    abort("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getMemory"]) _Module["getMemory"] = function () {
    abort("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["Pointer_stringify"]) _Module["Pointer_stringify"] = function () {
    abort("'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["AsciiToString"]) _Module["AsciiToString"] = function () {
    abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stringToAscii"]) _Module["stringToAscii"] = function () {
    abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["UTF8ArrayToString"]) _Module["UTF8ArrayToString"] = function () {
    abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["UTF8ToString"]) _Module["UTF8ToString"] = function () {
    abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stringToUTF8Array"]) _Module["stringToUTF8Array"] = function () {
    abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stringToUTF8"]) _Module["stringToUTF8"] = function () {
    abort("'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["lengthBytesUTF8"]) _Module["lengthBytesUTF8"] = function () {
    abort("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["UTF16ToString"]) _Module["UTF16ToString"] = function () {
    abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stringToUTF16"]) _Module["stringToUTF16"] = function () {
    abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["lengthBytesUTF16"]) _Module["lengthBytesUTF16"] = function () {
    abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["UTF32ToString"]) _Module["UTF32ToString"] = function () {
    abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stringToUTF32"]) _Module["stringToUTF32"] = function () {
    abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["lengthBytesUTF32"]) _Module["lengthBytesUTF32"] = function () {
    abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["allocateUTF8"]) _Module["allocateUTF8"] = function () {
    abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stackTrace"]) _Module["stackTrace"] = function () {
    abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addOnPreRun"]) _Module["addOnPreRun"] = function () {
    abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addOnInit"]) _Module["addOnInit"] = function () {
    abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addOnPreMain"]) _Module["addOnPreMain"] = function () {
    abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addOnExit"]) _Module["addOnExit"] = function () {
    abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addOnPostRun"]) _Module["addOnPostRun"] = function () {
    abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["writeStringToMemory"]) _Module["writeStringToMemory"] = function () {
    abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["writeArrayToMemory"]) _Module["writeArrayToMemory"] = function () {
    abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["writeAsciiToMemory"]) _Module["writeAsciiToMemory"] = function () {
    abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addRunDependency"]) _Module["addRunDependency"] = function () {
    abort("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["removeRunDependency"]) _Module["removeRunDependency"] = function () {
    abort("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS"]) _Module["FS"] = function () {
    abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["FS_createFolder"]) _Module["FS_createFolder"] = function () {
    abort("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createPath"]) _Module["FS_createPath"] = function () {
    abort("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createDataFile"]) _Module["FS_createDataFile"] = function () {
    abort("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createPreloadedFile"]) _Module["FS_createPreloadedFile"] = function () {
    abort("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createLazyFile"]) _Module["FS_createLazyFile"] = function () {
    abort("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createLink"]) _Module["FS_createLink"] = function () {
    abort("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createDevice"]) _Module["FS_createDevice"] = function () {
    abort("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_unlink"]) _Module["FS_unlink"] = function () {
    abort("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["GL"]) _Module["GL"] = function () {
    abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["staticAlloc"]) _Module["staticAlloc"] = function () {
    abort("'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["dynamicAlloc"]) _Module["dynamicAlloc"] = function () {
    abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["warnOnce"]) _Module["warnOnce"] = function () {
    abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["loadDynamicLibrary"]) _Module["loadDynamicLibrary"] = function () {
    abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["loadWebAssemblyModule"]) _Module["loadWebAssemblyModule"] = function () {
    abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getLEB"]) _Module["getLEB"] = function () {
    abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getFunctionTables"]) _Module["getFunctionTables"] = function () {
    abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["alignFunctionTables"]) _Module["alignFunctionTables"] = function () {
    abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["registerFunctions"]) _Module["registerFunctions"] = function () {
    abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addFunction"]) _Module["addFunction"] = function () {
    abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["removeFunction"]) _Module["removeFunction"] = function () {
    abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getFuncWrapper"]) _Module["getFuncWrapper"] = function () {
    abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["prettyPrint"]) _Module["prettyPrint"] = function () {
    abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["makeBigInt"]) _Module["makeBigInt"] = function () {
    abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["dynCall"]) _Module["dynCall"] = function () {
    abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getCompilerSetting"]) _Module["getCompilerSetting"] = function () {
    abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["intArrayFromBase64"]) _Module["intArrayFromBase64"] = function () {
    abort("'intArrayFromBase64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["tryParseAsDataURI"]) _Module["tryParseAsDataURI"] = function () {
    abort("'tryParseAsDataURI' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["ALLOC_NORMAL"]) Object.defineProperty(_Module, "ALLOC_NORMAL", {
    get: function get() {
      abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
    }
  });
  if (!_Module["ALLOC_STACK"]) Object.defineProperty(_Module, "ALLOC_STACK", {
    get: function get() {
      abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
    }
  });
  if (!_Module["ALLOC_STATIC"]) Object.defineProperty(_Module, "ALLOC_STATIC", {
    get: function get() {
      abort("'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
    }
  });
  if (!_Module["ALLOC_DYNAMIC"]) Object.defineProperty(_Module, "ALLOC_DYNAMIC", {
    get: function get() {
      abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
    }
  });
  if (!_Module["ALLOC_NONE"]) Object.defineProperty(_Module, "ALLOC_NONE", {
    get: function get() {
      abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
    }
  }); // Modularize mode returns a function, which can be called to
  // create instances. The instances provide a then() method,
  // must like a Promise, that receives a callback. The callback
  // is called when the module is ready to run, with the module
  // as a parameter. (Like a Promise, it also returns the module
  // so you can use the output of .then(..)).

  _Module['then'] = function (func) {
    // We may already be ready to run code at this time. if
    // so, just queue a call to the callback.
    if (_Module['calledRun']) {
      func(_Module);
    } else {
      // we are not ready to call then() yet. we must call it
      // at the same time we would call onRuntimeInitialized.
      var old = _Module['onRuntimeInitialized'];

      _Module['onRuntimeInitialized'] = function () {
        if (old) old();
        func(_Module);
      };
    }

    return _Module;
  };
  /**
   * @constructor
   * @extends {Error}
   * @this {ExitStatus}
   */


  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = "Program terminated with exit(" + status + ")";
    this.status = status;
  }

  ;
  ExitStatus.prototype = new Error();
  ExitStatus.prototype.constructor = ExitStatus;
  var initialStackTop;
  var calledMain = false;

  dependenciesFulfilled = function runCaller() {
    // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
    if (!_Module['calledRun']) run();
    if (!_Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
  };
  /** @type {function(Array=)} */


  function run(args) {
    args = args || _Module['arguments'];

    if (runDependencies > 0) {
      return;
    }

    writeStackCookie();
    preRun();
    if (runDependencies > 0) return; // a preRun added a dependency, run will be called later

    if (_Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

    function doRun() {
      if (_Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening

      _Module['calledRun'] = true;
      if (ABORT) return;
      ensureInitRuntime();
      preMain();
      if (_Module['onRuntimeInitialized']) _Module['onRuntimeInitialized']();
      assert(!_Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
      postRun();
    }

    if (_Module['setStatus']) {
      _Module['setStatus']('Running...');

      setTimeout(function () {
        setTimeout(function () {
          _Module['setStatus']('');
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }

    checkStackCookie();
  }

  _Module['run'] = run;

  function checkUnflushedContent() {
    // Compiler settings do not allow exiting the runtime, so flushing
    // the streams is not possible. but in ASSERTIONS mode we check
    // if there was something to flush, and if so tell the user they
    // should request that the runtime be exitable.
    // Normally we would not even include flush() at all, but in ASSERTIONS
    // builds we do so just for this check, and here we see if there is any
    // content to flush, that is, we check if there would have been
    // something a non-ASSERTIONS build would have not seen.
    // How we flush the streams depends on whether we are in NO_FILESYSTEM
    // mode (which has its own special function for this; otherwise, all
    // the code is inside libc)
    var print = _Module['print'];
    var printErr = _Module['printErr'];
    var has = false;

    _Module['print'] = _Module['printErr'] = function (x) {
      has = true;
    };

    try {
      // it doesn't matter if it fails
      var flush = flush_NO_FILESYSTEM;
      if (flush) flush(0);
    } catch (e) {}

    _Module['print'] = print;
    _Module['printErr'] = printErr;

    if (has) {
      warnOnce('stdio streams had content in them that was not flushed. you should set NO_EXIT_RUNTIME to 0 (see the FAQ), or make sure to emit a newline when you printf etc.');
    }
  }

  function exit(status, implicit) {
    checkUnflushedContent(); // if this is just main exit-ing implicitly, and the status is 0, then we
    // don't need to do anything here and can just leave. if the status is
    // non-zero, though, then we need to report it.
    // (we may have warned about this earlier, if a situation justifies doing so)

    if (implicit && _Module['noExitRuntime'] && status === 0) {
      return;
    }

    if (_Module['noExitRuntime']) {
      // if exit() was called, we may warn the user if the runtime isn't actually being shut down
      if (!implicit) {
        _Module.printErr('exit(' + status + ') called, but NO_EXIT_RUNTIME is set, so halting execution but not exiting the runtime or preventing further async execution (build with NO_EXIT_RUNTIME=0, if you want a true shutdown)');
      }
    } else {
      ABORT = true;
      EXITSTATUS = status;
      STACKTOP = initialStackTop;
      exitRuntime();
      if (_Module['onExit']) _Module['onExit'](status);
    }

    if (ENVIRONMENT_IS_NODE) {
      process['exit'](status);
    }

    _Module['quit'](status, new ExitStatus(status));
  }

  _Module['exit'] = exit;
  var abortDecorators = [];

  function abort(what) {
    if (_Module['onAbort']) {
      _Module['onAbort'](what);
    }

    if (what !== undefined) {
      _Module.print(what);

      _Module.printErr(what);

      what = JSON.stringify(what);
    } else {
      what = '';
    }

    ABORT = true;
    EXITSTATUS = 1;
    var extra = '';
    var output = 'abort(' + what + ') at ' + stackTrace() + extra;

    if (abortDecorators) {
      abortDecorators.forEach(function (decorator) {
        output = decorator(output, what);
      });
    }

    throw output;
  }

  _Module['abort'] = abort; // {{PRE_RUN_ADDITIONS}}

  if (_Module['preInit']) {
    if (typeof _Module['preInit'] == 'function') _Module['preInit'] = [_Module['preInit']];

    while (_Module['preInit'].length > 0) {
      _Module['preInit'].pop()();
    }
  }

  _Module["noExitRuntime"] = true;
  run(); // {{POST_RUN_ADDITIONS}}
  // {{MODULE_ADDITIONS}}

  return _Module;
};

if (( false ? "undefined" : _typeof(exports)) === 'object' && ( false ? "undefined" : _typeof(module)) === 'object') module.exports = Module;else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  return Module;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') exports["Module"] = Module;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(51);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(4);

var numberHelper_1 = __webpack_require__(2);

var objectHelper_1 = __webpack_require__(0);

var cryptoError_1 = __webpack_require__(5);

var trytes_1 = __webpack_require__(1);

var pearlDiver_1 = __webpack_require__(97);
/**
 * ProofOfWork implementation using WebGL.
 */


var ProofOfWorkWebGl =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of ProofOfWork.
   * @param webGLPlatform Provides platform specific functions, optional mostly used for testing.
   */
  function ProofOfWorkWebGl(webGLPlatform) {
    _classCallCheck(this, ProofOfWorkWebGl);

    if (objectHelper_1.ObjectHelper.isEmpty(webGLPlatform)) {
      this._webGLPlatform = {
        getWindow: function getWindow() {
          return window;
        },
        getDocument: function getDocument(window) {
          return window.document;
        },
        getCanvas: function getCanvas(document) {
          return document.createElement("canvas");
        },
        getWebGL: function getWebGL(canvas) {
          var attr = {
            alpha: false,
            antialias: false
          };
          var gl = canvas.getContext("webgl2", attr);
          return gl;
        }
      };
    } else {
      this._webGLPlatform = webGLPlatform;
    }
  }
  /**
   * Allow the proof of work to perform any initialization.
   * Will throw an exception if the implementation is not supported.
   */


  _createClass(ProofOfWorkWebGl, [{
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee() {
        var _this = this;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  try {
                    pearlDiver_1.PearlDiver.initialize(_this._webGLPlatform);
                    _this._isInitialized = true;
                    resolve();
                  } catch (err) {
                    reject(err);
                  }
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function initialize() {
        return _initialize.apply(this, arguments);
      };
    }()
    /**
     * Performs single conversion per pow call.
     * @returns True if pow only does one conversion.
     */

  }, {
    key: "performsSingle",
    value: function performsSingle() {
      return true;
    }
    /**
     * Perform a proof of work on the data.
     * @param trunkTransaction The trunkTransaction to use for the pow.
     * @param branchTransaction The branchTransaction to use for the pow.
     * @param trytes The trytes to perform the pow on.
     * @param minWeightMagnitude The minimum weight magnitude.
     * @returns The trytes produced by the proof of work.
     */

  }, {
    key: "pow",
    value: function () {
      var _pow = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {
        var singleTrytes, nonce, trytesString, nonceString;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this._isInitialized) {
                  _context2.next = 2;
                  break;
                }

                throw new cryptoError_1.CryptoError("WebGL is not initialized, have you called initialize");

              case 2:
                if (arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {
                  _context2.next = 4;
                  break;
                }

                throw new cryptoError_1.CryptoError("The trytes must be an array of type Trytes");

              case 4:
                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {
                  _context2.next = 6;
                  break;
                }

                throw new cryptoError_1.CryptoError("The minWeightMagnitude must be > 0");

              case 6:
                singleTrytes = trytes[0];
                _context2.next = 9;
                return pearlDiver_1.PearlDiver.instance.searchWithTrytes(singleTrytes, minWeightMagnitude);

              case 9:
                nonce = _context2.sent;
                trytesString = singleTrytes.toString();
                nonceString = nonce.toString();
                return _context2.abrupt("return", [trytes_1.Trytes.fromString(trytesString.substr(0, trytesString.length - nonceString.length).concat(nonceString))]);

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function pow(_x, _x2, _x3, _x4) {
        return _pow.apply(this, arguments);
      };
    }()
  }]);

  return ProofOfWorkWebGl;
}();

exports.ProofOfWorkWebGl = ProofOfWorkWebGl;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(96);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 96 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var _regeneratorRuntime = __webpack_require__(51);

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(0);

var spongeFactory_1 = __webpack_require__(10);

var trits_1 = __webpack_require__(7);

var add_1 = __importDefault(__webpack_require__(98));

var checkCol_1 = __importDefault(__webpack_require__(99));

var checkDo_1 = __importDefault(__webpack_require__(100));

var checkK_1 = __importDefault(__webpack_require__(101));

var finalize_1 = __importDefault(__webpack_require__(102));

var headers_1 = __importDefault(__webpack_require__(103));

var increment_1 = __importDefault(__webpack_require__(104));

var init_1 = __importDefault(__webpack_require__(105));

var transform_1 = __importDefault(__webpack_require__(106));

var webGLWorker_1 = __webpack_require__(107);

var pearlDiverState_1 = __webpack_require__(111);
/**
 * PearlDiver.
 * Converted from https://github.com/iotaledger/curl.lib.js/blob/master/src/pearldiver.js
 */


var PearlDiver =
/*#__PURE__*/
function () {
  /* @internal */
  function PearlDiver(webGLPlatform) {
    _classCallCheck(this, PearlDiver);

    this._webGLWorker = new webGLWorker_1.WebGLWorker();
    var curl = spongeFactory_1.SpongeFactory.instance().create("curl");
    this._hashLength = curl.getConstant("HASH_LENGTH");
    this._stateLength = curl.getConstant("STATE_LENGTH");
    this._numberRounds = curl.getConstant("NUMBER_OF_ROUNDS");
    this._transactionLength = this._hashLength * 33;
    this._nonceLength = this._hashLength / 3;
    this._nonceStart = this._hashLength - this._nonceLength;

    this._webGLWorker.initialize(webGLPlatform, this._stateLength + 1, PearlDiver.TEXEL_SIZE);

    this._currentBuffer = this._webGLWorker.getIpt().data;

    this._webGLWorker.addProgram("init", headers_1.default + add_1.default + init_1.default, "gr_offset");

    this._webGLWorker.addProgram("increment", headers_1.default + add_1.default + increment_1.default);

    this._webGLWorker.addProgram("twist", headers_1.default + transform_1.default);

    this._webGLWorker.addProgram("check", headers_1.default + checkDo_1.default + checkK_1.default, "minWeightMagnitude");

    this._webGLWorker.addProgram("col_check", headers_1.default + checkCol_1.default);

    this._webGLWorker.addProgram("finalize", headers_1.default + checkDo_1.default + finalize_1.default);

    this._state = pearlDiverState_1.PearlDiverState.ready;
    this._queue = [];
  }
  /**
   * Initialize the PearlDiver main instance.
   */


  _createClass(PearlDiver, [{
    key: "searchWithTrytes",

    /**
     * Perform a search using trytes.
     * @param trytes The trytes to perform the search on.
     * @param minWeightMagnitude The minimum weight magnitude.
     * @returns Promise which resolves to the trytes from the search.
     */
    value: function () {
      var _searchWithTrytes = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee(trytes, minWeightMagnitude) {
        var searchStates;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                searchStates = this.prepare(trytes);
                return _context.abrupt("return", this.search(searchStates, minWeightMagnitude));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function searchWithTrytes(_x, _x2) {
        return _searchWithTrytes.apply(this, arguments);
      };
    }()
    /* @internal */

  }, {
    key: "prepare",
    value: function prepare(transactionTrytes) {
      var curl = spongeFactory_1.SpongeFactory.instance().create("curl");
      curl.initialize();
      var transactionTrits = trits_1.Trits.fromTrytes(transactionTrytes).toArray();
      curl.absorb(transactionTrits, 0, this._transactionLength - this._hashLength);
      var curlState = curl.getState();
      transactionTrits.slice(this._transactionLength - this._hashLength, this._transactionLength).forEach(function (value, index) {
        curlState[index] = value;
      });
      return this.searchToPair(curlState);
    }
    /* @internal */

  }, {
    key: "search",
    value: function () {
      var _search = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2(states, minWeight) {
        var _this = this;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  _this._queue.push({
                    states: states,
                    minWeightMagnitude: minWeight,
                    callback: resolve
                  });

                  if (_this._state === pearlDiverState_1.PearlDiverState.ready) {
                    _this.searchDoNext();
                  }
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function search(_x3, _x4) {
        return _search.apply(this, arguments);
      };
    }()
    /* @internal */

  }, {
    key: "searchToPair",
    value: function searchToPair(state) {
      var states = {
        low: new Int32Array(this._stateLength),
        high: new Int32Array(this._stateLength)
      };
      state.forEach(function (trit, index) {
        switch (trit) {
          case 0:
            states.low[index] = PearlDiver.HIGH_BITS;
            states.high[index] = PearlDiver.HIGH_BITS;
            break;

          case 1:
            states.low[index] = PearlDiver.LOW_BITS;
            states.high[index] = PearlDiver.HIGH_BITS;
            break;

          default:
            states.low[index] = PearlDiver.HIGH_BITS;
            states.high[index] = PearlDiver.LOW_BITS;
        }
      });
      this.searchOffset(states, this._nonceStart);
      return states;
    }
    /* @internal */

  }, {
    key: "searchOffset",
    value: function searchOffset(states, offset) {
      states.low[offset + 0] = PearlDiver.LOW_0;
      states.low[offset + 1] = PearlDiver.LOW_1;
      states.low[offset + 2] = PearlDiver.LOW_2;
      states.low[offset + 3] = PearlDiver.LOW_3;
      states.high[offset + 0] = PearlDiver.HIGH_0;
      states.high[offset + 1] = PearlDiver.HIGH_1;
      states.high[offset + 2] = PearlDiver.HIGH_2;
      states.high[offset + 3] = PearlDiver.HIGH_3;
    }
    /* @internal */

  }, {
    key: "searchDoNext",
    value: function searchDoNext() {
      var next = this._queue.shift();

      if (objectHelper_1.ObjectHelper.isEmpty(next)) {
        this._state = pearlDiverState_1.PearlDiverState.ready;
      } else {
        this._state = pearlDiverState_1.PearlDiverState.searching;
        this.webGLFindNonce(next);
      }
    }
    /* @internal */

  }, {
    key: "webGLFindNonce",
    value: function webGLFindNonce(searchObject) {
      var _this2 = this;

      this.webGLWriteBuffers(searchObject.states);

      this._webGLWorker.writeData(this._currentBuffer);

      this._webGLWorker.runProgram("init", 1, {
        name: "gr_offset",
        value: 0
      });

      setTimeout(function () {
        return _this2.webGLSearch(searchObject);
      }, 1);
    }
    /* @internal */

  }, {
    key: "webGLWriteBuffers",
    value: function webGLWriteBuffers(states) {
      for (var i = 0; i < this._stateLength; i++) {
        this._currentBuffer[i * PearlDiver.TEXEL_SIZE] = states.low[i];
        this._currentBuffer[i * PearlDiver.TEXEL_SIZE + 1] = states.high[i];
        this._currentBuffer[i * PearlDiver.TEXEL_SIZE + 2] = states.low[i];
        this._currentBuffer[i * PearlDiver.TEXEL_SIZE + 3] = states.high[i];
      }
    }
    /* @internal */

  }, {
    key: "webGLSearch",
    value: function webGLSearch(searchObject) {
      var _this3 = this;

      this._webGLWorker.runProgram("increment", 1);

      this._webGLWorker.runProgram("twist", this._numberRounds);

      this._webGLWorker.runProgram("check", 1, {
        name: "minWeightMagnitude",
        value: searchObject.minWeightMagnitude
      });

      this._webGLWorker.runProgram("col_check", 1);

      if (this._webGLWorker.readData(this._stateLength, 0, 1, 1)[2] === -1) {
        setTimeout(function () {
          return _this3.webGLSearch(searchObject);
        }, 10);
      } else {
        this._webGLWorker.runProgram("finalize", 1);

        var nonce = this._webGLWorker.readData(0, 0, this._webGLWorker.getDimensions().x, 1).reduce(this.pack(4), []).slice(0, this._hashLength).map(function (x) {
          return x[3];
        });

        searchObject.callback(trits_1.Trits.fromNumberArray(nonce).toTrytes());
        this.searchDoNext();
      }
    }
    /* @internal */

  }, {
    key: "pack",
    value: function pack(l) {
      return function (r, currentValue, currentIndex) {
        return (currentIndex % l === 0 ? r.push([currentValue]) : r[r.length - 1].push(currentValue)) && r;
      };
    }
  }], [{
    key: "initialize",
    value: function initialize(webGLPlatform) {
      if (!PearlDiver.instance) {
        PearlDiver.instance = new PearlDiver(webGLPlatform);
      }
    }
    /**
     * Closedown the PearlDiver main instance.
     */

  }, {
    key: "closedown",
    value: function closedown() {
      if (PearlDiver.instance) {
        PearlDiver.instance = undefined;
      }
    }
  }]);

  return PearlDiver;
}();
/* @internal */


PearlDiver.TEXEL_SIZE = 4;
/* @internal */

PearlDiver.LOW_BITS = 0; // 00000000

/* @internal */

PearlDiver.HIGH_BITS = -1; // 0xFFFFFFFF,FFFFFFFF,4294967295

/* @internal */

PearlDiver.LOW_0 = 0xDB6DB6DB; // 6DB6DB6D,

/* @internal */

PearlDiver.LOW_1 = 0xF1F8FC7E; // 3F1F8FC7,

/* @internal */

PearlDiver.LOW_2 = 0x7FFFE00F; // FFFC01FF,

/* @internal */

PearlDiver.LOW_3 = 0xFFC00000; // 07FFFFFF,

/* @internal */

PearlDiver.HIGH_0 = 0xB6DB6DB6; // DB6DB6DB,

/* @internal */

PearlDiver.HIGH_1 = 0x8FC7E3F1; // F8FC7E3F,

/* @internal */

PearlDiver.HIGH_2 = 0xFFC01FFF; // F803FFFF,

/* @internal */

PearlDiver.HIGH_3 = 0x003FFFFF; //FFFFFFFF,

exports.PearlDiver = PearlDiver;

/***/ }),
/* 98 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Shaders add.
 */

exports.default = "\nint sum (int a, int b) {\n  int my_sum = a + b;\n  return my_sum == 2 ? -1 : (my_sum == -2) ? 1 : my_sum;\n}\nint cons (int a, int b) {\n  return (a == 1 && b == 1)? 1 : (a == -1 && b == -1) ? -1 : 0;\n}\nint any_t (int a, int b) {\n  int my_any = a + b;\n  return my_any == 0 ? 0 : (my_any > 0) ? 1 : -1;\n}\nivec2 full_adder(int a, int b, int c) {\n  int c_a, c_b, sum_ab, c_s;\n\n  c_a    = cons(a,b);\n  sum_ab = sum(a,b);\n  c_b    = cons(sum_ab,c);\n  c_s    = any_t(c_a, c_b);\n\n  return ivec2(sum(sum_ab, c), c_s);\n}\nivec2 get_sum_to_index(int from, int to, int number_to_add, int row) {\n  int trit_to_add, trit_at_index, pow, carry, num_carry;\n  ivec2 read_in, sum_out, out_trit;\n  pow = 1;\n  carry = 0;\n  num_carry = 0;\n\n  for(int i = from; i < to; i++) {\n    //if(trit_to_add == 0 && sum_out.t == 0) continue;\n\n    read_in = read_at ( ivec2 (i, row)).rg;\n\n    trit_to_add = ((number_to_add / pow) % 3) + num_carry;\n    num_carry = trit_to_add > 1 ? 1 : 0;\n    trit_to_add = (trit_to_add == 2 ? -1 : (trit_to_add == 3 ? 0 : trit_to_add));\n\n    sum_out = full_adder(\n      (read_in.s == LOW_BITS ? 1 : read_in.t == LOW_BITS? -1 : 0),\n      trit_to_add,\n      carry\n    );\n\n    if(my_coord.x == i) break;\n    carry = sum_out.t;\n    pow *=3;\n  }\n  if(sum_out.s == 0) {\n    return ivec2(HIGH_BITS);\n  } else if (sum_out.s == 1) {\n    return ivec2(LOW_BITS, HIGH_BITS);\n  } else {\n    return ivec2(HIGH_BITS, LOW_BITS);\n  }\n}\n";

/***/ }),
/* 99 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Shaders check_col.
 */

exports.default = "\nvoid main() {\n  init();\n  ivec4 my_vec = read();\n  int i;\n  if(my_coord.x == STATE_LENGTH && my_coord.y == 0) {\n    my_vec.b = 0;\n    if(my_vec.a == 0) {\n      ivec4 read_vec;\n      my_vec.b = -1;\n      for(i = 1; i < int(size.y); i++) {\n        read_vec = read_at( ivec2( STATE_LENGTH, i));\n        if(read_vec.a != 0) {\n          my_vec.a = read_vec.a;\n          my_vec.b = i;\n          break;\n        }\n      }\n    }\n  }\n  commit(my_vec);\n}\n";

/***/ }),
/* 100 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Shaders check_do.
 */

exports.default = "\nint check(int row, int min_weight_magnitude) {\n  int nonce_probe, i;\n  ivec2 r_texel;\n  nonce_probe = HIGH_BITS;\n  for(i = min_weight_magnitude; i-- > 0; ) {\n    r_texel = read_at(ivec2(HASH_LENGTH - 1 - i, row)).ba;\n    nonce_probe &= ~(r_texel.s ^ r_texel.t);\n    if(nonce_probe == 0) break;\n  }\n  return nonce_probe;\n}\n";

/***/ }),
/* 101 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Shaders check_k.
 */

exports.default = "\nuniform int minWeightMagnitude;\nvoid main() {\n  init();\n  ivec4 my_vec = read();\n  if(my_coord.x == STATE_LENGTH) {\n    my_vec.r = minWeightMagnitude;\n    my_vec.a = check(my_coord.y, minWeightMagnitude);\n  }\n  commit(my_vec);\n}\n";

/***/ }),
/* 102 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Shaders finalize.
 */

exports.default = "\nvoid main() {\n  init();\n  ivec4 my_vec = read();\n  if(my_coord.y == 0 && my_coord.x == STATE_LENGTH) {\n    my_vec.g = check(my_vec.b, my_vec.r);\n  }\n  if(my_coord.y == 0 && my_coord.x < HASH_LENGTH) {\n    ivec4 info_vec = read_at(ivec2(STATE_LENGTH, 0));\n    int nonce_probe = info_vec.a;\n    int row = info_vec.b;\n    ivec4 hash_vec = read_at(ivec2(my_coord.x, row));\n    my_vec.a = (hash_vec.r & nonce_probe) == 0? 1 : ((hash_vec.g & nonce_probe) == 0? -1 : 0);\n  }\n  commit(my_vec);\n}\n";

/***/ }),
/* 103 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Shaders add.
 */

exports.default = "\n#define HASH_LENGTH 243\n#define NUMBER_OF_ROUNDS 81\n#define INCREMENT_START HASH_LENGTH - 64\n#define STATE_LENGTH 3 * HASH_LENGTH\n#define HALF_LENGTH 364\n#define HIGH_BITS 0xFFFFFFFF\n#define LOW_BITS 0x00000000\n";

/***/ }),
/* 104 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Shaders increment.
 */

exports.default = "\nvoid main() {\n  init();\n  ivec4 my_vec = read();\n  if(my_coord.x >= INCREMENT_START && my_coord.x < HASH_LENGTH ) {\n    my_vec.rg = get_sum_to_index(INCREMENT_START, HASH_LENGTH, 1, my_coord.y);\n  }\n  if(my_coord.x == STATE_LENGTH ) {\n    my_vec.rg = ivec2(0);\n  }\n  my_vec.ba = my_vec.rg;\n  commit(my_vec);\n}\n";

/***/ }),
/* 105 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Shaders init.
 */

exports.default = "\nuniform int gr_offset;\nivec4 offset() {\n  if(my_coord.x >= HASH_LENGTH / 3 && my_coord.x < HASH_LENGTH / 3 * 2 ) {\n    ivec4 my_vec;\n    my_vec.rg = get_sum_to_index(HASH_LENGTH / 3, HASH_LENGTH / 3 * 2, my_coord.y + gr_offset, 0);\n    return my_vec;\n  } else {\n    return read_at(ivec2(my_coord.x,0));\n  }\n}\nvoid main() {\n  init();\n  commit(offset());\n}\n";

/***/ }),
/* 106 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Shaders transform.
 */

exports.default = "\nivec2 twist() {\n  int alpha, beta, gamma, delta;\n  ivec4 v1, v2;\n  int j = my_coord.x;\n\n  v1 = read_at(ivec2(j == 0? 0:(((j - 1)%2)+1)*HALF_LENGTH - ((j-1)>>1), my_coord.y));\n  v2 = read_at(ivec2(((j%2)+1)*HALF_LENGTH - ((j)>>1), my_coord.y));\n  alpha = v1.b;\n  beta = v1.a;\n  gamma = v2.a;\n  delta = (alpha | (~gamma)) & (v2.b ^ beta);//v2.b === state_low[t2]\n\n  return ivec2(~delta, (alpha ^ gamma) | delta);\n}\nvoid main() {\n  init();\n  ivec4 my_vec = read();\n  if(my_coord.x < STATE_LENGTH)\n    my_vec.ba = twist();\n  commit(my_vec);\n}\n";

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var cryptoError_1 = __webpack_require__(5);

var stdlib_1 = __importDefault(__webpack_require__(108));

var vertexShaderCode_1 = __importDefault(__webpack_require__(109));

var webGLHelper_1 = __webpack_require__(110);
/**
 * WebGLWorker.
 */


var WebGLWorker =
/*#__PURE__*/
function () {
  function WebGLWorker() {
    _classCallCheck(this, WebGLWorker);
  }

  _createClass(WebGLWorker, [{
    key: "initialize",

    /**
     * Initialize the web GL Worker.
     * @param webGLPlatform The webGL platform.
     * @param stateLength The length of the state.
     * @param texelSize The texel size.
     */
    value: function initialize(webGLPlatform, stateLength, texelSize) {
      this._context = webGLHelper_1.WebGLHelper.createContext(webGLPlatform);
      this._dimensions = {
        x: stateLength,
        y: 0
      };
      var maxImageSize = Math.pow(this._context.MAX_TEXTURE_SIZE, 2) * 0.5;
      var imageSize = Math.floor(maxImageSize / this._dimensions.x / texelSize) * this._dimensions.x * texelSize;
      this._dimensions.y = imageSize / this._dimensions.x / texelSize;
      this._programs = new Map();
      this._ipt = {
        data: new Int32Array(imageSize),
        length: imageSize
      }; // GPU texture buffer = from JS typed array

      this._buffers = {
        position: webGLHelper_1.WebGLHelper.createBuffer(this._context, [-1, -1, 1, -1, 1, 1, -1, 1]),
        texture: webGLHelper_1.WebGLHelper.createBuffer(this._context, [0, 0, 1, 0, 1, 1, 0, 1]),
        index: webGLHelper_1.WebGLHelper.createBuffer(this._context, [1, 2, 0, 3, 0, 2], Uint16Array, this._context.ELEMENT_ARRAY_BUFFER)
      };
      this._attrib = {
        position: 0,
        texture: 1
      };
      this._vertexArray = this._context.createVertexArray();

      this._context.bindVertexArray(this._vertexArray);

      this.bindBuffers();

      this._context.bindVertexArray(null);

      this.createVertexShader();
      this._frameBuffer = this._context.createFramebuffer();
      this._texture0 = webGLHelper_1.WebGLHelper.createTexture(this._context, this._ipt.data, this._dimensions);
      this._texture1 = webGLHelper_1.WebGLHelper.createTexture(this._context, new Int32Array(imageSize), this._dimensions);
    }
    /**
     * Get the dimensions from the worker.
     * @returns The dimensions.
     */

  }, {
    key: "getDimensions",
    value: function getDimensions() {
      return this._dimensions;
    }
    /**
     * Get the IPT from the worker.
     * @return The ipt.
     */

  }, {
    key: "getIpt",
    value: function getIpt() {
      return this._ipt;
    }
    /**
     * Add a program to the worker.
     * @param name The name of the program to add.
     * @param code The code for the program.
     * @param uniforms Additional uniform locations.
     */

  }, {
    key: "addProgram",
    value: function addProgram(name, code) {
      var fragmentShader = this.createFragmentShader(code);

      var program = this._context.createProgram();

      this._context.attachShader(program, this._vertexShader);

      this._context.attachShader(program, fragmentShader);

      this._context.bindAttribLocation(program, this._attrib.position, "position");

      this._context.bindAttribLocation(program, this._attrib.texture, "texture");

      this._context.linkProgram(program);

      var uniformVars = new Map();

      for (var _len = arguments.length, uniforms = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        uniforms[_key - 2] = arguments[_key];
      }

      for (var _i = 0; _i < uniforms.length; _i++) {
        var variable = uniforms[_i];
        uniformVars.set(variable, this._context.getUniformLocation(program, variable));
      }

      this._programs.set(name, {
        program: program,
        uniformVars: uniformVars
      });
    }
    /**
     * Run the program in the web worker.
     * @param name The name of the program to run.
     * @param count The number of times to run it.
     * @param uniforms Additional uniform locations to use.
     */

  }, {
    key: "runProgram",
    value: function runProgram(name, count) {
      var info = this._programs.get(name);

      var program = info.program;

      if (!this._context.getProgramParameter(program, this._context.LINK_STATUS)) {
        throw new cryptoError_1.CryptoError("Failed to link GLSL program code");
      }

      var uniformVars = info.uniformVars;

      var uTexture = this._context.getUniformLocation(program, "u_texture");

      this._context.useProgram(program);

      var localCount = count;

      for (var _len2 = arguments.length, uniforms = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        uniforms[_key2 - 2] = arguments[_key2];
      }

      while (localCount-- > 0) {
        this._context.bindTexture(this._context.TEXTURE_2D, this._texture0);

        this._context.activeTexture(this._context.TEXTURE0);

        this._context.uniform1i(uTexture, 0);

        this._context.viewport(0, 0, this._dimensions.x, this._dimensions.y);

        webGLHelper_1.WebGLHelper.frameBufferSetTexture(this._context, this._frameBuffer, this._texture1);

        this._context.bindVertexArray(this._vertexArray);

        for (var _i2 = 0; _i2 < uniforms.length; _i2++) {
          var uVars = uniforms[_i2];

          this._context.uniform1i(uniformVars.get(uVars.name), uVars.value);
        }

        this._context.drawElements(this._context.TRIANGLES, 6, this._context.UNSIGNED_SHORT, 0);

        var tex0 = this._texture0;
        this._texture0 = this._texture1;
        this._texture1 = tex0;
      }

      this.finishRun();
    }
    /**
     * Read data from the worker.
     * @param x The x position to read from.
     * @param y The y position to read from.
     * @param n The width position to read from.
     * @param m The height position to read from.
     */

  }, {
    key: "readData",
    value: function readData(x, y, n, m) {
      this._context.bindFramebuffer(this._context.FRAMEBUFFER, this._frameBuffer);

      this._context.readPixels(x, y, n, m, this._context.RGBA_INTEGER, this._context.INT, this._ipt.data);

      this._context.bindFramebuffer(this._context.FRAMEBUFFER, null);

      return this._ipt.data.subarray(0, this._ipt.length);
    }
    /**
     * Write data to the worker.
     * @param data The data to write.
     */

  }, {
    key: "writeData",
    value: function writeData(data) {
      this._context.bindTexture(this._context.TEXTURE_2D, this._texture0);

      this._context.texImage2D(this._context.TEXTURE_2D, 0, this._context.RGBA32I, this._dimensions.x, this._dimensions.y, 0, this._context.RGBA_INTEGER, this._context.INT, data);

      this._context.bindTexture(this._context.TEXTURE_2D, null);
    }
    /* @internal */

  }, {
    key: "bindBuffers",
    value: function bindBuffers() {
      this._context.bindBuffer(this._context.ARRAY_BUFFER, this._buffers.texture);

      this._context.enableVertexAttribArray(this._attrib.texture);

      this._context.vertexAttribPointer(this._attrib.texture, 2, this._context.FLOAT, false, 0, 0);

      this._context.bindBuffer(this._context.ARRAY_BUFFER, this._buffers.position);

      this._context.enableVertexAttribArray(this._attrib.position);

      this._context.vertexAttribPointer(this._attrib.position, 2, this._context.FLOAT, false, 0, 0);

      this._context.bindBuffer(this._context.ELEMENT_ARRAY_BUFFER, this._buffers.index);
    }
    /* @internal */

  }, {
    key: "createVertexShader",
    value: function createVertexShader() {
      this._vertexShader = this._context.createShader(this._context.VERTEX_SHADER);

      this._context.shaderSource(this._vertexShader, vertexShaderCode_1.default);

      this._context.compileShader(this._vertexShader); // This should not fail.


      if (!this._context.getShaderParameter(this._vertexShader, this._context.COMPILE_STATUS)) {
        throw new cryptoError_1.CryptoError("Could not build vertex shader.\n\n--- CODE DUMP ---".concat(vertexShaderCode_1.default, "\n\n--- ERROR LOG ---\n").concat(this._context.getShaderInfoLog(this._vertexShader)));
      }
    }
    /* @internal */

  }, {
    key: "createFragmentShader",
    value: function createFragmentShader(code) {
      var fragmentShader = this._context.createShader(this._context.FRAGMENT_SHADER);

      this._context.shaderSource(fragmentShader, stdlib_1.default + code);

      this._context.compileShader(fragmentShader); // Use this output to debug the shader
      // Keep in mind that WebGL GLSL is **much** stricter than e.g. OpenGL GLSL


      if (!this._context.getShaderParameter(fragmentShader, this._context.COMPILE_STATUS)) {
        var codeLines = code.split("\n");
        var dbgMsg = "Could not build fragment shader.\n\n------------------ KERNEL CODE DUMP ------------------\n";

        for (var nl = 0; nl < codeLines.length; nl++) {
          dbgMsg += "".concat(stdlib_1.default.split("\n").length + nl, "> ").concat(codeLines[nl], "\n");
        }

        dbgMsg += "\n--------------------- ERROR  LOG ---------------------\n".concat(this._context.getShaderInfoLog(fragmentShader));
        throw new cryptoError_1.CryptoError(dbgMsg);
      }

      return fragmentShader;
    }
    /* @internal */

  }, {
    key: "finishRun",
    value: function finishRun() {
      this._context.bindVertexArray(null);

      this._context.bindTexture(this._context.TEXTURE_2D, null);

      this._context.bindFramebuffer(this._context.FRAMEBUFFER, null);
    }
  }]);

  return WebGLWorker;
}();

exports.WebGLWorker = WebGLWorker;

/***/ }),
/* 108 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Stdlib.
 */

exports.default = "#version 300 es\nprecision highp float;\nprecision highp int;\nprecision highp isampler2D;\nuniform isampler2D u_texture;\nin vec2 pos;\nout ivec4 color;\n//out int isFinished;\n\nvec2 size;\nivec2 my_coord;\n\nvoid init(void) {\n  //size = vec2(textureSize(u_texture, 0) - 1);\n  size = vec2(textureSize(u_texture, 0));\n  my_coord = ivec2(pos * size);\n}\n\nivec4 read(void) {\n  return texture(u_texture, pos);\n}\n\nivec4 read_at(ivec2 coord) {\n  return texelFetch(u_texture, coord, 0);\n}\n\nvoid commit(ivec4 val) {\n  color = val;\n}\n";

/***/ }),
/* 109 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Vertex Shader code.
 */

exports.default = "#version 300 es\nlayout(location = 0) in vec2 position;\nlayout(location = 1) in vec2 texture;\nout vec2 pos;\n\nvoid main(void) {\n  pos = texture;\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n}";

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(0);

var cryptoError_1 = __webpack_require__(5);
/**
 * Helper functions for use with WebGL.
 */


var WebGLHelper =
/*#__PURE__*/
function () {
  function WebGLHelper() {
    _classCallCheck(this, WebGLHelper);
  }

  _createClass(WebGLHelper, null, [{
    key: "createContext",

    /**
     * Create a WebGL Context.
     * @returns The context if successfuly or throws an error if it cannot be created.
     */
    value: function createContext(webGLPlatform) {
      var window = webGLPlatform.getWindow();

      if (!objectHelper_1.ObjectHelper.isEmpty(window) && typeof window !== "undefined") {
        var document = webGLPlatform.getDocument(window);

        if (!objectHelper_1.ObjectHelper.isEmpty(document)) {
          var canvas = webGLPlatform.getCanvas(document);

          if (!objectHelper_1.ObjectHelper.isEmpty(canvas)) {
            var gl = webGLPlatform.getWebGL(canvas);

            if (objectHelper_1.ObjectHelper.isEmpty(gl)) {
              throw new cryptoError_1.CryptoError("Can not create a WebGL context on a <canvas> element.", {
                userAgent: window.navigator.userAgent
              });
            }

            return gl;
          } else {
            throw new cryptoError_1.CryptoError("The HTML5 <canvas> element is not available in your browser.", {
              userAgent: window.navigator.userAgent
            });
          }
        } else {
          throw new cryptoError_1.CryptoError("window.document is not available, you must be running in an environment with WebGL.");
        }
      } else {
        throw new cryptoError_1.CryptoError("window is not available, you must be running in an environment with WebGL.");
      }
    }
    /**
     * Create a new WebGL buffer.
     * @param gl The WebGL rendering context.
     * @param data The data to add to the buffer.
     * @param arrayType The data type for the buffer.
     * @param target A GL Enum specifying the binding point (target).
     * @returns The WebGL buffer.
     */

  }, {
    key: "createBuffer",
    value: function createBuffer(gl, data, arrayType, target) {
      var buf = gl.createBuffer();
      gl.bindBuffer(target || gl.ARRAY_BUFFER, buf);
      gl.bufferData(target || gl.ARRAY_BUFFER, new (arrayType || Float32Array)(data), gl.STATIC_DRAW);
      return buf;
    }
    /**
     * Transfer data onto clamped texture and turn off any filtering
     * @param gl The WebGL rendering context.
     * @param pixelData The pixel data to create the view from.
     * @param dimensions The dimensions to create the texture.
     * @returns The texture.
     */

  }, {
    key: "createTexture",
    value: function createTexture(gl, pixelData, dimensions) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32I, dimensions.x, dimensions.y, 0, gl.RGBA_INTEGER, gl.INT, pixelData);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Set the texure into the framebuffer.
     * @param gl The WebGL rendering context.
     * @param frameBuffer The frame buffer to set the text in to.
     * @param texture The texture to set in to the framebuffer.
     */

  }, {
    key: "frameBufferSetTexture",
    value: function frameBufferSetTexture(gl, frameBuffer, texture) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); // Test for mobile bug MDN->WebGL_best_practices, bullet 7

      var frameBufferStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

      if (frameBufferStatus !== gl.FRAMEBUFFER_COMPLETE) {
        throw new cryptoError_1.CryptoError("Error attaching float texture to framebuffer. Your device is probably incompatible.");
      }
    }
  }]);

  return WebGLHelper;
}();

exports.WebGLHelper = WebGLHelper;

/***/ }),
/* 111 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * PearlDiver State.
 */

var PearlDiverState;

(function (PearlDiverState) {
  PearlDiverState[PearlDiverState["ready"] = 0] = "ready";
  PearlDiverState[PearlDiverState["searching"] = 1] = "searching";
  PearlDiverState[PearlDiverState["interrupted"] = -1] = "interrupted";
})(PearlDiverState = exports.PearlDiverState || (exports.PearlDiverState = {}));

/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA4OGRmNDYxMTBlNmRjYWY5YTU0ZSIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2hlbHBlcnMvb2JqZWN0SGVscGVyLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvZGF0YS90cnl0ZXMudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9oZWxwZXJzL251bWJlckhlbHBlci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2Vycm9yL2RhdGFFcnJvci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2hlbHBlcnMvYXJyYXlIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9lcnJvci9jcnlwdG9FcnJvci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2hlbHBlcnMvc3RyaW5nSGVscGVyLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvZGF0YS90cml0cy50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2RhdGEvYWRkcmVzcy50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2RhdGEvaGFzaC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5LnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvZXJyb3IvY29yZUVycm9yLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvZGF0YS9zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9kYXRhL3RhZy50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2RhdGEvdHJhbnNhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9kYXRhL3RyeXRlTnVtYmVyLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvaGVscGVycy9qc29uSGVscGVyLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvZmFjdG9yaWVzL2ZhY3RvcnlCYXNlLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbG9nZ2Vycy9udWxsTG9nZ2VyLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvZGF0YS9hZGRyZXNzU2VjdXJpdHkudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9kYXRhL2J1bmRsZS50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2hhc2gvaXNzLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvZXJyb3IvYnVzaW5lc3NFcnJvci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2Vycm9yL25ldHdvcmtFcnJvci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3NlcnZpY2VzL3RpbWVTZXJ2aWNlLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvZGF0YS90cmFuc2Zlci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2hlbHBlcnMvYnVuZGxlSGVscGVyLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvZmFjdG9yaWVzL25ldHdvcmtDbGllbnRGYWN0b3J5LnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvaGVscGVycy9lcnJvckhlbHBlci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3NlcnZpY2VzL2JhY2tncm91bmRUYXNrU2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2NvbnZlcnRlcnMvYXNjaWlUcnl0ZXNDb252ZXJ0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9kYXRhL2lucHV0LnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvZXJyb3IvYXBpRXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2RpZ2VzdHMvc2hhMy50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3Nwb25nZXMvY3VybC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3Nwb25nZXMva2VybC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2hlbHBlcnMvYmlnSW50ZWdlckhlbHBlci50cyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiYW1kXCI6XCJiaWctaW50ZWdlclwiLFwiY29tbW9uanNcIjpcImJpZy1pbnRlZ2VyXCIsXCJjb21tb25qczJcIjpcImJpZy1pbnRlZ2VyXCIsXCJyb290XCI6XCJiaWdJbnRcIn0iLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9oZWxwZXJzL2FkZHJlc3NIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9zaWduL2htYWNDdXJsLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbXVsdGlTaWcvbXVsdGlTaWdBZGRyZXNzLnRzIiwid2VicGFjazovLy8uLi9pb3RhLXBpY28tYnVzaW5lc3Mvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9pb3RhLXBpY28tcGFsLWJyb3dzZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbmV0d29yay9uZXR3b3JrQ2xpZW50LnRzIiwid2VicGFjazovLy8uLi9pb3RhLXBpY28tcG93LXdlYmdsL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wa2cvYm9vdHN0cmFwLmpzIiwid2VicGFjazovLy8uLi9zcmMvaW5kZXgtYWxsLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbG9nZ2Vycy9jb25zb2xlTG9nZ2VyLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbmV0d29yay9uZXR3b3JrRW5kUG9pbnQudHMiLCJ3ZWJwYWNrOi8vLy4uL2lvdGEtcGljby1jb3JlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vaW90YS1waWNvLWNvcmUvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2lvdGEtcGljby1jb3JlL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9jb252ZXJ0ZXJzL29iamVjdFRyeXRlc0NvbnZlcnRlci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2NsaWVudC9hcGlDbGllbnQudHMiLCJ3ZWJwYWNrOi8vLy4uL2lvdGEtcGljby1hcGkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9pb3RhLXBpY28tYXBpL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzIiwid2VicGFjazovLy8uLi9pb3RhLXBpY28tYXBpL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9mYWN0b3JpZXMvcHJvb2ZPZldvcmtGYWN0b3J5LnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbXVsdGlTaWcvbXVsdGlTaWdDbGllbnQudHMiLCJ3ZWJwYWNrOi8vLy4uL2lvdGEtcGljby1idXNpbmVzcy9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vaW90YS1waWNvLWJ1c2luZXNzL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy90cmFuc2FjdGlvbnMvdHJhbnNhY3Rpb25DbGllbnQudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9wYWwudHMiLCJ3ZWJwYWNrOi8vLy4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vaW90YS1waWNvLXBhbC1icm93c2VyL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9wcm9vZk9mV29ya0JveC50cyIsIndlYnBhY2s6Ly8vLi4vaW90YS1waWNvLXBvdy1ib3gvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9pb3RhLXBpY28tcG93LWJveC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vaW90YS1waWNvLXBvdy1ib3gvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3JjL3Byb29mT2ZXb3JrSnMudHMiLCJ3ZWJwYWNrOi8vLy4uL2lvdGEtcGljby1wb3ctanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9pb3RhLXBpY28tcG93LWpzL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzIiwid2VicGFjazovLy8uLi9pb3RhLXBpY28tcG93LWpzL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9wZWFybERpdmVyL3BlYXJsRGl2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9wcm9vZk9mV29ya1dhc20udHMiLCJ3ZWJwYWNrOi8vLy4uL2lvdGEtcGljby1wb3ctd2FzbS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2lvdGEtcGljby1wb3ctd2FzbS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vaW90YS1waWNvLXBvdy13YXNtL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vaW90YS1waWNvLXBvdy13YXNtL3dhc20vaW90YS1waWNvLXBvdy13YXNtLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9wcm9vZk9mV29ya1dlYkdsLnRzIiwid2VicGFjazovLy8uLi9pb3RhLXBpY28tcG93LXdlYmdsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzIiwid2VicGFjazovLy8uLi9pb3RhLXBpY28tcG93LXdlYmdsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9zaGFkZXJzL2FkZC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3NoYWRlcnMvY2hlY2tDb2wudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9zaGFkZXJzL2NoZWNrRG8udHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9zaGFkZXJzL2NoZWNrSy50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3NoYWRlcnMvZmluYWxpemUudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9zaGFkZXJzL2hlYWRlcnMudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9zaGFkZXJzL2luY3JlbWVudC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3NoYWRlcnMvaW5pdC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3NoYWRlcnMvdHJhbnNmb3JtLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvd2ViR0wvd2ViR0xXb3JrZXIudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy93ZWJHTC9zdGRsaWIudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy93ZWJHTC92ZXJ0ZXhTaGFkZXJDb2RlLnRzIiwid2VicGFjazovLy8uLi8uLi9zcmMvd2ViR0wvd2ViR0xIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9wZWFybERpdmVyL3BlYXJsRGl2ZXJTdGF0ZS50cyJdLCJuYW1lcyI6WyJleHBvcnRzIiwiZGVmYXVsdCIsInJlcXVpcmUiLCJNb2R1bGUiLCJtb2R1bGVPdmVycmlkZXMiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsInN0YXR1cyIsInRvVGhyb3ciLCJFTlZJUk9OTUVOVF9JU19XRUIiLCJFTlZJUk9OTUVOVF9JU19XT1JLRVIiLCJFTlZJUk9OTUVOVF9JU19OT0RFIiwiRU5WSVJPTk1FTlRfSVNfU0hFTEwiLCJFcnJvciIsIndpbmRvdyIsImltcG9ydFNjcmlwdHMiLCJwcm9jZXNzIiwibm9kZUZTIiwibm9kZVBhdGgiLCJzaGVsbF9yZWFkIiwiZmlsZW5hbWUiLCJiaW5hcnkiLCJyZXQiLCJ0cnlQYXJzZUFzRGF0YVVSSSIsInRvU3RyaW5nIiwicmVhZEJpbmFyeSIsImJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJhc3NlcnQiLCJsZW5ndGgiLCJyZXBsYWNlIiwic2xpY2UiLCJleCIsIkV4aXRTdGF0dXMiLCJyZWFzb24iLCJwIiwicmVhZCIsImYiLCJkYXRhIiwiaW50QXJyYXlUb1N0cmluZyIsInJlYWRidWZmZXIiLCJzY3JpcHRBcmdzIiwiYXJndW1lbnRzIiwicXVpdCIsInVybCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNlbmQiLCJyZXNwb25zZVRleHQiLCJlcnIiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZSIsInJlYWRBc3luYyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJ4aHJfb25sb2FkIiwidGl0bGUiLCJkb2N1bWVudCIsImNvbnNvbGUiLCJsb2ciLCJwcmludCIsInByaW50RXJyIiwid2FybiIsInVuZGVmaW5lZCIsIlNUQUNLX0FMSUdOIiwic3RhY2tTYXZlIiwic3RhY2tSZXN0b3JlIiwic3RhY2tBbGxvYyIsInNldFRlbXBSZXQwIiwiZ2V0VGVtcFJldDAiLCJhYm9ydCIsInN0YXRpY0FsbG9jIiwic2l6ZSIsInN0YXRpY1NlYWxlZCIsIlNUQVRJQ1RPUCIsImR5bmFtaWNBbGxvYyIsIkRZTkFNSUNUT1BfUFRSIiwiSEVBUDMyIiwiZW5kIiwiVE9UQUxfTUVNT1JZIiwic3VjY2VzcyIsImVubGFyZ2VNZW1vcnkiLCJhbGlnbk1lbW9yeSIsImZhY3RvciIsIk1hdGgiLCJjZWlsIiwiZ2V0TmF0aXZlVHlwZVNpemUiLCJ0eXBlIiwiYml0cyIsInBhcnNlSW50Iiwic3Vic3RyIiwid2Fybk9uY2UiLCJ0ZXh0Iiwic2hvd24iLCJmdW5jdGlvblBvaW50ZXJzIiwiQXJyYXkiLCJhZGRGdW5jdGlvbiIsImZ1bmMiLCJpIiwicmVtb3ZlRnVuY3Rpb24iLCJpbmRleCIsImZ1bmNXcmFwcGVycyIsImdldEZ1bmNXcmFwcGVyIiwic2lnIiwic2lnQ2FjaGUiLCJkeW5DYWxsX3dyYXBwZXIiLCJkeW5DYWxsIiwiYXJnIiwicHJvdG90eXBlIiwiY2FsbCIsIm1ha2VCaWdJbnQiLCJsb3ciLCJoaWdoIiwidW5zaWduZWQiLCJwdHIiLCJhcmdzIiwiYXBwbHkiLCJjb25jYXQiLCJnZXRDb21waWxlclNldHRpbmciLCJuYW1lIiwiUnVudGltZSIsIkdMT0JBTF9CQVNFIiwiQUJPUlQiLCJFWElUU1RBVFVTIiwiY29uZGl0aW9uIiwiZ2xvYmFsU2NvcGUiLCJnZXRDRnVuYyIsImlkZW50IiwiSlNmdW5jcyIsImFyciIsIndyaXRlQXJyYXlUb01lbW9yeSIsInN0ciIsImxlbiIsInN0cmluZ1RvVVRGOCIsInRvQyIsImNjYWxsIiwicmV0dXJuVHlwZSIsImFyZ1R5cGVzIiwib3B0cyIsImNBcmdzIiwic3RhY2siLCJjb252ZXJ0ZXIiLCJQb2ludGVyX3N0cmluZ2lmeSIsImN3cmFwIiwiY2Z1bmMiLCJudW1lcmljQXJncyIsImV2ZXJ5IiwibnVtZXJpY1JldCIsInNldFZhbHVlIiwidmFsdWUiLCJub1NhZmUiLCJjaGFyQXQiLCJIRUFQOCIsIkhFQVAxNiIsInRlbXBJNjQiLCJ0ZW1wRG91YmxlIiwiTWF0aF9hYnMiLCJNYXRoX21pbiIsIk1hdGhfZmxvb3IiLCJNYXRoX2NlaWwiLCJIRUFQRjMyIiwiSEVBUEY2NCIsImdldFZhbHVlIiwiQUxMT0NfTk9STUFMIiwiQUxMT0NfU1RBQ0siLCJBTExPQ19TVEFUSUMiLCJBTExPQ19EWU5BTUlDIiwiQUxMT0NfTk9ORSIsImFsbG9jYXRlIiwic2xhYiIsInR5cGVzIiwiYWxsb2NhdG9yIiwiemVyb2luaXQiLCJzaW5nbGVUeXBlIiwiX21hbGxvYyIsIm1heCIsInN0b3AiLCJzdWJhcnJheSIsIkhFQVBVOCIsInNldCIsInR5cGVTaXplIiwicHJldmlvdXNUeXBlIiwiY3VyciIsImdldE1lbW9yeSIsInJ1bnRpbWVJbml0aWFsaXplZCIsImhhc1V0ZiIsInQiLCJNQVhfQ0hVTksiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJtaW4iLCJVVEY4VG9TdHJpbmciLCJBc2NpaVRvU3RyaW5nIiwiY2giLCJzdHJpbmdUb0FzY2lpIiwib3V0UHRyIiwid3JpdGVBc2NpaVRvTWVtb3J5IiwiVVRGOERlY29kZXIiLCJUZXh0RGVjb2RlciIsIlVURjhBcnJheVRvU3RyaW5nIiwidThBcnJheSIsImlkeCIsImVuZFB0ciIsImRlY29kZSIsInUwIiwidTEiLCJ1MiIsInUzIiwidTQiLCJ1NSIsInN0cmluZ1RvVVRGOEFycmF5Iiwib3V0VThBcnJheSIsIm91dElkeCIsIm1heEJ5dGVzVG9Xcml0ZSIsInN0YXJ0SWR4IiwiZW5kSWR4IiwidSIsImNoYXJDb2RlQXQiLCJsZW5ndGhCeXRlc1VURjgiLCJVVEYxNkRlY29kZXIiLCJVVEYxNlRvU3RyaW5nIiwiY29kZVVuaXQiLCJzdHJpbmdUb1VURjE2Iiwic3RhcnRQdHIiLCJudW1DaGFyc1RvV3JpdGUiLCJsZW5ndGhCeXRlc1VURjE2IiwiVVRGMzJUb1N0cmluZyIsInV0ZjMyIiwic3RyaW5nVG9VVEYzMiIsInRyYWlsU3Vycm9nYXRlIiwibGVuZ3RoQnl0ZXNVVEYzMiIsImFsbG9jYXRlVVRGOCIsImFsbG9jYXRlVVRGOE9uU3RhY2siLCJkZW1hbmdsZSIsImRlbWFuZ2xlQWxsIiwicmVnZXgiLCJ4IiwieSIsImpzU3RhY2tUcmFjZSIsImUiLCJzdGFja1RyYWNlIiwianMiLCJQQUdFX1NJWkUiLCJXQVNNX1BBR0VfU0laRSIsIkFTTUpTX1BBR0VfU0laRSIsIk1JTl9UT1RBTF9NRU1PUlkiLCJhbGlnblVwIiwibXVsdGlwbGUiLCJIRUFQIiwiSEVBUFUxNiIsIkhFQVBVMzIiLCJ1cGRhdGVHbG9iYWxCdWZmZXIiLCJidWYiLCJ1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cyIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIlNUQVRJQ19CQVNFIiwiU1RBQ0tfQkFTRSIsIlNUQUNLVE9QIiwiU1RBQ0tfTUFYIiwiRFlOQU1JQ19CQVNFIiwid3JpdGVTdGFja0Nvb2tpZSIsImNoZWNrU3RhY2tDb29raWUiLCJhYm9ydFN0YWNrT3ZlcmZsb3ciLCJhbGxvY1NpemUiLCJhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeSIsIlRPVEFMX1NUQUNLIiwiYnl0ZUxlbmd0aCIsIldlYkFzc2VtYmx5IiwiTWVtb3J5IiwiQXJyYXlCdWZmZXIiLCJnZXRUb3RhbE1lbW9yeSIsImNhbGxSdW50aW1lQ2FsbGJhY2tzIiwiY2FsbGJhY2tzIiwiY2FsbGJhY2siLCJzaGlmdCIsIl9fQVRQUkVSVU5fXyIsIl9fQVRJTklUX18iLCJfX0FUTUFJTl9fIiwiX19BVEVYSVRfXyIsIl9fQVRQT1NUUlVOX18iLCJydW50aW1lRXhpdGVkIiwicHJlUnVuIiwiYWRkT25QcmVSdW4iLCJlbnN1cmVJbml0UnVudGltZSIsInByZU1haW4iLCJleGl0UnVudGltZSIsInBvc3RSdW4iLCJhZGRPblBvc3RSdW4iLCJjYiIsInVuc2hpZnQiLCJhZGRPbkluaXQiLCJhZGRPblByZU1haW4iLCJhZGRPbkV4aXQiLCJ3cml0ZVN0cmluZ1RvTWVtb3J5Iiwic3RyaW5nIiwiZG9udEFkZE51bGwiLCJsYXN0Q2hhciIsIkluZmluaXR5IiwiYXJyYXkiLCJ1blNpZ24iLCJpZ25vcmUiLCJhYnMiLCJwb3ciLCJyZVNpZ24iLCJoYWxmIiwiTWF0aF9jb3MiLCJjb3MiLCJNYXRoX3NpbiIsInNpbiIsIk1hdGhfdGFuIiwidGFuIiwiTWF0aF9hY29zIiwiYWNvcyIsIk1hdGhfYXNpbiIsImFzaW4iLCJNYXRoX2F0YW4iLCJhdGFuIiwiTWF0aF9hdGFuMiIsImF0YW4yIiwiTWF0aF9leHAiLCJleHAiLCJNYXRoX2xvZyIsIk1hdGhfc3FydCIsInNxcnQiLCJmbG9vciIsIk1hdGhfcG93IiwiTWF0aF9pbXVsIiwiaW11bCIsIk1hdGhfZnJvdW5kIiwiZnJvdW5kIiwiTWF0aF9yb3VuZCIsInJvdW5kIiwiTWF0aF9tYXgiLCJNYXRoX2NsejMyIiwiY2x6MzIiLCJNYXRoX3RydW5jIiwidHJ1bmMiLCJydW5EZXBlbmRlbmNpZXMiLCJydW5EZXBlbmRlbmN5V2F0Y2hlciIsImRlcGVuZGVuY2llc0Z1bGZpbGxlZCIsInJ1bkRlcGVuZGVuY3lUcmFja2luZyIsImdldFVuaXF1ZVJ1bkRlcGVuZGVuY3kiLCJpZCIsIm9yaWciLCJyYW5kb20iLCJhZGRSdW5EZXBlbmRlbmN5Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiZGVwIiwicmVtb3ZlUnVuRGVwZW5kZW5jeSIsIm1lbW9yeUluaXRpYWxpemVyIiwiRlMiLCJlcnJvciIsImluaXQiLCJjcmVhdGVEYXRhRmlsZSIsImNyZWF0ZVByZWxvYWRlZEZpbGUiLCJjcmVhdGVMYXp5RmlsZSIsIm1rZGV2IiwicmVnaXN0ZXJEZXZpY2UiLCJhbmFseXplUGF0aCIsImxvYWRGaWxlc0Zyb21EQiIsIkVycm5vRXJyb3IiLCJkYXRhVVJJUHJlZml4IiwiaXNEYXRhVVJJIiwic3RhcnRzV2l0aCIsImluZGV4T2YiLCJpbnRlZ3JhdGVXYXNtSlMiLCJtZXRob2QiLCJ3YXNtVGV4dEZpbGUiLCJ3YXNtQmluYXJ5RmlsZSIsImFzbWpzQ29kZUZpbGUiLCJ3YXNtUGFnZVNpemUiLCJpbmZvIiwibWVyZ2VNZW1vcnkiLCJuZXdCdWZmZXIiLCJvbGRCdWZmZXIiLCJvbGRWaWV3IiwibmV3VmlldyIsImZpeEltcG9ydHMiLCJpbXBvcnRzIiwiZ2V0QmluYXJ5IiwiZ2V0QmluYXJ5UHJvbWlzZSIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJ0aGVuIiwiY2F0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImRvTmF0aXZlV2FzbSIsImdsb2JhbCIsImVudiIsInByb3ZpZGVkQnVmZmVyIiwiTmFOIiwicmVjZWl2ZUluc3RhbmNlIiwiaW5zdGFuY2UiLCJtb2R1bGUiLCJtZW1vcnkiLCJ0cnVlTW9kdWxlIiwicmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZSIsIm91dHB1dCIsImluc3RhbnRpYXRlQXJyYXlCdWZmZXIiLCJyZWNlaXZlciIsImluc3RhbnRpYXRlIiwiaW5zdGFudGlhdGVTdHJlYW1pbmciLCJhc21qc1JlYWxsb2NCdWZmZXIiLCJ3YXNtUmVhbGxvY0J1ZmZlciIsIlBBR0VfTVVMVElQTEUiLCJvbGQiLCJvbGRTaXplIiwicmVzdWx0IiwiZ3JvdyIsImZpbmFsTWV0aG9kIiwiVEFCTEVfU0laRSIsIk1BWF9UQUJMRV9TSVpFIiwiVGFibGUiLCJlbGVtZW50IiwibWV0aG9kSGFuZGxlciIsIkFTTV9DT05TVFMiLCJwdXNoIiwiU1RBVElDX0JVTVAiLCJ0ZW1wRG91YmxlUHRyIiwiY29weVRlbXBGbG9hdCIsImNvcHlUZW1wRG91YmxlIiwiX19fbG9jayIsIlNZU0NBTExTIiwidmFyYXJncyIsImdldCIsImdldFN0ciIsImdldDY0IiwiZ2V0WmVybyIsIl9fX3N5c2NhbGwxNDAiLCJ3aGljaCIsInN0cmVhbSIsImdldFN0cmVhbUZyb21GRCIsIm9mZnNldF9oaWdoIiwib2Zmc2V0X2xvdyIsIndoZW5jZSIsIm9mZnNldCIsImxsc2VlayIsInBvc2l0aW9uIiwiZ2V0ZGVudHMiLCJlcnJubyIsImZsdXNoX05PX0ZJTEVTWVNURU0iLCJmZmx1c2giLCJwcmludENoYXIiLCJfX19zeXNjYWxsMTQ2IiwiYnVmZmVycyIsImlvdiIsImlvdmNudCIsImoiLCJfX19zeXNjYWxsNTQiLCJfX19zeXNjYWxsNiIsImNsb3NlIiwiX19fdW5sb2NrIiwiX2Vtc2NyaXB0ZW5faGFzX3RocmVhZGluZ19zdXBwb3J0IiwiY3R0el9pOCIsIl9sbHZtX2N0dHpfaTMyIiwiX2xsdm1fY3R0el9pNjQiLCJsIiwiaCIsIl9sbHZtX3N0YWNrcmVzdG9yZSIsInNlbGYiLCJfbGx2bV9zdGFja3NhdmUiLCJMTFZNX1NBVkVEU1RBQ0tTIiwic3BsaWNlIiwiX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyIsImRlc3QiLCJzcmMiLCJudW0iLCJfcHRocmVhZF9jcmVhdGUiLCJfcHRocmVhZF9qb2luIiwiX3B0aHJlYWRfbXV0ZXhfaW5pdCIsIl9fX3NldEVyck5vIiwiRVJSTk9fQ09ERVMiLCJFUEVSTSIsIkVOT0VOVCIsIkVTUkNIIiwiRUlOVFIiLCJFSU8iLCJFTlhJTyIsIkUyQklHIiwiRU5PRVhFQyIsIkVCQURGIiwiRUNISUxEIiwiRUFHQUlOIiwiRVdPVUxEQkxPQ0siLCJFTk9NRU0iLCJFQUNDRVMiLCJFRkFVTFQiLCJFTk9UQkxLIiwiRUJVU1kiLCJFRVhJU1QiLCJFWERFViIsIkVOT0RFViIsIkVOT1RESVIiLCJFSVNESVIiLCJFSU5WQUwiLCJFTkZJTEUiLCJFTUZJTEUiLCJFTk9UVFkiLCJFVFhUQlNZIiwiRUZCSUciLCJFTk9TUEMiLCJFU1BJUEUiLCJFUk9GUyIsIkVNTElOSyIsIkVQSVBFIiwiRURPTSIsIkVSQU5HRSIsIkVOT01TRyIsIkVJRFJNIiwiRUNIUk5HIiwiRUwyTlNZTkMiLCJFTDNITFQiLCJFTDNSU1QiLCJFTE5STkciLCJFVU5BVENIIiwiRU5PQ1NJIiwiRUwySExUIiwiRURFQURMSyIsIkVOT0xDSyIsIkVCQURFIiwiRUJBRFIiLCJFWEZVTEwiLCJFTk9BTk8iLCJFQkFEUlFDIiwiRUJBRFNMVCIsIkVERUFETE9DSyIsIkVCRk9OVCIsIkVOT1NUUiIsIkVOT0RBVEEiLCJFVElNRSIsIkVOT1NSIiwiRU5PTkVUIiwiRU5PUEtHIiwiRVJFTU9URSIsIkVOT0xJTksiLCJFQURWIiwiRVNSTU5UIiwiRUNPTU0iLCJFUFJPVE8iLCJFTVVMVElIT1AiLCJFRE9URE9UIiwiRUJBRE1TRyIsIkVOT1RVTklRIiwiRUJBREZEIiwiRVJFTUNIRyIsIkVMSUJBQ0MiLCJFTElCQkFEIiwiRUxJQlNDTiIsIkVMSUJNQVgiLCJFTElCRVhFQyIsIkVOT1NZUyIsIkVOT1RFTVBUWSIsIkVOQU1FVE9PTE9ORyIsIkVMT09QIiwiRU9QTk9UU1VQUCIsIkVQRk5PU1VQUE9SVCIsIkVDT05OUkVTRVQiLCJFTk9CVUZTIiwiRUFGTk9TVVBQT1JUIiwiRVBST1RPVFlQRSIsIkVOT1RTT0NLIiwiRU5PUFJPVE9PUFQiLCJFU0hVVERPV04iLCJFQ09OTlJFRlVTRUQiLCJFQUREUklOVVNFIiwiRUNPTk5BQk9SVEVEIiwiRU5FVFVOUkVBQ0giLCJFTkVURE9XTiIsIkVUSU1FRE9VVCIsIkVIT1NURE9XTiIsIkVIT1NUVU5SRUFDSCIsIkVJTlBST0dSRVNTIiwiRUFMUkVBRFkiLCJFREVTVEFERFJSRVEiLCJFTVNHU0laRSIsIkVQUk9UT05PU1VQUE9SVCIsIkVTT0NLVE5PU1VQUE9SVCIsIkVBRERSTk9UQVZBSUwiLCJFTkVUUkVTRVQiLCJFSVNDT05OIiwiRU5PVENPTk4iLCJFVE9PTUFOWVJFRlMiLCJFVVNFUlMiLCJFRFFVT1QiLCJFU1RBTEUiLCJFTk9UU1VQIiwiRU5PTUVESVVNIiwiRUlMU0VRIiwiRU9WRVJGTE9XIiwiRUNBTkNFTEVEIiwiRU5PVFJFQ09WRVJBQkxFIiwiRU9XTkVSREVBRCIsIkVTVFJQSVBFIiwiX3N5c2NvbmYiLCJtYXhIZWFwU2l6ZSIsIm5hdmlnYXRvciIsIkFTU0VSVElPTlMiLCJpbnRBcnJheUZyb21TdHJpbmciLCJzdHJpbmd5IiwidThhcnJheSIsIm51bUJ5dGVzV3JpdHRlbiIsImNociIsImpvaW4iLCJkZWNvZGVCYXNlNjQiLCJhdG9iIiwiaW5wdXQiLCJrZXlTdHIiLCJjaHIxIiwiY2hyMiIsImNocjMiLCJlbmMxIiwiZW5jMiIsImVuYzMiLCJlbmM0IiwiaW50QXJyYXlGcm9tQmFzZTY0IiwicyIsIkJ1ZmZlciIsImZyb20iLCJfIiwiYnl0ZU9mZnNldCIsImRlY29kZWQiLCJieXRlcyIsIm51bGxGdW5jX2lpIiwibnVsbEZ1bmNfaWlpaSIsImludm9rZV9paSIsImExIiwiaW52b2tlX2lpaWkiLCJhMiIsImEzIiwiYXNtR2xvYmFsQXJnIiwiYXNtTGlicmFyeUFyZyIsImFzbSIsInJlYWxfX19fZXJybm9fbG9jYXRpb24iLCJyZWFsX19jY3VybF9wb3ciLCJyZWFsX19mZmx1c2giLCJyZWFsX19mcmVlIiwicmVhbF9fbGx2bV9ic3dhcF9pMzIiLCJyZWFsX19tYWxsb2MiLCJyZWFsX19wdGhyZWFkX211dGV4X2xvY2siLCJyZWFsX19wdGhyZWFkX211dGV4X3VubG9jayIsInJlYWxfX3NicmsiLCJyZWFsX2VzdGFibGlzaFN0YWNrU3BhY2UiLCJyZWFsX2dldFRlbXBSZXQwIiwicmVhbF9zZXRUZW1wUmV0MCIsInJlYWxfc2V0VGhyZXciLCJyZWFsX3N0YWNrQWxsb2MiLCJyZWFsX3N0YWNrUmVzdG9yZSIsInJlYWxfc3RhY2tTYXZlIiwiX19fZXJybm9fbG9jYXRpb24iLCJfY2N1cmxfcG93IiwiX2ZmbHVzaCIsIl9mcmVlIiwiX2xsdm1fYnN3YXBfaTMyIiwiX21lbWNweSIsIl9tZW1zZXQiLCJfcHRocmVhZF9tdXRleF9sb2NrIiwiX3B0aHJlYWRfbXV0ZXhfdW5sb2NrIiwiX3NicmsiLCJlc3RhYmxpc2hTdGFja1NwYWNlIiwicnVuUG9zdFNldHMiLCJzZXRUaHJldyIsImR5bkNhbGxfaWkiLCJkeW5DYWxsX2lpaWkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIm1lc3NhZ2UiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxTdGFja1RvcCIsImNhbGxlZE1haW4iLCJydW5DYWxsZXIiLCJydW4iLCJkb1J1biIsInNldFRpbWVvdXQiLCJjaGVja1VuZmx1c2hlZENvbnRlbnQiLCJoYXMiLCJmbHVzaCIsImV4aXQiLCJpbXBsaWNpdCIsImFib3J0RGVjb3JhdG9ycyIsIndoYXQiLCJKU09OIiwic3RyaW5naWZ5IiwiZXh0cmEiLCJmb3JFYWNoIiwiZGVjb3JhdG9yIiwicG9wIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxREE7Ozs7Ozs7Ozs7Ozs7O0FBTXlCOzs7Ozs0QkFBVztBQUN0QixhQUFNLFVBQVMsUUFBUyxVQUNsQztBQUFDO0FBT3FCOzs7Ozs7Ozs2QkFBVztBQUN2QixhQUFNLFVBQVMsUUFBUyxVQUN6QixZQUFRLFFBQU8sUUFBTyxXQUFhLFlBQUksQ0FBTSxNQUFRLFFBQzlEO0FBQUM7QUFRbUI7Ozs7Ozs7OzsyQkFBVyxPQUEyQjtBQUN0RCxVQUFvQixpQkFB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R0FBZSxPQUFVO0FBQ2xDLFVBQUcsTUFBTTtBQUNULFVBQUcsTUFBTTtBQUNULFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFlBQVEsTUFBSSxNQUFTLENBQVosR0FBZSxPQUFVO0FBQ2xDLFlBQVEsTUFBSSxNQUFTLENBQVosR0FBZSxPQUFVO0FBQ2xDLFVBQUcsTUFBTTtBQUNULFVBQUcsTUFBTTtBQUNULFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFlBQVEsTUFBSSxNQUFTLENBQVosR0FBZSxPQUFVO0FBQ2xDLFlBQVEsTUFBSSxNQUFTLENBQVosR0FBZSxPQUFVO0FBQ2xDLFVBQUcsTUFBTTtBQUNULFVBQUcsTUFBTTtBQUNULFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFlBQVEsTUFBSSxNQUFTLENBQVosR0FBZSxPQUFVO0FBQ2xDLFlBQVEsTUFBSSxNQUFTLENBQVosR0FBZSxPQUFVO0FBQ2xDLFVBQUcsTUFBTTtBQUNULFVBQUcsTUFBTTtBQUNULFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUNWLFVBQUksT0FBTTtBQUVULGFBQUksRUFBSTtBQUNSLGFBQUksRUFBSTtBQUNQLGNBQUssRUFBSSxPQUFTLENBQWYsR0FBaUIsRUFBSSxRQUFTO0FB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LENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBRyxLQUFRLEtBQUMsQ0FBRyxLQUFPO0FBQ3RCLFVBQUcsS0FBUSxLQUFDLENBQUcsS0FBTztBQUN0QixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUcsS0FBUSxLQUFDLENBQUcsS0FBTztBQUN0QixVQUFHLEtBQVEsS0FBQyxDQUFHLEtBQU87QUFDdEIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUUxQixVQUFHLE1BQVEsS0FBZ0IsZ0JBQUk7QUFDL0IsVUFBRyxNQUFRLEtBQWdCLGdC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QTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQSxxQkFBcUIsY0FBYzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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O0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0FBbkcsRUFBcUcsQ0FBckcsRUFBdUcsQ0FBdkcsRUFBeUcsQ0FBekcsRUFBMkcsQ0FBM0csRUFBNkcsQ0FBN0csRUFBK0csQ0FBL0csRUFBaUgsQ0FBakgsRUFBbUgsQ0FBbkgsRUFBcUgsQ0FBckgsRUFBdUgsQ0FBdkgsRUFBeUgsQ0FBekgsRUFBMkgsQ0FBM0gsRUFBNkgsQ0FBN0gsRUFBK0gsQ0FBL0gsRUFBaUksQ0FBakksRUFBbUksQ0FBbkksRUFBcUksQ0FBckksRUFBdUksQ0FBdkksRUFBeUksQ0FBekksRUFBMkksQ0FBM0ksRUFBNkksQ0FBN0ksRUFBK0ksQ0FBL0ksRUFBaUosQ0FBakosRUFBbUosQ0FBbkosRUFBcUosQ0FBckosRUFBdUosQ0FBdkosRUFBeUosQ0FBekosRUFBMkosQ0FBM0osRUFBNkosQ0FBN0osRUFBK0osQ0FBL0osRUFBaUssQ0FBakssRUFBbUssQ0FBbkssRUFBcUssQ0FBckssRUFBdUssQ0FBdkssRUFBeUssQ0FBekssRUFBMkssQ0FBM0ssRUFBNkssQ0FBN0ssRUFBK0ssQ0FBL0ssRUFBaUwsQ0FBakwsRUFBbUwsQ0FBbkwsRUFBcUwsQ0FBckwsRUFBdUwsQ0FBdkwsRUFBeUwsQ0FBekwsRUFBMkwsQ0FBM0wsRUFBNkwsQ0FBN0wsRUFBK0wsQ0FBL0wsRUFBaU0sQ0FBak0sRUFBbU0sQ0FBbk0sRUFBcU0sQ0FBck0sRUFBdU0sQ0FBdk0sRUFBeU0sQ0FBek0sRUFBMk0sQ0FBM00sRUFBNk0sQ0FBN00sRUFBK00sQ0FBL00sRUFBaU4sQ0FBak4sRUFBbU4sQ0FBbk4sRUFBcU4sQ0FBck4sRUFBdU4sQ0FBdk4sRUFBeU4sQ0FBek4sRUFBMk4sQ0FBM04sRUFBNk4sQ0FBN04sRUFBK04sQ0FBL04sRUFBaU8sQ0FBak8sRUFBbU8sQ0FBbk8sRUFBcU8sQ0FBck8sRUFBdU8sQ0FBdk8sRUFBeU8sQ0FBek8sRUFBMk8sQ0FBM08sRUFBNk8sQ0FBN08sRUFBK08sQ0FBL08sRUFBaVAsQ0FBalAsRUFBbVAsQ0FBblAsRUFBcVAsQ0FBclAsRUFBdVAsQ0FBdlAsRUFBeVAsQ0FBelAsRUFBMlAsQ0FBM1AsRUFBNlAsQ0FBN1AsRUFBK1AsQ0FBL1AsRUFBaVEsQ0FBalEsRUFBbVEsQ0FBblEsRUFBcVEsQ0FBclEsRUFBdVEsQ0FBdlEsRUFBeVEsQ0FBelEsRUFBMlEsQ0FBM1EsRUFBNlEsQ0FBN1EsRUFBK1EsQ0FBL1EsRUFBaVIsQ0FBalIsRUFBbVIsQ0FBblIsRUFBcVIsQ0FBclIsRUFBdVIsQ0FBdlIsRUFBeVIsQ0FBelIsRUFBMlIsQ0FBM1IsRUFBNlIsQ0FBN1IsRUFBK1IsQ0FBL1IsRUFBaVMsQ0FBalMsRUFBbVMsQ0FBblMsRUFBcVMsQ0FBclMsRUFBdVMsQ0FBdlMsRUFBeVMsQ0FBelMsRUFBMlMsQ0FBM1MsRUFBNlMsQ0FBN1MsRUFBK1MsQ0FBL1MsRUFBaVQsQ0FBalQsRUFBbVQsQ0FBblQsRUFBcVQsQ0FBclQsRUFBdVQsQ0FBdlQsRUFBeVQsQ0FBelQsRUFBMlQsQ0FBM1QsRUFBNlQsQ0FBN1QsRUFBK1QsQ0FBL1QsRUFBaVUsQ0FBalUsRUFBbVUsQ0FBblUsRUFBcVUsQ0FBclUsRUFBdVUsQ0FBdlUsRUFBeVUsQ0FBelUsRUFBMlUsQ0FBM1UsRUFBNlUsQ0FBN1UsRUFBK1UsQ0FBL1UsRUFBaVYsQ0FBalYsRUFBbVYsQ0FBblYsRUFBcVYsQ0FBclYsRUFBdVYsQ0FBdlYsRUFBeVYsQ0FBelYsRUFBMlYsQ0FBM1YsRUFBNlYsQ0FBN1YsRUFBK1YsQ0FBL1YsRUFBaVcsQ0FBalcsRUFBbVcsQ0FBblcsRUFBcVcsQ0FBclcsRUFBdVcsQ0FBdlcsRUFBeVcsQ0FBelcsRUFBMlcsQ0FBM1csRUFBNlcsQ0FBN1csRUFBK1csQ0FBL1csRUFBaVgsQ0FBalgsRUFBbVgsQ0FBblgsRUFBcVgsQ0FBclgsRUFBdVgsQ0FBdlgsRUFBeVgsQ0FBelgsRUFBMlgsQ0FBM1gsRUFBNlgsQ0FBN1gsRUFBK1gsQ0FBL1gsRUFBaVksQ0FBalksRUFBbVksQ0FBblksRUFBcVksQ0FBclksRUFBdVksQ0FBdlksRUFBeVksQ0FBelksRUFBMlksQ0FBM1ksRUFBNlksQ0FBN1ksRUFBK1ks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Q0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0UsZUFBTyxNQUFQOztBQUNGLFdBQUssRUFBTDtBQUNFLGVBQU8sQ0FBUDs7QUFDRixXQUFLLEVBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDRSxlQUFPLENBQUMsQ0FBUjs7QUFDRixXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLENBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLENBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDRSxlQUFPLENBQVA7O0FBQ0YsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxDQUFMO0FBQ0UsZUFBTyxJQUFQOztBQUNGLFdBQUssRUFBTDtBQUNBLFdBQUssRUFBTDtBQUNBLFdBQUssRUFBTDtBQUNFLGVBQU8sRUFBUDs7QUFDRixXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDRSxlQUFPLFVBQVA7O0FBQ0YsV0FBSyxFQUFMO0FBQ0EsV0FBSyxDQUFMO0FBQ0UsZUFBTyxLQUFQOztBQUNGLFdBQUssRUFBTDtBQUNBLFdBQUssRUFBTDtBQUNFLGVBQU8sRUFBUDs7QUFDRixXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDRSxlQUFPLElBQVA7O0FBQ0YsV0FBSyxDQUFMO0FBQVEsZUFBTyxPQUFQOztBQUNSLFdBQUssQ0FBTDtBQUFRLGVBQU8sS0FBUDs7QUFDUixXQUFLLEVBQUw7QUFBUyxlQUFPLEtBQVA7O0FBQ1QsV0FBSyxFQUFMO0FBQVMsZUFBTyxLQUFQOztBQUNULFdBQUssRUFBTDtBQUFTLGVBQU8sS0FBUDs7QUFDVCxXQUFLLEVBQUw7QUFBUyxlQUFPLElBQVA7O0FBQ1QsV0FBSyxFQUFMO0FBQVMsZUFBTyxHQUFQOztBQUNULFdBQUssRUFBTDtBQUFTLGVBQU8sR0FBUDs7QUFDVCxXQUFLLEVBQUw7QUFBUyxlQUFPLEdBQVA7O0FBQ1QsV0FBSyxDQUFMO0FBQVEsZUFBTyxHQUFQOztBQUNSLFdBQUssR0FBTDtBQUFVLGVBQU8sRUFBUDs7QUFDVixXQUFLLEVBQUw7QUFBUyxlQUFPLEVBQVA7O0FBQ1QsV0FBSyxDQUFMO0FBQVEsZUFBTyxFQUFQOztBQUNSLFdBQUssQ0FBTDtBQUFRLGVBQU8sQ0FBUDs7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFZLGFBQWU7QUFFOUMsU0FBcUIscUJBQUcsR0FBWSxhQUFJLEdBQWtCLG1CQUFJLEdBQVcsWUFBUyxTQUFLLElBRS9COztBQUMxRCxVQUF1QixvQkFBSyxHQUF1Qix1QkFBRyxHQUFjOztBQUVqRSxVQUFrQixzQkFBTyxHQUFzQixzQkFBRTtBQUNoRCxjQUFNLElBQUksY0FBVyxZQUN6QjtBQUNKO0FBQ0g7Ozs7OztBQXpGRCxzQkF5RkMsWTs7Ozs7Ozs7O0FDL0ZFOzs7O0FBQ0gsSUFJQzs7QUFKRCxXQUEyQjtBQUN2QixrREFBUztBQUNULHNEQUFhO0FBQ2IseURBQ0o7QUFBQyxHQUowQixrQkFBZixRQUFlLG9CQUFmLFFBQWUsa0JBSTFCLEsiLCJmaWxlIjoiaW90YS1waWNvLWxpYi1icm93c2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiYmlnLWludGVnZXJcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJAaW90YS1waWNvL2xpYi1icm93c2VyXCIsIFtcImJpZy1pbnRlZ2VyXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkBpb3RhLXBpY28vbGliLWJyb3dzZXJcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJiaWctaW50ZWdlclwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiSW90YVBpY29cIl0gPSBmYWN0b3J5KHJvb3RbXCJiaWdJbnRcIl0pO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMzhfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1Mik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgODhkZjQ2MTEwZTZkY2FmOWE1NGUiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBPYmplY3QgaGVscGVyIG1ldGhvZHMuXHJcbiAqL1xyXG5jbGFzcyBPYmplY3RIZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgZW1wdHkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRW1wdHkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGFuIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBmYWxzZSA6IHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGFuIG9iamVjdCBpZiBnaXZlbiB0eXBlLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0LlxyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIG9iamVjdFxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzVHlwZSh2YWx1ZSwgdHlwZUNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVDbGFzc05hbWUgPSBPYmplY3RIZWxwZXIuZ2V0Q2xhc3NOYW1lKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWVDbGFzc05hbWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZUNsYXNzTmFtZSA9PT0gT2JqZWN0SGVscGVyLmdldENsYXNzTmFtZSh0eXBlQ29uc3RydWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNsYXNzIG5hbWUgb2YgYW4gb2JqZWN0IGlmIGl0IGhhcyBvbmUuXHJcbiAgICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gZ2V0IHRoZSBjbGFzcyBuYW1lIGZvci5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjbGFzcyBuYW1lIGlmIGl0IGhhcyBvbmUgb3IgdW5kZWZpbmVkIGlmIG5vdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldENsYXNzTmFtZShvYmplY3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHR5cGVvZiBvYmplY3QgPT09IFwiZnVuY3Rpb25cIiA/IG9iamVjdC50b1N0cmluZygpIDogb2JqZWN0LmNvbnN0cnVjdG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBjb25zdHJ1Y3Rvci5tYXRjaCgvXFx3Ky9nKTtcclxuICAgICAgICAgICAgcmV0dXJuIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSkgPyByZXN1bHRzWzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLk9iamVjdEhlbHBlciA9IE9iamVjdEhlbHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYjJKcVpXTjBTR1ZzY0dWeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJobGJIQmxjbk12YjJKcVpXTjBTR1ZzY0dWeUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVRzN1IwRkZSenRCUVVOSU8wbEJRMGs3T3pzN1QwRkpSenRKUVVOSkxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCVlR0UlFVTTFRaXhOUVVGTkxFTkJRVU1zUzBGQlN5eExRVUZMTEVsQlFVa3NTVUZCU1N4TFFVRkxMRXRCUVVzc1UwRkJVeXhEUVVGRE8wbEJRMnBFTEVOQlFVTTdTVUZGUkRzN096dFBRVWxITzBsQlEwa3NUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJReXhMUVVGVk8xRkJRemRDTEUxQlFVMHNRMEZCUXl4TFFVRkxMRXRCUVVzc1NVRkJTU3hKUVVGSkxFdEJRVXNzUzBGQlN5eFRRVUZUTzFsQlEzaERMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhSUVVGUkxFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRM1JGTEVOQlFVTTdTVUZGUkRzN096czdUMEZMUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlZTeEZRVUZGTEdWQlFYbENPMUZCUTNSRUxFMUJRVTBzWTBGQll5eEhRVUZITEZsQlFWa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03VVVGRGVFUXNUVUZCVFN4RFFVRkRMR05CUVdNc1MwRkJTeXhUUVVGVExFbEJRVWtzWTBGQll5eExRVUZMTEZsQlFWa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU03U1VGRGVrY3NRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1dVRkJXU3hEUVVGRExFMUJRVmM3VVVGRGJFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hMUVVGTExFbEJRVWtzU1VGQlNTeE5RVUZOTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNeFF5eE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRPMUZCUTNKQ0xFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTktMRTFCUVUwc1YwRkJWeXhIUVVGSExFOUJRVThzVFVGQlRTeExRVUZMTEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1YwRkJWeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzFsQlEzSkhMRTFCUVUwc1QwRkJUeXhIUVVGSExGZEJRVmNzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1dVRkRNVU1zVFVGQlRTeERRVUZETEVOQlFVTXNUMEZCVHl4SlFVRkpMRTlCUVU4c1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRPMUZCUTNCRkxFTkJRVU03U1VGRFRDeERRVUZETzBOQlEwbzdRVUUzUTBRc2IwTkJOa05ESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvaGVscGVycy9vYmplY3RIZWxwZXIudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBzdHJpbmdIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL3N0cmluZ0hlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG4vKipcclxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgdHJ5dGVzLlxyXG4gKi9cclxuY2xhc3MgVHJ5dGVzIHtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IodHJ5dGVzKSB7XHJcbiAgICAgICAgdGhpcy5fdHJ5dGVzID0gdHJ5dGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdHJ5dGVzIGZyb20gYSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgQSBzdHJpbmcgdG8gY3JlYXRlIHRoZSB0cnl0ZXMgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggQW4gb3B0aW9uYWwgdmFsaWRhdGlvbiBsZW5ndGggZm9yIHRoZSB0cnl0ZXMsIDAgbWVhbnMgaWdub3JlIGxlbmd0aC5cclxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUsIGxlbmd0aCA9IDApIHtcclxuICAgICAgICBpZiAoIXN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSB2YWx1ZSBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIGxlbmd0aCBtdXN0IGJlID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghVHJ5dGVzLmlzVmFsaWQodmFsdWUsIGxlbmd0aCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSB2YWx1ZSBhbmQgbGVuZ3RoIGRvIG5vdCBjb250YWluIHZhbGlkIHRyeXRlc1wiLCB7IHZhbHVlLCBsZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJ5dGVzKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRG9lcyB0aGUgdmFsdWUgY29udGFpbiB2YWxpZCB0cnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgQSBzdHJpbmcgdG8gdmFsaWRhdGUgYXMgdHJ5dGVzLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBBbiBvcHRpb25hbCB2YWxpZGF0aW9uIGxlbmd0aCBmb3IgdGhlIHRyeXRlcywgMCBtZWFucyBpZ25vcmUgbGVuZ3RoLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgaW5wdXQgd2FzIHZhbGlkIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzVmFsaWQodmFsdWUsIGxlbmd0aCA9IDApIHtcclxuICAgICAgICBpZiAoIXN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5bOUEtWl17JHtsZW5ndGggPyBsZW5ndGggOiBcIjAsXCJ9fSRgKS50ZXN0KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIHRyeXRlcyB0byBhIHN0cmluZy5cclxuICAgICAqIEByZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJ5dGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgdHJ5dGVzLlxyXG4gICAgICogQHJldHVybnMgVGhlIGxlbmd0aCBvZiB0aGUgdHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBsZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyeXRlcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIHN1YiBvZiB0aGUgdHJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbiB0byBnZXQgdGhlIHN1Yi5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgc3ViLlxyXG4gICAgICogQHJldHVybnMgVGhlIHRyeXRlcyBzdWIuXHJcbiAgICAgKi9cclxuICAgIHN1YihzdGFydCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHN0YXJ0KSB8fCBzdGFydCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBzdGFydCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IChzdGFydCArIGxlbmd0aCkgPiB0aGlzLl90cnl0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBzdGFydCArIGxlbmd0aCBtdXN0IDw9ICR7dGhpcy5fdHJ5dGVzLmxlbmd0aH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFRyeXRlcy5mcm9tU3RyaW5nKHRoaXMuX3RyeXRlcy5zdWJzdHIoc3RhcnQsIGxlbmd0aCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbGwgdGhlIGNoYXJhY3RlcnMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0cnl0ZXMuXHJcbiAqL1xyXG5Ucnl0ZXMuQUxQSEFCRVQgPSBcIjlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xyXG5leHBvcnRzLlRyeXRlcyA9IFRyeXRlcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEhKNWRHVnpMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyUmhkR0V2ZEhKNWRHVnpMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFTdzBSVUZCZVVVN1FVRkRla1VzTkVWQlFYbEZPMEZCUTNwRkxHdEVRVUVyUXp0QlFVVXZRenM3UjBGRlJ6dEJRVU5JTzBsQlUwa3NaVUZCWlR0SlFVTm1MRmxCUVc5Q0xFMUJRV003VVVGRE9VSXNTVUZCU1N4RFFVRkRMRTlCUVU4c1IwRkJSeXhOUVVGTkxFTkJRVU03U1VGRE1VSXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eExRVUZoTEVWQlFVVXNVMEZCYVVJc1EwRkJRenRSUVVOMFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOb1F5eE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXh6UTBGQmMwTXNRMEZCUXl4RFFVRkRPMUZCUTJoRkxFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyaEVMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEhsQ1FVRjVRaXhEUVVGRExFTkJRVU03VVVGRGJrUXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4TFFVRkxMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEycERMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEd0RVFVRnJSQ3hGUVVGRkxFVkJRVVVzUzBGQlN5eEZRVUZGTEUxQlFVMHNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRMMFlzUTBGQlF6dFJRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dEpRVU0zUWl4RFFVRkRPMGxCUlVRN096czdPMDlCUzBjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEV0QlFXRXNSVUZCUlN4VFFVRnBRaXhEUVVGRE8xRkJRMjVFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMmhETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1VVRkRha0lzUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTBvc1RVRkJUU3hEUVVGRExFbEJRVWtzVFVGQlRTeERRVUZETEZkQlFWY3NUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NTVUZCU1N4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzFGQlEzcEZMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRPMGxCUTNoQ0xFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hOUVVGTk8xRkJRMVFzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRE8wbEJReTlDTEVOQlFVTTdTVUZGUkRzN096czdUMEZMUnp0SlFVTkpMRWRCUVVjc1EwRkJReXhMUVVGaExFVkJRVVVzVFVGQll6dFJRVU53UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFdEJRVXNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpsRExFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMR2xEUVVGcFF5eERRVUZETEVOQlFVTTdVVUZETTBRc1EwRkJRenRSUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRWRCUVVjc1RVRkJUU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRelZGTEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExEaENRVUU0UWl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVOQlFVTTdVVUZETjBVc1EwRkJRenRSUVVORUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMnBGTEVOQlFVTTdPMEZCTlVWRU96dEhRVVZITzBGQlExY3NaVUZCVVN4SFFVRlhMRFpDUVVFMlFpeERRVUZETzBGQlNtNUZMSGRDUVRoRlF5SjlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL2RhdGEvdHJ5dGVzLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogTnVtYmVyIGhlbHBlciBtZXRob2RzLlxyXG4gKi9cclxuY2xhc3MgTnVtYmVySGVscGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGFuIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QgZm9yIGl0cyBpbnRlZ2VybmVzcy5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIGludGVnZXIuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0ludGVnZXIodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgIU51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGEgbnVtYmVyLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0IGZvciBpdHMgbnVtYmVyeW5lc3MuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBudW1iZXIuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc051bWJlcih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAhTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgYSBmbG9hdCBudW1iZXIgZm9ybWF0dGVkIGFzIGEgc3RyaW5nLCBjYW4gYmUgdXNlZCBmb3IgYmlnIG51bWJlcnMgdGhhdCB3b3VsZCBvdmVyZmxvdyBwYXJzZUZsb2F0LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVja1xyXG4gICAgICogQHJldHVybiBUcnVlIGlmIHRoZSBudW1iZXIgaXMgZm9ybWF0dGVkIGNvcnJlY3RseS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRmxvYXRTdHJpbmcodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gL14tP1xcZCpcXC4/XFxkKyQvLnRlc3QodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgYSBpbnRlZ2VyIG51bWJlciBmb3JtYXR0ZWQgYXMgYSBzdHJpbmcsIGNhbiBiZSB1c2VkIGZvciBiaWcgbnVtYmVycyB0aGF0IHdvdWxkIG92ZXJmbG93IHBhcnNlSW50LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVja1xyXG4gICAgICogQHJldHVybiBUcnVlIGlmIHRoZSBudW1iZXIgaXMgZm9ybWF0dGVkIGNvcnJlY3RseS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzSW50ZWdlclN0cmluZyh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAvXi0/XFxkKyQvLnRlc3QodmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTnVtYmVySGVscGVyID0gTnVtYmVySGVscGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liblZ0WW1WeVNHVnNjR1Z5TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMmhsYkhCbGNuTXZiblZ0WW1WeVNHVnNjR1Z5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHM3UjBGRlJ6dEJRVU5JTzBsQlEwazdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJWVHRSUVVNNVFpeE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRKUVVOeVJpeERRVUZETzBsQlJVUTdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJWVHRSUVVNM1FpeE5RVUZOTEVOQlFVTXNTMEZCU3l4TFFVRkxMRk5CUVZNc1NVRkJTU3hMUVVGTExFdEJRVXNzU1VGQlNTeEpRVUZKTEU5QlFVOHNTMEZCU3l4TFFVRkxMRkZCUVZFc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXp0SlFVTm9TU3hEUVVGRE8wbEJSVVE3T3pzN1QwRkpSenRKUVVOSkxFMUJRVTBzUTBGQlF5eGhRVUZoTEVOQlFVTXNTMEZCWVR0UlFVTnlReXhOUVVGTkxFTkJRVU1zWlVGQlpTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRKUVVOMlF5eERRVUZETzBsQlJVUTdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4bFFVRmxMRU5CUVVNc1MwRkJZVHRSUVVOMlF5eE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dEpRVU5xUXl4RFFVRkRPME5CUTBvN1FVRndRMFFzYjBOQmIwTkRJbjA9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9oZWxwZXJzL251bWJlckhlbHBlci50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY29yZUVycm9yXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvZXJyb3IvY29yZUVycm9yXCIpO1xyXG4vKipcclxuICogQSBkYXRhIGltcGxlbWVudGF0aW9uIG9mIGFuIGVycm9yLlxyXG4gKi9cclxuY2xhc3MgRGF0YUVycm9yIGV4dGVuZHMgY29yZUVycm9yXzEuQ29yZUVycm9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIERhdGFFcnJvci5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIGZvciB0aGUgZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbCBBZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yLlxyXG4gICAgICogQHBhcmFtIGlubmVyRXJyb3IgQWRkIGluZm9ybWF0aW9uIGZyb20gaW5uZXIgZXJyb3IgaWYgdGhlcmUgd2FzIG9uZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgYWRkaXRpb25hbCwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGFkZGl0aW9uYWwsIGlubmVyRXJyb3IpO1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gXCJEYXRhXCI7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5EYXRhRXJyb3IgPSBEYXRhRXJyb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVpHRjBZVVZ5Y205eUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJWeWNtOXlMMlJoZEdGRmNuSnZjaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNiMFZCUVdsRk8wRkJSV3BGT3p0SFFVVkhPMEZCUTBnc1pVRkJkVUlzVTBGQlVTeHhRa0ZCVXp0SlFVTndRenM3T3pzN1QwRkxSenRKUVVOSUxGbEJRVmtzVDBGQlpTeEZRVUZGTEZWQlFXdERMRVZCUVVVc1ZVRkJhMEk3VVVGREwwVXNTMEZCU3l4RFFVRkRMRTlCUVU4c1JVRkJSU3hWUVVGVkxFVkJRVVVzVlVGQlZTeERRVUZETEVOQlFVTTdVVUZEZGtNc1NVRkJTU3hEUVVGRExFMUJRVTBzUjBGQlJ5eE5RVUZOTEVOQlFVTTdTVUZEZWtJc1EwRkJRenREUVVOS08wRkJXRVFzT0VKQlYwTWlmUT09XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9lcnJvci9kYXRhRXJyb3IudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIi4vb2JqZWN0SGVscGVyXCIpO1xyXG4vKipcclxuICogQXJyYXkgaGVscGVyIG1ldGhvZHMuXHJcbiAqL1xyXG5jbGFzcyBBcnJheUhlbHBlciB7XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhbiBhcnJheS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNBcnJheSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8gZmFsc2UgOiBBcnJheS5pc0FycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGEgZW1wdHkgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGVtcHR5IGFycmF5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNFbXB0eSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAhQXJyYXlIZWxwZXIuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgYSBub24gZW1wdHkgYXJyYXkgb2Ygc3BlY2lmaWMgdHlwZS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdC5cclxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBvYmplY3RcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgbm9uIGVtcHR5IGFycmF5IG9mIGEgc3BlY2lmaWMgdHlwZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzVHlwZWQodmFsdWUsIHR5cGUpIHtcclxuICAgICAgICByZXR1cm4gIUFycmF5SGVscGVyLmlzRW1wdHkodmFsdWUpICYmXHJcbiAgICAgICAgICAgICF2YWx1ZS5pbmNsdWRlcyh1bmRlZmluZWQpICYmXHJcbiAgICAgICAgICAgICF2YWx1ZS5pbmNsdWRlcyhudWxsKSAmJlxyXG4gICAgICAgICAgICB2YWx1ZS5ldmVyeSgoYSkgPT4gb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShhLCB0eXBlKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5BcnJheUhlbHBlciA9IEFycmF5SGVscGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZWEp5WVhsSVpXeHdaWEl1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZhR1ZzY0dWeWN5OWhjbkpoZVVobGJIQmxjaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNhVVJCUVRoRE8wRkJSVGxET3p0SFFVVkhPMEZCUTBnN1NVRkRTVHM3T3p0UFFVbEhPMGxCUTBrc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eExRVUZWTzFGQlF6VkNMRTFCUVUwc1EwRkJReXhMUVVGTExFdEJRVXNzU1VGQlNTeEpRVUZKTEV0QlFVc3NTMEZCU3l4VFFVRlRPMWxCUTNoRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdTVUZEZGtNc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEV0QlFWVTdVVUZETlVJc1RVRkJUU3hEUVVGRExFTkJRVU1zVjBGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hMUVVGTExFTkJRVU1zVFVGQlRTeExRVUZMTEVOQlFVTXNRMEZCUXp0SlFVTTNSQ3hEUVVGRE8wbEJSVVE3T3pzN08wOUJTMGM3U1VGRFNTeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVZVc1JVRkJSU3hKUVVGak8xRkJRelZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRmRCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETzFsQlF6bENMRU5CUVVNc1MwRkJTeXhEUVVGRExGRkJRVkVzUTBGQlF5eFRRVUZUTEVOQlFVTTdXVUZETVVJc1EwRkJReXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXp0WlFVTnlRaXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCVFN4RlFVRkZMRVZCUVVVc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU01UkN4RFFVRkRPME5CUlVvN1FVRnFRMFFzYTBOQmFVTkRJbjA9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9oZWxwZXJzL2FycmF5SGVscGVyLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjb3JlRXJyb3JfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9lcnJvci9jb3JlRXJyb3JcIik7XHJcbi8qKlxyXG4gKiBBIGNyeXB0byBpbXBsZW1lbnRhdGlvbiBvZiBhbiBlcnJvci5cclxuICovXHJcbmNsYXNzIENyeXB0b0Vycm9yIGV4dGVuZHMgY29yZUVycm9yXzEuQ29yZUVycm9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIENyeXB0b0Vycm9yLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgZm9yIHRoZSBlcnJvci5cclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsIEFkZGl0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gaW5uZXJFcnJvciBBZGQgaW5mb3JtYXRpb24gZnJvbSBpbm5lciBlcnJvciBpZiB0aGVyZSB3YXMgb25lLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBhZGRpdGlvbmFsLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgYWRkaXRpb25hbCwgaW5uZXJFcnJvcik7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSBcIkNyeXB0b1wiO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ3J5cHRvRXJyb3IgPSBDcnlwdG9FcnJvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWTNKNWNIUnZSWEp5YjNJdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12WlhKeWIzSXZZM0o1Y0hSdlJYSnliM0l1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJMRzlGUVVGcFJUdEJRVVZxUlRzN1IwRkZSenRCUVVOSUxHbENRVUY1UWl4VFFVRlJMSEZDUVVGVE8wbEJRM1JET3pzN096dFBRVXRITzBsQlEwZ3NXVUZCV1N4UFFVRmxMRVZCUVVVc1ZVRkJhME1zUlVGQlJTeFZRVUZyUWp0UlFVTXZSU3hMUVVGTExFTkJRVU1zVDBGQlR5eEZRVUZGTEZWQlFWVXNSVUZCUlN4VlFVRlZMRU5CUVVNc1EwRkJRenRSUVVOMlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRkZCUVZFc1EwRkJRenRKUVVNelFpeERRVUZETzBOQlEwbzdRVUZZUkN4clEwRlhReUo5XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9lcnJvci9jcnlwdG9FcnJvci50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFN0cmluZyBoZWxwZXIgbWV0aG9kcy5cclxuICovXHJcbmNsYXNzIFN0cmluZ0hlbHBlciB7XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdCBmb3IgaXRzIHN0cmluZ3luZXNzLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNTdHJpbmcodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IGZhbHNlIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGEgc3RyaW5nIHRoYXQgaXMgZW1wdHkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QgZm9yIGl0cyBubyBlbXB0eW5lc3MuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNFbXB0eSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAhU3RyaW5nSGVscGVyLmlzU3RyaW5nKHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSBzdHJpbmcgYWxsIEFTQ0lJIGNoYXJhY3RlcnMuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgc3RyaW5nIHRvIHRlc3QgaWYgaXMgaXMgQVNDSUkuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYWxsIEFTQ0lJLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNBc2NpaSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8gZmFsc2UgOiAvXltcXHgwMC1cXHhGRl0qJC8udGVzdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZSBub24gQVNDSUkgY2hhcmFjdGVycyB3aXRoIGNvbnRyb2wgY2hhcmFjdGVycy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgc3RyaW5nIHZhbHVlIHRvIGVzY2FwZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBlc2NhcGVkIHZlcnNpb24gb2YgdGhlIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGVuY29kZU5vbkFTQ0lJKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZ0hlbHBlci5pc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKC9bXFx1MDA3Ri1cXHVGRkZGXS9nLCAoY2hyKSA9PiBgXFxcXHUkeyhgMDAwMCR7Y2hyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpfWApLnN1YnN0cigtNCl9YCkgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlY29kZSBjb250cm9sIGNoYXJhY3RlcnMgdG8gQVNDSUkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGVuY29kZWQgc3RyaW5nIHRvIGNvbnZlcnQgYmFjayB0byBBU0NJSS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHZlcnNpb24gb2YgdGhlIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlY29kZU5vbkFTQ0lJKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZ0hlbHBlci5pc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKC9cXFxcdShbXFxkXFx3XXs0fSkvZ2ksIChtYXRjaCwgZ3JwKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGdycCwgMTYpKSkgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TdHJpbmdIZWxwZXIgPSBTdHJpbmdIZWxwZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWMzUnlhVzVuU0dWc2NHVnlMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyaGxiSEJsY25NdmMzUnlhVzVuU0dWc2NHVnlMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUczdSMEZGUnp0QlFVTklPMGxCUTBrN096czdUMEZKUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU1zUzBGQlZUdFJRVU0zUWl4TlFVRk5MRU5CUVVNc1MwRkJTeXhMUVVGTExFbEJRVWtzU1VGQlNTeExRVUZMTEV0QlFVc3NVMEZCVXp0WlFVTjRReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc2FVSkJRV2xDTEVOQlFVTTdTVUZET1VVc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEV0QlFWVTdVVUZETlVJc1RVRkJUU3hEUVVGRExFTkJRVU1zV1VGQldTeERRVUZETEZGQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hMUVVGTExFTkJRVU1zVFVGQlRTeExRVUZMTEVOQlFVTXNRMEZCUXp0SlFVTXZSQ3hEUVVGRE8wbEJSVVE3T3pzN1QwRkpSenRKUVVOSkxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCWVR0UlFVTXZRaXhOUVVGTkxFTkJRVU1zUzBGQlN5eExRVUZMTEVsQlFVa3NTVUZCU1N4TFFVRkxMRXRCUVVzc1UwRkJVenRaUVVONFF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03U1VGREwwTXNRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1kwRkJZeXhEUVVGRExFdEJRV0U3VVVGRGRFTXNUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhSUVVGUkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zYTBKQlFXdENMRVZCUVVVc1EwRkJReXhIUVVGSExFVkJRVVVzUlVGQlJTeERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRWRCUVVjc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTXZTaXhEUVVGRE8wbEJSVVE3T3pzN1QwRkpSenRKUVVOSkxFMUJRVTBzUTBGQlF5eGpRVUZqTEVOQlFVTXNTMEZCWVR0UlFVTjBReXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEZGQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4clFrRkJhMElzUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4SFFVRkhMRVZCUVVVc1JVRkJSU3hEUVVGRExFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRk5CUVZNc1EwRkJRenRKUVVOb1NpeERRVUZETzBOQlEwbzdRVUV2UTBRc2IwTkJLME5ESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvaGVscGVycy9zdHJpbmdIZWxwZXIudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGFycmF5SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlclwiKTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBkYXRhRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9kYXRhRXJyb3JcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIi4vdHJ5dGVzXCIpO1xyXG4vKipcclxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgdHJpdHMuXHJcbiAqL1xyXG5jbGFzcyBUcml0cyB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRyaXRzKSB7XHJcbiAgICAgICAgdGhpcy5fdHJpdHMgPSB0cml0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGluc3RhbmNlIG9mIHRyaXRzIGZyb20gSW50OEFycmF5IGFycmF5LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRyeXRlcyB1c2VkIHRvIGNyZWF0ZSB0cml0cy5cclxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRyaXRzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUFycmF5KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHZhbHVlLCBJbnQ4QXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgZG9lcyBub3QgY29udGFpbiB2YWxpZCB0cml0c1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcml0cyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBpbnN0YW5jZSBvZiB0cml0cyBmcm9tIG51bWJlciBhcnJheS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUcnl0ZXMgdXNlZCB0byBjcmVhdGUgdHJpdHMuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUcml0cy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21OdW1iZXJBcnJheSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHZhbHVlLCBOdW1iZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgZG9lcyBub3QgY29udGFpbiB2YWxpZCB0cml0c1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcml0cyhuZXcgSW50OEFycmF5KHZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBpbnN0YW5jZSBvZiB0cml0cyBmcm9tIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUcnl0ZXMgdXNlZCB0byBjcmVhdGUgdHJpdHMuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUcml0cy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21Ucnl0ZXModmFsdWUpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodmFsdWUsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSB2YWx1ZSBzaG91bGQgYmUgYSB2YWxpZCBUcnl0ZXMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cnl0ZXNTdHJpbmcgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IHRyaXRzID0gbmV3IEludDhBcnJheSh0cnl0ZXNTdHJpbmcubGVuZ3RoICogMyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cnl0ZXNTdHJpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaWR4ID0gdHJ5dGVzXzEuVHJ5dGVzLkFMUEhBQkVULmluZGV4T2YodHJ5dGVzU3RyaW5nLmNoYXJBdChpKSk7XHJcbiAgICAgICAgICAgIHRyaXRzW2kgKiAzXSA9IFRyaXRzLlRSWVRFU19UUklUU1tpZHhdWzBdO1xyXG4gICAgICAgICAgICB0cml0c1tpICogMyArIDFdID0gVHJpdHMuVFJZVEVTX1RSSVRTW2lkeF1bMV07XHJcbiAgICAgICAgICAgIHRyaXRzW2kgKiAzICsgMl0gPSBUcml0cy5UUllURVNfVFJJVFNbaWR4XVsyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcml0cyh0cml0cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBpbnN0YW5jZSBvZiB0cml0cyBmcm9tIG51bWJlclxyXG4gICAgICogQHBhcmFtIHZhbHVlIE51bWJlciB1c2VkIHRvIGNyZWF0ZSB0cml0cy5cclxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRyaXRzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbU51bWJlcih2YWx1ZSkge1xyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSB2YWx1ZSBpcyBub3QgYW4gaW50ZWdlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJpdHMgPSBbXTtcclxuICAgICAgICBsZXQgYWJzb2x1dGVWYWx1ZSA9IHZhbHVlIDwgMCA/IC12YWx1ZSA6IHZhbHVlO1xyXG4gICAgICAgIHdoaWxlIChhYnNvbHV0ZVZhbHVlID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gYWJzb2x1dGVWYWx1ZSAlIDM7XHJcbiAgICAgICAgICAgIGFic29sdXRlVmFsdWUgPSBNYXRoLmZsb29yKGFic29sdXRlVmFsdWUgLyAzKTtcclxuICAgICAgICAgICAgaWYgKHJlbWFpbmRlciA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlbWFpbmRlciA9IC0xO1xyXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVWYWx1ZSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyaXRzW3RyaXRzLmxlbmd0aF0gPSByZW1haW5kZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cml0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdHJpdHNbaV0gPSAtdHJpdHNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcml0cyhuZXcgSW50OEFycmF5KHRyaXRzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0d28gdHJpdHMgdG9nZXRoZXIuXHJcbiAgICAgKiBAcGFyYW0gZmlyc3QgVGhlIGZpcnN0IHRyaXQuXHJcbiAgICAgKiBAcGFyYW0gc2Vjb25kIFRoZSBzZWNvbmQgdHJpdC5cclxuICAgICAqIEByZXR1cm4gTmV3IHRyaXQgd2hpY2ggaXMgdGhlIGFkZGl0aW9uIG9mIHRoZSBhICsgYi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFkZChmaXJzdCwgc2Vjb25kKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGZpcnN0LCBUcml0cykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBmaXJzdCBzaG91bGQgYmUgYSB2YWxpZCBUcml0cyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWNvbmQsIFRyaXRzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHNlY29uZHMgc2hvdWxkIGJlIGEgdmFsaWQgVHJpdHMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvdXQgPSBuZXcgSW50OEFycmF5KE1hdGgubWF4KGZpcnN0Ll90cml0cy5sZW5ndGgsIHNlY29uZC5fdHJpdHMubGVuZ3RoKSk7XHJcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcclxuICAgICAgICBsZXQgaUE7XHJcbiAgICAgICAgbGV0IGlCO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlBID0gaSA8IGZpcnN0Ll90cml0cy5sZW5ndGggPyBmaXJzdC5fdHJpdHNbaV0gOiAwO1xyXG4gICAgICAgICAgICBpQiA9IGkgPCBzZWNvbmQuX3RyaXRzLmxlbmd0aCA/IHNlY29uZC5fdHJpdHNbaV0gOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBmQSA9IFRyaXRzLmZ1bGxBZGQoaUEsIGlCLCBjYXJyeSk7XHJcbiAgICAgICAgICAgIG91dFtpXSA9IGZBWzBdO1xyXG4gICAgICAgICAgICBjYXJyeSA9IGZBWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVHJpdHMuZnJvbUFycmF5KG91dCk7XHJcbiAgICB9XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIHN0YXRpYyBmdWxsQWRkKGEsIGIsIGMpIHtcclxuICAgICAgICBjb25zdCBzQSA9IFRyaXRzLnN1bShhLCBiKTtcclxuICAgICAgICBjb25zdCBjQSA9IFRyaXRzLmNvbnMoYSwgYik7XHJcbiAgICAgICAgY29uc3QgY0IgPSBUcml0cy5jb25zKHNBLCBjKTtcclxuICAgICAgICBjb25zdCBjT3V0ID0gVHJpdHMuYW55KGNBLCBjQik7XHJcbiAgICAgICAgY29uc3Qgc09VdCA9IFRyaXRzLnN1bShzQSwgYyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoW3NPVXQsIGNPdXRdKTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIHN1bShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgcyA9IGEgKyBiO1xyXG4gICAgICAgIHN3aXRjaCAocykge1xyXG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiAtMTtcclxuICAgICAgICAgICAgY2FzZSAtMjogcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIGNvbnMoYSwgYikge1xyXG4gICAgICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIGFueShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgcyA9IGEgKyBiO1xyXG4gICAgICAgIGlmIChzID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocyA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgdHJpdHMgYXJyYXkuXHJcbiAgICAgKiBAcmV0dXJucyBBcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJpdHMuXHJcbiAgICAgKi9cclxuICAgIHRvQXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaXRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSB0cml0cyBhcnJheSBhcyBhIG51bWJlciBhcnJheS5cclxuICAgICAqIEByZXR1cm5zIEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cml0cy5cclxuICAgICAqL1xyXG4gICAgdG9OdW1iZXJBcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl90cml0cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdHJpdHMgYXMgdHJ5dGVzLlxyXG4gICAgICogQHJldHVybnMgSW5zdGFuY2Ugb2YgVHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICB0b1RyeXRlcygpIHtcclxuICAgICAgICBsZXQgdHJ5dGVzID0gXCJcIjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RyaXRzLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgcG9zc2libGUgdHJ5dGUgdmFsdWVzIHRvIGZpbmQgY29ycmVjdCB0cml0IHJlcHJlc2VudGF0aW9uXHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdHJ5dGVzXzEuVHJ5dGVzLkFMUEhBQkVULmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoVHJpdHMuVFJZVEVTX1RSSVRTW2pdWzBdID09PSB0aGlzLl90cml0c1tpXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIFRyaXRzLlRSWVRFU19UUklUU1tqXVsxXSA9PT0gdGhpcy5fdHJpdHNbaSArIDFdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgVHJpdHMuVFJZVEVTX1RSSVRTW2pdWzJdID09PSB0aGlzLl90cml0c1tpICsgMl0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnl0ZXMgKz0gdHJ5dGVzXzEuVHJ5dGVzLkFMUEhBQkVULmNoYXJBdChqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodHJ5dGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB0cml0cyBhcyBhIG51bWJlci5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cml0cyBjb252ZXJ0ZWQgdG8gYSBudW1iZXIuXHJcbiAgICAgKi9cclxuICAgIHRvTnVtYmVyKCkge1xyXG4gICAgICAgIGxldCByZXR1cm5WYWx1ZSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3RyaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmV0dXJuVmFsdWUgKiAzICsgdGhpcy5fdHJpdHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2hhdCBpcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cml0cy5cclxuICAgICAqIEByZXR1cm5zIExlbmd0aCBvZiB0aGUgdHJpdHMuXHJcbiAgICAgKi9cclxuICAgIGxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJpdHMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBzdWIgb2YgdGhlIHRyaXRzLlxyXG4gICAgICogQHBhcmFtIHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbiB0byBnZXQgdGhlIHN1Yi5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgc3ViLlxyXG4gICAgICogQHJldHVybnMgVGhlIHRyaXRzIHN1Yi5cclxuICAgICAqL1xyXG4gICAgc3ViKHN0YXJ0LCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc3RhcnQpIHx8IHN0YXJ0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHN0YXJ0IG11c3QgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgKHN0YXJ0ICsgbGVuZ3RoKSA+IHRoaXMuX3RyaXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgc3RhcnQgKyBsZW5ndGggbXVzdCA8PSAke3RoaXMuX3RyaXRzLmxlbmd0aH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFRyaXRzLmZyb21BcnJheSh0aGlzLl90cml0cy5zbGljZShzdGFydCwgc3RhcnQgKyBsZW5ndGgpKTtcclxuICAgIH1cclxufVxyXG4vKiBAaW50ZXJuYWwgKi9cclxuVHJpdHMuVFJZVEVTX1RSSVRTID0gW1xyXG4gICAgbmV3IEludDhBcnJheShbMCwgMCwgMF0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgMCwgMF0pLFxyXG4gICAgbmV3IEludDhBcnJheShbLTEsIDEsIDBdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzAsIDEsIDBdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzEsIDEsIDBdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWy0xLCAtMSwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMCwgLTEsIDFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzEsIC0xLCAxXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFstMSwgMCwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMCwgMCwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgMCwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbLTEsIDEsIDFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzAsIDEsIDFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzEsIDEsIDFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWy0xLCAtMSwgLTFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzAsIC0xLCAtMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgLTEsIC0xXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFstMSwgMCwgLTFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzAsIDAsIC0xXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFsxLCAwLCAtMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbLTEsIDEsIC0xXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFswLCAxLCAtMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgMSwgLTFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWy0xLCAtMSwgMF0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMCwgLTEsIDBdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzEsIC0xLCAwXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFstMSwgMCwgMF0pXHJcbl07XHJcbmV4cG9ydHMuVHJpdHMgPSBUcml0cztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEhKcGRITXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdlpHRjBZUzkwY21sMGN5NTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFc01FVkJRWFZGTzBGQlEzWkZMRFJGUVVGNVJUdEJRVU42UlN3MFJVRkJlVVU3UVVGRGVrVXNhMFJCUVN0RE8wRkJReTlETEhGRFFVRnJRenRCUVVWc1F6czdSMEZGUnp0QlFVTklPMGxCYlVOSkxHVkJRV1U3U1VGRFppeFpRVUZ2UWl4TFFVRm5RanRSUVVOb1F5eEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJRenRKUVVONFFpeERRVUZETzBsQlJVUTdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJaMEk3VVVGRGNFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzcERMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEhkRFFVRjNReXhEUVVGRExFTkJRVU03VVVGRGJFVXNRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXp0SlFVTTFRaXhEUVVGRE8wbEJSVVE3T3pzN1QwRkpSenRKUVVOSkxFMUJRVTBzUTBGQlF5eGxRVUZsTEVOQlFVTXNTMEZCWlR0UlFVTjZReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFdEJRVXNzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRkRU1zVFVGQlRTeEpRVUZKTEhGQ1FVRlRMRU5CUVVNc2QwTkJRWGRETEVOQlFVTXNRMEZCUXp0UlFVTnNSU3hEUVVGRE8xRkJRMFFzVFVGQlRTeERRVUZETEVsQlFVa3NTMEZCU3l4RFFVRkRMRWxCUVVrc1UwRkJVeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETTBNc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEV0QlFXRTdVVUZEYkVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFVkJRVVVzWlVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNSRExFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMREpEUVVFeVF5eERRVUZETEVOQlFVTTdVVUZEY2tVc1EwRkJRenRSUVVORUxFMUJRVTBzV1VGQldTeEhRVUZITEV0QlFVc3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRSUVVOMFF5eE5RVUZOTEV0QlFVc3NSMEZCWXl4SlFVRkpMRk5CUVZNc1EwRkJReXhaUVVGWkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJoRkxFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzV1VGQldTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRE8xbEJRek5ETEUxQlFVMHNSMEZCUnl4SFFVRkhMR1ZCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU0xUkN4TFFVRkxMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4WlFVRlpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1MwRkJTeXhEUVVGRExGbEJRVmtzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNNVF5eExRVUZMTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eExRVUZMTEVOQlFVTXNXVUZCV1N4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyeEVMRU5CUVVNN1VVRkRSQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1NVRkROVUlzUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRXRCUVdFN1VVRkRiRU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha01zVFVGQlRTeEpRVUZKTEhGQ1FVRlRMRU5CUVVNc05rSkJRVFpDTEVOQlFVTXNRMEZCUXp0UlFVTjJSQ3hEUVVGRE8xRkJRMFFzVFVGQlRTeExRVUZMTEVkQlFXRXNSVUZCUlN4RFFVRkRPMUZCUXpOQ0xFbEJRVWtzWVVGQllTeEhRVUZITEV0QlFVc3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNN1VVRkZMME1zVDBGQlR5eGhRVUZoTEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNN1dVRkRka0lzU1VGQlNTeFRRVUZUTEVkQlFVY3NZVUZCWVN4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVOc1F5eGhRVUZoTEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhoUVVGaExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZGT1VNc1JVRkJSU3hEUVVGRExFTkJRVU1zVTBGQlV5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMmhDTEZOQlFWTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRFppeGhRVUZoTEVWQlFVVXNRMEZCUXp0WlFVTndRaXhEUVVGRE8xbEJSVVFzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhUUVVGVExFTkJRVU03VVVGRGNFTXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTFvc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhMUVVGTExFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNN1owSkJRM0JETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZRaXhEUVVGRE8xRkJRMHdzUTBGQlF6dFJRVVZFTEUxQlFVMHNRMEZCUXl4SlFVRkpMRXRCUVVzc1EwRkJReXhKUVVGSkxGTkJRVk1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUXpORExFTkJRVU03U1VGRlJEczdPenM3VDBGTFJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1MwRkJXU3hGUVVGRkxFMUJRV0U3VVVGRGVrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzSkRMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETERCRFFVRXdReXhEUVVGRExFTkJRVU03VVVGRGNFVXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjBReXhOUVVGTkxFbEJRVWtzY1VKQlFWTXNRMEZCUXl3MFEwRkJORU1zUTBGQlF5eERRVUZETzFGQlEzUkZMRU5CUVVNN1VVRkZSQ3hOUVVGTkxFZEJRVWNzUjBGQlJ5eEpRVUZKTEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RlFVRkZMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTXZSU3hKUVVGSkxFdEJRVXNzUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZEWkN4SlFVRkpMRVZCUVVVc1EwRkJRenRSUVVOUUxFbEJRVWtzUlVGQlJTeERRVUZETzFGQlJWQXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTTdXVUZGYkVNc1JVRkJSU3hIUVVGSExFTkJRVU1zUjBGQlJ5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNUVMRVZCUVVVc1IwRkJSeXhEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU55UkN4TlFVRk5MRVZCUVVVc1IwRkJSeXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1MwRkJTeXhEUVVGRExFTkJRVU03V1VGRGVFTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTm1MRXRCUVVzc1IwRkJSeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYkVJc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8wbEJRMmhETEVOQlFVTTdTVUZGUkN4bFFVRmxPMGxCUTFBc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZUTEVWQlFVVXNRMEZCVXl4RlFVRkZMRU5CUVZNN1VVRkRiRVFzVFVGQlRTeEZRVUZGTEVkQlFVY3NTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETTBJc1RVRkJUU3hGUVVGRkxFZEJRVWNzUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE5VSXNUVUZCVFN4RlFVRkZMRWRCUVVjc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkROMElzVFVGQlRTeEpRVUZKTEVkQlFVY3NTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdVVUZETDBJc1RVRkJUU3hKUVVGSkxFZEJRVWNzUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRk9VSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRka01zUTBGQlF6dEpRVVZFTEdWQlFXVTdTVUZEVUN4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVk1zUlVGQlJTeERRVUZUTzFGQlEyNURMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZGYUVJc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTlNMRXRCUVVzc1EwRkJReXhGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnNRaXhMUVVGTExFTkJRVU1zUTBGQlF5eEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRiRUlzVTBGQlV5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNSQ0xFTkJRVU03U1VGRFRDeERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlFMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlV5eEZRVUZGTEVOQlFWTTdVVUZEY0VNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRWaXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEySXNRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFlpeERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlFMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlV5eEZRVUZGTEVOQlFWTTdVVUZEYmtNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVVm9RaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOU0xFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEWWl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMllzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJRc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEWWl4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NUMEZCVHp0UlFVTldMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETzBsQlEzWkNMRU5CUVVNN1NVRkZSRHM3TzA5QlIwYzdTVUZEU1N4aFFVRmhPMUZCUTJoQ0xFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU51UXl4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NVVUZCVVR0UlFVTllMRWxCUVVrc1RVRkJUU3hIUVVGSExFVkJRVVVzUTBGQlF6dFJRVVZvUWl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJRenRaUVVNM1F5dzJSVUZCTmtVN1dVRkROMFVzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eGxRVUZOTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETzJkQ1FVTTVReXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU16UXl4TFFVRkxMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0dlFrRkRMME1zUzBGQlN5eERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTJ4RUxFMUJRVTBzU1VGQlNTeGxRVUZOTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZEY0VNc1MwRkJTeXhEUVVGRE8yZENRVU5XTEVOQlFVTTdXVUZEVEN4RFFVRkRPMUZCUTB3c1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eGxRVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8wbEJRM0pETEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeFJRVUZSTzFGQlExZ3NTVUZCU1N4WFFVRlhMRWRCUVVjc1EwRkJReXhEUVVGRE8xRkJSWEJDTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNN1dVRkRMME1zVjBGQlZ5eEhRVUZITEZkQlFWY3NSMEZCUnl4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnVSQ3hEUVVGRE8xRkJSVVFzVFVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXp0SlFVTjJRaXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1RVRkJUVHRSUVVOVUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVNNVFpeERRVUZETzBsQlJVUTdPenM3TzA5QlMwYzdTVUZEU1N4SFFVRkhMRU5CUVVNc1MwRkJZU3hGUVVGRkxFMUJRV003VVVGRGNFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hMUVVGTExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTVReXhOUVVGTkxFbEJRVWtzY1VKQlFWTXNRMEZCUXl4cFEwRkJhVU1zUTBGQlF5eERRVUZETzFGQlF6TkVMRU5CUVVNN1VVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4SFFVRkhMRTFCUVUwc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNelJTeE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXc0UWtGQk9FSXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETzFGQlF6VkZMRU5CUVVNN1VVRkRSQ3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eExRVUZMTEVWQlFVVXNTMEZCU3l4SFFVRkhMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGNrVXNRMEZCUXpzN1FVRjJVVVFzWlVGQlpUdEJRVU5UTEd0Q1FVRlpMRWRCUVdkQ08wbEJRMmhFTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTjRRaXhKUVVGSkxGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGVFSXNTVUZCU1N4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRla0lzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzaENMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVONFFpeEpRVUZKTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUXpGQ0xFbEJRVWtzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzcENMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRM3BDTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNwQ0xFbEJRVWtzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU40UWl4SlFVRkpMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRlRUlzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEZWtJc1NVRkJTU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRM2hDTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTjRRaXhKUVVGSkxGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETTBJc1NVRkJTU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU14UWl4SlFVRkpMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRekZDTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRNVUlzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEZWtJc1NVRkJTU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGVrSXNTVUZCU1N4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNeFFpeEpRVUZKTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTjZRaXhKUVVGSkxGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU42UWl4SlFVRkpMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRekZDTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNwQ0xFbEJRVWtzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzcENMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wTkJRelZDTEVOQlFVTTdRVUU1UWs0c2MwSkJNRkZESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvZGF0YS90cml0cy50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IGRhdGFFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2RhdGFFcnJvclwiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiLi90cnl0ZXNcIik7XHJcbi8qKlxyXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyBhZGRyZXNzZXMuXHJcbiAqL1xyXG5jbGFzcyBBZGRyZXNzIHtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoYWRkcmVzc1RyeXRlcywgY2hlY2tzdW1Ucnl0ZXMpIHtcclxuICAgICAgICB0aGlzLl9hZGRyZXNzVHJ5dGVzID0gYWRkcmVzc1RyeXRlcztcclxuICAgICAgICB0aGlzLl9jaGVja3N1bVRyeXRlcyA9IGNoZWNrc3VtVHJ5dGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYWRkcmVzcyBmcm9tIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSB0cnl0ZXMgdG8gY3JlYXRlIHRoZSBhZGRyZXNzIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBBZGRyZXNzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVRyeXRlcyhhZGRyZXNzKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGFkZHJlc3MsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBhZGRyZXNzIHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyeXRlc1N0cmluZyA9IGFkZHJlc3MudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAodHJ5dGVzU3RyaW5nLmxlbmd0aCAhPT0gQWRkcmVzcy5MRU5HVEggJiYgdHJ5dGVzU3RyaW5nLmxlbmd0aCAhPT0gQWRkcmVzcy5MRU5HVEhfV0lUSF9DSEVDS1NVTSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgYWRkcmVzcyBzaG91bGQgZWl0aGVyIGJlICR7QWRkcmVzcy5MRU5HVEh9IG9yICR7QWRkcmVzcy5MRU5HVEhfV0lUSF9DSEVDS1NVTX0gY2hhcmFjdGVycyBpbiBsZW5ndGhgLCB7IGxlbmd0aDogdHJ5dGVzU3RyaW5nLmxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWRkcmVzc1RyeXRlcyA9IHRyeXRlc1N0cmluZy5zdWJzdHIoMCwgQWRkcmVzcy5MRU5HVEgpO1xyXG4gICAgICAgIGxldCBjaGVja3N1bVRyeXRlcztcclxuICAgICAgICBpZiAodHJ5dGVzU3RyaW5nLmxlbmd0aCA9PT0gQWRkcmVzcy5MRU5HVEhfV0lUSF9DSEVDS1NVTSkge1xyXG4gICAgICAgICAgICBjaGVja3N1bVRyeXRlcyA9IHRyeXRlc1N0cmluZy5zdWJzdHIoQWRkcmVzcy5MRU5HVEgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYWRkcmVzc1RyeXRlcywgY2hlY2tzdW1Ucnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSBhZGRyZXNzIHRvIHRyeXRlcyB3aXRoIG5vIGNoZWNrc3VtLlxyXG4gICAgICogQHJldHVybnMgVHJ5dGVzIHZlcnNpb24gb2YgdGhlIGFkZHJlc3Mgd2l0aCBubyBjaGVja3N1bS5cclxuICAgICAqL1xyXG4gICAgdG9Ucnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRoaXMuX2FkZHJlc3NUcnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSBhZGRyZXNzIHRvIHRyeXRlcyB3aXRoIGEgY2hlY2tzdW0sIGNyZWF0aW5nIGEgYmxhbmsgb25lIGlmIG5lZWRlZC5cclxuICAgICAqIEByZXR1cm5zIFRyeXRlcyB2ZXJzaW9uIG9mIHRoZSBhZGRyZXNzIHdpdGggY2hlY2tzdSwuXHJcbiAgICAgKi9cclxuICAgIHRvVHJ5dGVzV2l0aENoZWNrc3VtKCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkodGhpcy5fY2hlY2tzdW1Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0aGlzLl9hZGRyZXNzVHJ5dGVzICsgdGhpcy5fY2hlY2tzdW1Ucnl0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhpcyBhZGRyZXNzIGhhcyBubyBjaGVja3N1bSBjYWxjdWxhdGVkIGZvciBpdGApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdHJpbmcgdmlldyBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgc3RyaW5nIG9mIHRoZSB0cnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkodGhpcy5fY2hlY2tzdW1Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRyZXNzVHJ5dGVzICsgdGhpcy5fY2hlY2tzdW1Ucnl0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkcmVzc1RyeXRlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBsZW5ndGggZm9yIGEgdmFsaWQgYWRkcmVzcyB3aXRob3V0IGNoZWNrc3VtICg4MSkuXHJcbiAqL1xyXG5BZGRyZXNzLkxFTkdUSCA9IDgxO1xyXG4vKipcclxuICogVGhlIGxlbmd0aCBmb3IgYW4gYWRkcmVzcyBjaGVja3N1bSAoOSkuXHJcbiAqL1xyXG5BZGRyZXNzLkxFTkdUSF9DSEVDS1NVTSA9IDk7XHJcbi8qKlxyXG4gKiBUaGUgbGVuZ3RoIGZvciB2YWxpZCBhZGRyZXNzIHdpdGggY2hlY2tzdW0gKDkwKS5cclxuICovXHJcbkFkZHJlc3MuTEVOR1RIX1dJVEhfQ0hFQ0tTVU0gPSBBZGRyZXNzLkxFTkdUSCArIEFkZHJlc3MuTEVOR1RIX0NIRUNLU1VNO1xyXG4vKipcclxuICogQW4gZW1wdHkgaGFzaCBhbGwgOXMuXHJcbiAqL1xyXG5BZGRyZXNzLkVNUFRZID0gQWRkcmVzcy5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKFwiOVwiLnJlcGVhdChBZGRyZXNzLkxFTkdUSCkpKTtcclxuZXhwb3J0cy5BZGRyZXNzID0gQWRkcmVzcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWVdSa2NtVnpjeTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWtZWFJoTDJGa1pISmxjM011ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJMRFJGUVVGNVJUdEJRVU42UlN4clJFRkJLME03UVVGREwwTXNjVU5CUVd0RE8wRkJSV3hET3p0SFFVVkhPMEZCUTBnN1NVRjNRa2tzWlVGQlpUdEpRVU5tTEZsQlFXOUNMR0ZCUVhGQ0xFVkJRVVVzWTBGQmMwSTdVVUZETjBRc1NVRkJTU3hEUVVGRExHTkJRV01zUjBGQlJ5eGhRVUZoTEVOQlFVTTdVVUZEY0VNc1NVRkJTU3hEUVVGRExHVkJRV1VzUjBGQlNTeGpRVUZqTEVOQlFVTTdTVUZETTBNc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEU5QlFXVTdVVUZEY0VNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhQUVVGUExFVkJRVVVzWlVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNoRExFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMRFpEUVVFMlF5eERRVUZETEVOQlFVTTdVVUZEZGtVc1EwRkJRenRSUVVWRUxFMUJRVTBzV1VGQldTeEhRVUZITEU5QlFVOHNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRSUVVWNFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4WlFVRlpMRU5CUVVNc1RVRkJUU3hMUVVGTExFOUJRVThzUTBGQlF5eE5RVUZOTEVsQlFVa3NXVUZCV1N4RFFVRkRMRTFCUVUwc1MwRkJTeXhQUVVGUExFTkJRVU1zYjBKQlFXOUNMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnBITEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExHZERRVUZuUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hQUVVGUExFOUJRVThzUTBGQlF5eHZRa0ZCYjBJc2RVSkJRWFZDTEVWQlFVVXNSVUZCUlN4TlFVRk5MRVZCUVVVc1dVRkJXU3hEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVOQlFVTTdVVUZEYmtzc1EwRkJRenRSUVVWRUxFMUJRVTBzWVVGQllTeEhRVUZITEZsQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhGUVVGRkxFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTTNSQ3hKUVVGSkxHTkJRV01zUTBGQlF6dFJRVU51UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhaUVVGWkxFTkJRVU1zVFVGQlRTeExRVUZMTEU5QlFVOHNRMEZCUXl4dlFrRkJiMElzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZGtRc1kwRkJZeXhIUVVGSExGbEJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJRM3BFTEVOQlFVTTdVVUZEUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hQUVVGUExFTkJRVU1zWVVGQllTeEZRVUZGTEdOQlFXTXNRMEZCUXl4RFFVRkRPMGxCUTNSRUxFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hSUVVGUk8xRkJRMWdzVFVGQlRTeERRVUZETEdWQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETzBsQlEyeEVMRU5CUVVNN1NVRkZSRHM3TzA5QlIwYzdTVUZEU1N4dlFrRkJiMEk3VVVGRGRrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6bERMRTFCUVUwc1EwRkJReXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEVsQlFVa3NRMEZCUXl4alFVRmpMRWRCUVVjc1NVRkJTU3hEUVVGRExHVkJRV1VzUTBGQlF5eERRVUZETzFGQlEzcEZMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5LTEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExHZEVRVUZuUkN4RFFVRkRMRU5CUVVNN1VVRkRNVVVzUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeFJRVUZSTzFGQlExZ3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6bERMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zWTBGQll5eEhRVUZITEVsQlFVa3NRMEZCUXl4bFFVRmxMRU5CUVVNN1VVRkRkRVFzUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTBvc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTTdVVUZETDBJc1EwRkJRenRKUVVOTUxFTkJRVU03TzBGQmJrWkVPenRIUVVWSE8wRkJRMjlDTEdOQlFVMHNSMEZCVnl4RlFVRkZMRU5CUVVNN1FVRkRNME03TzBkQlJVYzdRVUZEYjBJc2RVSkJRV1VzUjBGQlZ5eERRVUZETEVOQlFVTTdRVUZEYmtRN08wZEJSVWM3UVVGRGIwSXNORUpCUVc5Q0xFZEJRVmNzVDBGQlR5eERRVUZETEUxQlFVMHNSMEZCUnl4UFFVRlBMRU5CUVVNc1pVRkJaU3hEUVVGRE8wRkJSUzlHT3p0SFFVVkhPMEZCUTI5Q0xHRkJRVXNzUjBGQldTeFBRVUZQTEVOQlFVTXNWVUZCVlN4RFFVRkRMR1ZCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBGQmFrSTVSeXd3UWtGeFJrTWlmUT09XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9kYXRhL2FkZHJlc3MudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBkYXRhRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9kYXRhRXJyb3JcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIi4vdHJ5dGVzXCIpO1xyXG4vKipcclxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgaGFzaGVzLlxyXG4gKi9cclxuY2xhc3MgSGFzaCB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRyeXRlcykge1xyXG4gICAgICAgIHRoaXMuX3RyeXRlcyA9IHRyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGhhc2ggZnJvbSB0cnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gaGFzaCBUaGUgdHJ5dGVzIHRvIGNyZWF0ZSB0aGUgaGFzaCBmcm9tLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgSGFzaC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21Ucnl0ZXMoaGFzaCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShoYXNoLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgaGFzaCBzaG91bGQgYmUgYSB2YWxpZCBUcnl0ZXMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW5ndGggPSBoYXNoLmxlbmd0aCgpO1xyXG4gICAgICAgIGlmIChsZW5ndGggIT09IEhhc2guTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBoYXNoIHNob3VsZCBiZSAke0hhc2guTEVOR1RIfSBjaGFyYWN0ZXJzIGluIGxlbmd0aGAsIHsgbGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEhhc2goaGFzaCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIGhhc2ggdG8gdHJ5dGVzLlxyXG4gICAgICogQHJldHVybnMgVHJ5dGVzIHZlcnNpb24gb2YgdGhlIGhhc2guXHJcbiAgICAgKi9cclxuICAgIHRvVHJ5dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cnl0ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RyaW5nIHZpZXcgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHN0cmluZyBvZiB0aGUgdHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJ5dGVzLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBsZW5ndGggZm9yIGEgdmFsaWQgaGFzaCAoODEpLlxyXG4gKi9cclxuSGFzaC5MRU5HVEggPSA4MTtcclxuLyoqXHJcbiAqIEFuIGVtcHR5IGhhc2ggYWxsIDlzLlxyXG4gKi9cclxuSGFzaC5FTVBUWSA9IEhhc2guZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhcIjlcIi5yZXBlYXQoSGFzaC5MRU5HVEgpKSk7XHJcbmV4cG9ydHMuSGFzaCA9IEhhc2g7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFHRnphQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWtZWFJoTDJoaGMyZ3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQkxEUkZRVUY1UlR0QlFVTjZSU3hyUkVGQkswTTdRVUZETDBNc2NVTkJRV3RETzBGQlJXeERPenRIUVVWSE8wRkJRMGc3U1VGaFNTeGxRVUZsTzBsQlEyWXNXVUZCYjBJc1RVRkJZenRSUVVNNVFpeEpRVUZKTEVOQlFVTXNUMEZCVHl4SFFVRkhMRTFCUVUwc1EwRkJRenRKUVVNeFFpeERRVUZETzBsQlJVUTdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNc1NVRkJXVHRSUVVOcVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NSVUZCUlN4bFFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNrTXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zTUVOQlFUQkRMRU5CUVVNc1EwRkJRenRSUVVOd1JTeERRVUZETzFGQlJVUXNUVUZCVFN4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETzFGQlF6ZENMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUzBGQlN5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONlFpeE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXh6UWtGQmMwSXNTVUZCU1N4RFFVRkRMRTFCUVUwc2RVSkJRWFZDTEVWQlFVVXNSVUZCUlN4TlFVRk5MRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRemxHTEVOQlFVTTdVVUZGUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdTVUZETVVJc1EwRkJRenRKUVVWRU96czdUMEZIUnp0SlFVTkpMRkZCUVZFN1VVRkRXQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXp0SlFVTjRRaXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8wbEJRMjVETEVOQlFVTTdPMEZCYWtSRU96dEhRVVZITzBGQlEyOUNMRmRCUVUwc1IwRkJWeXhGUVVGRkxFTkJRVU03UVVGRE0wTTdPMGRCUlVjN1FVRkRiMElzVlVGQlN5eEhRVUZUTEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eEhRVUZITEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdRVUZTY2tjc2IwSkJiVVJESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvZGF0YS9oYXNoLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBmYWN0b3J5QmFzZV8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2ZhY3Rvcmllcy9mYWN0b3J5QmFzZVwiKTtcclxuY29uc3QgY3VybF8xID0gcmVxdWlyZShcIi4uL3Nwb25nZXMvY3VybFwiKTtcclxuY29uc3Qga2VybF8xID0gcmVxdWlyZShcIi4uL3Nwb25nZXMva2VybFwiKTtcclxuLyoqXHJcbiAqIEZhY3RvcnkgdG8gZ2VuZXJhdGUgc3Bvbmdlcy5cclxuICovXHJcbmNsYXNzIFNwb25nZUZhY3RvcnkgZXh0ZW5kcyBmYWN0b3J5QmFzZV8xLkZhY3RvcnlCYXNlIHtcclxuICAgIC8qKlxyXG4gICAgICogRG9uJ3QgYWxsb3cgbWFudWFsIGNvbnN0cnVjdGlvbiBvZiB0aGUgZmFjdG9yeS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGluc3RhbmNlIG9mIHRoZSBmYWN0b3J5LlxyXG4gICAgICogQHJldHVybnMgVGhlIGZhY3RvcnkgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnN0YW5jZSgpIHtcclxuICAgICAgICBpZiAoIVNwb25nZUZhY3RvcnkuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIFNwb25nZUZhY3RvcnkuX2luc3RhbmNlID0gbmV3IFNwb25nZUZhY3RvcnkoKTtcclxuICAgICAgICAgICAgU3BvbmdlRmFjdG9yeS5faW5zdGFuY2UucmVnaXN0ZXIoXCJjdXJsXCIsICguLi5hcmdzKSA9PiBuZXcgY3VybF8xLkN1cmwoLi4uYXJncykpO1xyXG4gICAgICAgICAgICBTcG9uZ2VGYWN0b3J5Ll9pbnN0YW5jZS5yZWdpc3RlcihcImtlcmxcIiwgKC4uLmFyZ3MpID0+IG5ldyBrZXJsXzEuS2VybCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNwb25nZUZhY3RvcnkuX2luc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBnZXRJbnN0YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU3BvbmdlRmFjdG9yeSA9IFNwb25nZUZhY3Rvcnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWMzQnZibWRsUm1GamRHOXllUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OW1ZV04wYjNKcFpYTXZjM0J2Ym1kbFJtRmpkRzl5ZVM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzTkVWQlFYbEZPMEZCUlhwRkxEQkRRVUYxUXp0QlFVTjJReXd3UTBGQmRVTTdRVUZGZGtNN08wZEJSVWM3UVVGRFNDeHRRa0ZCTWtJc1UwRkJVU3g1UWtGQmIwSTdTVUZKYmtRN096dFBRVWRITzBsQlEwZzdVVUZEU1N4TFFVRkxMRVZCUVVVc1EwRkJRenRKUVVOYUxFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVVVGQlVUdFJRVU5zUWl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExHRkJRV0VzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpOQ0xHRkJRV0VzUTBGQlF5eFRRVUZUTEVkQlFVY3NTVUZCU1N4aFFVRmhMRVZCUVVVc1EwRkJRenRaUVVNNVF5eGhRVUZoTEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEhRVUZITEVsQlFVa3NSVUZCUlN4RlFVRkZMRU5CUVVNc1NVRkJTU3hYUVVGSkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNwRkxHRkJRV0VzUTBGQlF5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFZEJRVWNzU1VGQlNTeEZRVUZGTEVWQlFVVXNRMEZCUXl4SlFVRkpMRmRCUVVrc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGRFVXNRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhoUVVGaExFTkJRVU1zVTBGQlV5eERRVUZETzBsQlEyNURMRU5CUVVNN1NVRkZSQ3hsUVVGbE8wbEJRMHdzVjBGQlZ6dFJRVU5xUWl4TlFVRk5MRU5CUVVNc1lVRkJZU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzBsQlEzQkRMRU5CUVVNN1EwRkRTanRCUVRkQ1JDeHpRMEUyUWtNaWZRPT1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5LnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBqc29uSGVscGVyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9qc29uSGVscGVyXCIpO1xyXG5jb25zdCBzdHJpbmdIZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0cmluZ0hlbHBlclwiKTtcclxuLyoqXHJcbiAqIEEgY29yZSBpbXBsZW1lbnRhdGlvbiBvZiBhbiBlcnJvci5cclxuICovXHJcbmNsYXNzIENvcmVFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIENvcmVFcnJvci5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIGZvciB0aGUgZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbCBBZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yLlxyXG4gICAgICogQHBhcmFtIGlubmVyRXJyb3IgQWRkIGluZm9ybWF0aW9uIGZyb20gaW5uZXIgZXJyb3IgaWYgdGhlcmUgd2FzIG9uZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgYWRkaXRpb25hbCwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuYWRkaXRpb25hbCA9IGFkZGl0aW9uYWwgPyBhZGRpdGlvbmFsIDoge307XHJcbiAgICAgICAgdGhpcy5pbm5lckVycm9yID0gaW5uZXJFcnJvcjtcclxuICAgICAgICB0aGlzLmRvbWFpbiA9IFwiQ29yZVwiO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhbiBvYmplY3QgY291bGQgYmUgYSBDb3JlRXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgaWYgaXQgaXMgYSBDb3JlRXJyb3IuXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIElmIHRoZSB0ZXN0ZWQgb2JqZWN0IGlzIGEgQ29yZUVycm9yLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNFcnJvcihvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgXCJtZXNzYWdlXCIgaW4gb2JqICYmIFwiYWRkaXRpb25hbFwiIGluIG9iajtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9ybWF0IHRoZSBlcnJvciB0byBhIHJlYWRhYmxlIHZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdCgpIHtcclxuICAgICAgICBsZXQgb3V0ID0gXCJcIjtcclxuICAgICAgICBpZiAoIXN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KHRoaXMuZG9tYWluKSkge1xyXG4gICAgICAgICAgICBvdXQgKz0gYCR7dGhpcy5kb21haW59OiBgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KHRoaXMubWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgb3V0ICs9IGAke3RoaXMubWVzc2FnZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5hZGRpdGlvbmFsKTtcclxuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChvdXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvdXQgKz0gYFxcdCR7a2V5fTogJHtqc29uSGVscGVyXzEuSnNvbkhlbHBlci5zdHJpbmdpZnkodGhpcy5hZGRpdGlvbmFsW2tleV0pfVxcbmA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ29yZUVycm9yID0gQ29yZUVycm9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZMjl5WlVWeWNtOXlMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyVnljbTl5TDJOdmNtVkZjbkp2Y2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzYzBSQlFXMUVPMEZCUTI1RUxEQkVRVUYxUkR0QlFVVjJSRHM3UjBGRlJ6dEJRVU5JTEdWQlFYVkNMRk5CUVZFc1MwRkJTenRKUVdkQ2FFTTdPenM3TzA5QlMwYzdTVUZEU0N4WlFVRlpMRTlCUVdVc1JVRkJSU3hWUVVGclF5eEZRVUZGTEZWQlFXdENPMUZCUXk5RkxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTm1MRWxCUVVrc1EwRkJReXhWUVVGVkxFZEJRVWNzVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF6dFJRVU12UXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hIUVVGSExGVkJRVlVzUTBGQlF6dFJRVU0zUWl4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF6dEpRVU42UWl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlVUdFJRVU14UWl4TlFVRk5MRU5CUVVNc1IwRkJSeXhMUVVGTExGTkJRVk1zU1VGQlNTeEhRVUZITEV0QlFVc3NTVUZCU1N4SlFVRkpMRTlCUVU4c1IwRkJSeXhMUVVGTExGRkJRVkVzU1VGQlNTeFRRVUZUTEVsQlFVa3NSMEZCUnl4SlFVRkpMRmxCUVZrc1NVRkJTU3hIUVVGSExFTkJRVU03U1VGRGJrZ3NRMEZCUXp0SlFVVkVPenRQUVVWSE8wbEJRMGtzVFVGQlRUdFJRVU5VTEVsQlFVa3NSMEZCUnl4SFFVRkhMRVZCUVVVc1EwRkJRenRSUVVWaUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOeVF5eEhRVUZITEVsQlFVa3NSMEZCUnl4SlFVRkpMRU5CUVVNc1RVRkJUU3hKUVVGSkxFTkJRVU03VVVGRE9VSXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjBReXhIUVVGSExFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNN1VVRkROMElzUTBGQlF6dFJRVVZFTEUxQlFVMHNTVUZCU1N4SFFVRkhMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRPMUZCUXpGRExFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5zUWl4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMnBDTEVkQlFVY3NTVUZCU1N4SlFVRkpMRU5CUVVNN1dVRkRhRUlzUTBGQlF6dFpRVU5FTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVU3WjBKQlEyWXNSMEZCUnl4SlFVRkpMRXRCUVVzc1IwRkJSeXhMUVVGTExIVkNRVUZWTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRPMWxCUTNaRkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlExQXNRMEZCUXp0UlFVVkVMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU03U1VGRFppeERRVUZETzBOQlEwbzdRVUV2UkVRc09FSkJLMFJESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvZXJyb3IvY29yZUVycm9yLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCIuL3RyeXRlc1wiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHNpZ25hdHVyZSBtZXNzYWdlIGZyYWdtZW50cy5cclxuICovXHJcbmNsYXNzIFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRyeXRlcykge1xyXG4gICAgICAgIHRoaXMuX3RyeXRlcyA9IHRyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHNpZ25hdHVyZSBmcmFnbWVudCBmcm9tIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgVGhlIHRyeXRlcyB0byBjcmVhdGUgdGhlIHNpZ25hdHVyZSBmcmFnbWVudCBmcm9tLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVRyeXRlcyhzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5sZW5ndGgoKTtcclxuICAgICAgICBpZiAobGVuZ3RoICE9PSBTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgc2hvdWxkIGJlICR7U2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSH0gY2hhcmFjdGVycyBpbiBsZW5ndGhgLCB7IGxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgc2lnbmF0dXJlIGZyYWdtZW50IHRvIHRyeXRlcy5cclxuICAgICAqIEByZXR1cm5zIFRyeXRlcyB2ZXJzaW9uIG9mIHRoZSBzaWduYXR1cmUgZnJhZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIHRvVHJ5dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cnl0ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RyaW5nIHZpZXcgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHN0cmluZyBvZiB0aGUgdHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJ5dGVzLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBsZW5ndGggb2YgYSB2YWxpZCBzaWduYXR1cmUgbWVzc2FnZSBmcmFnbWVudCAoMjE4NylcclxuICovXHJcblNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEggPSAyMTg3O1xyXG4vKipcclxuICogQW4gZW1wdHkgc2lnbmF0dXJlIG1lc3NhZ2UgZnJhZ21lbnQgYWxsIDlzLlxyXG4gKi9cclxuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkVNUFRZID0gU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoXCI5XCIucmVwZWF0KFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEgpKSk7XHJcbmV4cG9ydHMuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50ID0gU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljMmxuYm1GMGRYSmxUV1Z6YzJGblpVWnlZV2R0Wlc1MExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJSaGRHRXZjMmxuYm1GMGRYSmxUV1Z6YzJGblpVWnlZV2R0Wlc1MExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVN3MFJVRkJlVVU3UVVGRGVrVXNhMFJCUVN0RE8wRkJReTlETEhGRFFVRnJRenRCUVVWc1F6czdSMEZGUnp0QlFVTklPMGxCWVVrc1pVRkJaVHRKUVVObUxGbEJRVzlDTEUxQlFXTTdVVUZET1VJc1NVRkJTU3hEUVVGRExFOUJRVThzUjBGQlJ5eE5RVUZOTEVOQlFVTTdTVUZETVVJc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEhkQ1FVRm5RenRSUVVOeVJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEhkQ1FVRjNRaXhGUVVGRkxHVkJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZSQ3hOUVVGTkxFbEJRVWtzY1VKQlFWTXNRMEZCUXl3NFJFRkJPRVFzUTBGQlF5eERRVUZETzFGQlEzaEdMRU5CUVVNN1VVRkZSQ3hOUVVGTkxFMUJRVTBzUjBGQlJ5eDNRa0ZCZDBJc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF6dFJRVU5xUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFdEJRVXNzZDBKQlFYZENMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU0zUXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5d3dRMEZCTUVNc2QwSkJRWGRDTEVOQlFVTXNUVUZCVFN4MVFrRkJkVUlzUlVGQlJTeEZRVUZGTEUxQlFVMHNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRkRWtzUTBGQlF6dFJRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMSGRDUVVGM1FpeERRVUZETEhkQ1FVRjNRaXhEUVVGRExFTkJRVU03U1VGRGJFVXNRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5KTEZGQlFWRTdVVUZEV0N4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF6dEpRVU40UWl4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NVVUZCVVR0UlFVTllMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMGxCUTI1RExFTkJRVU03TzBGQmFFUkVPenRIUVVWSE8wRkJRMjlDTEN0Q1FVRk5MRWRCUVZjc1NVRkJTU3hEUVVGRE8wRkJRemRET3p0SFFVVkhPMEZCUTI5Q0xEaENRVUZMTEVkQlFUWkNMSGRDUVVGM1FpeERRVUZETEZWQlFWVXNRMEZCUXl4bFFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNkMEpCUVhkQ0xFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCVW1wTExEUkVRV3RFUXlKOVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvZGF0YS9zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBkYXRhRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9kYXRhRXJyb3JcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIi4vdHJ5dGVzXCIpO1xyXG4vKipcclxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgdGFncy5cclxuICovXHJcbmNsYXNzIFRhZyB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRyeXRlcykge1xyXG4gICAgICAgIHRoaXMuX3RyeXRlcyA9IHRyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRhZyBmcm9tIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSB0YWcgVGhlIHRyeXRlcyB0byBjcmVhdGUgdGhlIHRhZyBmcm9tLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgVGFnLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVRyeXRlcyh0YWcpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodGFnLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdGFnIHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0cnl0ZXNTdHJpbmcgPSB0YWcudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAodHJ5dGVzU3RyaW5nLmxlbmd0aCA+IFRhZy5MRU5HVEgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIHRhZyBzaG91bGQgYmUgYXQgbW9zdCAke1RhZy5MRU5HVEh9IGNoYXJhY3RlcnMgaW4gbGVuZ3RoYCwgeyBsZW5ndGg6IHRyeXRlc1N0cmluZy5sZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICh0cnl0ZXNTdHJpbmcubGVuZ3RoIDwgVGFnLkxFTkdUSCkge1xyXG4gICAgICAgICAgICB0cnl0ZXNTdHJpbmcgKz0gXCI5XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVGFnKHRyeXRlc1N0cmluZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIHRhZyB0byB0cnl0ZXMuXHJcbiAgICAgKiBAcmV0dXJucyBUcnl0ZXMgdmVyc2lvbiBvZiB0aGUgdGFnLlxyXG4gICAgICovXHJcbiAgICB0b1RyeXRlcygpIHtcclxuICAgICAgICByZXR1cm4gdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodGhpcy5fdHJ5dGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdHJpbmcgdmlldyBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgc3RyaW5nIG9mIHRoZSB0cnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cnl0ZXM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBsZW5ndGggb2YgYSB2YWxpZCB0YWcgKDI3KS5cclxuICovXHJcblRhZy5MRU5HVEggPSAyNztcclxuLyoqXHJcbiAqIEFuIGVtcHR5IHRhZyBhbGwgOXMuXHJcbiAqL1xyXG5UYWcuRU1QVFkgPSBUYWcuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhcIjlcIi5yZXBlYXQoVGFnLkxFTkdUSCkpKTtcclxuZXhwb3J0cy5UYWcgPSBUYWc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRHRm5MbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyUmhkR0V2ZEdGbkxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVN3MFJVRkJlVVU3UVVGRGVrVXNhMFJCUVN0RE8wRkJReTlETEhGRFFVRnJRenRCUVVWc1F6czdSMEZGUnp0QlFVTklPMGxCWVVrc1pVRkJaVHRKUVVObUxGbEJRVzlDTEUxQlFXTTdVVUZET1VJc1NVRkJTU3hEUVVGRExFOUJRVThzUjBGQlJ5eE5RVUZOTEVOQlFVTTdTVUZETVVJc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEVkQlFWYzdVVUZEYUVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFVkJRVVVzWlVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMSGxEUVVGNVF5eERRVUZETEVOQlFVTTdVVUZEYmtVc1EwRkJRenRSUVVWRUxFbEJRVWtzV1VGQldTeEhRVUZITEVkQlFVY3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRSUVVWc1F5eEZRVUZGTEVOQlFVTXNRMEZCUXl4WlFVRlpMRU5CUVVNc1RVRkJUU3hIUVVGSExFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1RExFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMRFpDUVVFMlFpeEhRVUZITEVOQlFVTXNUVUZCVFN4MVFrRkJkVUlzUlVGQlJTeEZRVUZGTEUxQlFVMHNSVUZCUlN4WlFVRlpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVU42U0N4RFFVRkRPMUZCUlVRc1QwRkJUeXhaUVVGWkxFTkJRVU1zVFVGQlRTeEhRVUZITEVkQlFVY3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJRenRaUVVOMFF5eFpRVUZaTEVsQlFVa3NSMEZCUnl4RFFVRkRPMUZCUTNoQ0xFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4SFFVRkhMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU03U1VGRGFrTXNRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5KTEZGQlFWRTdVVUZEV0N4TlFVRk5MRU5CUVVNc1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRNME1zUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxGRkJRVkU3VVVGRFdDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJRenRKUVVONFFpeERRVUZET3p0QlFYUkVSRHM3UjBGRlJ6dEJRVU52UWl4VlFVRk5MRWRCUVZjc1JVRkJSU3hEUVVGRE8wRkJRek5ET3p0SFFVVkhPMEZCUTI5Q0xGTkJRVXNzUjBGQlVTeEhRVUZITEVOQlFVTXNWVUZCVlN4RFFVRkRMR1ZCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBGQlVteEhMR3RDUVhkRVF5SjlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL2RhdGEvdGFnLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzXCIpO1xyXG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xyXG5jb25zdCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMSA9IHJlcXVpcmUoXCIuL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFwiKTtcclxuY29uc3QgdGFnXzEgPSByZXF1aXJlKFwiLi90YWdcIik7XHJcbmNvbnN0IHRyeXRlTnVtYmVyXzEgPSByZXF1aXJlKFwiLi90cnl0ZU51bWJlclwiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiLi90cnl0ZXNcIik7XHJcbi8qKlxyXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyB0cmFuc2FjdGlvbnMuXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2FjdGlvbiB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgdHJhbnNhY3Rpb24gZnJvbSBwYXJhbWV0ZXJzLlxyXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCBUaGUgc2lnbmF0dXJlIG1lc3NhZ2UgZnJhZ21lbnQuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gb2Jzb2xldGVUYWcgT2Jzb2xldGUgdHJhbnNhY3Rpb24gdGFnLlxyXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wLlxyXG4gICAgICogQHBhcmFtIGN1cnJlbnRJbmRleCBUaGUgY3VycmVudCBpbmRleC5cclxuICAgICAqIEBwYXJhbSBsYXN0SW5kZXggVGhlIGxhc3QgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0gYnVuZGxlIFRoZSBidW5kbGUuXHJcbiAgICAgKiBAcGFyYW0gdHJ1bmtUcmFuc2FjdGlvbiBUaGUgdHJ1bmsgdHJhbnNhY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gYnJhbmNoVHJhbnNhY3Rpb24gVGhlIGJyYW5jaCB0cmFuc2FjdGlvbi5cclxuICAgICAqIEBwYXJhbSB0YWcgVGhlIHRhZy5cclxuICAgICAqIEBwYXJhbSBhdHRhY2htZW50VGltZXN0YW1wIFRoZSBhdHRhY2htZW50IHRpbWVzdGFtcC5cclxuICAgICAqIEBwYXJhbSBhdHRhY2htZW50VGltZXN0YW1wTG93ZXJCb3VuZCBUaGUgYXR0YWNobWVudCB0aW1lc3RhbXAgbG93ZXIgYm91bmQuXHJcbiAgICAgKiBAcGFyYW0gYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQgIFRoZSBhdHRhY2htZW50IHRpbWVzdGFtcCB1cHBlciBib3VuZC5cclxuICAgICAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2UuXHJcbiAgICAgKiBAcmV0dXJuIE5ldyBpbnN0YW5jZSBvZiB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21QYXJhbXMoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LCBhZGRyZXNzLCB2YWx1ZSwgb2Jzb2xldGVUYWcsIHRpbWVzdGFtcCwgY3VycmVudEluZGV4LCBsYXN0SW5kZXgsIGJ1bmRsZSwgdHJ1bmtUcmFuc2FjdGlvbiwgYnJhbmNoVHJhbnNhY3Rpb24sIHRhZywgYXR0YWNobWVudFRpbWVzdGFtcCwgYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQsIGF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kLCBub25jZSkge1xyXG4gICAgICAgIGNvbnN0IHR4ID0gbmV3IFRyYW5zYWN0aW9uKCk7XHJcbiAgICAgICAgdHguc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50ID0gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50O1xyXG4gICAgICAgIHR4LmFkZHJlc3MgPSBhZGRyZXNzO1xyXG4gICAgICAgIHR4LnZhbHVlID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKHZhbHVlLCAxMSk7XHJcbiAgICAgICAgdHgub2Jzb2xldGVUYWcgPSBvYnNvbGV0ZVRhZztcclxuICAgICAgICB0eC50aW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIodGltZXN0YW1wKTtcclxuICAgICAgICB0eC5jdXJyZW50SW5kZXggPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoY3VycmVudEluZGV4KTtcclxuICAgICAgICB0eC5sYXN0SW5kZXggPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIobGFzdEluZGV4KTtcclxuICAgICAgICB0eC5idW5kbGUgPSBidW5kbGU7XHJcbiAgICAgICAgdHgudHJ1bmtUcmFuc2FjdGlvbiA9IHRydW5rVHJhbnNhY3Rpb247XHJcbiAgICAgICAgdHguYnJhbmNoVHJhbnNhY3Rpb24gPSBicmFuY2hUcmFuc2FjdGlvbjtcclxuICAgICAgICB0eC50YWcgPSB0YWc7XHJcbiAgICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbU51bWJlcihhdHRhY2htZW50VGltZXN0YW1wKTtcclxuICAgICAgICB0eC5hdHRhY2htZW50VGltZXN0YW1wTG93ZXJCb3VuZCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbU51bWJlcihhdHRhY2htZW50VGltZXN0YW1wTG93ZXJCb3VuZCk7XHJcbiAgICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQpO1xyXG4gICAgICAgIHR4Lm5vbmNlID0gbm9uY2U7XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgdHJhbnNhY3Rpb24gZnJvbSB0cnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gdHJ5dGVzIFRoZSB0cnl0ZXMgZm9yIHRoZSB0aGlzLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhpcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21Ucnl0ZXModHJ5dGVzKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyeXRlcywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHRyeXRlcyBzaG91bGQgYmUgYSB2YWxpZCBUcnl0ZXMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW5ndGggPSB0cnl0ZXMubGVuZ3RoKCk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gVHJhbnNhY3Rpb24uTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSB0cnl0ZXMgbXVzdCBiZSAke1RyYW5zYWN0aW9uLkxFTkdUSH0gaW4gbGVuZ3RoYCwgeyBsZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoZWNrSW5kZXhTdGFydCA9IDIyNzk7XHJcbiAgICAgICAgY29uc3QgY2hlY2tJbmRleExlbmd0aCA9IDE2O1xyXG4gICAgICAgIGNvbnN0IGNoZWNrID0gdHJ5dGVzLnN1YihjaGVja0luZGV4U3RhcnQsIGNoZWNrSW5kZXhMZW5ndGgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKGNoZWNrICE9PSBUcmFuc2FjdGlvbi5DSEVDS19WQUxVRSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgdHJ5dGVzIGJldHdlZW4gJHtjaGVja0luZGV4U3RhcnR9IGFuZCAke2NoZWNrSW5kZXhTdGFydCArIGNoZWNrSW5kZXhMZW5ndGh9IHNob3VsZCBiZSBhbGwgOXNgLCB7IGNoZWNrIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvbigpO1xyXG4gICAgICAgIGxldCBzdGFydFBvcyA9IDA7XHJcbiAgICAgICAgdHguc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50ID0gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEg7XHJcbiAgICAgICAgdHguYWRkcmVzcyA9IGFkZHJlc3NfMS5BZGRyZXNzLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgYWRkcmVzc18xLkFkZHJlc3MuTEVOR1RIKSk7XHJcbiAgICAgICAgc3RhcnRQb3MgKz0gYWRkcmVzc18xLkFkZHJlc3MuTEVOR1RIO1xyXG4gICAgICAgIHR4LnZhbHVlID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIDExKSwgMTEpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IDExO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IFRyYW5zYWN0aW9uLkNIRUNLX1ZBTFVFX0xFTkdUSDtcclxuICAgICAgICB0eC5vYnNvbGV0ZVRhZyA9IHRhZ18xLlRhZy5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRhZ18xLlRhZy5MRU5HVEgpKTtcclxuICAgICAgICBzdGFydFBvcyArPSB0YWdfMS5UYWcuTEVOR1RIO1xyXG4gICAgICAgIHR4LnRpbWVzdGFtcCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbVRyeXRlcyh0cnl0ZXMuc3ViKHN0YXJ0UG9zLCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkxFTkdUSF85KSk7XHJcbiAgICAgICAgc3RhcnRQb3MgKz0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOTtcclxuICAgICAgICB0eC5jdXJyZW50SW5kZXggPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XHJcbiAgICAgICAgdHgubGFzdEluZGV4ID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzkpKTtcclxuICAgICAgICBzdGFydFBvcyArPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkxFTkdUSF85O1xyXG4gICAgICAgIHR4LmJ1bmRsZSA9IGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgaGFzaF8xLkhhc2guTEVOR1RIKSk7XHJcbiAgICAgICAgc3RhcnRQb3MgKz0gaGFzaF8xLkhhc2guTEVOR1RIO1xyXG4gICAgICAgIHR4LnRydW5rVHJhbnNhY3Rpb24gPSBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIGhhc2hfMS5IYXNoLkxFTkdUSCkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IGhhc2hfMS5IYXNoLkxFTkdUSDtcclxuICAgICAgICB0eC5icmFuY2hUcmFuc2FjdGlvbiA9IGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgaGFzaF8xLkhhc2guTEVOR1RIKSk7XHJcbiAgICAgICAgc3RhcnRQb3MgKz0gaGFzaF8xLkhhc2guTEVOR1RIO1xyXG4gICAgICAgIHR4LnRhZyA9IHRhZ18xLlRhZy5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRhZ18xLlRhZy5MRU5HVEgpKTtcclxuICAgICAgICBzdGFydFBvcyArPSB0YWdfMS5UYWcuTEVOR1RIO1xyXG4gICAgICAgIHR4LmF0dGFjaG1lbnRUaW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XHJcbiAgICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XHJcbiAgICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XHJcbiAgICAgICAgdHgubm9uY2UgPSB0YWdfMS5UYWcuZnJvbVRyeXRlcyh0cnl0ZXMuc3ViKHN0YXJ0UG9zLCB0YWdfMS5UYWcuTEVOR1RIKSk7XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSB0cmFuc2FjdGlvbiB0byB0cnl0ZXMuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSB0cmFuc2FjdGlvbiBhcyB0cnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHRvVHJ5dGVzKCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0aGlzLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCwgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IG11c3QgYmUgc2V0IHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiB0cnl0ZXNgLCB7IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudDogdGhpcy5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0aGlzLmFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgYWRkcmVzcyBtdXN0IGJlIHNldCB0byBjcmVhdGUgdHJhbnNhY3Rpb24gdHJ5dGVzYCwgeyBhZGRyZXNzOiB0aGlzLmFkZHJlc3MgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0aGlzLm9ic29sZXRlVGFnLCB0YWdfMS5UYWcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBvYnNvbGV0ZVRhZyBtdXN0IGJlIHNldCB0byBjcmVhdGUgdHJhbnNhY3Rpb24gdHJ5dGVzYCwgeyBvYnNvbGV0ZVRhZzogdGhpcy5vYnNvbGV0ZVRhZyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRoaXMuYnVuZGxlLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIGJ1bmRsZSBtdXN0IGJlIHNldCB0byBjcmVhdGUgdHJhbnNhY3Rpb24gdHJ5dGVzYCwgeyBidW5kbGU6IHRoaXMuYnVuZGxlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodGhpcy50cnVua1RyYW5zYWN0aW9uLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIHRydW5rVHJhbnNhY3Rpb24gbXVzdCBiZSBzZXQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIHRyeXRlc2AsIHsgdHJ1bmtUcmFuc2FjdGlvbjogdGhpcy50cnVua1RyYW5zYWN0aW9uIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodGhpcy5icmFuY2hUcmFuc2FjdGlvbiwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBicmFuY2hUcmFuc2FjdGlvbiBtdXN0IGJlIHNldCB0byBjcmVhdGUgdHJhbnNhY3Rpb24gdHJ5dGVzYCwgeyBicmFuY2hUcmFuc2FjdGlvbjogdGhpcy5icmFuY2hUcmFuc2FjdGlvbiB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRoaXMubm9uY2UsIHRhZ18xLlRhZykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIG5vbmNlIG11c3QgYmUgc2V0IHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiB0cnl0ZXNgLCB7IG5vbmNlOiB0aGlzLm5vbmNlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cnl0ZXMgPSB0aGlzLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyB0aGlzLmFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgKHRoaXMudmFsdWUgfHwgVHJhbnNhY3Rpb24uRU1QVFlfMTEpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArIFRyYW5zYWN0aW9uLkNIRUNLX1ZBTFVFXHJcbiAgICAgICAgICAgICsgdGhpcy5vYnNvbGV0ZVRhZy50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyAodGhpcy50aW1lc3RhbXAgfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyAodGhpcy5jdXJyZW50SW5kZXggfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyAodGhpcy5sYXN0SW5kZXggfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyB0aGlzLmJ1bmRsZS50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyB0aGlzLnRydW5rVHJhbnNhY3Rpb24udG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgdGhpcy5icmFuY2hUcmFuc2FjdGlvbi50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyAodGhpcy50YWcgfHwgdGhpcy5vYnNvbGV0ZVRhZykudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgKHRoaXMuYXR0YWNobWVudFRpbWVzdGFtcCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArICh0aGlzLmF0dGFjaG1lbnRUaW1lc3RhbXBMb3dlckJvdW5kIHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgKHRoaXMuYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQgfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyB0aGlzLm5vbmNlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSB0cnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChsZW5ndGggIT09IFRyYW5zYWN0aW9uLkxFTkdUSCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgdHJ5dGVzIG11c3QgYmUgJHtUcmFuc2FjdGlvbi5MRU5HVEh9IGluIGxlbmd0aCAke2xlbmd0aH1gLCB7IGxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRyeXRlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RyaW5nIHZpZXcgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHN0cmluZyB2aWV3IG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBge1xuXFx0c2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50OiBcIiR7KHRoaXMuc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IHx8IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5FTVBUWSkudG9Ucnl0ZXMoKS50b1N0cmluZygpfVwiXG5cXHRhZGRyZXNzOiBcIiR7KHRoaXMuYWRkcmVzcyB8fCBhZGRyZXNzXzEuQWRkcmVzcy5FTVBUWSkudG9Ucnl0ZXMoKS50b1N0cmluZygpfVwiXG5cXHR2YWx1ZTogJHsodGhpcy52YWx1ZSB8fCBUcmFuc2FjdGlvbi5FTVBUWV8xMSkudG9OdW1iZXIoKX1cblxcdG9ic29sZXRlVGFnOiBcIiR7KHRoaXMub2Jzb2xldGVUYWcgfHwgdGFnXzEuVGFnLkVNUFRZKS50b1RyeXRlcygpLnRvU3RyaW5nKCl9XCJcblxcdHRpbWVzdGFtcDogJHsodGhpcy50aW1lc3RhbXAgfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b051bWJlcigpfVxuXFx0Y3VycmVudEluZGV4OiAkeyh0aGlzLmN1cnJlbnRJbmRleCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvTnVtYmVyKCl9XG5cXHRsYXN0SW5kZXg6ICR7KHRoaXMubGFzdEluZGV4IHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9OdW1iZXIoKX1cblxcdGJ1bmRsZTogXCIkeyh0aGlzLmJ1bmRsZSB8fCBoYXNoXzEuSGFzaC5FTVBUWSkudG9Ucnl0ZXMoKS50b1N0cmluZygpfVwiXG5cXHR0cnVua1RyYW5zYWN0aW9uOiBcIiR7KHRoaXMudHJ1bmtUcmFuc2FjdGlvbiB8fCBoYXNoXzEuSGFzaC5FTVBUWSkudG9Ucnl0ZXMoKS50b1N0cmluZygpfVwiXG5cXHRicmFuY2hUcmFuc2FjdGlvbjogXCIkeyh0aGlzLmJyYW5jaFRyYW5zYWN0aW9uIHx8IGhhc2hfMS5IYXNoLkVNUFRZKS50b1RyeXRlcygpLnRvU3RyaW5nKCl9XCJcblxcdHRhZzogXCIkeyh0aGlzLnRhZyB8fCB0aGlzLm9ic29sZXRlVGFnIHx8IHRhZ18xLlRhZy5FTVBUWSkudG9Ucnl0ZXMoKS50b1N0cmluZygpfVwiXG5cXHRhdHRhY2htZW50VGltZXN0YW1wOiAkeyh0aGlzLmF0dGFjaG1lbnRUaW1lc3RhbXAgfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b051bWJlcigpfVxuXFx0YXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQ6ICR7KHRoaXMuYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQgfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b051bWJlcigpfVxuXFx0YXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQ6ICR7KHRoaXMuYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQgfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b051bWJlcigpfVxuXFx0bm9uY2U6IFwiJHsodGhpcy5ub25jZSB8fCB0YWdfMS5UYWcuRU1QVFkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKX1cIlxufWA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBsZW5ndGggb2YgYSB2YWxpZCB0cmFuc2FjdGlvbiAoMjY3MykuXHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5MRU5HVEggPSAyNjczO1xyXG4vKipcclxuICogVGhlIGxlbmd0aCBvZiBhIHZhbGlkIGNoZWNrIHZhbHVlICgxNikuXHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5DSEVDS19WQUxVRV9MRU5HVEggPSAxNjtcclxuLyoqXHJcbiAqIFRoZSBjaGVjayB2YWx1ZSBmb3IgYnVuZGxlcyBhbGwgOXMuXHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5DSEVDS19WQUxVRSA9IFwiOVwiLnJlcGVhdChUcmFuc2FjdGlvbi5DSEVDS19WQUxVRV9MRU5HVEgpO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuVHJhbnNhY3Rpb24uRU1QVFlfMTEgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoMCwgMTEpO1xyXG5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRISmhibk5oWTNScGIyNHVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdlpHRjBZUzkwY21GdWMyRmpkR2x2Ymk1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzTkVWQlFYbEZPMEZCUTNwRkxHdEVRVUVyUXp0QlFVTXZReXgxUTBGQmIwTTdRVUZEY0VNc2FVTkJRVGhDTzBGQlF6bENMSGxGUVVGelJUdEJRVU4wUlN3clFrRkJORUk3UVVGRE5VSXNLME5CUVRSRE8wRkJRelZETEhGRFFVRnJRenRCUVVWc1F6czdSMEZGUnp0QlFVTklPMGxCWjBaSkxHVkJRV1U3U1VGRFpqdEpRVU5CTEVOQlFVTTdTVUZGUkRzN096czdPenM3T3pzN096czdPenM3TzA5QmEwSkhPMGxCUTBrc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eDNRa0ZCYTBRc1JVRkRiRVFzVDBGQlowSXNSVUZEYUVJc1MwRkJZU3hGUVVOaUxGZEJRV2RDTEVWQlEyaENMRk5CUVdsQ0xFVkJRMnBDTEZsQlFXOUNMRVZCUTNCQ0xGTkJRV2xDTEVWQlEycENMRTFCUVZrc1JVRkRXaXhuUWtGQmMwSXNSVUZEZEVJc2FVSkJRWFZDTEVWQlEzWkNMRWRCUVZFc1JVRkRVaXh0UWtGQk1rSXNSVUZETTBJc05rSkJRWEZETEVWQlEzSkRMRFpDUVVGeFF5eEZRVU55UXl4TFFVRlZPMUZCUXk5Q0xFMUJRVTBzUlVGQlJTeEhRVUZITEVsQlFVa3NWMEZCVnl4RlFVRkZMRU5CUVVNN1VVRkROMElzUlVGQlJTeERRVUZETEhkQ1FVRjNRaXhIUVVGSExIZENRVUYzUWl4RFFVRkRPMUZCUTNaRUxFVkJRVVVzUTBGQlF5eFBRVUZQTEVkQlFVY3NUMEZCVHl4RFFVRkRPMUZCUTNKQ0xFVkJRVVVzUTBGQlF5eExRVUZMTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUXpkRExFVkJRVVVzUTBGQlF5eFhRVUZYTEVkQlFVY3NWMEZCVnl4RFFVRkRPMUZCUXpkQ0xFVkJRVVVzUTBGQlF5eFRRVUZUTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTTdVVUZEYWtRc1JVRkJSU3hEUVVGRExGbEJRVmtzUjBGQlJ5eDVRa0ZCVnl4RFFVRkRMRlZCUVZVc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF6dFJRVU4yUkN4RlFVRkZMRU5CUVVNc1UwRkJVeXhIUVVGSExIbENRVUZYTEVOQlFVTXNWVUZCVlN4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRE8xRkJRMnBFTEVWQlFVVXNRMEZCUXl4TlFVRk5MRWRCUVVjc1RVRkJUU3hEUVVGRE8xRkJRMjVDTEVWQlFVVXNRMEZCUXl4blFrRkJaMElzUjBGQlJ5eG5Ra0ZCWjBJc1EwRkJRenRSUVVOMlF5eEZRVUZGTEVOQlFVTXNhVUpCUVdsQ0xFZEJRVWNzYVVKQlFXbENMRU5CUVVNN1VVRkRla01zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNN1VVRkRZaXhGUVVGRkxFTkJRVU1zYlVKQlFXMUNMRWRCUVVjc2VVSkJRVmNzUTBGQlF5eFZRVUZWTEVOQlFVTXNiVUpCUVcxQ0xFTkJRVU1zUTBGQlF6dFJRVU55UlN4RlFVRkZMRU5CUVVNc05rSkJRVFpDTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zTmtKQlFUWkNMRU5CUVVNc1EwRkJRenRSUVVONlJpeEZRVUZGTEVOQlFVTXNOa0pCUVRaQ0xFZEJRVWNzZVVKQlFWY3NRMEZCUXl4VlFVRlZMRU5CUVVNc05rSkJRVFpDTEVOQlFVTXNRMEZCUXp0UlFVTjZSaXhGUVVGRkxFTkJRVU1zUzBGQlN5eEhRVUZITEV0QlFVc3NRMEZCUXp0UlFVTnFRaXhOUVVGTkxFTkJRVU1zUlVGQlJTeERRVUZETzBsQlEyUXNRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRV003VVVGRGJrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRVZCUVVVc1pVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzWkRMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETERSRFFVRTBReXhEUVVGRExFTkJRVU03VVVGRGRFVXNRMEZCUXp0UlFVVkVMRTFCUVUwc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXp0UlFVTXZRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eE5RVUZOTEV0QlFVc3NWMEZCVnl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFFTXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zYzBKQlFYTkNMRmRCUVZjc1EwRkJReXhOUVVGTkxGbEJRVmtzUlVGQlJTeEZRVUZGTEUxQlFVMHNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRNVVlzUTBGQlF6dFJRVVZFTEUxQlFVMHNaVUZCWlN4SFFVRkhMRWxCUVVrc1EwRkJRenRSUVVNM1FpeE5RVUZOTEdkQ1FVRm5RaXhIUVVGSExFVkJRVVVzUTBGQlF6dFJRVU0xUWl4TlFVRk5MRXRCUVVzc1IwRkJSeXhOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEdWQlFXVXNSVUZCUlN4blFrRkJaMElzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMUZCUlhaRkxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NTMEZCU3l4WFFVRlhMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU53UXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHpRa0ZCYzBJc1pVRkJaU3hSUVVGUkxHVkJRV1VzUjBGQlJ5eG5Ra0ZCWjBJc2JVSkJRVzFDTEVWQlFVVXNSVUZCUlN4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRM1pKTEVOQlFVTTdVVUZGUkN4TlFVRk5MRVZCUVVVc1IwRkJSeXhKUVVGSkxGZEJRVmNzUlVGQlJTeERRVUZETzFGQlJUZENMRWxCUVVrc1VVRkJVU3hIUVVGSExFTkJRVU1zUTBGQlF6dFJRVU5xUWl4RlFVRkZMRU5CUVVNc2QwSkJRWGRDTEVkQlFVY3NiVVJCUVhkQ0xFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1VVRkJVU3hGUVVGRkxHMUVRVUYzUWl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVrZ3NVVUZCVVN4SlFVRkpMRzFFUVVGM1FpeERRVUZETEUxQlFVMHNRMEZCUXp0UlFVTTFReXhGUVVGRkxFTkJRVU1zVDBGQlR5eEhRVUZITEdsQ1FVRlBMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNVVUZCVVN4RlFVRkZMR2xDUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjBSU3hSUVVGUkxFbEJRVWtzYVVKQlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNN1VVRkRNMElzUlVGQlJTeERRVUZETEV0QlFVc3NSMEZCUnl4NVFrRkJWeXhEUVVGRExGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRkZCUVZFc1JVRkJSU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTm9SU3hSUVVGUkxFbEJRVWtzUlVGQlJTeERRVUZETzFGQlEyWXNVVUZCVVN4SlFVRkpMRmRCUVZjc1EwRkJReXhyUWtGQmEwSXNRMEZCUXp0UlFVTXpReXhGUVVGRkxFTkJRVU1zVjBGQlZ5eEhRVUZITEZOQlFVY3NRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eFJRVUZSTEVWQlFVVXNVMEZCUnl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGJFVXNVVUZCVVN4SlFVRkpMRk5CUVVjc1EwRkJReXhOUVVGTkxFTkJRVU03VVVGRGRrSXNSVUZCUlN4RFFVRkRMRk5CUVZNc1IwRkJSeXg1UWtGQlZ5eERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExGRkJRVkVzUlVGQlJTeDVRa0ZCVnl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGJFWXNVVUZCVVN4SlFVRkpMSGxDUVVGWExFTkJRVU1zVVVGQlVTeERRVUZETzFGQlEycERMRVZCUVVVc1EwRkJReXhaUVVGWkxFZEJRVWNzZVVKQlFWY3NRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eFJRVUZSTEVWQlFVVXNlVUpCUVZjc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzSkdMRkZCUVZFc1NVRkJTU3g1UWtGQlZ5eERRVUZETEZGQlFWRXNRMEZCUXp0UlFVTnFReXhGUVVGRkxFTkJRVU1zVTBGQlV5eEhRVUZITEhsQ1FVRlhMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNVVUZCVVN4RlFVRkZMSGxDUVVGWExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnNSaXhSUVVGUkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4UlFVRlJMRU5CUVVNN1VVRkRha01zUlVGQlJTeERRVUZETEUxQlFVMHNSMEZCUnl4WFFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNVVUZCVVN4RlFVRkZMRmRCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF5OUVMRkZCUVZFc1NVRkJTU3hYUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETzFGQlEzaENMRVZCUVVVc1EwRkJReXhuUWtGQlowSXNSMEZCUnl4WFFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNVVUZCVVN4RlFVRkZMRmRCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzcEZMRkZCUVZFc1NVRkJTU3hYUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETzFGQlEzaENMRVZCUVVVc1EwRkJReXhwUWtGQmFVSXNSMEZCUnl4WFFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNVVUZCVVN4RlFVRkZMRmRCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6RkZMRkZCUVZFc1NVRkJTU3hYUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETzFGQlEzaENMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzVTBGQlJ5eERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExGRkJRVkVzUlVGQlJTeFRRVUZITEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNeFJDeFJRVUZSTEVsQlFVa3NVMEZCUnl4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVOMlFpeEZRVUZGTEVOQlFVTXNiVUpCUVcxQ0xFZEJRVWNzZVVKQlFWY3NRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eFJRVUZSTEVWQlFVVXNlVUpCUVZjc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6VkdMRkZCUVZFc1NVRkJTU3g1UWtGQlZ5eERRVUZETEZGQlFWRXNRMEZCUXp0UlFVTnFReXhGUVVGRkxFTkJRVU1zTmtKQlFUWkNMRWRCUVVjc2VVSkJRVmNzUTBGQlF5eFZRVUZWTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFVkJRVVVzZVVKQlFWY3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1JITEZGQlFWRXNTVUZCU1N4NVFrRkJWeXhEUVVGRExGRkJRVkVzUTBGQlF6dFJRVU5xUXl4RlFVRkZMRU5CUVVNc05rSkJRVFpDTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4UlFVRlJMRVZCUVVVc2VVSkJRVmNzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNSSExGRkJRVkVzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMRkZCUVZFc1EwRkJRenRSUVVOcVF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4SFFVRkhMRk5CUVVjc1EwRkJReXhWUVVGVkxFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4UlFVRlJMRVZCUVVVc1UwRkJSeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZGTlVRc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF6dEpRVU5rTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeFJRVUZSTzFGQlExZ3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc2QwSkJRWGRDTEVWQlFVVXNiVVJCUVhkQ0xFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYUVZc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNkVVZCUVhWRkxFVkJRVVVzUlVGQlJTeDNRa0ZCZDBJc1JVRkJSU3hKUVVGSkxFTkJRVU1zZDBKQlFYZENMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRemxLTEVOQlFVTTdVVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFVkJRVVVzYVVKQlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNNVF5eE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXh6UkVGQmMwUXNSVUZCUlN4RlFVRkZMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTXpSeXhEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RlFVRkZMRk5CUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU01UXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5d3dSRUZCTUVRc1JVRkJSU3hGUVVGRkxGZEJRVmNzUlVGQlJTeEpRVUZKTEVOQlFVTXNWMEZCVnl4RlFVRkZMRU5CUVVNc1EwRkJRenRSUVVOMlNDeERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxGZEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXhReXhOUVVGTkxFbEJRVWtzY1VKQlFWTXNRMEZCUXl4eFJFRkJjVVFzUlVGQlJTeEZRVUZGTEUxQlFVMHNSVUZCUlN4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVU40Unl4RFFVRkRPMUZCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zWjBKQlFXZENMRVZCUVVVc1YwRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkVMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEN0RVFVRXJSQ3hGUVVGRkxFVkJRVVVzWjBKQlFXZENMRVZCUVVVc1NVRkJTU3hEUVVGRExHZENRVUZuUWl4RlFVRkZMRU5CUVVNc1EwRkJRenRSUVVOMFNTeERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc2FVSkJRV2xDTEVWQlFVVXNWMEZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0pFTEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExHZEZRVUZuUlN4RlFVRkZMRVZCUVVVc2FVSkJRV2xDTEVWQlFVVXNTVUZCU1N4RFFVRkRMR2xDUVVGcFFpeEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTjZTU3hEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZMRk5CUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU40UXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHZSRUZCYjBRc1JVRkJSU3hGUVVGRkxFdEJRVXNzUlVGQlJTeEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRSUVVOeVJ5eERRVUZETzFGQlJVUXNUVUZCVFN4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRExIZENRVUYzUWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJUdGpRVU0xUkN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlR0alFVTnNReXhEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVsQlFVa3NWMEZCVnl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlR0alFVTXhSQ3hYUVVGWExFTkJRVU1zVjBGQlZ6dGpRVU4yUWl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlR0alFVTjBReXhEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVN1kwRkROMFFzUTBGQlF5eEpRVUZKTEVOQlFVTXNXVUZCV1N4SlFVRkpMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRk8yTkJRMmhGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1NVRkJTU3g1UWtGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJUdGpRVU0zUkN4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlR0alFVTnFReXhKUVVGSkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTzJOQlF6TkRMRWxCUVVrc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3WTBGRE5VTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhKUVVGSkxFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3WTBGRGNFUXNRMEZCUXl4SlFVRkpMRU5CUVVNc2JVSkJRVzFDTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVN1kwRkRka1VzUTBGQlF5eEpRVUZKTEVOQlFVTXNOa0pCUVRaQ0xFbEJRVWtzZVVKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVTdZMEZEYWtZc1EwRkJReXhKUVVGSkxFTkJRVU1zTmtKQlFUWkNMRWxCUVVrc2VVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3WTBGRGFrWXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXp0UlFVVjJReXhOUVVGTkxFMUJRVTBzUjBGQlJ5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUXpkQ0xFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNTMEZCU3l4WFFVRlhMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5vUXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHpRa0ZCYzBJc1YwRkJWeXhEUVVGRExFMUJRVTBzWTBGQll5eE5RVUZOTEVWQlFVVXNSVUZCUlN4RlFVRkZMRTFCUVUwc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGNFY3NRMEZCUXp0UlFVVkVMRTFCUVUwc1EwRkJReXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMGxCUTNKRExFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hSUVVGUk8xRkJRMWdzVFVGQlRTeERRVUZET3l0Q1FVTm5RaXhEUVVGRExFbEJRVWtzUTBGQlF5eDNRa0ZCZDBJc1NVRkJTU3h0UkVGQmQwSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVTdZMEZEZUVjc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eEpRVUZKTEdsQ1FVRlBMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZPMWRCUTNoRUxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NTVUZCU1N4WFFVRlhMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTzJ0Q1FVTjRReXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVsQlFVa3NVMEZCUnl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlR0bFFVTjRSQ3hEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVTdhMEpCUXk5RExFTkJRVU1zU1VGQlNTeERRVUZETEZsQlFWa3NTVUZCU1N4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlR0bFFVTjRSQ3hEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVTdZVUZEY0VRc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeEpRVUZKTEZkQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVTdkVUpCUTNaRExFTkJRVU1zU1VGQlNTeERRVUZETEdkQ1FVRm5RaXhKUVVGSkxGZEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3ZDBKQlF6RkVMRU5CUVVNc1NVRkJTU3hEUVVGRExHbENRVUZwUWl4SlFVRkpMRmRCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVN1ZVRkRNVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4SlFVRkpMRWxCUVVrc1EwRkJReXhYUVVGWExFbEJRVWtzVTBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJUdDVRa0ZEYkVRc1EwRkJReXhKUVVGSkxFTkJRVU1zYlVKQlFXMUNMRWxCUVVrc2VVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVN2JVTkJRMnhFTEVOQlFVTXNTVUZCU1N4RFFVRkRMRFpDUVVFMlFpeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTzIxRFFVTjBSU3hEUVVGRExFbEJRVWtzUTBGQlF5dzJRa0ZCTmtJc1NVRkJTU3g1UWtGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSVHRaUVVNM1JpeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRWxCUVVrc1UwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSVHRGUVVONlJDeERRVUZETzBsQlEwTXNRMEZCUXpzN1FVRndVa1E3TzBkQlJVYzdRVUZEYjBJc2EwSkJRVTBzUjBGQlZ5eEpRVUZKTEVOQlFVTTdRVUZGTjBNN08wZEJSVWM3UVVGRGIwSXNPRUpCUVd0Q0xFZEJRVmNzUlVGQlJTeERRVUZETzBGQlJYWkVPenRIUVVWSE8wRkJRMjlDTEhWQ1FVRlhMRWRCUVZjc1IwRkJSeXhEUVVGRExFMUJRVTBzUTBGQlF5eFhRVUZYTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zUTBGQlF6dEJRVVY0Uml4bFFVRmxPMEZCUTFNc2IwSkJRVkVzUjBGQlowSXNlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMEZCYWtKc1JpeHJRMEZ6VWtNaWZRPT1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL2RhdGEvdHJhbnNhY3Rpb24udHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCB0cml0c18xID0gcmVxdWlyZShcIi4vdHJpdHNcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIi4vdHJ5dGVzXCIpO1xyXG4vKipcclxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgdHJ5dGUgbnVtYmVyLlxyXG4gKi9cclxuY2xhc3MgVHJ5dGVOdW1iZXIge1xyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0cnl0ZXMpIHtcclxuICAgICAgICB0aGlzLl90cnl0ZXMgPSB0cnl0ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0cnl0ZSBudW1iZXIgZnJvbSBudW1iZXIuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG51bWJlciB2YWx1ZSB0byBjcmVhdGUgdGhlIG9iamVjdCBmcm9tLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgdHJ5dGUgbGVuZ3RoIHRvIHBhZCB0aGUgbnVtYmVyIHdpdGguXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUcnl0ZU51bWJlci5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21OdW1iZXIodmFsdWUsIGxlbmd0aCA9IFRyeXRlTnVtYmVyLkxFTkdUSF85KSB7XHJcbiAgICAgICAgbGV0IHRyeXRlcztcclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIGxlbmd0aCBzaG91bGQgYmUgYSBudW1iZXIgPiAwXCIsIHsgbGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRyeXRlcyA9IFwiOVwiLnJlcGVhdChsZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSB2YWx1ZSBpcyBub3QgYW4gaW50ZWdlclwiLCB7IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRyaXRzID0gdHJpdHNfMS5Ucml0cy5mcm9tTnVtYmVyKHZhbHVlKS50b051bWJlckFycmF5KCk7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cml0cy5sZW5ndGggPCBsZW5ndGggKiAzKSB7XHJcbiAgICAgICAgICAgICAgICB0cml0cy5wdXNoKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeXRlcyA9IHRyaXRzXzEuVHJpdHMuZnJvbU51bWJlckFycmF5KHRyaXRzKS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJ5dGVOdW1iZXIodHJ5dGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRyeXRlIG51bWJlciBmcm9tIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgbnVtYmVyIHZhbHVlIHRvIGNyZWF0ZSB0aGUgb2JqZWN0IGZyb20uXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSB0cnl0ZSBsZW5ndGggdG8gcGFkIHRoZSBudW1iZXIgd2l0aC5cclxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRyeXRlTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVRyeXRlcyh2YWx1ZSwgbGVuZ3RoID0gVHJ5dGVOdW1iZXIuTEVOR1RIXzkpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodmFsdWUsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSB2YWx1ZSBzaG91bGQgYmUgYSB2YWxpZCBUcnl0ZXMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdHJ5dGVTdHJpbmcgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgbGVuZ3RoIHNob3VsZCBiZSBhIG51bWJlciA+IDBcIiwgeyBsZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cnl0ZVN0cmluZy5sZW5ndGggPiBsZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSB2YWx1ZSBjb250YWlucyB0b28gbWFueSBjaGFyYWN0ZXJzXCIsIHsgbGVuZ3RoOiB0cnl0ZVN0cmluZy5sZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICh0cnl0ZVN0cmluZy5sZW5ndGggPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgdHJ5dGVTdHJpbmcgKz0gXCI5XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJ5dGVOdW1iZXIodHJ5dGVTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSB0cnl0ZSBudW1iZXIgdG8gdHJ5dGVzLlxyXG4gICAgICogQHJldHVybnMgVHJ5dGVzIHZlcnNpb24gb2YgdGhlIHRyeXRlIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgdG9Ucnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRoaXMuX3RyeXRlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIHRyeXRlIG51bWJlciB0byBudW1iZXIuXHJcbiAgICAgKiBAcmV0dXJucyBudW1iZXIgdmFsdWUgb2YgdGhlIHRyeXRlIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgdG9OdW1iZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0aGlzLl90cnl0ZXMpKS50b051bWJlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHN0cmluZyB2aWV3IG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBzdHJpbmcgb2YgdGhlIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgc3RyaW5nIG9mIHRoZSB0cnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHZhbHVlT2YoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9OdW1iZXIoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTGVuZ3RoIG9mIGEgbnVtYmVyIHRoYXQgdXNlcyA5IHRyeXRlcy5cclxuICovXHJcblRyeXRlTnVtYmVyLkxFTkdUSF85ID0gOTtcclxuLyoqXHJcbiAqIEFuIGVtcHR5IDkgbGVuZ3RoIHRyeXRlIG51bWJlci5cclxuICovXHJcblRyeXRlTnVtYmVyLkVNUFRZXzkgPSBUcnl0ZU51bWJlci5mcm9tTnVtYmVyKDAsIFRyeXRlTnVtYmVyLkxFTkdUSF85KTtcclxuZXhwb3J0cy5Ucnl0ZU51bWJlciA9IFRyeXRlTnVtYmVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkSEo1ZEdWT2RXMWlaWEl1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZaR0YwWVM5MGNubDBaVTUxYldKbGNpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFc05FVkJRWGxGTzBGQlEzcEZMRFJGUVVGNVJUdEJRVU42UlN4clJFRkJLME03UVVGREwwTXNiVU5CUVdkRE8wRkJRMmhETEhGRFFVRnJRenRCUVVWc1F6czdSMEZGUnp0QlFVTklPMGxCWVVrc1pVRkJaVHRKUVVObUxGbEJRVzlDTEUxQlFXTTdVVUZET1VJc1NVRkJTU3hEUVVGRExFOUJRVThzUjBGQlJ5eE5RVUZOTEVOQlFVTTdTVUZETVVJc1EwRkJRenRKUVVWRU96czdPenRQUVV0SE8wbEJRMGtzVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4TFFVRmhMRVZCUVVVc1UwRkJhVUlzVjBGQlZ5eERRVUZETEZGQlFWRTdVVUZEZWtVc1NVRkJTU3hOUVVGTkxFTkJRVU03VVVGRldDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRTFCUVUwc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEycEVMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEcxRFFVRnRReXhGUVVGRkxFVkJRVVVzVFVGQlRTeEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTjZSU3hEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpsQ0xFMUJRVTBzUjBGQlJ5eEhRVUZITEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJRMmhETEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOS0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOcVF5eE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXcyUWtGQk5rSXNSVUZCUlN4RlFVRkZMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGJFVXNRMEZCUXp0WlFVVkVMRTFCUVUwc1MwRkJTeXhIUVVGSExHRkJRVXNzUTBGQlF5eFZRVUZWTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1lVRkJZU3hGUVVGRkxFTkJRVU03V1VGRmRFUXNUMEZCVHl4TFFVRkxMRU5CUVVNc1RVRkJUU3hIUVVGSExFMUJRVTBzUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXp0blFrRkRMMElzUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOc1FpeERRVUZETzFsQlJVUXNUVUZCVFN4SFFVRkhMR0ZCUVVzc1EwRkJReXhsUVVGbExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU03VVVGRGFFVXNRMEZCUXp0UlFVVkVMRTFCUVUwc1EwRkJReXhKUVVGSkxGZEJRVmNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTnVReXhEUVVGRE8wbEJSVVE3T3pzN08wOUJTMGM3U1VGRFNTeE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRXRCUVdFc1JVRkJSU3hUUVVGcFFpeFhRVUZYTEVOQlFVTXNVVUZCVVR0UlFVTjZSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJTeGxRVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRkRU1zVFVGQlRTeEpRVUZKTEhGQ1FVRlRMRU5CUVVNc01rTkJRVEpETEVOQlFVTXNRMEZCUXp0UlFVTnlSU3hEUVVGRE8xRkJRMFFzU1VGQlNTeFhRVUZYTEVkQlFVY3NTMEZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8xRkJSVzVETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1RVRkJUU3hKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYWtRc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNiVU5CUVcxRExFVkJRVVVzUlVGQlJTeE5RVUZOTEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUTNwRkxFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4WFFVRlhMRU5CUVVNc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZET1VJc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNkME5CUVhkRExFVkJRVVVzUlVGQlJTeE5RVUZOTEVWQlFVVXNWMEZCVnl4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGJFY3NRMEZCUXp0UlFVVkVMRTlCUVU4c1YwRkJWeXhEUVVGRExFMUJRVTBzUjBGQlJ5eE5RVUZOTEVWQlFVVXNRMEZCUXp0WlFVTnFReXhYUVVGWExFbEJRVWtzUjBGQlJ5eERRVUZETzFGQlEzWkNMRU5CUVVNN1VVRkZSQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeFhRVUZYTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNN1NVRkRlRU1zUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxGRkJRVkU3VVVGRFdDeE5RVUZOTEVOQlFVTXNaVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdTVUZETTBNc1EwRkJRenRKUVVWRU96czdUMEZIUnp0SlFVTkpMRkZCUVZFN1VVRkRXQ3hOUVVGTkxFTkJRVU1zWVVGQlN5eERRVUZETEZWQlFWVXNRMEZCUXl4bFFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8wbEJRM2hGTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeFJRVUZSTzFGQlExZ3NUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU03U1VGRGVFSXNRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5KTEU5QlFVODdVVUZEVml4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzBsQlF6TkNMRU5CUVVNN08wRkJNVWRFT3p0SFFVVkhPMEZCUTI5Q0xHOUNRVUZSTEVkQlFWY3NRMEZCUXl4RFFVRkRPMEZCUXpWRE96dEhRVVZITzBGQlEyOUNMRzFDUVVGUExFZEJRV2RDTEZkQlFWY3NRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhGUVVGRkxGZEJRVmNzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0QlFWSnNSeXhyUTBFMFIwTWlmUT09XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9kYXRhL3RyeXRlTnVtYmVyLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogSnNvbiBoZWxwZXIgbWV0aG9kcy5cclxuICovXHJcbmNsYXNzIEpzb25IZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpbmdpZnkgYW4gb2JqZWN0IHdpdGggcmVjdXJzaW9uIGJyZWFraW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIEEgSmF2YVNjcmlwdCB2YWx1ZSwgdXN1YWxseSBhbiBvYmplY3Qgb3IgYXJyYXksIHRvIGJlIGNvbnZlcnRlZC5cclxuICAgICAqIEBwYXJhbSByZXBsYWNlciBBIGZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgcmVzdWx0cy5cclxuICAgICAqIEBwYXJhbSBzcGFjZSBBZGRzIGluZGVudGF0aW9uLCB3aGl0ZSBzcGFjZSwgYW5kIGxpbmUgYnJlYWsgY2hhcmFjdGVycyB0byB0aGUgcmV0dXJuLXZhbHVlIEpTT04gdGV4dCB0byBtYWtlIGl0IGVhc2llciB0byByZWFkLlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHZlcnNpb24gb2YgdGhlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XHJcbiAgICAgICAgLy8gZWxpbWluYXRlcyBhbnkgcmVjdXJzaW9uIGluIHRoZSBzdHJpbmdpZnlcclxuICAgICAgICBjb25zdCBjYWNoZSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHJlY3VzaW9uUmVwbGFjZXIgPSAoa2V5LCByZXBsYWNlVmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgcmVwbGFjZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZS5pbmRleE9mKHJlcGxhY2VWYWx1ZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2lyY3VsYXIgcmVmZXJlbmNlIGZvdW5kLCBkaXNjYXJkIGtleVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnB1c2gocmVwbGFjZVZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZXIgPyByZXBsYWNlcihrZXksIHJlcGxhY2VWYWx1ZSkgOiByZXBsYWNlVmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHJlY3VzaW9uUmVwbGFjZXIsIHNwYWNlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkpzb25IZWxwZXIgPSBKc29uSGVscGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhbk52YmtobGJIQmxjaTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OW9aV3h3WlhKekwycHpiMjVJWld4d1pYSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk96dEhRVVZITzBGQlEwZzdTVUZEU1RzN096czdPMDlCVFVjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEV0QlFWVXNSVUZCUlN4UlFVRXlReXhGUVVGRkxFdEJRWFZDTzFGQlEzQkhMRFJEUVVFMFF6dFJRVU0xUXl4TlFVRk5MRXRCUVVzc1IwRkJWU3hGUVVGRkxFTkJRVU03VVVGRmVFSXNUVUZCVFN4blFrRkJaMElzUjBGQlJ5eERRVUZETEVkQlFWY3NSVUZCUlN4WlFVRnBRaXhGUVVGRkxFVkJRVVU3V1VGRGVFUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhaUVVGWkxFdEJRVXNzVVVGQlVTeEpRVUZKTEV0QlFVc3NTMEZCU3l4SlFVRkpMRWxCUVVrc1dVRkJXU3hMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTI1R0xFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1dVRkJXU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVOeVF5eDNRMEZCZDBNN2IwSkJRM2hETEUxQlFVMHNRMEZCUXp0blFrRkRXQ3hEUVVGRE8yZENRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMjlDUVVOS0xFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNN1owSkJRemRDTEVOQlFVTTdXVUZEVEN4RFFVRkRPMWxCUlVRc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1JVRkJSU3haUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNXVUZCV1N4RFFVRkRPMUZCUTJwRkxFTkJRVU1zUTBGQlF6dFJRVVZHTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFdEJRVXNzUlVGQlJTeG5Ra0ZCWjBJc1JVRkJSU3hMUVVGTExFTkJRVU1zUTBGQlF6dEpRVU14UkN4RFFVRkRPME5CUTBvN1FVRXpRa1FzWjBOQk1rSkRJbjA9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9oZWxwZXJzL2pzb25IZWxwZXIudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBGYWN0b3J5IHRvIGdlbmVyYXRlIHR5cGVzLlxyXG4gKiBAdHlwZXBhcmFtIFQgVGhlIGdlbmVyaWMgdHlwZSBmb3IgdGhlIG9iamVjdCB0eXBlcyBpbiB0aGUgZmFjdG9yeS5cclxuICovXHJcbmNsYXNzIEZhY3RvcnlCYXNlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3R5cGVzID0ge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGEgbmV3IHR5cGUgd2l0aCB0aGUgZmFjdG9yeS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0eXBlIHRvIHJlZ2lzdGVyLlxyXG4gICAgICogQHBhcmFtIHR5cGVDb25zdHJ1Y3RvciBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSB0eXBlLlxyXG4gICAgICovXHJcbiAgICByZWdpc3RlcihuYW1lLCB0eXBlQ29uc3RydWN0b3IpIHtcclxuICAgICAgICB0aGlzLmdldEluc3RhbmNlKCkuX3R5cGVzW25hbWVdID0gdHlwZUNvbnN0cnVjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnJlZ2lzdGVyIGEgdHlwZSBmcm9tIHRoZSBmYWN0b3J5LlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHR5cGUgdG8gdW5yZWdpc3Rlci5cclxuICAgICAqL1xyXG4gICAgdW5yZWdpc3RlcihuYW1lKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZ2V0SW5zdGFuY2UoKS5fdHlwZXNbbmFtZV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERvZXMgdGhlIGZhY3RvcnkgY29udGFpbiBhIHNwZWNpZmljIHR5cGUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdHlwZSB0byBsb29rIGZvci5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHR5cGUgZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBleGlzdHMobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKCkuX3R5cGVzW25hbWVdICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhbiBvYmplY3QgZnJvbSB0aGUgZmFjdG9yeS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0eXBlIHRvIGNyZWF0ZS5cclxuICAgICAqIEBwYXJhbSBhcmdzIEFueSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHR5cGUgaWYgaXQgZXhpc3RzLCBvciB1bmRlZmluZWQgaWYgaXQgZG9lcyBub3QuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZShuYW1lLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLl90eXBlc1tuYW1lXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuX3R5cGVzW25hbWVdKC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5GYWN0b3J5QmFzZSA9IEZhY3RvcnlCYXNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2labUZqZEc5eWVVSmhjMlV1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZabUZqZEc5eWFXVnpMMlpoWTNSdmNubENZWE5sTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHM3TzBkQlIwYzdRVUZEU0R0SlFVRkJPMUZCUTBrc1pVRkJaVHRSUVVORkxGZEJRVTBzUjBGQk9FTXNSVUZCUlN4RFFVRkRPMGxCTmtNMVJTeERRVUZETzBsQk0wTkhPenM3TzA5QlNVYzdTVUZEU1N4UlFVRlJMRU5CUVVNc1NVRkJXU3hGUVVGRkxHVkJRWE5ETzFGQlEyaEZMRWxCUVVrc1EwRkJReXhYUVVGWExFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1pVRkJaU3hEUVVGRE8wbEJRM1JFTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeFZRVUZWTEVOQlFVTXNTVUZCV1R0UlFVTXhRaXhQUVVGUExFbEJRVWtzUTBGQlF5eFhRVUZYTEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRE0wTXNRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1NVRkJXVHRSUVVOMFFpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1JVRkJSU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4VFFVRlRMRU5CUVVNN1NVRkRla1FzUTBGQlF6dEpRVVZFT3pzN096dFBRVXRITzBsQlEwa3NUVUZCVFN4RFFVRkRMRWxCUVZrc1JVRkJSU3hIUVVGSExFbEJRVmM3VVVGRGRFTXNUVUZCVFN4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRExGZEJRVmNzUlVGQlJTeERRVUZETzFGQlEzQkRMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM2hDTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRNVU1zUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTBvc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF6dFJRVU55UWl4RFFVRkRPMGxCUTB3c1EwRkJRenREUVVsS08wRkJMME5FTEd0RFFTdERReUo5XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9mYWN0b3JpZXMvZmFjdG9yeUJhc2UudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBJTG9nZ2VyIHdoaWNoIGlzIHNpbGVudC5cclxuICovXHJcbmNsYXNzIE51bGxMb2dnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGJhbm5lciB0byB0aGUgbG9nZ2VyLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxyXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cclxuICAgICAqL1xyXG4gICAgYmFubmVyKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCBsb2cgdG8gdGhlIGxvZ2dlci5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZy5cclxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byBsb2cuXHJcbiAgICAgKi9cclxuICAgIGxvZyhtZXNzYWdlLCAuLi5hcmdzKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgaW5mb3JtYXRpb24gdG8gdGhlIGxvZ2dlci5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZy5cclxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byBsb2cuXHJcbiAgICAgKi9cclxuICAgIGluZm8obWVzc2FnZSwgLi4uYXJncykge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIHdhcm5pbmcgdG8gdGhlIGxvZ2dlci5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZy5cclxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byBsb2cuXHJcbiAgICAgKi9cclxuICAgIHdhcm5pbmcobWVzc2FnZSwgLi4uYXJncykge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGVycm9yIHRvIHRoZSBsb2dnZXIuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXHJcbiAgICAgKiBAcGFyYW0gZXJyIEFuIGVycm9yIG9iamVjdCB0byBsb2cuXHJcbiAgICAgKiBAcGFyYW0gYXJncyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gbG9nLlxyXG4gICAgICovXHJcbiAgICBlcnJvcihtZXNzYWdlLCBlcnIsIC4uLmFyZ3MpIHtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk51bGxMb2dnZXIgPSBOdWxsTG9nZ2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liblZzYkV4dloyZGxjaTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXNiMmRuWlhKekwyNTFiR3hNYjJkblpYSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVWQk96dEhRVVZITzBGQlEwZzdTVUZEU1RzN096dFBRVWxITzBsQlEwa3NUVUZCVFN4RFFVRkRMRTlCUVdVc1JVRkJSU3hIUVVGSExFbEJRVmM3U1VGRE4wTXNRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4SFFVRkhMRU5CUVVNc1QwRkJaU3hGUVVGRkxFZEJRVWNzU1VGQlZ6dEpRVU14UXl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRWxCUVVrc1EwRkJReXhQUVVGbExFVkJRVVVzUjBGQlJ5eEpRVUZYTzBsQlF6TkRMRU5CUVVNN1NVRkZSRHM3T3p0UFFVbEhPMGxCUTBrc1QwRkJUeXhEUVVGRExFOUJRV1VzUlVGQlJTeEhRVUZITEVsQlFWYzdTVUZET1VNc1EwRkJRenRKUVVWRU96czdPenRQUVV0SE8wbEJRMGtzUzBGQlN5eERRVUZETEU5QlFXVXNSVUZCUlN4SFFVRlRMRVZCUVVVc1IwRkJSeXhKUVVGWE8wbEJRM1pFTEVOQlFVTTdRMEZEU2p0QlFYcERSQ3huUTBGNVEwTWlmUT09XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9sb2dnZXJzL251bGxMb2dnZXIudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGVudW0gZm9yIHRoZSBhZGRyZXNzIHNlY3VyaXR5IHZhbHVlcy5cclxuICovXHJcbnZhciBBZGRyZXNzU2VjdXJpdHk7XHJcbihmdW5jdGlvbiAoQWRkcmVzc1NlY3VyaXR5KSB7XHJcbiAgICBBZGRyZXNzU2VjdXJpdHlbQWRkcmVzc1NlY3VyaXR5W1wibG93XCJdID0gMV0gPSBcImxvd1wiO1xyXG4gICAgQWRkcmVzc1NlY3VyaXR5W0FkZHJlc3NTZWN1cml0eVtcIm1lZGl1bVwiXSA9IDJdID0gXCJtZWRpdW1cIjtcclxuICAgIEFkZHJlc3NTZWN1cml0eVtBZGRyZXNzU2VjdXJpdHlbXCJoaWdoXCJdID0gM10gPSBcImhpZ2hcIjtcclxufSkoQWRkcmVzc1NlY3VyaXR5ID0gZXhwb3J0cy5BZGRyZXNzU2VjdXJpdHkgfHwgKGV4cG9ydHMuQWRkcmVzc1NlY3VyaXR5ID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWVdSa2NtVnpjMU5sWTNWeWFYUjVMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyUmhkR0V2WVdSa2NtVnpjMU5sWTNWeWFYUjVMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUczdSMEZGUnp0QlFVTklMRWxCUVZrc1pVRkpXRHRCUVVwRUxGZEJRVmtzWlVGQlpUdEpRVU4yUWl4dFJFRkJVU3hEUVVGQk8wbEJRMUlzZVVSQlFWVXNRMEZCUVR0SlFVTldMSEZFUVVGUkxFTkJRVUU3UVVGRFdpeERRVUZETEVWQlNsY3NaVUZCWlN4SFFVRm1MSFZDUVVGbExFdEJRV1lzZFVKQlFXVXNVVUZKTVVJaWZRPT1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL2RhdGEvYWRkcmVzc1NlY3VyaXR5LnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xyXG5jb25zdCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMSA9IHJlcXVpcmUoXCIuL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFwiKTtcclxuY29uc3QgdGFnXzEgPSByZXF1aXJlKFwiLi90YWdcIik7XHJcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcclxuY29uc3QgdHJ5dGVOdW1iZXJfMSA9IHJlcXVpcmUoXCIuL3RyeXRlTnVtYmVyXCIpO1xyXG4vKipcclxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgYnVuZGxlcy5cclxuICovXHJcbmNsYXNzIEJ1bmRsZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBCdW5kbGUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBuZXcgdHJhbnNhY3Rpb25zIHRvIHRoZSBidW5kbGUuXHJcbiAgICAgKiBAcGFyYW0gc2lnbmF0dXJlTWVzc2FnZUxlbmd0aCBUaGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyB0byBhZGQuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyBmb3IgdGhlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgZm9yIHRoZSBmaXJzdCBvZiB0aGUgdHJhbnNhY3Rpb25zLlxyXG4gICAgICogQHBhcmFtIHRhZyBUaGUgdGFnIHRvIGluY2x1ZGUgaW4gdGhlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBmb3IgdGhlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgYWRkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZU1lc3NhZ2VMZW5ndGgsIGFkZHJlc3MsIHZhbHVlLCB0YWcsIHRpbWVzdGFtcCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlTWVzc2FnZUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zLnB1c2godHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tUGFyYW1zKHVuZGVmaW5lZCwgYWRkcmVzcywgaSA9PT0gMCA/IHZhbHVlIDogMCwgdGFnLCB0aW1lc3RhbXAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0YWcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHNpZ25hdHVyZSBmcmFnbWVudHMgdG8gdGhlIGJ1bmRsZS5cclxuICAgICAqIEBwYXJhbSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzIFRoZSBzaWduYXR1cmUgZnJhZ21lbnRzIHRvIGFkZCB0byB0aGUgYnVuZGxlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgYWRkU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyhzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzKSB7XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50c1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uc1tpXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPSAoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50c1tpXSB8fCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuRU1QVFkpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uc1tpXS50cnVua1RyYW5zYWN0aW9uID0gaGFzaF8xLkhhc2guRU1QVFk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zW2ldLmJyYW5jaFRyYW5zYWN0aW9uID0gaGFzaF8xLkhhc2guRU1QVFk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zW2ldLmF0dGFjaG1lbnRUaW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zW2ldLmF0dGFjaG1lbnRUaW1lc3RhbXBMb3dlckJvdW5kID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85O1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uc1tpXS5hdHRhY2htZW50VGltZXN0YW1wVXBwZXJCb3VuZCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnNbaV0ubm9uY2UgPSB0YWdfMS5UYWcuRU1QVFk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQnVuZGxlID0gQnVuZGxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZblZ1Wkd4bExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJSaGRHRXZZblZ1Wkd4bExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVN3MFJVRkJlVVU3UVVGRGVrVXNhMFJCUVN0RE8wRkJSUzlETEdsRFFVRTRRanRCUVVNNVFpeDVSVUZCYzBVN1FVRkRkRVVzSzBKQlFUUkNPMEZCUXpWQ0xDdERRVUUwUXp0QlFVTTFReXdyUTBGQk5FTTdRVUZGTlVNN08wZEJSVWM3UVVGRFNEdEpRVlZKT3p0UFFVVkhPMGxCUTBnN1VVRkRTU3hKUVVGSkxFTkJRVU1zV1VGQldTeEhRVUZITEVWQlFVVXNRMEZCUXp0SlFVTXpRaXhEUVVGRE8wbEJSVVE3T3pzN096czdUMEZQUnp0SlFVTkpMR1ZCUVdVc1EwRkJReXh6UWtGQk9FSXNSVUZCUlN4UFFVRm5RaXhGUVVGRkxFdEJRV0VzUlVGQlJTeEhRVUZSTEVWQlFVVXNVMEZCYVVJN1VVRkRMMGNzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eHpRa0ZCYzBJc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETzFsQlF6bERMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zU1VGQlNTeERRVUZETEhsQ1FVRlhMRU5CUVVNc1ZVRkJWU3hEUVVGRExGTkJRVk1zUlVGQlJTeFBRVUZQTEVWQlFVVXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1IwRkJSeXhGUVVNMVF5eFRRVUZUTEVWQlFVVXNVMEZCVXl4RlFVRkZMRk5CUVZNc1JVRkJSU3hUUVVGVExFVkJRekZETEZOQlFWTXNSVUZCUlN4VFFVRlRMRVZCUVVVc1IwRkJSeXhGUVVGRkxGTkJRVk1zUlVGRGNFTXNVMEZCVXl4RlFVRkZMRk5CUVZNc1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzQkdMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc05FSkJRVFJDTEVOQlFVTXNlVUpCUVhGRU8xRkJRM0pHTEVWQlFVVXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEhsQ1FVRjVRaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyeEVMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEN0RlFVRXJSU3hEUVVGRExFTkJRVU03VVVGRGVrY3NRMEZCUXp0UlFVVkVMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJRenRaUVVOb1JDeEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExIZENRVUYzUWl4SFFVRkhMRU5CUVVNc2VVSkJRWGxDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc2JVUkJRWGRDTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1dVRkRha2dzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhuUWtGQlowSXNSMEZCUnl4WFFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRE8xbEJRMjVFTEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zYVVKQlFXbENMRWRCUVVjc1YwRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF6dFpRVU53UkN4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEcxQ1FVRnRRaXhIUVVGSExIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRPMWxCUXk5RUxFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc05rSkJRVFpDTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU03V1VGRGVrVXNTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5dzJRa0ZCTmtJc1IwRkJSeXg1UWtGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXp0WlFVTjZSU3hKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1IwRkJSeXhUUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETzFGQlF6TkRMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wTkJRMG83UVVGeVJFUXNkMEpCY1VSREluMD1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL2RhdGEvYnVuZGxlLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBhcnJheUhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXJcIik7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvYWRkcmVzc1wiKTtcclxuY29uc3QgYWRkcmVzc1NlY3VyaXR5XzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9hZGRyZXNzU2VjdXJpdHlcIik7XHJcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2hhc2hcIik7XHJcbmNvbnN0IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XCIpO1xyXG5jb25zdCB0cml0c18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJpdHNcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJ5dGVzXCIpO1xyXG5jb25zdCBjcnlwdG9FcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG5jb25zdCBzcG9uZ2VGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnlcIik7XHJcbi8qKlxyXG4gKiBJU1MgSGFzaGluZyBmdW5jdGlvbnMuXHJcbiAqIENvbnZlcnRlZCBodHRwczovL2dpdGh1Yi5jb20vaW90YWxlZGdlci9pcmkvc3JjL21haW4vamF2YS9jb20vaW90YS9pcmkvaGFzaC9JU1MuamF2YVxyXG4gKi9cclxuY2xhc3MgSVNTIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRoZSBrZXkgZm9yIHRoZSBzZWVkLlxyXG4gICAgICogQHBhcmFtIHNlZWQgVGhlIHNlZWQgdG8gY3JlYXRlIHRoZSBrZXkgZm9yLlxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCB0byB1c2UgZm9yIHRoZSBzZWVkLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgc2VjdXJpdHkgbGV2ZWwgdG8gY3JlYXRlIHRoZSBrZXkuXHJcbiAgICAgKiBAcmV0dXJucyB0aGUga2V5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMga2V5KHNlZWQsIGluZGV4LCBzZWN1cml0eSkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgc2VlZCBtdXN0IGJlIG9mIHR5cGUgSGFzaFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGluZGV4KSB8fCBpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgaW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzZWN1cml0eSkgfHwgc2VjdXJpdHkgPCBhZGRyZXNzU2VjdXJpdHlfMS5BZGRyZXNzU2VjdXJpdHkubG93IHx8IHNlY3VyaXR5ID4gYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5LmhpZ2gpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoYFRoZSBzZWN1cml0eSBtdXN0IGJlIGFuIGludGVnZXIgPj0gMSBhbmQgPD0gM2ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzZWVkVHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXMoc2VlZC50b1RyeXRlcygpKTtcclxuICAgICAgICBjb25zdCBpbmRleFRyaXRzID0gdHJpdHNfMS5Ucml0cy5mcm9tTnVtYmVyKGluZGV4KTtcclxuICAgICAgICBjb25zdCBzdWJzZWVkID0gdHJpdHNfMS5Ucml0cy5hZGQoc2VlZFRyaXRzLCBpbmRleFRyaXRzKS50b0FycmF5KCk7XHJcbiAgICAgICAgY29uc3Qgc3Vic2VlZExlbmd0aCA9IHN1YnNlZWQubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGtlcmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcImtlcmxcIik7XHJcbiAgICAgICAgY29uc3QgaGFzaExlbmd0aCA9IGtlcmwuZ2V0Q29uc3RhbnQoXCJIQVNIX0xFTkdUSFwiKTtcclxuICAgICAgICBrZXJsLmluaXRpYWxpemUoKTtcclxuICAgICAgICBrZXJsLmFic29yYihzdWJzZWVkLCAwLCBzdWJzZWVkTGVuZ3RoKTtcclxuICAgICAgICBrZXJsLnNxdWVlemUoc3Vic2VlZCwgMCwgc3Vic2VlZExlbmd0aCk7XHJcbiAgICAgICAga2VybC5yZXNldCgpO1xyXG4gICAgICAgIGtlcmwuYWJzb3JiKHN1YnNlZWQsIDAsIHN1YnNlZWRMZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBJbnQ4QXJyYXkoSVNTLk5VTUJFUl9PRl9GUkFHTUVOVF9DSFVOS1MgKiBoYXNoTGVuZ3RoICogc2VjdXJpdHkpO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBJbnQ4QXJyYXkoc3Vic2VlZExlbmd0aCk7XHJcbiAgICAgICAgbGV0IGxvY2FsTGVuZ3RoID0gc2VjdXJpdHk7XHJcbiAgICAgICAgd2hpbGUgKGxvY2FsTGVuZ3RoLS0gPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSVNTLk5VTUJFUl9PRl9GUkFHTUVOVF9DSFVOS1M7IGkrKykge1xyXG4gICAgICAgICAgICAgICAga2VybC5zcXVlZXplKGJ1ZmZlciwgMCwgc3Vic2VlZExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhhc2hMZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleVtvZmZzZXQrK10gPSBidWZmZXJbal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRoZSBkaWdlc3RzIGZvciB0aGUgZ2l2ZW4gc3Vic2VlZC5cclxuICAgICAqIEBwYXJhbSBzdWJzZWVkIFRvIGNyZWF0ZSB0aGUgZGlnZXN0cyBmb3IuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlnZXN0cy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRpZ2VzdHMoc3Vic2VlZCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzdWJzZWVkLCBJbnQ4QXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHN1YnNlZWQgbXVzdCBiZSBvZiB0eXBlIEludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGFzaCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFwia2VybFwiKTtcclxuICAgICAgICBjb25zdCBoYXNoTGVuZ3RoID0gaGFzaC5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50TGVuZ3RoID0gaGFzaExlbmd0aCAqIElTUy5OVU1CRVJfT0ZfRlJBR01FTlRfQ0hVTktTO1xyXG4gICAgICAgIGlmIChzdWJzZWVkLmxlbmd0aCAlIGZyYWdtZW50TGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBUaGUgc3Vic2VlZCBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7ZnJhZ21lbnRMZW5ndGh9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyeXRlUmFuZ2UgPSBJU1MuTUFYX1RSWVRFX1ZBTFVFIC0gSVNTLk1JTl9UUllURV9WQUxVRTtcclxuICAgICAgICBjb25zdCBrZXlMZW5EaXYgPSBzdWJzZWVkLmxlbmd0aCAvIGZyYWdtZW50TGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGRpZ2VzdHMgPSBuZXcgSW50OEFycmF5KGtleUxlbkRpdiAqIGhhc2hMZW5ndGgpO1xyXG4gICAgICAgIGxldCBidWZmZXI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlMZW5EaXY7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpTXVsID0gaSAqIGZyYWdtZW50TGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBrZXlGcmFnbWVudCA9IHN1YnNlZWQuc2xpY2UoaU11bCwgaU11bCArIGZyYWdtZW50TGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBJU1MuTlVNQkVSX09GX0ZSQUdNRU5UX0NIVU5LUzsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBqTXVsID0gaiAqIGhhc2hMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBrZXlGcmFnbWVudC5zbGljZShqTXVsLCBqTXVsICsgaGFzaExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRyeXRlUmFuZ2U7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2gucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoLmFic29yYihidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2guc3F1ZWV6ZShidWZmZXIsIDAsIGhhc2hMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBoYXNoTGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlGcmFnbWVudFtqTXVsICsga10gPSBidWZmZXJba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGFzaC5yZXNldCgpO1xyXG4gICAgICAgICAgICBoYXNoLmFic29yYihrZXlGcmFnbWVudCwgMCwga2V5RnJhZ21lbnQubGVuZ3RoKTtcclxuICAgICAgICAgICAgaGFzaC5zcXVlZXplKGJ1ZmZlciwgMCwgaGFzaExlbmd0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlNdWwyID0gaSAqIGhhc2hMZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGFzaExlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBkaWdlc3RzW2lNdWwyICsgal0gPSBidWZmZXJbal07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpZ2VzdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0aGUgYWRkcmVzcyBmb3IgdGhlIGRpZ2VzdHMuXHJcbiAgICAgKiBAcGFyYW0gZGlnZXN0cyBUaGUgZGlnZXN0cyB0byBjcmVhdGUgdGhlIGFkZHJlc3MgZm9yLlxyXG4gICAgICogQHJldHVybnMgdGhlIGFkZHJlc3MgdHJpdHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhZGRyZXNzKGRpZ2VzdHMpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoZGlnZXN0cywgSW50OEFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBkaWdlc3RzIG11c3QgYmUgb2YgdHlwZSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtlcmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcImtlcmxcIik7XHJcbiAgICAgICAgY29uc3Qga2VybEhhc2hMZW5ndGggPSBrZXJsLmdldENvbnN0YW50KFwiSEFTSF9MRU5HVEhcIik7XHJcbiAgICAgICAgaWYgKGRpZ2VzdHMubGVuZ3RoICUga2VybEhhc2hMZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoYEludmFsaWQgZGlnZXN0cyBsZW5ndGgsIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2tlcmxIYXNoTGVuZ3RofWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXJsLmluaXRpYWxpemUoKTtcclxuICAgICAgICBrZXJsLmFic29yYihkaWdlc3RzLCAwLCBkaWdlc3RzLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzc1RyaXRzID0gbmV3IEludDhBcnJheShrZXJsSGFzaExlbmd0aCk7XHJcbiAgICAgICAga2VybC5zcXVlZXplKGFkZHJlc3NUcml0cywgMCwgYWRkcmVzc1RyaXRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGFkZHJlc3NUcml0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGRpZ2VzdCBvZiB0aGUgbm9ybWFsaXplZCBidW5kbGUgZnJhZ21lbnQuXHJcbiAgICAgKiBAcGFyYW0gbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50IFRoZSBmcmFnbWVudCB0byBjcmVhdGUgZGlnZXN0LlxyXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCBUaGUgdHJpdHMgZm9yIHNpZ25hdHVyZSBtZXNzYWdlIGZyYWdtZW50LlxyXG4gICAgICogQHJldHVybnMgVGhlIGRpZ2VzdCBvZiB0aGUgYnVuZGxlIGFuZCBzaWduYXR1cmUgbWVzc2FnZSBmcmFnbWVudC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRpZ2VzdChub3JtYWxpemVkQnVuZGxlRnJhZ21lbnQsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShub3JtYWxpemVkQnVuZGxlRnJhZ21lbnQsIEludDhBcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50IG11c3QgYmUgb2YgdHlwZSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQsIEludDhBcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IG11c3QgYmUgb2YgdHlwZSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBidWZmZXI7XHJcbiAgICAgICAgY29uc3Qga2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFwia2VybFwiKTtcclxuICAgICAgICBjb25zdCBoYXNoTGVuZ3RoID0ga2VybC5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpO1xyXG4gICAgICAgIGtlcmwuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSVNTLk5VTUJFUl9PRl9GUkFHTUVOVF9DSFVOS1M7IGkrKykge1xyXG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgSW50OEFycmF5KHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5zbGljZShpICogaGFzaExlbmd0aCwgKGkgKyAxKSAqIGhhc2hMZW5ndGgpKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IG5vcm1hbGl6ZWRCdW5kbGVGcmFnbWVudFtpXSAtIElTUy5NSU5fVFJZVEVfVkFMVUU7IGogPiAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGpLZXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXCJrZXJsXCIpO1xyXG4gICAgICAgICAgICAgICAgaktlcmwuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgaktlcmwuYWJzb3JiKGJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBqS2VybC5zcXVlZXplKGJ1ZmZlciwgMCwgaktlcmwuZ2V0Q29uc3RhbnQoXCJIQVNIX0xFTkdUSFwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAga2VybC5hYnNvcmIoYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAga2VybC5zcXVlZXplKGJ1ZmZlciwgMCwga2VybC5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpKTtcclxuICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBub3JtYWxpemVkIGJ1bmRsZS5cclxuICAgICAqIEBwYXJhbSBidW5kbGVIYXNoIFRoZSBoYXNoIG9mIHRoZSBidW5kbGUuXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgbm9ybWFsaXplZCBidW5kbGUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBub3JtYWxpemVkQnVuZGxlKGJ1bmRsZUhhc2gpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoYnVuZGxlSGFzaCwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIGJ1bmRsZUhhc2ggbXVzdCBiZSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGN1cmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcImN1cmxcIik7XHJcbiAgICAgICAgY29uc3QgY3VybEhhc2hMZW5ndGggPSBjdXJsLmdldENvbnN0YW50KFwiSEFTSF9MRU5HVEhcIik7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEJ1bmRsZSA9IG5ldyBJbnQ4QXJyYXkoSVNTLk5VTUJFUl9PRl9GUkFHTUVOVF9DSFVOS1MgKiBJU1MuTlVNQkVSX09GX1NFQ1VSSVRZX0xFVkVMUyk7XHJcbiAgICAgICAgY29uc3QgaGFzaFN0cmluZyA9IGJ1bmRsZUhhc2gudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcmFnbWVudExlbmd0aCA9IGN1cmxIYXNoTGVuZ3RoIC8gSVNTLlRSWVRFX1dJRFRIIC8gSVNTLk5VTUJFUl9PRl9TRUNVUklUWV9MRVZFTFM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBJU1MuTlVNQkVSX09GX1NFQ1VSSVRZX0xFVkVMUzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vcm1hbGl6ZWRGcmFnbWVudExlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoQ2hhciA9IGhhc2hTdHJpbmcuY2hhckF0KGkgKiBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGggKyBqKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhoYXNoQ2hhcikpLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkQnVuZGxlW2kgKiBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGggKyBqXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIHN1bSArPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN1bSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3VtLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZEJ1bmRsZVtpICogbm9ybWFsaXplZEZyYWdtZW50TGVuZ3RoICsgal0gPiBJU1MuTUlOX1RSWVRFX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkQnVuZGxlW2kgKiBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGggKyBqXS0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3VtKysgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZEJ1bmRsZVtpICogbm9ybWFsaXplZEZyYWdtZW50TGVuZ3RoICsgal0gPCBJU1MuTUFYX1RSWVRFX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkQnVuZGxlW2kgKiBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGggKyBqXSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRCdW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBzaWduYXR1cmUgZnJhZ21lbnRzIGZyb20gdGhlIGFkZHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gZXhwZWN0ZWRBZGRyZXNzIFRoZSBhZGRyZXNzLlxyXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMgVGhlIHNpZ25hdHVyZSBtZXNzYWdlIGZyYWdtZW50cy5cclxuICAgICAqIEBwYXJhbSBidW5kbGVIYXNoIFRoZSBoYXNoIGZvciB0aGUgYnVuZGxlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIG1lc3NhZ2UgZnJhZ21lbnQgYXJlIHNpZ25lZCBieSB0aGUgZXhwZWN0ZWQgYWRkcmVzcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHZhbGlkYXRlU2lnbmF0dXJlcyhleHBlY3RlZEFkZHJlc3MsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMsIGJ1bmRsZUhhc2gpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoZXhwZWN0ZWRBZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgZXhwZWN0ZWRBZGRyZXNzIG11c3QgYmUgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGJ1bmRsZUhhc2gsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBidW5kbGVIYXNoIG11c3QgYmUgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBub3JtYWxpemVkQnVuZGxlRnJhZ21lbnRzID0gW107XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEJ1bmRsZUhhc2ggPSBJU1Mubm9ybWFsaXplZEJ1bmRsZShidW5kbGVIYXNoKTtcclxuICAgICAgICBjb25zdCBrZXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXCJrZXJsXCIpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hMZW5ndGggPSBrZXJsLmdldENvbnN0YW50KFwiSEFTSF9MRU5HVEhcIik7XHJcbiAgICAgICAgZm9yIChsZXQgZiA9IDA7IGYgPCAzOyBmKyspIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50c1tmXSA9IG5vcm1hbGl6ZWRCdW5kbGVIYXNoLnNsaWNlKGYgKiBJU1MuTlVNQkVSX09GX0ZSQUdNRU5UX0NIVU5LUywgKGYgKyAxKSAqIElTUy5OVU1CRVJfT0ZfRlJBR01FTlRfQ0hVTktTKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGlnZXN0cyA9IG5ldyBJbnQ4QXJyYXkoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cy5sZW5ndGggKiBoYXNoTGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZGlnZXN0QnVmZmVyID0gSVNTLmRpZ2VzdChub3JtYWxpemVkQnVuZGxlRnJhZ21lbnRzW2kgJSAzXSwgdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHNbaV0udG9Ucnl0ZXMoKSkudG9BcnJheSgpKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoYXNoTGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGRpZ2VzdHNbaSAqIGhhc2hMZW5ndGggKyBqXSA9IGRpZ2VzdEJ1ZmZlcltqXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXhwZWN0ZWRBZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSA9PT0gdHJpdHNfMS5Ucml0cy5mcm9tQXJyYXkoSVNTLmFkZHJlc3MoZGlnZXN0cykpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcclxuICAgIH1cclxufVxyXG4vKiBAaW50ZXJuYWwgKi9cclxuSVNTLk5VTUJFUl9PRl9GUkFHTUVOVF9DSFVOS1MgPSAyNztcclxuLyogQGludGVybmFsICovXHJcbklTUy5OVU1CRVJfT0ZfU0VDVVJJVFlfTEVWRUxTID0gMztcclxuLyogQGludGVybmFsICovXHJcbklTUy5UUllURV9XSURUSCA9IDM7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5JU1MuTUlOX1RSWVRFX1ZBTFVFID0gLTEzO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuSVNTLk1BWF9UUllURV9WQUxVRSA9IDEzO1xyXG5leHBvcnRzLklTUyA9IElTUztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVhOekxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJoaGMyZ3ZhWE56TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3d3UlVGQmRVVTdRVUZEZGtVc05FVkJRWGxGTzBGQlEzcEZMRFJGUVVGNVJUdEJRVU42UlN3clJFRkJORVE3UVVGRE5VUXNLMFZCUVRSRk8wRkJRelZGTEhsRVFVRnpSRHRCUVVOMFJDeHBSMEZCT0VZN1FVRkRPVVlzTWtSQlFYZEVPMEZCUTNoRUxEWkVRVUV3UkR0QlFVTXhSQ3h6UkVGQmJVUTdRVUZEYmtRc09FUkJRVEpFTzBGQlJUTkVPenM3UjBGSFJ6dEJRVU5JTzBsQldVazdPenM3T3p0UFFVMUhPMGxCUTBrc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZWTEVWQlFVVXNTMEZCWVN4RlFVRkZMRkZCUVhsQ08xRkJRMnhGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RlFVRkZMRmRCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU51UXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5d3JRa0ZCSzBJc1EwRkJReXhEUVVGRE8xRkJRek5FTEVOQlFVTTdVVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFdEJRVXNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpsRExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMRzFEUVVGdFF5eERRVUZETEVOQlFVTTdVVUZETDBRc1EwRkJRenRSUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NVVUZCVVN4SFFVRkhMR2xEUVVGbExFTkJRVU1zUjBGQlJ5eEpRVUZKTEZGQlFWRXNSMEZCUnl4cFEwRkJaU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZWtjc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNLME5CUVN0RExFTkJRVU1zUTBGQlF6dFJRVU16UlN4RFFVRkRPMUZCUlVRc1RVRkJUU3hUUVVGVExFZEJRVWNzWVVGQlN5eERRVUZETEZWQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVU53UkN4TlFVRk5MRlZCUVZVc1IwRkJSeXhoUVVGTExFTkJRVU1zVlVGQlZTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUXpORExFMUJRVTBzVDBGQlR5eEhRVUZITEdGQlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1UwRkJVeXhGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRPMUZCUXpORUxFMUJRVTBzWVVGQllTeEhRVUZITEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNN1VVRkZja01zVFVGQlRTeEpRVUZKTEVkQlFVY3NOa0pCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRja1FzVFVGQlRTeFZRVUZWTEVkQlFVY3NTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlF6dFJRVVZ1UkN4SlFVRkpMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFTkJRVU03VVVGRGJFSXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF5eEZRVUZGTEdGQlFXRXNRMEZCUXl4RFFVRkRPMUZCUTNaRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNc1JVRkJSU3hoUVVGaExFTkJRVU1zUTBGQlF6dFJRVVY0UXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU03VVVGRFlpeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRExFVkJRVVVzWVVGQllTeERRVUZETEVOQlFVTTdVVUZGZGtNc1RVRkJUU3hIUVVGSExFZEJRVWNzU1VGQlNTeFRRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMSGxDUVVGNVFpeEhRVUZITEZWQlFWVXNSMEZCUnl4UlFVRlJMRU5CUVVNc1EwRkJRenRSUVVOcVJpeEpRVUZKTEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRaaXhOUVVGTkxFMUJRVTBzUjBGQlJ5eEpRVUZKTEZOQlFWTXNRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenRSUVVNMVF5eEpRVUZKTEZkQlFWY3NSMEZCUnl4UlFVRlJMRU5CUVVNN1VVRkZNMElzVDBGQlR5eFhRVUZYTEVWQlFVVXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJRenRaUVVOMlFpeEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NRMEZCUXl4NVFrRkJlVUlzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRPMmRDUVVOeVJDeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzWVVGQllTeERRVUZETEVOQlFVTTdaMEpCUTNaRExFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVlVGQlZTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNN2IwSkJRMnhETEVkQlFVY3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhIUVVGSExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRPVUlzUTBGQlF6dFpRVU5NTEVOQlFVTTdVVUZEVEN4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF6dEpRVU5tTEVOQlFVTTdTVUZGUkRzN096dFBRVWxITzBsQlEwa3NUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGclFqdFJRVU53UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETTBNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNkVU5CUVhWRExFTkJRVU1zUTBGQlF6dFJRVU51UlN4RFFVRkRPMUZCUlVRc1RVRkJUU3hKUVVGSkxFZEJRVWNzTmtKQlFXRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZEY2tRc1RVRkJUU3hWUVVGVkxFZEJRVmNzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenRSUVVNelJDeE5RVUZOTEdOQlFXTXNSMEZCUnl4VlFVRlZMRWRCUVVjc1IwRkJSeXhEUVVGRExIbENRVUY1UWl4RFFVRkRPMUZCUld4RkxFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRWRCUVVjc1kwRkJZeXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZUVNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNORU5CUVRSRExHTkJRV01zUlVGQlJTeERRVUZETEVOQlFVTTdVVUZEZUVZc1EwRkJRenRSUVVWRUxFMUJRVTBzVlVGQlZTeEhRVUZITEVkQlFVY3NRMEZCUXl4bFFVRmxMRWRCUVVjc1IwRkJSeXhEUVVGRExHVkJRV1VzUTBGQlF6dFJRVVUzUkN4TlFVRk5MRk5CUVZNc1IwRkJSeXhQUVVGUExFTkJRVU1zVFVGQlRTeEhRVUZITEdOQlFXTXNRMEZCUXp0UlFVVnNSQ3hOUVVGTkxFOUJRVThzUjBGQlJ5eEpRVUZKTEZOQlFWTXNRMEZCUXl4VFFVRlRMRWRCUVVjc1ZVRkJWU3hEUVVGRExFTkJRVU03VVVGRGRFUXNTVUZCU1N4TlFVRnBRaXhEUVVGRE8xRkJSWFJDTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NVMEZCVXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU03V1VGRGFrTXNUVUZCVFN4SlFVRkpMRWRCUVVjc1EwRkJReXhIUVVGSExHTkJRV01zUTBGQlF6dFpRVU5vUXl4TlFVRk5MRmRCUVZjc1IwRkJSeXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NSVUZCUlN4SlFVRkpMRWRCUVVjc1kwRkJZeXhEUVVGRExFTkJRVU03V1VGRkwwUXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRU5CUVVNc2VVSkJRWGxDTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJRenRuUWtGRGNrUXNUVUZCVFN4SlFVRkpMRWRCUVZjc1EwRkJReXhIUVVGSExGVkJRVlVzUTBGQlF6dG5Ra0ZEY0VNc1RVRkJUU3hIUVVGSExGZEJRVmNzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RlFVRkZMRWxCUVVrc1IwRkJSeXhWUVVGVkxFTkJRVU1zUTBGQlF6dG5Ra0ZGY0VRc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhWUVVGVkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXp0dlFrRkRiRU1zU1VGQlNTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRPMjlDUVVOaUxFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1JVRkJSU3hOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdiMEpCUTNSRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1JVRkJSU3hWUVVGVkxFTkJRVU1zUTBGQlF6dG5Ra0ZEZUVNc1EwRkJRenRuUWtGRlJDeEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEZWQlFWVXNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRE8yOUNRVU5zUXl4WFFVRlhMRU5CUVVNc1NVRkJTU3hIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGRFTXNRMEZCUXp0WlFVTk1MRU5CUVVNN1dVRkZSQ3hKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdXVUZEWWl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExGZEJRVmNzUlVGQlJTeERRVUZETEVWQlFVVXNWMEZCVnl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xbEJRMmhFTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0WlFVVndReXhOUVVGTkxFdEJRVXNzUjBGQlJ5eERRVUZETEVkQlFVY3NWVUZCVlN4RFFVRkRPMWxCUXpkQ0xFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVlVGQlZTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNN1owSkJRMnhETEU5QlFVOHNRMEZCUXl4TFFVRkxMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1RExFTkJRVU03VVVGRFRDeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJRenRKUVVOdVFpeERRVUZETzBsQlJVUTdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJhMEk3VVVGRGNFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6TkRMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEhWRFFVRjFReXhEUVVGRExFTkJRVU03VVVGRGJrVXNRMEZCUXp0UlFVVkVMRTFCUVUwc1NVRkJTU3hIUVVGSExEWkNRVUZoTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlEzSkVMRTFCUVUwc1kwRkJZeXhIUVVGSExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1VVRkZka1FzUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1IwRkJSeXhqUVVGakxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjRReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4cFJFRkJhVVFzWTBGQll5eEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTTNSaXhEUVVGRE8xRkJSVVFzU1VGQlNTeERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRPMUZCUTJ4Q0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNc1JVRkJSU3hQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZGZUVNc1RVRkJUU3haUVVGWkxFZEJRVWNzU1VGQlNTeFRRVUZUTEVOQlFVTXNZMEZCWXl4RFFVRkRMRU5CUVVNN1VVRkRia1FzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4WlFVRlpMRVZCUVVVc1EwRkJReXhGUVVGRkxGbEJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVVnVSQ3hOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETzBsQlEzaENMRU5CUVVNN1NVRkZSRHM3T3pzN1QwRkxSenRKUVVOSkxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNkMEpCUVcxRExFVkJRVVVzZDBKQlFXMURPMUZCUTNwR0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zZDBKQlFYZENMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6VkVMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEhkRVFVRjNSQ3hEUVVGRExFTkJRVU03VVVGRGNFWXNRMEZCUXp0UlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc2QwSkJRWGRDTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRelZFTEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExIZEVRVUYzUkN4RFFVRkRMRU5CUVVNN1VVRkRjRVlzUTBGQlF6dFJRVVZFTEVsQlFVa3NUVUZCYVVJc1EwRkJRenRSUVVWMFFpeE5RVUZOTEVsQlFVa3NSMEZCUnl3MlFrRkJZU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVOeVJDeE5RVUZOTEZWQlFWVXNSMEZCUnl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExHRkJRV0VzUTBGQlF5eERRVUZETzFGQlEyNUVMRWxCUVVrc1EwRkJReXhWUVVGVkxFVkJRVVVzUTBGQlF6dFJRVVZzUWl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1EwRkJReXg1UWtGQmVVSXNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRE8xbEJRM0pFTEUxQlFVMHNSMEZCUnl4SlFVRkpMRk5CUVZNc1EwRkJReXgzUWtGQmQwSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhIUVVGSExGVkJRVlVzUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlJUZEdMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEhkQ1FVRjNRaXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NRMEZCUXl4bFFVRmxMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRPMmRDUVVONlJTeE5RVUZOTEV0QlFVc3NSMEZCUnl3MlFrRkJZU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRuUWtGRmRFUXNTMEZCU3l4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8yZENRVU51UWl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8yZENRVU4yUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNTMEZCU3l4RFFVRkRMRmRCUVZjc1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF5OUVMRU5CUVVNN1dVRkZSQ3hKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlF6RkRMRU5CUVVNN1VVRkZSQ3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNwRUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZEYkVJc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1ZVRkJaMEk3VVVGRE0wTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRlZMRVZCUVVVc1YwRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzcERMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEhGRFFVRnhReXhEUVVGRExFTkJRVU03VVVGRGFrVXNRMEZCUXp0UlFVVkVMRTFCUVUwc1NVRkJTU3hIUVVGSExEWkNRVUZoTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlJYSkVMRTFCUVUwc1kwRkJZeXhIUVVGSExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1VVRkZka1FzVFVGQlRTeG5Ra0ZCWjBJc1IwRkJSeXhKUVVGSkxGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNlVUpCUVhsQ0xFZEJRVWNzUjBGQlJ5eERRVUZETEhsQ1FVRjVRaXhEUVVGRExFTkJRVU03VVVGRGRFY3NUVUZCVFN4VlFVRlZMRWRCUVVjc1ZVRkJWU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMUZCUlhCRUxFMUJRVTBzZDBKQlFYZENMRWRCUVVjc1kwRkJZeXhIUVVGSExFZEJRVWNzUTBGQlF5eFhRVUZYTEVkQlFVY3NSMEZCUnl4RFFVRkRMSGxDUVVGNVFpeERRVUZETzFGQlJXeEhMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhEUVVGRExIbENRVUY1UWl4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU03V1VGRGNrUXNTVUZCU1N4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRMW9zUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eDNRa0ZCZDBJc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETzJkQ1FVTm9SQ3hOUVVGTkxGRkJRVkVzUjBGQlJ5eFZRVUZWTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1IwRkJSeXgzUWtGQmQwSXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGNrVXNUVUZCVFN4SFFVRkhMRWRCUVVjc1lVRkJTeXhEUVVGRExGVkJRVlVzUTBGQlF5eGxRVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdaMEpCUTNKRkxHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1IwRkJSeXgzUWtGQmQwSXNSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFTkJRVU03WjBKQlEzcEVMRWRCUVVjc1NVRkJTU3hIUVVGSExFTkJRVU03V1VGRFppeERRVUZETzFsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTFnc1QwRkJUeXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXp0dlFrRkRaaXhIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExIZENRVUYzUWl4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU03ZDBKQlEyaEVMRVZCUVVVc1EwRkJReXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1IwRkJSeXgzUWtGQmQwSXNSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFTkJRVU1zWlVGQlpTeERRVUZETEVOQlFVTXNRMEZCUXpzMFFrRkRNMFVzWjBKQlFXZENMRU5CUVVNc1EwRkJReXhIUVVGSExIZENRVUYzUWl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU03TkVKQlEzSkVMRXRCUVVzc1EwRkJRenQzUWtGRFZpeERRVUZETzI5Q1FVTk1MRU5CUVVNN1owSkJRMHdzUTBGQlF6dFpRVU5NTEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRFNpeFBRVUZQTEVkQlFVY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRE8yOUNRVU5tTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NkMEpCUVhkQ0xFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXp0M1FrRkRhRVFzUlVGQlJTeERRVUZETEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF5eEhRVUZITEhkQ1FVRjNRaXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NRMEZCUXl4bFFVRmxMRU5CUVVNc1EwRkJReXhEUVVGRE96UkNRVU16UlN4blFrRkJaMElzUTBGQlF5eERRVUZETEVkQlFVY3NkMEpCUVhkQ0xFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXpzMFFrRkRja1FzUzBGQlN5eERRVUZETzNkQ1FVTldMRU5CUVVNN2IwSkJRMHdzUTBGQlF6dG5Ra0ZEVEN4RFFVRkRPMWxCUTB3c1EwRkJRenRSUVVOTUxFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU03U1VGRE5VSXNRMEZCUXp0SlFVVkVPenM3T3pzN1QwRk5SenRKUVVOSkxFMUJRVTBzUTBGQlF5eHJRa0ZCYTBJc1EwRkJReXhsUVVGM1FpeEZRVUZGTEhsQ1FVRnhSQ3hGUVVGRkxGVkJRV2RDTzFGQlF6bElMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1pVRkJaU3hGUVVGRkxHbENRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha1FzVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc01FTkJRVEJETEVOQlFVTXNRMEZCUXp0UlFVTjBSU3hEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eDVRa0ZCZVVJc1JVRkJSU3h0UkVGQmQwSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNMVJTeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhwUmtGQmFVWXNRMEZCUXl4RFFVRkRPMUZCUXpkSExFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEZWQlFWVXNSVUZCUlN4WFFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGVrTXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zY1VOQlFYRkRMRU5CUVVNc1EwRkJRenRSUVVOcVJTeERRVUZETzFGQlJVUXNUVUZCVFN4NVFrRkJlVUlzUjBGQlJ5eEZRVUZGTEVOQlFVTTdVVUZEY2tNc1RVRkJUU3h2UWtGQmIwSXNSMEZCUnl4SFFVRkhMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNN1VVRkZPVVFzVFVGQlRTeEpRVUZKTEVkQlFVY3NOa0pCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRja1FzVFVGQlRTeFZRVUZWTEVkQlFVY3NTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlF6dFJRVVZ1UkN4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETzFsQlEzcENMSGxDUVVGNVFpeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRzlDUVVGdlFpeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhEUVVGRExIbENRVUY1UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NRMEZCUXl4NVFrRkJlVUlzUTBGQlF5eERRVUZETzFGQlF6RkpMRU5CUVVNN1VVRkZSQ3hOUVVGTkxFOUJRVThzUjBGQlJ5eEpRVUZKTEZOQlFWTXNRMEZCUXl4NVFrRkJlVUlzUTBGQlF5eE5RVUZOTEVkQlFVY3NWVUZCVlN4RFFVRkRMRU5CUVVNN1VVRkZOMFVzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eDVRa0ZCZVVJc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXp0WlFVTjRSQ3hOUVVGTkxGbEJRVmtzUjBGQlJ5eEhRVUZITEVOQlFVTXNUVUZCVFN4RFFVRkRMSGxDUVVGNVFpeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hoUVVGTExFTkJRVU1zVlVGQlZTeERRVUZETEhsQ1FVRjVRaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVVYyU1N4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRlZCUVZVc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETzJkQ1FVTnNReXhQUVVGUExFTkJRVU1zUTBGQlF5eEhRVUZITEZWQlFWVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYkVRc1EwRkJRenRSUVVOTUxFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNaVUZCWlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeExRVUZMTEdGQlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzBsQlEycElMRU5CUVVNN08wRkJjRkpFTEdWQlFXVTdRVUZEVXl3MlFrRkJlVUlzUjBGQlZ5eEZRVUZGTEVOQlFVTTdRVUZETDBRc1pVRkJaVHRCUVVOVExEWkNRVUY1UWl4SFFVRlhMRU5CUVVNc1EwRkJRenRCUVVNNVJDeGxRVUZsTzBGQlExTXNaVUZCVnl4SFFVRlhMRU5CUVVNc1EwRkJRenRCUVVOb1JDeGxRVUZsTzBGQlExTXNiVUpCUVdVc1IwRkJWeXhEUVVGRExFVkJRVVVzUTBGQlF6dEJRVU4wUkN4bFFVRmxPMEZCUTFNc2JVSkJRV1VzUjBGQlZ5eEZRVUZGTEVOQlFVTTdRVUZXZWtRc2EwSkJjMUpESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvaGFzaC9pc3MudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNvcmVFcnJvcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2Vycm9yL2NvcmVFcnJvclwiKTtcclxuLyoqXHJcbiAqIEEgYnVzaW5lc3MgaW1wbGVtZW50YXRpb24gb2YgYW4gZXJyb3IuXHJcbiAqL1xyXG5jbGFzcyBCdXNpbmVzc0Vycm9yIGV4dGVuZHMgY29yZUVycm9yXzEuQ29yZUVycm9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEJ1c2luZXNzRXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSBmb3IgdGhlIGVycm9yLlxyXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWwgQWRkaXRpb25hbCBkZXRhaWxzIGFib3V0IHRoZSBlcnJvci5cclxuICAgICAqIEBwYXJhbSBpbm5lckVycm9yIEFkZCBpbmZvcm1hdGlvbiBmcm9tIGlubmVyIGVycm9yIGlmIHRoZXJlIHdhcyBvbmUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGFkZGl0aW9uYWwsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlLCBhZGRpdGlvbmFsLCBpbm5lckVycm9yKTtcclxuICAgICAgICB0aGlzLmRvbWFpbiA9IFwiQnVzaW5lc3NcIjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkJ1c2luZXNzRXJyb3IgPSBCdXNpbmVzc0Vycm9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZblZ6YVc1bGMzTkZjbkp2Y2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlsY25KdmNpOWlkWE5wYm1WemMwVnljbTl5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3h2UlVGQmFVVTdRVUZGYWtVN08wZEJSVWM3UVVGRFNDeHRRa0ZCTWtJc1UwRkJVU3h4UWtGQlV6dEpRVU40UXpzN096czdUMEZMUnp0SlFVTklMRmxCUVZrc1QwRkJaU3hGUVVGRkxGVkJRV3RETEVWQlFVVXNWVUZCYTBJN1VVRkRMMFVzUzBGQlN5eERRVUZETEU5QlFVOHNSVUZCUlN4VlFVRlZMRVZCUVVVc1ZVRkJWU3hEUVVGRExFTkJRVU03VVVGRGRrTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhWUVVGVkxFTkJRVU03U1VGRE4wSXNRMEZCUXp0RFFVTktPMEZCV0VRc2MwTkJWME1pZlE9PVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvZXJyb3IvYnVzaW5lc3NFcnJvci50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY29yZUVycm9yXzEgPSByZXF1aXJlKFwiLi9jb3JlRXJyb3JcIik7XHJcbi8qKlxyXG4gKiBBIG5ldHdvcmsgaW1wbGVtZW50YXRpb24gb2YgYW4gZXJyb3IuXHJcbiAqL1xyXG5jbGFzcyBOZXR3b3JrRXJyb3IgZXh0ZW5kcyBjb3JlRXJyb3JfMS5Db3JlRXJyb3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgTmV0d29ya0Vycm9yLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgZm9yIHRoZSBlcnJvci5cclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsIEFkZGl0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gaW5uZXJFcnJvciBBZGQgaW5mb3JtYXRpb24gZnJvbSBpbm5lciBlcnJvciBpZiB0aGVyZSB3YXMgb25lLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBhZGRpdGlvbmFsLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgYWRkaXRpb25hbCwgaW5uZXJFcnJvcik7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSBcIk5ldHdvcmtcIjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk5ldHdvcmtFcnJvciA9IE5ldHdvcmtFcnJvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYm1WMGQyOXlhMFZ5Y205eUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJWeWNtOXlMMjVsZEhkdmNtdEZjbkp2Y2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzTWtOQlFYZERPMEZCUlhoRE96dEhRVVZITzBGQlEwZ3NhMEpCUVRCQ0xGTkJRVkVzY1VKQlFWTTdTVUZEZGtNN096czdPMDlCUzBjN1NVRkRTQ3haUVVGWkxFOUJRV1VzUlVGQlJTeFZRVUZyUXl4RlFVRkZMRlZCUVd0Q08xRkJReTlGTEV0QlFVc3NRMEZCUXl4UFFVRlBMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETzFGQlEzWkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzVTBGQlV5eERRVUZETzBsQlF6VkNMRU5CUVVNN1EwRkRTanRCUVZoRUxHOURRVmRESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvZXJyb3IvbmV0d29ya0Vycm9yLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGNsYXNzIHdoaWNoIGNhbiBwcm92aWRlIHRoZSB0aW1lLlxyXG4gKi9cclxuY2xhc3MgVGltZVNlcnZpY2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDE5NzAvMDEvMDEuXHJcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxyXG4gICAgICovXHJcbiAgICBtc1NpbmNlRXBvY2goKSB7XHJcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5UaW1lU2VydmljZSA9IFRpbWVTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkR2x0WlZObGNuWnBZMlV1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZjMlZ5ZG1salpYTXZkR2x0WlZObGNuWnBZMlV1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVVkJPenRIUVVWSE8wRkJRMGc3U1VGRFNUczdPMDlCUjBjN1NVRkRTU3haUVVGWk8xRkJRMllzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRVZCUVVVc1EwRkJRenRKUVVOMFFpeERRVUZETzBOQlEwbzdRVUZTUkN4clEwRlJReUo5XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9zZXJ2aWNlcy90aW1lU2VydmljZS50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBkYXRhRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9kYXRhRXJyb3JcIik7XHJcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3NcIik7XHJcbmNvbnN0IHRhZ18xID0gcmVxdWlyZShcIi4vdGFnXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCIuL3RyeXRlc1wiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHRyYW5zZmVycy5cclxuICovXHJcbmNsYXNzIFRyYW5zZmVyIHtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBpbnN0YW5jZSBvZiB0cmFuc2ZlciBmcm9tIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gbWVzc3NhZ2UgVGhlIG1lc3NhZ2UgZm9yIHRoZSB0cmFuc2Zlci5cclxuICAgICAqIEBwYXJhbSB0YWcgVGhlIHRhZy5cclxuICAgICAqIEByZXR1cm4gTmV3IGluc3RhbmNlIG9mIFRyYW5zZmVyLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVBhcmFtcyhhZGRyZXNzLCB2YWx1ZSwgbWVzc2FnZSwgdGFnKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIGFkZHJlc3Mgc2hvdWxkIGJlIGEgdmFsaWQgQWRkcmVzcyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgc2hvdWxkIGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkobWVzc2FnZSkgJiYgIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUobWVzc2FnZSwgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIG1lc3NhZ2Ugc2hvdWxkIGJlIGEgdmFsaWQgVHJ5dGVzIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh0YWcpICYmICFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRhZywgdGFnXzEuVGFnKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHRhZyBzaG91bGQgYmUgYSB2YWxpZCBUYWcgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cmFuc2ZlciA9IG5ldyBUcmFuc2ZlcigpO1xyXG4gICAgICAgIHRyYW5zZmVyLmFkZHJlc3MgPSBhZGRyZXNzO1xyXG4gICAgICAgIHRyYW5zZmVyLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdHJhbnNmZXIubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgdHJhbnNmZXIudGFnID0gdGFnO1xyXG4gICAgICAgIHJldHVybiB0cmFuc2ZlcjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlRyYW5zZmVyID0gVHJhbnNmZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRISmhibk5tWlhJdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12WkdGMFlTOTBjbUZ1YzJabGNpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFc05FVkJRWGxGTzBGQlEzcEZMRFJGUVVGNVJUdEJRVU42UlN4clJFRkJLME03UVVGREwwTXNkVU5CUVc5RE8wRkJRM0JETEN0Q1FVRTBRanRCUVVNMVFpeHhRMEZCYTBNN1FVRkZiRU03TzBkQlJVYzdRVUZEU0R0SlFXdENTU3hsUVVGbE8wbEJRMlk3U1VGRFFTeERRVUZETzBsQlJVUTdPenM3T3pzN1QwRlBSenRKUVVOSkxFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTXNUMEZCWjBJc1JVRkRhRUlzUzBGQllTeEZRVU5pTEU5QlFXVXNSVUZEWml4SFFVRlJPMUZCUXpkQ0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zVDBGQlR5eEZRVUZGTEdsQ1FVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGVrTXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zT0VOQlFUaERMRU5CUVVNc1EwRkJRenRSUVVONFJTeERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hMUVVGTExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTVReXhOUVVGTkxFbEJRVWtzY1VKQlFWTXNRMEZCUXl4dFEwRkJiVU1zUTBGQlF5eERRVUZETzFGQlF6ZEVMRU5CUVVNN1VVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zVDBGQlR5eEZRVUZGTEdWQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNeFJTeE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXcyUTBGQk5rTXNRMEZCUXl4RFFVRkRPMUZCUTNaRkxFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RlFVRkZMRk5CUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU12UkN4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHpRMEZCYzBNc1EwRkJReXhEUVVGRE8xRkJRMmhGTEVOQlFVTTdVVUZGUkN4TlFVRk5MRkZCUVZFc1IwRkJSeXhKUVVGSkxGRkJRVkVzUlVGQlJTeERRVUZETzFGQlEyaERMRkZCUVZFc1EwRkJReXhQUVVGUExFZEJRVWNzVDBGQlR5eERRVUZETzFGQlF6TkNMRkZCUVZFc1EwRkJReXhMUVVGTExFZEJRVWNzUzBGQlN5eERRVUZETzFGQlEzWkNMRkZCUVZFc1EwRkJReXhQUVVGUExFZEJRVWNzVDBGQlR5eERRVUZETzFGQlF6TkNMRkZCUVZFc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETzFGQlEyNUNMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU03U1VGRGNFSXNRMEZCUXp0RFFVTktPMEZCZWtSRUxEUkNRWGxFUXlKOVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvZGF0YS90cmFuc2Zlci50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgYXJyYXlIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3Qgc3BvbmdlRmFjdG9yeV8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnlcIik7XHJcbmNvbnN0IGlzc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvaGFzaC9pc3NcIik7XHJcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2FkZHJlc3NcIik7XHJcbmNvbnN0IGJ1bmRsZV8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvYnVuZGxlXCIpO1xyXG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9oYXNoXCIpO1xyXG5jb25zdCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFwiKTtcclxuY29uc3QgdGFnXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90YWdcIik7XHJcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cmFuc2FjdGlvblwiKTtcclxuY29uc3QgdHJpdHNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyaXRzXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlc1wiKTtcclxuY29uc3QgdHJ5dGVOdW1iZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJ5dGVOdW1iZXJcIik7XHJcbmNvbnN0IGhtYWNDdXJsXzEgPSByZXF1aXJlKFwiLi4vc2lnbi9obWFjQ3VybFwiKTtcclxuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyBmb3Igc2lnbmluZyBidW5kbGVzLlxyXG4gKiBDb252ZXJ0ZWQgaHR0cHM6Ly9naXRodWIuY29tL2lvdGFsZWRnZXIvaW90YS5saWIuanMvYmxvYi9tYXN0ZXIvbGliL2NyeXB0by9zaWduaW5nL3NpZ25pbmcuanNcclxuICovXHJcbmNsYXNzIEJ1bmRsZUhlbHBlciB7XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSBidW5kbGUgdmFsaWQuXHJcbiAgICAgKiBAcGFyYW0gYnVuZGxlIFRoZSBidW5kbGUgdG8gY2hlY2sgZm9yIHZhbGlkaXR5LlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYnVuZGxlIGlzIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNWYWxpZChidW5kbGUpIHtcclxuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGJ1bmRsZSwgYnVuZGxlXzEuQnVuZGxlKSAmJiBhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYnVuZGxlLnRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbikpIHtcclxuICAgICAgICAgICAgbGV0IHRvdGFsU3VtID0gMDtcclxuICAgICAgICAgICAgY29uc3Qga2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFwia2VybFwiKTtcclxuICAgICAgICAgICAga2VybC5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgIC8vIFByZXBhcmUgZm9yIHNpZ25hdHVyZSB2YWxpZGF0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZXNUb1ZhbGlkYXRlID0gW107XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoICYmIGlzVmFsaWQ7IHQrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVuZGxlVHggPSBidW5kbGUudHJhbnNhY3Rpb25zW3RdO1xyXG4gICAgICAgICAgICAgICAgdG90YWxTdW0gKz0gYnVuZGxlVHgudmFsdWUudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRJbmRleCBoYXMgdG8gYmUgZXF1YWwgdG8gdGhlIGluZGV4IGluIHRoZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgaWYgKGJ1bmRsZVR4LmN1cnJlbnRJbmRleC50b051bWJlcigpICE9PSB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0cmFuc2FjdGlvbiB0cnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGlzVHhUcnl0ZXMgPSBidW5kbGVUeC50b1RyeXRlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFic29yYiBidW5kbGUgaGFzaCArIHZhbHVlICsgdGltZXN0YW1wICsgbGFzdEluZGV4ICsgY3VycmVudEluZGV4IHRyeXRlcy5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGlzVHhUcml0cyA9IHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyh0aGlzVHhUcnl0ZXMuc3ViKHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEgsIDE2MikpLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICBrZXJsLmFic29yYih0aGlzVHhUcml0cywgMCwgdGhpc1R4VHJpdHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpbnB1dCB0cmFuc2FjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidW5kbGVUeC52YWx1ZS50b051bWJlcigpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTaWduYXR1cmVUb1ZhbGlkYXRlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogYnVuZGxlVHguYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHM6IFtidW5kbGVUeC5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHN1YnNlcXVlbnQgdHhzIHdpdGggdGhlIHJlbWFpbmluZyBzaWduYXR1cmUgZnJhZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHQ7IGkgPCBidW5kbGUudHJhbnNhY3Rpb25zLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3QnVuZGxlVHggPSBidW5kbGUudHJhbnNhY3Rpb25zW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG5ldyB0eCBpcyBwYXJ0IG9mIHRoZSBzaWduYXR1cmUgZnJhZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdCdW5kbGVUeC5hZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSA9PT0gYnVuZGxlVHguYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBuZXdCdW5kbGVUeC52YWx1ZS50b051bWJlcigpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2lnbmF0dXJlVG9WYWxpZGF0ZS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLnB1c2gobmV3QnVuZGxlVHguc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVzVG9WYWxpZGF0ZS5wdXNoKG5ld1NpZ25hdHVyZVRvVmFsaWRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdG90YWwgc3VtLCBpZiBub3QgZXF1YWwgMCByZXR1cm4gZXJyb3JcclxuICAgICAgICAgICAgaWYgKHRvdGFsU3VtICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGJ1bmRsZSBoYXNoIGZyb20gdGhlIGJ1bmRsZSB0cmFuc2FjdGlvbnNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1bmRsZUZyb21UeHMgPSBuZXcgSW50OEFycmF5KGtlcmwuZ2V0Q29uc3RhbnQoXCJIQVNIX0xFTkdUSFwiKSk7XHJcbiAgICAgICAgICAgICAgICBrZXJsLnNxdWVlemUoYnVuZGxlRnJvbVR4cywgMCwgYnVuZGxlRnJvbVR4cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVuZGxlRnJvbVR4c1RyeXRlcyA9IHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGJ1bmRsZUZyb21UeHMpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGJ1bmRsZSBoYXNoIGlzIHRoZSBzYW1lIGFzIHJldHVybmVkIGJ5IHR4IG9iamVjdFxyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVuZGxlSGFzaCA9IGJ1bmRsZS50cmFuc2FjdGlvbnNbMF0uYnVuZGxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1bmRsZUZyb21UeHNUcnl0ZXMgIT09IGJ1bmRsZUhhc2gudG9Ucnl0ZXMoKS50b1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCB0eCBpbiB0aGUgYnVuZGxlIHNob3VsZCBoYXZlIGN1cnJlbnRJbmRleCA9PT0gbGFzdEluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1bmRsZS50cmFuc2FjdGlvbnNbYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGggLSAxXS5jdXJyZW50SW5kZXgudG9OdW1iZXIoKSAhPT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9uc1tidW5kbGUudHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFdLmxhc3RJbmRleC50b051bWJlcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBzaWduYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlc1RvVmFsaWRhdGUubGVuZ3RoICYmIGlzVmFsaWQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNpZ25hdHVyZSA9IGlzc18xLklTUy52YWxpZGF0ZVNpZ25hdHVyZXMoc2lnbmF0dXJlc1RvVmFsaWRhdGVbaV0uYWRkcmVzcywgc2lnbmF0dXJlc1RvVmFsaWRhdGVbaV0uc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cywgYnVuZGxlSGFzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRTaWduYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHNpZ25hdHVyZXMgZm9yIGVhY2ggb2YgdGhlIGNvLXNpZ25lcnMgaW4gdGhlIG11bHRpLXNpZ25hdHVyZSB0byBpbmRlcGVuZGVudGx5IHZlcmlmeSB0aGF0IGEgZ2VuZXJhdGVkXHJcbiAgICAgKiB0cmFuc2FjdGlvbiB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHNpZ25hdHVyZXMgb2YgdGhlIGNvLXNpZ25lcnMgaXMgdmFsaWQuXHJcbiAgICAgKiBAcGFyYW0gc2lnbmVkQnVuZGxlIFRoZSBzaWduZWQgYnVuZGxlIHRvIGNoZWNrIHRoZSBzaWduYXR1cmVzLlxyXG4gICAgICogQHBhcmFtIGlucHV0QWRkcmVzcyBUaGUgYWRkcmVzcyB1c2VkIHRvIGluaXRpYXRlIHRoZSB0cmFuc2Zlci5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaXMgdGhlIHNpZ25hdHVyZXMgYXJlIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdmFsaWRhdGVTaWduYXR1cmVzKHNpZ25lZEJ1bmRsZSwgaW5wdXRBZGRyZXNzKSB7XHJcbiAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzaWduZWRCdW5kbGUsIGJ1bmRsZV8xLkJ1bmRsZSkgJiZcclxuICAgICAgICAgICAgYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHNpZ25lZEJ1bmRsZS50cmFuc2FjdGlvbnMsIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24pICYmXHJcbiAgICAgICAgICAgIG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoaW5wdXRBZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgbGV0IGJ1bmRsZUhhc2g7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZUZyYWdtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dEFkZHJlc3NUcnl0ZXMgPSBpbnB1dEFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25lZEJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChzaWduZWRCdW5kbGUudHJhbnNhY3Rpb25zW2ldLmFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpID09PSBpbnB1dEFkZHJlc3NUcnl0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBidW5kbGVIYXNoID0gc2lnbmVkQnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5idW5kbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgcmVhY2hlZCByZW1haW5kZXIgYnVuZGxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25lZEJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LnRvVHJ5dGVzKCkudG9TdHJpbmcoKSA9PT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkVNUFRZLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlRnJhZ21lbnRzLnB1c2goc2lnbmVkQnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChidW5kbGVIYXNoKSB7XHJcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gaXNzXzEuSVNTLnZhbGlkYXRlU2lnbmF0dXJlcyhpbnB1dEFkZHJlc3MsIHNpZ25hdHVyZUZyYWdtZW50cywgYnVuZGxlSGFzaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcHJlcGFyZUJ1bmRsZSh0aW1lU2VydmljZSwgdHJhbnNmZXJzKSB7XHJcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbmV3IGJ1bmRsZV8xLkJ1bmRsZSgpO1xyXG4gICAgICAgIGxldCBsYXN0VGFnO1xyXG4gICAgICAgIGxldCB0b3RhbFZhbHVlID0gMDtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzID0gW107XHJcbiAgICAgICAgLy8gIEl0ZXJhdGUgb3ZlciBhbGwgdHJhbnNmZXJzLCBnZXQgdG90YWxWYWx1ZVxyXG4gICAgICAgIC8vICBhbmQgcHJlcGFyZSB0aGUgTWVzc2FnZXMsIG1lc3NhZ2UgYW5kIHRhZ1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmVNZXNzYWdlTGVuZ3RoID0gMTtcclxuICAgICAgICAgICAgLy8gSWYgbWVzc2FnZSBsb25nZXIgdGhhbiAyMTg3IHRyeXRlcywgaW5jcmVhc2Ugc2lnbmF0dXJlTWVzc2FnZUxlbmd0aCAoYWRkIDJuZCB0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVN0cmluZyA9IHRyYW5zZmVyc1tpXS5tZXNzYWdlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlU3RyaW5nLmxlbmd0aCA+IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEgpIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0b3RhbCBsZW5ndGgsIG1lc3NhZ2UgLyBtYXhMZW5ndGggKDIxODcgdHJ5dGVzKVxyXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlTWVzc2FnZUxlbmd0aCArPSBNYXRoLmZsb29yKG1lc3NhZ2VTdHJpbmcubGVuZ3RoIC8gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbXNnQ29weSA9IG1lc3NhZ2VTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAvLyBXaGlsZSB0aGVyZSBpcyBzdGlsbCBhIG1lc3NhZ2UsIGNvcHkgaXRcclxuICAgICAgICAgICAgICAgIHdoaWxlIChtc2dDb3B5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWdtZW50ID0gbXNnQ29weS5zbGljZSgwLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIKTtcclxuICAgICAgICAgICAgICAgICAgICBtc2dDb3B5ID0gbXNnQ29weS5zbGljZShzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RILCBtc2dDb3B5Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFkIHJlbWFpbmRlciBvZiBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBmcmFnbWVudC5sZW5ndGggPCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgKz0gXCI5XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMucHVzaChzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhmcmFnbWVudCkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEVsc2UsIGdldCBzaW5nbGUgZnJhZ21lbnQgd2l0aCAyMTg3IG9mIDkncyB0cnl0ZXNcclxuICAgICAgICAgICAgICAgIGxldCBmcmFnbWVudCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gbWVzc2FnZVN0cmluZy5zbGljZSgwLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBmcmFnbWVudC5sZW5ndGggPCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCArPSBcIjlcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMucHVzaChzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhmcmFnbWVudCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBnZXQgY3VycmVudCB0aW1lc3RhbXAgaW4gc2Vjb25kc1xyXG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKHRpbWVTZXJ2aWNlLm1zU2luY2VFcG9jaCgpIC8gMTAwMCk7XHJcbiAgICAgICAgICAgIGxhc3RUYWcgPSB0cmFuc2ZlcnNbaV0udGFnO1xyXG4gICAgICAgICAgICAvLyBBZGQgZmlyc3QgZW50cmllcyB0byB0aGUgYnVuZGxlXHJcbiAgICAgICAgICAgIGJ1bmRsZS5hZGRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlTWVzc2FnZUxlbmd0aCwgdHJhbnNmZXJzW2ldLmFkZHJlc3MsIHRyYW5zZmVyc1tpXS52YWx1ZSwgdHJhbnNmZXJzW2ldLnRhZywgdGltZXN0YW1wKTtcclxuICAgICAgICAgICAgLy8gU3VtIHVwIHRvdGFsIHZhbHVlXHJcbiAgICAgICAgICAgIHRvdGFsVmFsdWUgKz0gdHJhbnNmZXJzW2ldLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBidW5kbGUsIHRvdGFsVmFsdWUsIGxhc3RUYWcsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMgfTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIHNpZ25JbnB1dHMoc2VlZCwgYnVuZGxlLCB0cmFuc2Zlck9wdGlvbnMsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMsIGlucHV0cywgYWRkZWRITUFDKSB7XHJcbiAgICAgICAgQnVuZGxlSGVscGVyLmZpbmFsaXplQnVuZGxlKGJ1bmRsZSk7XHJcbiAgICAgICAgYnVuZGxlLmFkZFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyk7XHJcbiAgICAgICAgLy8gIEhlcmUgd2UgZG8gdGhlIGFjdHVhbCBzaWduaW5nIG9mIHRoZSBpbnB1dHNcclxuICAgICAgICAvLyAgSXRlcmF0ZSBvdmVyIGFsbCBidW5kbGUgdHJhbnNhY3Rpb25zLCBmaW5kIHRoZSBpbnB1dHNcclxuICAgICAgICAvLyAgR2V0IHRoZSBjb3JyZXNwb25kaW5nIHByaXZhdGUga2V5IGFuZCBjYWxjdWxhdGUgdGhlIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS52YWx1ZS50b051bWJlcigpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzc1RyeXRlcyA9IGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNvcnJlc3BvbmRpbmcga2V5SW5kZXggYW5kIHNlY3VyaXR5IG9mIHRoZSBhZGRyZXNzXHJcbiAgICAgICAgICAgICAgICBsZXQga2V5SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBsZXQga2V5U2VjdXJpdHk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHNba10uYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09IGFkZHJlc3NUcnl0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5kZXggPSBpbnB1dHNba10ua2V5SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVNlY3VyaXR5ID0gaW5wdXRzW2tdLnNlY3VyaXR5ID8gaW5wdXRzW2tdLnNlY3VyaXR5IDogdHJhbnNmZXJPcHRpb25zLnNlY3VyaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgY29ycmVzcG9uZGluZyBwcml2YXRlIGtleSBvZiBhZGRyZXNzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBpc3NfMS5JU1Mua2V5KHNlZWQsIGtleUluZGV4LCBrZXlTZWN1cml0eSk7XHJcbiAgICAgICAgICAgICAgICBCdW5kbGVIZWxwZXIuc2lnblRyYW5zYWN0aW9ucyhidW5kbGUsIGksIDAsIGtleSwgYWRkcmVzc1RyeXRlcywga2V5U2VjdXJpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGRlZEhNQUMpIHtcclxuICAgICAgICAgICAgY29uc3QgaG1hYyA9IG5ldyBobWFjQ3VybF8xLkhtYWNDdXJsKHRyYW5zZmVyT3B0aW9ucy5obWFjS2V5KTtcclxuICAgICAgICAgICAgaG1hYy5hZGRITUFDKGJ1bmRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgc2lnblRyYW5zYWN0aW9ucyhidW5kbGUsIGluZGV4LCBmaXJzdFVuc2lnbmVkSW5kZXgsIGtleVRyaXRzLCBhZGRyZXNzVHJ5dGVzLCBzZWN1cml0eSkge1xyXG4gICAgICAgIGNvbnN0IGJ1bmRsZUhhc2ggPSBidW5kbGUudHJhbnNhY3Rpb25zW2luZGV4XS5idW5kbGU7XHJcbiAgICAgICAgLy8gIEdldCB0aGUgbm9ybWFsaXplZCBidW5kbGUgaGFzaFxyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRCdW5kbGVIYXNoID0gaXNzXzEuSVNTLm5vcm1hbGl6ZWRCdW5kbGUoYnVuZGxlSGFzaCk7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50cyA9IFtdO1xyXG4gICAgICAgIC8vIFNwbGl0IGhhc2ggaW50byAzIGZyYWdtZW50c1xyXG4gICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgMzsgbCsrKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRCdW5kbGVGcmFnbWVudHNbbF0gPSBub3JtYWxpemVkQnVuZGxlSGFzaC5zbGljZShsICogMjcsIChsICsgMSkgKiAyNyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vICBGaXJzdCA2NTYxIHRyaXRzIGZvciB0aGUgZmlyc3RGcmFnbWVudFxyXG4gICAgICAgIGNvbnN0IGZpcnN0RnJhZ21lbnQgPSBrZXlUcml0cy5zbGljZSgwLCA2NTYxKTtcclxuICAgICAgICAvLyAgRmlyc3QgYnVuZGxlIGZyYWdtZW50IHVzZXMgdGhlIGZpcnN0IDI3IHRyeXRlc1xyXG4gICAgICAgIGNvbnN0IGZpcnN0QnVuZGxlRnJhZ21lbnQgPSBub3JtYWxpemVkQnVuZGxlRnJhZ21lbnRzW2ZpcnN0VW5zaWduZWRJbmRleF07XHJcbiAgICAgICAgLy8gIENhbGN1bGF0ZSB0aGUgbmV3IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCB3aXRoIHRoZSBmaXJzdCBidW5kbGUgZnJhZ21lbnRcclxuICAgICAgICBjb25zdCBmaXJzdFNpZ25lZEZyYWdtZW50ID0gQnVuZGxlSGVscGVyLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudChmaXJzdEJ1bmRsZUZyYWdtZW50LCBmaXJzdEZyYWdtZW50KTtcclxuICAgICAgICAvLyAgQ29udmVydCBzaWduYXR1cmUgdG8gdHJ5dGVzIGFuZCBhc3NpZ24gdGhlIG5ldyBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRcclxuICAgICAgICBidW5kbGUudHJhbnNhY3Rpb25zW2luZGV4XS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuZnJvbVRyeXRlcyh0cml0c18xLlRyaXRzLmZyb21BcnJheShmaXJzdFNpZ25lZEZyYWdtZW50KS50b1RyeXRlcygpKTtcclxuICAgICAgICAvLyBpZiB1c2VyIGNob29zZXMgaGlnaGVyIHRoYW4gMjctdHJ5dGUgc2VjdXJpdHlcclxuICAgICAgICAvLyBmb3IgZWFjaCBzZWN1cml0eSBsZXZlbCwgYWRkIGFuIGFkZGl0aW9uYWwgc2lnbmF0dXJlXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBzZWN1cml0eTsgaisrKSB7XHJcbiAgICAgICAgICAgIC8vICBCZWNhdXNlIHRoZSBzaWduYXR1cmUgaXMgPiAyMTg3IHRyeXRlcywgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAvLyAgZmluZCB0aGUgc3Vic2VxdWVudCB0cmFuc2FjdGlvbiB0byBhZGQgdGhlIHJlbWFpbmRlciBvZiB0aGUgc2lnbmF0dXJlXHJcbiAgICAgICAgICAgIC8vICBTYW1lIGFkZHJlc3MgYXMgd2VsbCBhcyB2YWx1ZSA9IDAgKGFzIHdlIGFscmVhZHkgc3BlbnQgdGhlIGlucHV0KVxyXG4gICAgICAgICAgICBpZiAoYnVuZGxlLnRyYW5zYWN0aW9uc1tpbmRleCArIGpdLmFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpID09PSBhZGRyZXNzVHJ5dGVzXHJcbiAgICAgICAgICAgICAgICAmJiBidW5kbGUudHJhbnNhY3Rpb25zW2luZGV4ICsgal0udmFsdWUudG9OdW1iZXIoKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBuZXh0IDY1NjEgdHJpdHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRGcmFnbWVudCA9IGtleVRyaXRzLnNsaWNlKDY1NjEgKiBqLCAoaiArIDEpICogNjU2MSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0QnVuZGxlRnJhZ21lbnQgPSBub3JtYWxpemVkQnVuZGxlRnJhZ21lbnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgLy8gIENhbGN1bGF0ZSB0aGUgbmV3IHNpZ25hdHVyZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFNpZ25lZEZyYWdtZW50ID0gQnVuZGxlSGVscGVyLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudChuZXh0QnVuZGxlRnJhZ21lbnQsIG5leHRGcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICAvLyAgQ29udmVydCBzaWduYXR1cmUgdG8gdHJ5dGVzIGFuZCBhc3NpZ24gaXQgYWdhaW4gdG8gdGhpcyBidW5kbGUgZW50cnlcclxuICAgICAgICAgICAgICAgIGJ1bmRsZS50cmFuc2FjdGlvbnNbaW5kZXggKyBqXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuZnJvbVRyeXRlcyh0cml0c18xLlRyaXRzLmZyb21BcnJheShuZXh0U2lnbmVkRnJhZ21lbnQpLnRvVHJ5dGVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgZmluYWxpemVCdW5kbGUoYnVuZGxlKSB7XHJcbiAgICAgICAgaWYgKGJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgdmFsaWRCdW5kbGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgd2hpbGUgKCF2YWxpZEJ1bmRsZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFwia2VybFwiKTtcclxuICAgICAgICAgICAgICAgIGtlcmwuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidW5kbGUudHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5jdXJyZW50SW5kZXggPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5sYXN0SW5kZXggPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBidW5kbGVFc3NlbmNlID0gdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyBidW5kbGUudHJhbnNhY3Rpb25zW2ldLnZhbHVlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSArIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uQ0hFQ0tfVkFMVUVcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyBidW5kbGUudHJhbnNhY3Rpb25zW2ldLm9ic29sZXRlVGFnLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0udGltZXN0YW1wLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uY3VycmVudEluZGV4LnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0ubGFzdEluZGV4LnRvVHJ5dGVzKCkudG9TdHJpbmcoKSkpLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICBrZXJsLmFic29yYihidW5kbGVFc3NlbmNlLCAwLCBidW5kbGVFc3NlbmNlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoVHJpdHMgPSBuZXcgSW50OEFycmF5KGtlcmwuZ2V0Q29uc3RhbnQoXCJIQVNIX0xFTkdUSFwiKSk7XHJcbiAgICAgICAgICAgICAgICBrZXJsLnNxdWVlemUoaGFzaFRyaXRzLCAwLCBoYXNoVHJpdHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGhhc2hUcml0cykudG9Ucnl0ZXMoKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBidW5kbGUudHJhbnNhY3Rpb25zW2ldLmJ1bmRsZSA9IGhhc2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSGFzaCA9IGlzc18xLklTUy5ub3JtYWxpemVkQnVuZGxlKGhhc2gpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRIYXNoLmluZGV4T2YoMTMgLyogPSBNICovKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlY3VyZSBidW5kbGUuIEluY3JlbWVudCBUYWcgYW5kIHJlY29tcHV0ZSBidW5kbGUgaGFzaC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmNyZWFzZWRUYWcgPSB0cml0c18xLlRyaXRzLmFkZCh0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXMoYnVuZGxlLnRyYW5zYWN0aW9uc1swXS5vYnNvbGV0ZVRhZy50b1RyeXRlcygpKSwgdHJpdHNfMS5Ucml0cy5mcm9tTnVtYmVyQXJyYXkoWzFdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9uc1swXS5vYnNvbGV0ZVRhZyA9IHRhZ18xLlRhZy5mcm9tVHJ5dGVzKGluY3JlYXNlZFRhZy50b1RyeXRlcygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkQnVuZGxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIHRyYW5zYWN0aW9uSGFzaCh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGN1cmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcImN1cmxcIik7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25Ucml0cyA9IHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyh0cmFuc2FjdGlvbi50b1RyeXRlcygpKS50b0FycmF5KCk7XHJcbiAgICAgICAgY3VybC5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgY3VybC5hYnNvcmIodHJhbnNhY3Rpb25Ucml0cywgMCwgdHJhbnNhY3Rpb25Ucml0cy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hUcml0cyA9IG5ldyBJbnQ4QXJyYXkoY3VybC5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpKTtcclxuICAgICAgICBjdXJsLnNxdWVlemUoaGFzaFRyaXRzLCAwLCBoYXNoVHJpdHMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cml0c18xLlRyaXRzLmZyb21BcnJheShoYXNoVHJpdHMpLnRvVHJ5dGVzKCkpO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KG5vcm1hbGl6ZWRCdW5kbGVGcmFnbWVudCwga2V5RnJhZ21lbnQpIHtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPSBrZXlGcmFnbWVudC5zbGljZSgpO1xyXG4gICAgICAgIGxldCBoYXNoO1xyXG4gICAgICAgIGNvbnN0IGtlcmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcImtlcmxcIik7XHJcbiAgICAgICAgY29uc3QgaGFzaExlbmd0aCA9IGtlcmwuZ2V0Q29uc3RhbnQoXCJIQVNIX0xFTkdUSFwiKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI3OyBpKyspIHtcclxuICAgICAgICAgICAgaGFzaCA9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5zbGljZShpICogaGFzaExlbmd0aCwgKGkgKyAxKSAqIGhhc2hMZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDEzIC0gbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50W2ldOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGtlcmwuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAga2VybC5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAga2VybC5hYnNvcmIoaGFzaCwgMCwgaGFzaExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBrZXJsLnNxdWVlemUoaGFzaCwgMCwgaGFzaExlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoYXNoTGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFtpICogaGFzaExlbmd0aCArIGpdID0gaGFzaFtqXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50O1xyXG4gICAgfVxyXG59XHJcbkJ1bmRsZUhlbHBlci5OVU1CRVJfT0ZfRlJBR01FTlRfQ0hVTktTID0gMjc7XHJcbmV4cG9ydHMuQnVuZGxlSGVscGVyID0gQnVuZGxlSGVscGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZblZ1Wkd4bFNHVnNjR1Z5TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMmhsYkhCbGNuTXZZblZ1Wkd4bFNHVnNjR1Z5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3d3UlVGQmRVVTdRVUZEZGtVc05FVkJRWGxGTzBGQlJYcEZMR3RHUVVFclJUdEJRVU12UlN4NVJFRkJjMFE3UVVGRGRFUXNLMFJCUVRSRU8wRkJSVFZFTERaRVFVRXdSRHRCUVVNeFJDeDVSRUZCYzBRN1FVRkZkRVFzYVVkQlFUaEdPMEZCUXpsR0xIVkVRVUZ2UkR0QlFVTndSQ3gxUlVGQmIwVTdRVUZGY0VVc01rUkJRWGRFTzBGQlEzaEVMRFpFUVVFd1JEdEJRVU14UkN3clJVRkJORVU3UVVGRE5VVXNLME5CUVRSRE8wRkJSelZET3pzN1IwRkhSenRCUVVOSU8wbEJSMGs3T3pzN1QwRkpSenRKUVVOSkxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCWXp0UlFVTm9ReXhKUVVGSkxFOUJRVThzUjBGQlJ5eExRVUZMTEVOQlFVTTdVVUZGY0VJc1JVRkJSU3hEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hGUVVGRkxHVkJRVTBzUTBGQlF5eEpRVUZKTEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUTBGQlF5eFpRVUZaTEVWQlFVVXNlVUpCUVZjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU12Uml4SlFVRkpMRkZCUVZFc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRmFrSXNUVUZCVFN4SlFVRkpMRWRCUVVjc05rSkJRV0VzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03V1VGRGNrUXNTVUZCU1N4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8xbEJSV3hDTEcxRFFVRnRRenRaUVVOdVF5eE5RVUZOTEc5Q1FVRnZRaXhIUVVGclJpeEZRVUZGTEVOQlFVTTdXVUZGTDBjc1QwRkJUeXhIUVVGSExFbEJRVWtzUTBGQlF6dFpRVU5tTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhOUVVGTkxFbEJRVWtzVDBGQlR5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNN1owSkJRemRFTEUxQlFVMHNVVUZCVVN4SFFVRkhMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNoRExGRkJRVkVzU1VGQlNTeFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8yZENRVVYwUXl4NVJFRkJlVVE3WjBKQlEzcEVMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eFpRVUZaTEVOQlFVTXNVVUZCVVN4RlFVRkZMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZEZWtNc1QwRkJUeXhIUVVGSExFdEJRVXNzUTBGQlF6dG5Ra0ZEY0VJc1EwRkJRenRuUWtGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0dlFrRkRTaXcyUWtGQk5rSTdiMEpCUXpkQ0xFMUJRVTBzV1VGQldTeEhRVUZITEZGQlFWRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenR2UWtGRmVrTXNORVZCUVRSRk8yOUNRVU0xUlN4TlFVRk5MRmRCUVZjc1IwRkJSeXhoUVVGTExFTkJRVU1zVlVGQlZTeERRVUZETEZsQlFWa3NRMEZCUXl4SFFVRkhMRU5CUVVNc2JVUkJRWGRDTEVOQlFVTXNUVUZCVFN4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTTdiMEpCUTNaSExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RlFVRkZMRU5CUVVNc1JVRkJSU3hYUVVGWExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdiMEpCUldoRUxEWkNRVUUyUWp0dlFrRkROMElzUlVGQlJTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhSUVVGUkxFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPM2RDUVVOb1F5eE5RVUZOTEhOQ1FVRnpRaXhIUVVGblJqczBRa0ZEZUVjc1QwRkJUeXhGUVVGRkxGRkJRVkVzUTBGQlF5eFBRVUZQT3pSQ1FVTjZRaXg1UWtGQmVVSXNSVUZCUlN4RFFVRkRMRkZCUVZFc1EwRkJReXgzUWtGQmQwSXNRMEZCUXp0NVFrRkRha1VzUTBGQlF6dDNRa0ZGUml4blJVRkJaMFU3ZDBKQlEyaEZMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU03TkVKQlEzUkVMRTFCUVUwc1YwRkJWeXhIUVVGSExFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE96UkNRVVV2UXl4dlJFRkJiMFE3TkVKQlEzQkVMRVZCUVVVc1EwRkJReXhEUVVGRExGZEJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFdEJRVXNzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3YlVOQlEycEdMRmRCUVZjc1EwRkJReXhMUVVGTExFTkJRVU1zVVVGQlVTeEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUTBGRGVFTXNjMEpCUVhOQ0xFTkJRVU1zZVVKQlFYbENMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eDNRa0ZCZDBJc1EwRkJReXhEUVVGRE96UkNRVU5vUnl4RFFVRkRPM2RDUVVOTUxFTkJRVU03ZDBKQlJVUXNiMEpCUVc5Q0xFTkJRVU1zU1VGQlNTeERRVUZETEhOQ1FVRnpRaXhEUVVGRExFTkJRVU03YjBKQlEzUkVMRU5CUVVNN1owSkJRMHdzUTBGQlF6dFpRVU5NTEVOQlFVTTdXVUZGUkN4dFJFRkJiVVE3V1VGRGJrUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTJwQ0xFOUJRVThzUjBGQlJ5eExRVUZMTEVOQlFVTTdXVUZEY0VJc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTktMRzFFUVVGdFJEdG5Ra0ZEYmtRc1RVRkJUU3hoUVVGaExFZEJRVWNzU1VGQlNTeFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTnlSU3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEdGQlFXRXNSVUZCUlN4RFFVRkRMRVZCUVVVc1lVRkJZU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzJkQ1FVVnlSQ3hOUVVGTkxHMUNRVUZ0UWl4SFFVRkhMR0ZCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zWVVGQllTeERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU03WjBKQlJXcEdMRFJFUVVFMFJEdG5Ra0ZETlVRc1RVRkJUU3hWUVVGVkxFZEJRVWNzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU03WjBKQlEycEVMRVZCUVVVc1EwRkJReXhEUVVGRExHMUNRVUZ0UWl4TFFVRkxMRlZCUVZVc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRek5FTEU5QlFVOHNSMEZCUnl4TFFVRkxMRU5CUVVNN1owSkJRM0JDTEVOQlFVTTdaMEpCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03YjBKQlEwb3NLMFJCUVN0RU8yOUNRVU12UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEZsQlFWa3NRMEZCUXl4UlFVRlJMRVZCUVVVN2QwSkJRM1pGTEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0M1FrRkRMMFVzVDBGQlR5eEhRVUZITEV0QlFVc3NRMEZCUXp0dlFrRkRjRUlzUTBGQlF6dHZRa0ZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenQzUWtGRFNpd3dRa0ZCTUVJN2QwSkJRekZDTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NiMEpCUVc5Q0xFTkJRVU1zVFVGQlRTeEpRVUZKTEU5QlFVOHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRE96UkNRVU01UkN4TlFVRk5MR2RDUVVGblFpeEhRVUZITEZOQlFVY3NRMEZCUXl4clFrRkJhMElzUTBGQlF5eHZRa0ZCYjBJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVWQlF5OUNMRzlDUVVGdlFpeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMSGxDUVVGNVFpeEZRVU5xUkN4VlFVRlZMRU5CUVVNc1EwRkJRenMwUWtGRk5VUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owTkJRM0JDTEU5QlFVOHNSMEZCUnl4TFFVRkxMRU5CUVVNN05FSkJRM0JDTEVOQlFVTTdkMEpCUTB3c1EwRkJRenR2UWtGRFRDeERRVUZETzJkQ1FVTk1MRU5CUVVNN1dVRkRUQ3hEUVVGRE8xRkJRMHdzUTBGQlF6dFJRVVZFTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNN1NVRkRia0lzUTBGQlF6dEpRVVZFT3pzN096czdUMEZOUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhyUWtGQmEwSXNRMEZCUXl4WlFVRnZRaXhGUVVGRkxGbEJRWEZDTzFGQlEzaEZMRWxCUVVrc1QwRkJUeXhIUVVGSExFdEJRVXNzUTBGQlF6dFJRVU53UWl4RlFVRkZMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4WlFVRlpMRVZCUVVVc1pVRkJUU3hEUVVGRE8xbEJRM3BETEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExGbEJRVmtzUTBGQlF5eFpRVUZaTEVWQlFVVXNlVUpCUVZjc1EwRkJRenRaUVVNelJDd3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFVkJRVVVzYVVKQlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNM1F5eEpRVUZKTEZWQlFWVXNRMEZCUXp0WlFVTm1MRTFCUVUwc2EwSkJRV3RDTEVkQlFVY3NSVUZCUlN4RFFVRkRPMWxCUXpsQ0xFMUJRVTBzYTBKQlFXdENMRWRCUVVjc1dVRkJXU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMWxCUlRsRUxFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzV1VGQldTeERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF6dG5Ra0ZEZUVRc1JVRkJSU3hEUVVGRExFTkJRVU1zV1VGQldTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZMRXRCUVVzc2EwSkJRV3RDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVOd1JpeFZRVUZWTEVkQlFVY3NXVUZCV1N4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTTdiMEpCUldwRUxHbERRVUZwUXp0dlFrRkRha01zUlVGQlJTeERRVUZETEVOQlFVTXNXVUZCV1N4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eDNRa0ZCZDBJc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVTdkMEpCUXpORkxHMUVRVUYzUWl4RFFVRkRMRXRCUVVzc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN2QwSkJRM1pFTEV0QlFVc3NRMEZCUXp0dlFrRkRWaXhEUVVGRE8yOUNRVVZFTEd0Q1FVRnJRaXhEUVVGRExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExIZENRVUYzUWl4RFFVRkRMRU5CUVVNN1owSkJRMjVHTEVOQlFVTTdXVUZEVEN4RFFVRkRPMWxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRZaXhQUVVGUExFZEJRVWNzVTBGQlJ5eERRVUZETEd0Q1FVRnJRaXhEUVVGRExGbEJRVmtzUlVGQlJTeHJRa0ZCYTBJc1JVRkJSU3hWUVVGVkxFTkJRVU1zUTBGQlF6dFpRVU51Uml4RFFVRkRPMUZCUTB3c1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTTdTVUZEYmtJc1EwRkJRenRKUVVWTkxFMUJRVTBzUTBGQlF5eGhRVUZoTEVOQlFVTXNWMEZCZVVJc1JVRkJSU3hUUVVGeFFqdFJRVVY0UlN4TlFVRk5MRTFCUVUwc1IwRkJSeXhKUVVGSkxHVkJRVTBzUlVGQlJTeERRVUZETzFGQlF6VkNMRWxCUVVrc1QwRkJXU3hEUVVGRE8xRkJSV3BDTEVsQlFVa3NWVUZCVlN4SFFVRlhMRU5CUVVNc1EwRkJRenRSUVVNelFpeE5RVUZOTEhsQ1FVRjVRaXhIUVVFclFpeEZRVUZGTEVOQlFVTTdVVUZGYWtVc09FTkJRVGhETzFGQlF6bERMRFpEUVVFMlF6dFJRVU0zUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRk5CUVZNc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXp0WlFVTjRReXhKUVVGSkxITkNRVUZ6UWl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVVdlFpdzBSa0ZCTkVZN1dVRkROVVlzVFVGQlRTeGhRVUZoTEVkQlFVY3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXp0WlFVTjBSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eGhRVUZoTEVOQlFVTXNUVUZCVFN4SFFVRkhMRzFFUVVGM1FpeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM3BFTEhORVFVRnpSRHRuUWtGRGRFUXNjMEpCUVhOQ0xFbEJRVWtzU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4aFFVRmhMRU5CUVVNc1RVRkJUU3hIUVVGSExHMUVRVUYzUWl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8yZENRVVUzUml4SlFVRkpMRTlCUVU4c1IwRkJSeXhoUVVGaExFTkJRVU03WjBKQlJUVkNMREJEUVVFd1F6dG5Ra0ZETVVNc1QwRkJUeXhQUVVGUExFVkJRVVVzUTBGQlF6dHZRa0ZEWWl4SlFVRkpMRkZCUVZFc1IwRkJSeXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNSVUZCUlN4dFJFRkJkMElzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0dlFrRkRha1VzVDBGQlR5eEhRVUZITEU5QlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNc2JVUkJRWGRDTEVOQlFVTXNUVUZCVFN4RlFVRkZMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dHZRa0ZGZWtVc05FSkJRVFJDTzI5Q1FVTTFRaXhIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1VVRkJVU3hEUVVGRExFMUJRVTBzUjBGQlJ5eHRSRUZCZDBJc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXp0M1FrRkRja1VzVVVGQlVTeEpRVUZKTEVkQlFVY3NRMEZCUXp0dlFrRkRjRUlzUTBGQlF6dHZRa0ZGUkN4NVFrRkJlVUlzUTBGQlF5eEpRVUZKTEVOQlFVTXNiVVJCUVhkQ0xFTkJRVU1zVlVGQlZTeERRVUZETEdWQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTnlSeXhEUVVGRE8xbEJRMHdzUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOS0xHOUVRVUZ2UkR0blFrRkRjRVFzU1VGQlNTeFJRVUZSTEVkQlFVY3NSVUZCUlN4RFFVRkRPMmRDUVVWc1FpeEZRVUZGTEVOQlFVTXNRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU5vUWl4UlFVRlJMRWRCUVVjc1lVRkJZU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVWQlFVVXNiVVJCUVhkQ0xFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdaMEpCUTNaRkxFTkJRVU03WjBKQlJVUXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEZGQlFWRXNRMEZCUXl4TlFVRk5MRWRCUVVjc2JVUkJRWGRDTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU03YjBKQlEzSkZMRkZCUVZFc1NVRkJTU3hIUVVGSExFTkJRVU03WjBKQlEzQkNMRU5CUVVNN1owSkJSVVFzZVVKQlFYbENMRU5CUVVNc1NVRkJTU3hEUVVGRExHMUVRVUYzUWl4RFFVRkRMRlZCUVZVc1EwRkJReXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOeVJ5eERRVUZETzFsQlJVUXNiVU5CUVcxRE8xbEJRMjVETEUxQlFVMHNVMEZCVXl4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVjBGQlZ5eERRVUZETEZsQlFWa3NSVUZCUlN4SFFVRkhMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJSV2hGTEU5QlFVOHNSMEZCUnl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETzFsQlJUTkNMR3REUVVGclF6dFpRVU5zUXl4TlFVRk5MRU5CUVVNc1pVRkJaU3hEUVVGRExITkNRVUZ6UWl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzFsQlJYUklMSEZDUVVGeFFqdFpRVU55UWl4VlFVRlZMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXp0UlFVTnlReXhEUVVGRE8xRkJSVVFzVFVGQlRTeERRVUZETEVWQlFVVXNUVUZCVFN4RlFVRkZMRlZCUVZVc1JVRkJSU3hQUVVGUExFVkJRVVVzZVVKQlFYbENMRVZCUVVVc1EwRkJRenRKUVVOMFJTeERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlNMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlZTeEZRVU5XTEUxQlFXTXNSVUZEWkN4bFFVRm5ReXhGUVVOb1F5eDVRa0ZCY1VRc1JVRkRja1FzVFVGQlpTeEZRVU5tTEZOQlFXdENPMUZCUTNaRExGbEJRVmtzUTBGQlF5eGpRVUZqTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRjRU1zVFVGQlRTeERRVUZETERSQ1FVRTBRaXhEUVVGRExIbENRVUY1UWl4RFFVRkRMRU5CUVVNN1VVRkZMMFFzSzBOQlFTdERPMUZCUXk5RExIbEVRVUY1UkR0UlFVTjZSQ3huUmtGQlowWTdVVUZEYUVZc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRE8xbEJRMnhFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUXpsRExFMUJRVTBzWVVGQllTeEhRVUZITEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8yZENRVVV6UlN3MlJFRkJOa1E3WjBKQlF6ZEVMRWxCUVVrc1VVRkJVU3hEUVVGRE8yZENRVU5pTEVsQlFVa3NWMEZCVnl4RFFVRkRPMmRDUVVOb1FpeEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEUxQlFVMHNRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF6dHZRa0ZGY2tNc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNTMEZCU3l4aFFVRmhMRU5CUVVNc1EwRkJReXhEUVVGRE8zZENRVVUxUkN4UlFVRlJMRWRCUVVjc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXp0M1FrRkRPVUlzVjBGQlZ5eEhRVUZITEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEdWQlFXVXNRMEZCUXl4UlFVRlJMRU5CUVVNN2QwSkJRMnBHTEV0QlFVc3NRMEZCUXp0dlFrRkRWaXhEUVVGRE8yZENRVU5NTEVOQlFVTTdaMEpCUlVRc01rTkJRVEpETzJkQ1FVTXpReXhOUVVGTkxFZEJRVWNzUjBGQlJ5eFRRVUZITEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1JVRkJSU3hSUVVGUkxFVkJRVVVzVjBGQlZ5eERRVUZETEVOQlFVTTdaMEpCUldwRUxGbEJRVmtzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4SFFVRkhMRVZCUVVVc1lVRkJZU3hGUVVGRkxGZEJRVmNzUTBGQlF5eERRVUZETzFsQlEycEdMRU5CUVVNN1VVRkRUQ3hEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOYUxFMUJRVTBzU1VGQlNTeEhRVUZITEVsQlFVa3NiVUpCUVZFc1EwRkJReXhsUVVGbExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdXVUZEYmtRc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTjZRaXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVVZFTEdWQlFXVTdTVUZEVWl4TlFVRk5MRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNUVUZCWXl4RlFVRkZMRXRCUVdFc1JVRkJSU3hyUWtGQk1FSXNSVUZCUlN4UlFVRnRRaXhGUVVGRkxHRkJRWEZDTEVWQlFVVXNVVUZCZVVJN1VVRkRNMG9zVFVGQlRTeFZRVUZWTEVkQlFVY3NUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTTdVVUZGY2tRc2EwTkJRV3RETzFGQlEyeERMRTFCUVUwc2IwSkJRVzlDTEVkQlFVY3NVMEZCUnl4RFFVRkRMR2RDUVVGblFpeERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRPMUZCUXpsRUxFMUJRVTBzZVVKQlFYbENMRWRCUVdkQ0xFVkJRVVVzUTBGQlF6dFJRVVZzUkN3NFFrRkJPRUk3VVVGRE9VSXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF6dFpRVU42UWl4NVFrRkJlVUlzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4dlFrRkJiMElzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4SFFVRkhMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4RlFVRkZMRU5CUVVNc1EwRkJRenRSUVVOd1JpeERRVUZETzFGQlJVUXNNRU5CUVRCRE8xRkJRekZETEUxQlFVMHNZVUZCWVN4SFFVRkhMRkZCUVZFc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUlRsRExHdEVRVUZyUkR0UlFVTnNSQ3hOUVVGTkxHMUNRVUZ0UWl4SFFVRkhMSGxDUVVGNVFpeERRVUZETEd0Q1FVRnJRaXhEUVVGRExFTkJRVU03VVVGRk1VVXNOa1ZCUVRaRk8xRkJRemRGTEUxQlFVMHNiVUpCUVcxQ0xFZEJRVWNzV1VGQldTeERRVUZETEhkQ1FVRjNRaXhEUVVGRExHMUNRVUZ0UWl4RlFVRkZMR0ZCUVdFc1EwRkJReXhEUVVGRE8xRkJSWFJITERKRlFVRXlSVHRSUVVNelJTeE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExIZENRVUYzUWl4SFFVRkhMRzFFUVVGM1FpeERRVUZETEZWQlFWVXNRMEZCUXl4aFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExHMUNRVUZ0UWl4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVVV6U1N4blJFRkJaMFE3VVVGRGFFUXNkVVJCUVhWRU8xRkJRM1pFTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NVVUZCVVN4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU03V1VGRmFFTXNjMFJCUVhORU8xbEJRM1JFTEhsRlFVRjVSVHRaUVVONlJTeHhSVUZCY1VVN1dVRkRja1VzUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhMUVVGTExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeExRVUZMTEdGQlFXRTdiVUpCUTNSRkxFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTXNTMEZCU3l4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eFJRVUZSTEVWQlFVVXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVVZvUlN3d1FrRkJNRUk3WjBKQlF6RkNMRTFCUVUwc1dVRkJXU3hIUVVGSExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRk9VUXNUVUZCVFN4clFrRkJhMElzUjBGQlJ5eDVRa0ZCZVVJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZGZUVRc0swSkJRU3RDTzJkQ1FVTXZRaXhOUVVGTkxHdENRVUZyUWl4SFFVRkhMRmxCUVZrc1EwRkJReXgzUWtGQmQwSXNRMEZCUXl4clFrRkJhMElzUlVGQlJTeFpRVUZaTEVOQlFVTXNRMEZCUXp0blFrRkZia2NzZDBWQlFYZEZPMmRDUVVONFJTeE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRXRCUVVzc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eDNRa0ZCZDBJc1IwRkJSeXh0UkVGQmQwSXNRMEZCUXl4VlFVRlZMRU5CUVVNc1lVRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eHJRa0ZCYTBJc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEYkVvc1EwRkJRenRSUVVOTUxFTkJRVU03U1VGRFRDeERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlNMRTFCUVUwc1EwRkJReXhqUVVGakxFTkJRVU1zVFVGQll6dFJRVU4yUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnBETEVsQlFVa3NWMEZCVnl4SFFVRkhMRXRCUVVzc1EwRkJRenRaUVVWNFFpeFBRVUZQTEVOQlFVTXNWMEZCVnl4RlFVRkZMRU5CUVVNN1owSkJSV3hDTEUxQlFVMHNTVUZCU1N4SFFVRkhMRFpDUVVGaExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8yZENRVU55UkN4SlFVRkpMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFTkJRVU03WjBKQlJXeENMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJRenR2UWtGRGJFUXNUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFpRVUZaTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTJoRkxFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVeXhIUVVGSExIbENRVUZYTEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVVeFJpeE5RVUZOTEdGQlFXRXNSMEZCUnl4aFFVRkxMRU5CUVVNc1ZVRkJWU3hEUVVGRExHVkJRVTBzUTBGQlF5eFZRVUZWTEVOQlEzQkVMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJUc3dRa0ZEYkVRc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhYUVVGWE96QkNRVU0xUlN4TlFVRk5MRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZkQlFWY3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3TUVKQlEzaEVMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJUc3dRa0ZEZEVRc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4WlFVRlpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGT3pCQ1FVTjZSQ3hOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRk5CUVZNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZETTBRc1EwRkJReXhEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETzI5Q1FVTmlMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zWVVGQllTeEZRVUZGTEVOQlFVTXNSVUZCUlN4aFFVRmhMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEzaEVMRU5CUVVNN1owSkJSVVFzVFVGQlRTeFRRVUZUTEVkQlFVY3NTVUZCU1N4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOcVJTeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRk5CUVZNc1JVRkJSU3hEUVVGRExFVkJRVVVzVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMmRDUVVVM1F5eE5RVUZOTEVsQlFVa3NSMEZCUnl4WFFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExHRkJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zUTBGQlF6dG5Ra0ZEY0VVc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRE8yOUNRVU5zUkN4TlFVRk5MRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNN1owSkJRM3BETEVOQlFVTTdaMEpCUlVRc1RVRkJUU3hqUVVGakxFZEJRVWNzVTBGQlJ5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTnNSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eGpRVUZqTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVVVc1EwRkJReXhUUVVGVExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRemxETERSRVFVRTBSRHR2UWtGRE5VUXNUVUZCVFN4WlFVRlpMRWRCUVVjc1lVRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eGhRVUZMTEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNWMEZCVnl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFVkJRVVVzWVVGQlN5eERRVUZETEdWQlFXVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZETlVnc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4WFFVRlhMRWRCUVVjc1UwRkJSeXhEUVVGRExGVkJRVlVzUTBGQlF5eFpRVUZaTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1EwRkJRenRuUWtGRGFrWXNRMEZCUXp0blFrRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dHZRa0ZEU2l4WFFVRlhMRWRCUVVjc1NVRkJTU3hEUVVGRE8yZENRVU4yUWl4RFFVRkRPMWxCUTB3c1EwRkJRenRSUVVOTUxFTkJRVU03U1VGRFRDeERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlNMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zVjBGQmQwSTdVVUZEYkVRc1RVRkJUU3hKUVVGSkxFZEJRVWNzTmtKQlFXRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZEY2tRc1RVRkJUU3huUWtGQlowSXNSMEZCUnl4aFFVRkxMRU5CUVVNc1ZVRkJWU3hEUVVGRExGZEJRVmNzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRE8xRkJSVFZGTEVsQlFVa3NRMEZCUXl4VlFVRlZMRVZCUVVVc1EwRkJRenRSUVVOc1FpeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMR2RDUVVGblFpeEZRVUZGTEVOQlFVTXNSVUZCUlN4blFrRkJaMElzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVVXhSQ3hOUVVGTkxGTkJRVk1zUjBGQlJ5eEpRVUZKTEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExHRkJRV0VzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYWtVc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eFRRVUZUTEVWQlFVVXNRMEZCUXl4RlFVRkZMRk5CUVZNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVVUzUXl4TlFVRk5MRU5CUVVNc1YwRkJTU3hEUVVGRExGVkJRVlVzUTBGQlF5eGhRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZEYkVVc1EwRkJRenRKUVVWRUxHVkJRV1U3U1VGRFVpeE5RVUZOTEVOQlFVTXNkMEpCUVhkQ0xFTkJRVU1zZDBKQlFXMURMRVZCUVVVc1YwRkJjMEk3VVVGRE9VWXNUVUZCVFN4M1FrRkJkMElzUjBGQlJ5eFhRVUZYTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNN1VVRkRja1FzU1VGQlNTeEpRVUZsTEVOQlFVTTdVVUZGY0VJc1RVRkJUU3hKUVVGSkxFZEJRVWNzTmtKQlFXRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZEY2tRc1RVRkJUU3hWUVVGVkxFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenRSUVVWdVJDeEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRE8xbEJRekZDTEVsQlFVa3NSMEZCUnl4M1FrRkJkMElzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4SFFVRkhMRlZCUVZVc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4VlFVRlZMRU5CUVVNc1EwRkJRenRaUVVVMVJTeEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4M1FrRkJkMElzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRE8yZENRVU40UkN4SlFVRkpMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFTkJRVU03WjBKQlEyeENMRWxCUVVrc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF6dG5Ra0ZEWWl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN1owSkJRMnBETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0WlFVTjBReXhEUVVGRE8xbEJSVVFzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eFZRVUZWTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJRenRuUWtGRGJFTXNkMEpCUVhkQ0xFTkJRVU1zUTBGQlF5eEhRVUZITEZWQlFWVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETTBRc1EwRkJRenRSUVVOTUxFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNkMEpCUVhkQ0xFTkJRVU03U1VGRGNFTXNRMEZCUXpzN1FVRndXSE5DTEhORFFVRjVRaXhIUVVGWExFVkJRVVVzUTBGQlF6dEJRVVJzUlN4dlEwRnpXRU1pZlE9PVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvaGVscGVycy9idW5kbGVIZWxwZXIudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGZhY3RvcnlCYXNlXzEgPSByZXF1aXJlKFwiLi9mYWN0b3J5QmFzZVwiKTtcclxuLyoqXHJcbiAqIEZhY3RvcnkgdG8gZ2VuZXJhdGUgbmV0d29yayBjbGllbnRzLlxyXG4gKi9cclxuY2xhc3MgTmV0d29ya0NsaWVudEZhY3RvcnkgZXh0ZW5kcyBmYWN0b3J5QmFzZV8xLkZhY3RvcnlCYXNlIHtcclxuICAgIC8qKlxyXG4gICAgICogRG9uJ3QgYWxsb3cgbWFudWFsIGNvbnN0cnVjdGlvbiBvZiB0aGUgZmFjdG9yeS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGluc3RhbmNlIG9mIHRoZSBmYWN0b3J5LlxyXG4gICAgICogQHJldHVybnMgVGhlIGZhY3RvcnkgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnN0YW5jZSgpIHtcclxuICAgICAgICBpZiAoIU5ldHdvcmtDbGllbnRGYWN0b3J5Ll9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBOZXR3b3JrQ2xpZW50RmFjdG9yeS5faW5zdGFuY2UgPSBuZXcgTmV0d29ya0NsaWVudEZhY3RvcnkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE5ldHdvcmtDbGllbnRGYWN0b3J5Ll9pbnN0YW5jZTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgZ2V0SW5zdGFuY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIE5ldHdvcmtDbGllbnRGYWN0b3J5Lmluc3RhbmNlKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5OZXR3b3JrQ2xpZW50RmFjdG9yeSA9IE5ldHdvcmtDbGllbnRGYWN0b3J5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2libVYwZDI5eWEwTnNhV1Z1ZEVaaFkzUnZjbmt1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZabUZqZEc5eWFXVnpMMjVsZEhkdmNtdERiR2xsYm5SR1lXTjBiM0o1TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkRRU3dyUTBGQk5FTTdRVUZGTlVNN08wZEJSVWM3UVVGRFNDd3dRa0ZCYTBNc1UwRkJVU3g1UWtGQk1rSTdTVUZKYWtVN096dFBRVWRITzBsQlEwZzdVVUZEU1N4TFFVRkxMRVZCUVVVc1EwRkJRenRKUVVOYUxFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVVVGQlVUdFJRVU5zUWl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExHOUNRVUZ2UWl4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJFTXNiMEpCUVc5Q0xFTkJRVU1zVTBGQlV5eEhRVUZITEVsQlFVa3NiMEpCUVc5Q0xFVkJRVVVzUTBGQlF6dFJRVU5vUlN4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExHOUNRVUZ2UWl4RFFVRkRMRk5CUVZNc1EwRkJRenRKUVVNeFF5eERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTk1MRmRCUVZjN1VVRkRha0lzVFVGQlRTeERRVUZETEc5Q1FVRnZRaXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzBsQlF6TkRMRU5CUVVNN1EwRkRTanRCUVROQ1JDeHZSRUV5UWtNaWZRPT1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL2ZhY3Rvcmllcy9uZXR3b3JrQ2xpZW50RmFjdG9yeS50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY29yZUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvY29yZUVycm9yXCIpO1xyXG5jb25zdCBqc29uSGVscGVyXzEgPSByZXF1aXJlKFwiLi9qc29uSGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCIuL29iamVjdEhlbHBlclwiKTtcclxuY29uc3Qgc3RyaW5nSGVscGVyXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdIZWxwZXJcIik7XHJcbi8qKlxyXG4gKiBIYW5kbGUgZXJyb3JzIGFzIGdyYWNlZnVsbHkgYXMgcG9zc2libGUuXHJcbiAqL1xyXG5jbGFzcyBFcnJvckhlbHBlciB7XHJcbiAgICAvKipcclxuICAgICAqIEZvcm1hdCBhbiBlcnJvciBvYmplY3QgaW50byBzb21ldGhpbmcgcmVhZGFibGUuXHJcbiAgICAgKiBAcGFyYW0gZXJyIFRoZSBvYmplY3QgdG8gZm9ybWF0LlxyXG4gICAgICogQHBhcmFtIGluY2x1ZGVTdGFjayBJbmNsdWRlIHRoZSBzdGFjayB0cmFjZSBpZiB0aGVyZSBpcyBvbmUuXHJcbiAgICAgKiBAcmV0dXJucyBGb3JtYXR0ZWQgdmVyc2lvbiBvZiB0aGUgZXJyb3Igb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZm9ybWF0KGVyciwgaW5jbHVkZVN0YWNrKSB7XHJcbiAgICAgICAgaWYgKGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJ1bmtub3duIGVycm9yXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvcmVFcnJvcl8xLkNvcmVFcnJvci5pc0Vycm9yKGVycikpIHtcclxuICAgICAgICAgICAgbGV0IHJldCA9IGVyci5mb3JtYXQoKTtcclxuICAgICAgICAgICAgaWYgKGluY2x1ZGVTdGFjayAmJiBlcnIuc3RhY2spIHtcclxuICAgICAgICAgICAgICAgIHJldCArPSBgXFxuU3RhY2sgVHJhY2VgO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBlcnIuc3RhY2suc3BsaXQoXCJcXG5cIik7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0ICs9IGBcXG4ke3BhcnRzLmpvaW4oXCJcXG5cIil9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KGVyci5pbm5lckVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVTdGFjayAmJiAhb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkoZXJyLmlubmVyRXJyb3Iuc3RhY2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGBcXG5cXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLWA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGBcXG5Jbm5lciBTdGFjayBUcmFjZVxcbmA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGVyci5pbm5lckVycm9yLnN0YWNrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGBcXG5Jbm5lciBFcnJvcjogJHtlcnIuaW5uZXJFcnJvci5tZXNzYWdlfVxcbmA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgbGV0IHJldCA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlmIChpbmNsdWRlU3RhY2sgJiYgIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KGVyci5zdGFjaykpIHtcclxuICAgICAgICAgICAgICAgIHJldCArPSBlcnIuc3RhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXQgKz0gZXJyLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNTdHJpbmcoZXJyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uSGVscGVyXzEuSnNvbkhlbHBlci5zdHJpbmdpZnkoZXJyLCB1bmRlZmluZWQsIFwiXFx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRXJyb3JIZWxwZXIgPSBFcnJvckhlbHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWlhKeWIzSklaV3h3WlhJdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12YUdWc2NHVnljeTlsY25KdmNraGxiSEJsY2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzYTBSQlFTdERPMEZCUXk5RExEWkRRVUV3UXp0QlFVTXhReXhwUkVGQk9FTTdRVUZET1VNc2FVUkJRVGhETzBGQlJUbERPenRIUVVWSE8wRkJRMGc3U1VGRFNUczdPenM3VDBGTFJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJVU3hGUVVGRkxGbEJRWEZDTzFGQlEyaEVMRVZCUVVVc1EwRkJReXhEUVVGRExFZEJRVWNzUzBGQlN5eEpRVUZKTEVsQlFVa3NSMEZCUnl4TFFVRkxMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFTXNUVUZCVFN4RFFVRkRMR1ZCUVdVc1EwRkJRenRSUVVNelFpeERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExIRkNRVUZUTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5vUXl4SlFVRkpMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTTdXVUZEZGtJc1JVRkJSU3hEUVVGRExFTkJRVU1zV1VGQldTeEpRVUZKTEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU0xUWl4SFFVRkhMRWxCUVVrc1pVRkJaU3hEUVVGRE8yZENRVU4yUWl4TlFVRk5MRXRCUVVzc1IwRkJSeXhIUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRGNFTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRE8yZENRVU5rTEVkQlFVY3NTVUZCU1N4TFFVRkxMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXp0WlFVTnVReXhEUVVGRE8xbEJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU40UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhaUVVGWkxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXhIUVVGSExFTkJRVU1zVlVGQlZTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRE9VUXNSMEZCUnl4SlFVRkpMSEZFUVVGeFJDeERRVUZETzI5Q1FVTTNSQ3hIUVVGSExFbEJRVWtzZFVKQlFYVkNMRU5CUVVNN2IwSkJReTlDTEVkQlFVY3NTVUZCU1N4SFFVRkhMRU5CUVVNc1ZVRkJWU3hEUVVGRExFdEJRVXNzUTBGQlF6dG5Ra0ZEYUVNc1EwRkJRenRuUWtGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0dlFrRkRTaXhIUVVGSExFbEJRVWtzYTBKQlFXdENMRWRCUVVjc1EwRkJReXhWUVVGVkxFTkJRVU1zVDBGQlR5eEpRVUZKTEVOQlFVTTdaMEpCUTNoRUxFTkJRVU03V1VGRFRDeERRVUZETzFsQlJVUXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJRenRSUVVObUxFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSeXhaUVVGWkxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZET1VJc1NVRkJTU3hIUVVGSExFZEJRVWNzUlVGQlJTeERRVUZETzFsQlEySXNSVUZCUlN4RFFVRkRMRU5CUVVNc1dVRkJXU3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRia1FzUjBGQlJ5eEpRVUZKTEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNN1dVRkRja0lzUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOS0xFZEJRVWNzU1VGQlNTeEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRPMWxCUTNaQ0xFTkJRVU03V1VGRFJDeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRPMUZCUTJZc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEwb3NSVUZCUlN4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU0zUWl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRE8xbEJRMllzUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOS0xFMUJRVTBzUTBGQlF5eDFRa0ZCVlN4RFFVRkRMRk5CUVZNc1EwRkJReXhIUVVGSExFVkJRVVVzVTBGQlV5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTNSRUxFTkJRVU03VVVGRFRDeERRVUZETzBsQlEwd3NRMEZCUXp0RFFVTktPMEZCT1VORUxHdERRVGhEUXlKOVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvaGVscGVycy9lcnJvckhlbHBlci50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYmFja2dyb3VuZCB0YXNrIHNlcnZpY2UuXHJcbiAqL1xyXG5jbGFzcyBCYWNrZ3JvdW5kVGFza1NlcnZpY2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBiYWNrZ3JvdW5kIHRhc2suXHJcbiAgICAgKiBAcGFyYW0gdGFzayBUaGUgdGFzayB0byBydW4gaW4gdGhlIGJhY2tncm91bmQuXHJcbiAgICAgKiBAcGFyYW0gZGVsYXkgVGhlIGRlbGF5IGJlZm9yZSBydW5uaW5nIHRoZSB0YXNrLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBjcmVhdGUodGFzaywgZGVsYXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0YXNrKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBkZWxheSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5CYWNrZ3JvdW5kVGFza1NlcnZpY2UgPSBCYWNrZ3JvdW5kVGFza1NlcnZpY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVltRmphMmR5YjNWdVpGUmhjMnRUWlhKMmFXTmxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwzTmxjblpwWTJWekwySmhZMnRuY205MWJtUlVZWE5yVTJWeWRtbGpaUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlJVRTdPMGRCUlVjN1FVRkRTRHRKUVVOSk96czdPMDlCU1VjN1NVRkRTU3hMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZKTEVsQlFYTkNMRVZCUVVVc1MwRkJZVHRSUVVONFJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4UFFVRlBMRU5CUVVrc1EwRkJReXhQUVVGUExFVkJRVVVzVFVGQlRTeEZRVUZGTEVWQlFVVTdXVUZEZEVNc1ZVRkJWU3hEUVVGRExFZEJRVWNzUlVGQlJUdG5Ra0ZEUVN4SlFVRkpMRU5CUVVNN2IwSkJRMFFzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNN1owSkJRM0JDTEVOQlFVTTdaMEpCUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkRXQ3hOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdaMEpCUTJoQ0xFTkJRVU03V1VGRFRDeERRVUZETEVWQlEwWXNTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkRkRUlzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEVUN4RFFVRkRPME5CUTBvN1FVRnNRa1FzYzBSQmEwSkRJbjA9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9zZXJ2aWNlcy9iYWNrZ3JvdW5kVGFza1NlcnZpY2UudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBzdHJpbmdIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL3N0cmluZ0hlbHBlclwiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiLi4vZGF0YS90cnl0ZXNcIik7XHJcbmNvbnN0IGRhdGFFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2RhdGFFcnJvclwiKTtcclxuLyoqXHJcbiAqIFRyeXRlcyBjb252ZXJ0ZXIgdGhhdCBjb252ZXJ0cyB0byBhbmQgZnJvbSBhIHN0cmluZy5cclxuICovXHJcbmNsYXNzIEFzY2lpVHJ5dGVzQ29udmVydGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBhIHN0cmluZyB2YWx1ZSBpbnRvIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBzdHJpbmcgdmFsdWUgdG8gY29udmVydCBpbnRvIHRyeXRlcy5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICB0byh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghc3RyaW5nSGVscGVyXzEuU3RyaW5nSGVscGVyLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIG11c3Qgbm90IGJlIHN0cmluZ1wiLCB7IHZhbHVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0FzY2lpKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIGNvbnRhaW5zIG5vbiBBU0NJSSBjaGFyYWN0ZXJzXCIsIHsgdmFsdWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0cnl0ZXMgPSBcIlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYXNjaWlWYWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBhc2NpaVZhbHVlICUgMjc7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZFZhbHVlID0gKGFzY2lpVmFsdWUgLSBmaXJzdFZhbHVlKSAvIDI3O1xyXG4gICAgICAgICAgICB0cnl0ZXMgKz0gdHJ5dGVzXzEuVHJ5dGVzLkFMUEhBQkVUW2ZpcnN0VmFsdWVdICsgdHJ5dGVzXzEuVHJ5dGVzLkFMUEhBQkVUW3NlY29uZFZhbHVlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRyeXRlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdHJ5dGVzIGludG8gYSBzdHJpbmcgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gdHJ5dGVzIHRvIGNvbnZlcnQgaW50byBhIHN0cmluZyB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgdmFsdWUgY29udmVydGVkIGZyb20gdGhlIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgZnJvbSh0cnl0ZXMpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJ5dGVzLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdHJ5dGVzIHBhcmFtZXRlciBpcyBlbXB0eSBvciBub3QgdGhlIGNvcnJlY3QgdHlwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJ5dGVzU3RyaW5nID0gdHJ5dGVzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHRyeXRlc1N0cmluZy5sZW5ndGggJSAyID09PSAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdHJ5dGVzIGxlbmd0aCBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYXNjaWkgPSBcIlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJ5dGVzU3RyaW5nLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyeXRlc1BhaXIgPSB0cnl0ZXNTdHJpbmdbaV0gKyB0cnl0ZXNTdHJpbmdbaSArIDFdO1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gdHJ5dGVzXzEuVHJ5dGVzLkFMUEhBQkVULmluZGV4T2YodHJ5dGVzUGFpclswXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZFZhbHVlID0gdHJ5dGVzXzEuVHJ5dGVzLkFMUEhBQkVULmluZGV4T2YodHJ5dGVzUGFpclsxXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxWYWx1ZSA9IGZpcnN0VmFsdWUgKyBzZWNvbmRWYWx1ZSAqIDI3O1xyXG4gICAgICAgICAgICBhc2NpaSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlY2ltYWxWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhc2NpaTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkFzY2lpVHJ5dGVzQ29udmVydGVyID0gQXNjaWlUcnl0ZXNDb252ZXJ0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVlYTmphV2xVY25sMFpYTkRiMjUyWlhKMFpYSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdlkyOXVkbVZ5ZEdWeWN5OWhjMk5wYVZSeWVYUmxjME52Ym5abGNuUmxjaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNORVZCUVhsRk8wRkJRM3BGTERSRlFVRjVSVHRCUVVONlJTd3lRMEZCZDBNN1FVRkRlRU1zYTBSQlFTdERPMEZCUnk5RE96dEhRVVZITzBGQlEwZzdTVUZEU1RzN096dFBRVWxITzBsQlEwa3NSVUZCUlN4RFFVRkRMRXRCUVdFN1VVRkRia0lzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRhRU1zVFVGQlRTeEpRVUZKTEhGQ1FVRlRMRU5CUVVNc09FSkJRVGhDTEVWQlFVVXNSVUZCUlN4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRMjVGTEVOQlFVTTdVVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU12UWl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eDVRMEZCZVVNc1JVRkJSU3hGUVVGRkxFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdVVUZET1VVc1EwRkJRenRSUVVWRUxFbEJRVWtzVFVGQlRTeEhRVUZITEVWQlFVVXNRMEZCUXp0UlFVVm9RaXhIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJRenRaUVVOd1F5eE5RVUZOTEZWQlFWVXNSMEZCUnl4TFFVRkxMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlJYWkRMRTFCUVUwc1ZVRkJWU3hIUVVGSExGVkJRVlVzUjBGQlJ5eEZRVUZGTEVOQlFVTTdXVUZEYmtNc1RVRkJUU3hYUVVGWExFZEJRVWNzUTBGQlF5eFZRVUZWTEVkQlFVY3NWVUZCVlN4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRE8xbEJSVzVFTEUxQlFVMHNTVUZCU1N4bFFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExGVkJRVlVzUTBGQlF5eEhRVUZITEdWQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU03VVVGRGVrVXNRMEZCUXp0UlFVVkVMRTFCUVUwc1EwRkJReXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMGxCUTNKRExFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGtzU1VGQlNTeERRVUZETEUxQlFXTTdVVUZEZEVJc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFVkJRVVVzWlVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNaRExFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMSFZFUVVGMVJDeERRVUZETEVOQlFVTTdVVUZEYWtZc1EwRkJRenRSUVVORUxFMUJRVTBzV1VGQldTeEhRVUZITEUxQlFVMHNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRSUVVWMlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4WlFVRlpMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJoRExFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMREJEUVVFd1F5eERRVUZETEVOQlFVTTdVVUZEY0VVc1EwRkJRenRSUVVWRUxFbEJRVWtzUzBGQlN5eEhRVUZITEVWQlFVVXNRMEZCUXp0UlFVVm1MRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1dVRkJXU3hEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNN1dVRkRPVU1zVFVGQlRTeFZRVUZWTEVkQlFVY3NXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExGbEJRVmtzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkZla1FzVFVGQlRTeFZRVUZWTEVkQlFVY3NaVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRNVVFzVFVGQlRTeFhRVUZYTEVkQlFVY3NaVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkZNMFFzVFVGQlRTeFpRVUZaTEVkQlFVY3NWVUZCVlN4SFFVRkhMRmRCUVZjc1IwRkJSeXhGUVVGRkxFTkJRVU03V1VGRmJrUXNTMEZCU3l4SlFVRkpMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTTdVVUZETDBNc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdTVUZEYWtJc1EwRkJRenREUVVOS08wRkJNMFJFTEc5RVFUSkVReUo5XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9jb252ZXJ0ZXJzL2FzY2lpVHJ5dGVzQ29udmVydGVyLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBudW1iZXJIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlclwiKTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IGRhdGFFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2RhdGFFcnJvclwiKTtcclxuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZShcIi4vYWRkcmVzc1wiKTtcclxuY29uc3QgYWRkcmVzc1NlY3VyaXR5XzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzU2VjdXJpdHlcIik7XHJcbi8qKlxyXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyBpbnB1dHMuXHJcbiAqL1xyXG5jbGFzcyBJbnB1dCB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgaW5wdXQgZnJvbSBwYXJhbWV0ZXJzLlxyXG4gICAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIGFkZHJlc3Mgc2VjdXJpdHkuXHJcbiAgICAgKiBAcGFyYW0ga2V5SW5kZXggVGhlIGtleSBpbmRleC5cclxuICAgICAqIEBwYXJhbSBiYWxhbmNlIFRoZSBiYWxhbmNlIG9mIHRoZSBhZGRyZXNzLlxyXG4gICAgICogQHJldHVybiBOZXcgaW5zdGFuY2Ugb2YgSW5wdXQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tUGFyYW1zKGFkZHJlc3MsIHNlY3VyaXR5LCBrZXlJbmRleCwgYmFsYW5jZSkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShhZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBhZGRyZXNzIHNob3VsZCBiZSBhIHZhbGlkIEFkZHJlc3Mgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc2VjdXJpdHkpIHx8IHNlY3VyaXR5IDwgYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5LmxvdyB8fCBzZWN1cml0eSA+IGFkZHJlc3NTZWN1cml0eV8xLkFkZHJlc3NTZWN1cml0eS5oaWdoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBzZWN1cml0eSBzaG91bGQgYmUgYSBudW1iZXIgYmV0d2VlbiAke2FkZHJlc3NTZWN1cml0eV8xLkFkZHJlc3NTZWN1cml0eS5sb3d9IGFuZCAke2FkZHJlc3NTZWN1cml0eV8xLkFkZHJlc3NTZWN1cml0eS5oaWdofWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoa2V5SW5kZXgpIHx8IGtleUluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIGtleUluZGV4IHNob3VsZCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoYmFsYW5jZSkgfHwgYmFsYW5jZSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBiYWxhbmNlIHNob3VsZCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnB1dCA9IG5ldyBJbnB1dCgpO1xyXG4gICAgICAgIGlucHV0LmFkZHJlc3MgPSBhZGRyZXNzO1xyXG4gICAgICAgIGlucHV0LnNlY3VyaXR5ID0gc2VjdXJpdHk7XHJcbiAgICAgICAgaW5wdXQua2V5SW5kZXggPSBrZXlJbmRleDtcclxuICAgICAgICBpbnB1dC5iYWxhbmNlID0gYmFsYW5jZTtcclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5JbnB1dCA9IElucHV0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzV3ZFhRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12WkdGMFlTOXBibkIxZEM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzTkVWQlFYbEZPMEZCUTNwRkxEUkZRVUY1UlR0QlFVTjZSU3hyUkVGQkswTTdRVUZETDBNc2RVTkJRVzlETzBGQlEzQkRMSFZFUVVGdlJEdEJRVVZ3UkRzN1IwRkZSenRCUVVOSU8wbEJhMEpKTEdWQlFXVTdTVUZEWmp0SlFVTkJMRU5CUVVNN1NVRkZSRHM3T3pzN096dFBRVTlITzBsQlEwa3NUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhQUVVGblFpeEZRVU5vUWl4UlFVRjVRaXhGUVVONlFpeFJRVUZuUWl4RlFVTm9RaXhQUVVGbE8xRkJRM0JETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RlFVRkZMR2xDUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZWtNc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNPRU5CUVRoRExFTkJRVU1zUTBGQlF6dFJRVU40UlN4RFFVRkRPMUZCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhSUVVGUkxFTkJRVU1zU1VGQlNTeFJRVUZSTEVkQlFVY3NhVU5CUVdVc1EwRkJReXhIUVVGSExFbEJRVWtzVVVGQlVTeEhRVUZITEdsRFFVRmxMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU42Unl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5d3lRMEZCTWtNc2FVTkJRV1VzUTBGQlF5eEhRVUZITEZGQlFWRXNhVU5CUVdVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETzFGQlEzUklMRU5CUVVNN1VVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1UwRkJVeXhEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEZGQlFWRXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JFTEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExITkRRVUZ6UXl4RFFVRkRMRU5CUVVNN1VVRkRhRVVzUTBGQlF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1QwRkJUeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYkVRc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNjVU5CUVhGRExFTkJRVU1zUTBGQlF6dFJRVU12UkN4RFFVRkRPMUZCUlVRc1RVRkJUU3hMUVVGTExFZEJRVWNzU1VGQlNTeExRVUZMTEVWQlFVVXNRMEZCUXp0UlFVTXhRaXhMUVVGTExFTkJRVU1zVDBGQlR5eEhRVUZITEU5QlFVOHNRMEZCUXp0UlFVTjRRaXhMUVVGTExFTkJRVU1zVVVGQlVTeEhRVUZITEZGQlFWRXNRMEZCUXp0UlFVTXhRaXhMUVVGTExFTkJRVU1zVVVGQlVTeEhRVUZITEZGQlFWRXNRMEZCUXp0UlFVTXhRaXhMUVVGTExFTkJRVU1zVDBGQlR5eEhRVUZITEU5QlFVOHNRMEZCUXp0UlFVTjRRaXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzBsQlEycENMRU5CUVVNN1EwRkRTanRCUVhwRVJDeHpRa0Y1UkVNaWZRPT1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL2RhdGEvaW5wdXQudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNvcmVFcnJvcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2Vycm9yL2NvcmVFcnJvclwiKTtcclxuLyoqXHJcbiAqIEFuIGFwaSBpbXBsZW1lbnRhdGlvbiBvZiBhbiBlcnJvci5cclxuICovXHJcbmNsYXNzIEFwaUVycm9yIGV4dGVuZHMgY29yZUVycm9yXzEuQ29yZUVycm9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEFwaUVycm9yLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgZm9yIHRoZSBlcnJvci5cclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsIEFkZGl0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gaW5uZXJFcnJvciBBZGQgaW5mb3JtYXRpb24gZnJvbSBpbm5lciBlcnJvciBpZiB0aGVyZSB3YXMgb25lLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBhZGRpdGlvbmFsLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgYWRkaXRpb25hbCwgaW5uZXJFcnJvcik7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSBcIkFQSVwiO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQXBpRXJyb3IgPSBBcGlFcnJvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWVhCcFJYSnliM0l1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZaWEp5YjNJdllYQnBSWEp5YjNJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTEc5RlFVRnBSVHRCUVVWcVJUczdSMEZGUnp0QlFVTklMR05CUVhOQ0xGTkJRVkVzY1VKQlFWTTdTVUZEYmtNN096czdPMDlCUzBjN1NVRkRTQ3haUVVGWkxFOUJRV1VzUlVGQlJTeFZRVUZyUXl4RlFVRkZMRlZCUVd0Q08xRkJReTlGTEV0QlFVc3NRMEZCUXl4UFFVRlBMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETzFGQlEzWkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETzBsQlEzaENMRU5CUVVNN1EwRkRTanRCUVZoRUxEUkNRVmRESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvZXJyb3IvYXBpRXJyb3IudHMiLCJmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQ29tYmluZWQgaW5kZXggb2YgYWxsIHRoZSBtb2R1bGVzLlxyXG4gKi9cclxuX19leHBvcnQocmVxdWlyZShcIi4vZXJyb3IvYnVzaW5lc3NFcnJvclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hlbHBlcnMvYWRkcmVzc0hlbHBlclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hlbHBlcnMvYnVuZGxlSGVscGVyXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vbXVsdGlTaWcvbXVsdGlTaWdBZGRyZXNzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vbXVsdGlTaWcvbXVsdGlTaWdDbGllbnRcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zaWduL2htYWNDdXJsXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNhY3Rpb25zL3RyYW5zYWN0aW9uQ2xpZW50XCIpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1a1pYZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOXpjbU12YVc1a1pYZ3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3T3p0QlFVRkJPenRIUVVWSE8wRkJRMGdzTWtOQlFYTkRPMEZCUTNSRExEWkRRVUYzUXp0QlFVTjRReXcwUTBGQmRVTTdRVUZGZGtNc1owUkJRVEpETzBGQlF6TkRMQ3REUVVFd1F6dEJRVU14UXl4eFEwRkJaME03UVVGRGFFTXNjMFJCUVdsRUluMD1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vc3JjL2luZGV4LnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgY3J5cHRvRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9jcnlwdG9FcnJvclwiKTtcclxuLyoqXHJcbiAqIFNoYTMgaW1wbGVtZW50YXRpb24uXHJcbiAqL1xyXG5jbGFzcyBTaGEzIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIFNIQTMuXHJcbiAgICAgKiBAcGFyYW0gYml0cyBUaGUgbnVtYmVyIG9mIGlucHV0IGJpdHMuXHJcbiAgICAgKiBAcGFyYW0gcGFkZGluZyBUaGUgcGFkZGluZyB0byB1c2UuXHJcbiAgICAgKiBAcGFyYW0gb3V0cHV0Qml0cyBUaGUgbnVtYmVyIG9mIG91dHB1dCBiaXRzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XHJcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XHJcbiAgICAgICAgdGhpcy5fb3V0cHV0Qml0cyA9IG91dHB1dEJpdHM7XHJcbiAgICAgICAgdGhpcy5fYmxvY2tDb3VudCA9ICgxNjAwIC0gKGJpdHMgPDwgMSkpID4+IDU7XHJcbiAgICAgICAgdGhpcy5fYnl0ZUNvdW50ID0gdGhpcy5fYmxvY2tDb3VudCA8PCAyO1xyXG4gICAgICAgIHRoaXMuX291dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTtcclxuICAgICAgICB0aGlzLl9leHRyYUJ5dGVzID0gKG91dHB1dEJpdHMgJiAzMSkgPj4gMztcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBkaWdlc3QuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9ibG9jayA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RhcnQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2Jsb2NrcyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLl9ibG9ja0NvdW50ICsgMSk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgVWludDMyQXJyYXkoNTApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGRpZ2VzdC5cclxuICAgICAqIEBwYXJhbSBpbnB1dCBBcnJheSBvZiBkYXRhIHRvIHVzZSBpbiB0aGUgdXBkYXRlLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoaW5wdXQpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoaW5wdXQsIEFycmF5QnVmZmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIklucHV0IGlzIG5vdCBvZiB0eXBlIEFycmF5QnVmZmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXNldCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2Nrc1swXSA9IHRoaXMuX2Jsb2NrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHRoaXMuX2Jsb2NrQ291bnQgKyAxOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja3NbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuX3N0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgdGhpcy5fYnl0ZUNvdW50OyArK2luZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTaGEzLlNISUZUW2krKyAmIDNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RCeXRlSW5kZXggPSBpO1xyXG4gICAgICAgICAgICBpZiAoaSA+PSB0aGlzLl9ieXRlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gaSAtIHRoaXMuX2J5dGVDb3VudDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrID0gdGhpcy5fYmxvY2tzW3RoaXMuX2Jsb2NrQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2Jsb2NrQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlW2ldIF49IHRoaXMuX2Jsb2Nrc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrUGVybXV0YXRpb24odGhpcy5fc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5hbGl6ZSBhbmQgcmV0dXJuIHRoZSBoYXNoIGZvciB0aGUgZGlnZXN0LCB3aWxsIGFsc28gcmVzZXQgdGhlIHN0YXRlLlxyXG4gICAgICogQHJldHVybiBBcnJheSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0LlxyXG4gICAgICovXHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBsZXQgaiA9IDA7XHJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLl9vdXRwdXRCaXRzID4+IDM7XHJcbiAgICAgICAgbGV0IGJ1ZmZlcjtcclxuICAgICAgICBpZiAodGhpcy5fZXh0cmFCeXRlcykge1xyXG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoKHRoaXMuX291dHB1dEJsb2NrcyArIDEpIDw8IDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcclxuICAgICAgICB3aGlsZSAoaiA8IHRoaXMuX291dHB1dEJsb2Nrcykge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYmxvY2tDb3VudCAmJiBqIDwgdGhpcy5fb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbal0gPSB0aGlzLl9zdGF0ZVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZXh0cmFCeXRlcykge1xyXG4gICAgICAgICAgICBhcnJheVtpXSA9IHRoaXMuX3N0YXRlW2ldO1xyXG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgYnl0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgZmluYWxpemUoKSB7XHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLl9sYXN0Qnl0ZUluZGV4O1xyXG4gICAgICAgIHRoaXMuX2Jsb2Nrc1tpID4+IDJdIHw9IHRoaXMuX3BhZGRpbmdbaSAmIDNdO1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXN0Qnl0ZUluZGV4ID09PSB0aGlzLl9ieXRlQ291bnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fYmxvY2tzWzBdID0gdGhpcy5fYmxvY2tzW3RoaXMuX2Jsb2NrQ291bnRdO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdGhpcy5fYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tzW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ibG9ja3NbdGhpcy5fYmxvY2tDb3VudCAtIDFdIHw9IDB4ODAwMDAwMDA7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2Jsb2NrQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVtpXSBePSB0aGlzLl9ibG9ja3NbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMua2VjY2FrUGVybXV0YXRpb24odGhpcy5fc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBrZWNjYWtQZXJtdXRhdGlvbihzKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9uZS12YXJpYWJsZS1wZXItZGVjbGFyYXRpb25cclxuICAgICAgICBsZXQgaCwgbCwgbiwgYzAsIGMxLCBjMiwgYzMsIGM0LCBjNSwgYzYsIGM3LCBjOCwgYzksIGIwLCBiMSwgYjIsIGIzLCBiNCwgYjUsIGI2LCBiNywgYjgsIGI5LCBiMTAsIGIxMSwgYjEyLCBiMTMsIGIxNCwgYjE1LCBiMTYsIGIxNywgYjE4LCBiMTksIGIyMCwgYjIxLCBiMjIsIGIyMywgYjI0LCBiMjUsIGIyNiwgYjI3LCBiMjgsIGIyOSwgYjMwLCBiMzEsIGIzMiwgYjMzLCBiMzQsIGIzNSwgYjM2LCBiMzcsIGIzOCwgYjM5LCBiNDAsIGI0MSwgYjQyLCBiNDMsIGI0NCwgYjQ1LCBiNDYsIGI0NywgYjQ4LCBiNDk7XHJcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IDQ4OyBuICs9IDIpIHtcclxuICAgICAgICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XHJcbiAgICAgICAgICAgIGMxID0gc1sxXSBeIHNbMTFdIF4gc1syMV0gXiBzWzMxXSBeIHNbNDFdO1xyXG4gICAgICAgICAgICBjMiA9IHNbMl0gXiBzWzEyXSBeIHNbMjJdIF4gc1szMl0gXiBzWzQyXTtcclxuICAgICAgICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XHJcbiAgICAgICAgICAgIGM0ID0gc1s0XSBeIHNbMTRdIF4gc1syNF0gXiBzWzM0XSBeIHNbNDRdO1xyXG4gICAgICAgICAgICBjNSA9IHNbNV0gXiBzWzE1XSBeIHNbMjVdIF4gc1szNV0gXiBzWzQ1XTtcclxuICAgICAgICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XHJcbiAgICAgICAgICAgIGM3ID0gc1s3XSBeIHNbMTddIF4gc1syN10gXiBzWzM3XSBeIHNbNDddO1xyXG4gICAgICAgICAgICBjOCA9IHNbOF0gXiBzWzE4XSBeIHNbMjhdIF4gc1szOF0gXiBzWzQ4XTtcclxuICAgICAgICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XHJcbiAgICAgICAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIGwgPSBjOSBeICgoYzMgPDwgMSkgfCAoYzIgPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIHNbMF0gXj0gaDtcclxuICAgICAgICAgICAgc1sxXSBePSBsO1xyXG4gICAgICAgICAgICBzWzEwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzExXSBePSBsO1xyXG4gICAgICAgICAgICBzWzIwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzIxXSBePSBsO1xyXG4gICAgICAgICAgICBzWzMwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzMxXSBePSBsO1xyXG4gICAgICAgICAgICBzWzQwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzQxXSBePSBsO1xyXG4gICAgICAgICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBsID0gYzEgXiAoKGM1IDw8IDEpIHwgKGM0ID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBzWzJdIF49IGg7XHJcbiAgICAgICAgICAgIHNbM10gXj0gbDtcclxuICAgICAgICAgICAgc1sxMl0gXj0gaDtcclxuICAgICAgICAgICAgc1sxM10gXj0gbDtcclxuICAgICAgICAgICAgc1syMl0gXj0gaDtcclxuICAgICAgICAgICAgc1syM10gXj0gbDtcclxuICAgICAgICAgICAgc1szMl0gXj0gaDtcclxuICAgICAgICAgICAgc1szM10gXj0gbDtcclxuICAgICAgICAgICAgc1s0Ml0gXj0gaDtcclxuICAgICAgICAgICAgc1s0M10gXj0gbDtcclxuICAgICAgICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcclxuICAgICAgICAgICAgbCA9IGMzIF4gKChjNyA8PCAxKSB8IChjNiA+Pj4gMzEpKTtcclxuICAgICAgICAgICAgc1s0XSBePSBoO1xyXG4gICAgICAgICAgICBzWzVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbMTRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbMTVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbMjRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbMjVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbMzRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbMzVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbNDRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbNDVdIF49IGw7XHJcbiAgICAgICAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIGwgPSBjNSBeICgoYzkgPDwgMSkgfCAoYzggPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIHNbNl0gXj0gaDtcclxuICAgICAgICAgICAgc1s3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzE2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzE3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzI2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzI3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzM2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzM3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzQ2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzQ3XSBePSBsO1xyXG4gICAgICAgICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBsID0gYzcgXiAoKGMxIDw8IDEpIHwgKGMwID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBzWzhdIF49IGg7XHJcbiAgICAgICAgICAgIHNbOV0gXj0gbDtcclxuICAgICAgICAgICAgc1sxOF0gXj0gaDtcclxuICAgICAgICAgICAgc1sxOV0gXj0gbDtcclxuICAgICAgICAgICAgc1syOF0gXj0gaDtcclxuICAgICAgICAgICAgc1syOV0gXj0gbDtcclxuICAgICAgICAgICAgc1szOF0gXj0gaDtcclxuICAgICAgICAgICAgc1szOV0gXj0gbDtcclxuICAgICAgICAgICAgc1s0OF0gXj0gaDtcclxuICAgICAgICAgICAgc1s0OV0gXj0gbDtcclxuICAgICAgICAgICAgYjAgPSBzWzBdO1xyXG4gICAgICAgICAgICBiMSA9IHNbMV07XHJcbiAgICAgICAgICAgIGIzMiA9IChzWzExXSA8PCA0KSB8IChzWzEwXSA+Pj4gMjgpO1xyXG4gICAgICAgICAgICBiMzMgPSAoc1sxMF0gPDwgNCkgfCAoc1sxMV0gPj4+IDI4KTtcclxuICAgICAgICAgICAgYjE0ID0gKHNbMjBdIDw8IDMpIHwgKHNbMjFdID4+PiAyOSk7XHJcbiAgICAgICAgICAgIGIxNSA9IChzWzIxXSA8PCAzKSB8IChzWzIwXSA+Pj4gMjkpO1xyXG4gICAgICAgICAgICBiNDYgPSAoc1szMV0gPDwgOSkgfCAoc1szMF0gPj4+IDIzKTtcclxuICAgICAgICAgICAgYjQ3ID0gKHNbMzBdIDw8IDkpIHwgKHNbMzFdID4+PiAyMyk7XHJcbiAgICAgICAgICAgIGIyOCA9IChzWzQwXSA8PCAxOCkgfCAoc1s0MV0gPj4+IDE0KTtcclxuICAgICAgICAgICAgYjI5ID0gKHNbNDFdIDw8IDE4KSB8IChzWzQwXSA+Pj4gMTQpO1xyXG4gICAgICAgICAgICBiMjAgPSAoc1syXSA8PCAxKSB8IChzWzNdID4+PiAzMSk7XHJcbiAgICAgICAgICAgIGIyMSA9IChzWzNdIDw8IDEpIHwgKHNbMl0gPj4+IDMxKTtcclxuICAgICAgICAgICAgYjIgPSAoc1sxM10gPDwgMTIpIHwgKHNbMTJdID4+PiAyMCk7XHJcbiAgICAgICAgICAgIGIzID0gKHNbMTJdIDw8IDEyKSB8IChzWzEzXSA+Pj4gMjApO1xyXG4gICAgICAgICAgICBiMzQgPSAoc1syMl0gPDwgMTApIHwgKHNbMjNdID4+PiAyMik7XHJcbiAgICAgICAgICAgIGIzNSA9IChzWzIzXSA8PCAxMCkgfCAoc1syMl0gPj4+IDIyKTtcclxuICAgICAgICAgICAgYjE2ID0gKHNbMzNdIDw8IDEzKSB8IChzWzMyXSA+Pj4gMTkpO1xyXG4gICAgICAgICAgICBiMTcgPSAoc1szMl0gPDwgMTMpIHwgKHNbMzNdID4+PiAxOSk7XHJcbiAgICAgICAgICAgIGI0OCA9IChzWzQyXSA8PCAyKSB8IChzWzQzXSA+Pj4gMzApO1xyXG4gICAgICAgICAgICBiNDkgPSAoc1s0M10gPDwgMikgfCAoc1s0Ml0gPj4+IDMwKTtcclxuICAgICAgICAgICAgYjQwID0gKHNbNV0gPDwgMzApIHwgKHNbNF0gPj4+IDIpO1xyXG4gICAgICAgICAgICBiNDEgPSAoc1s0XSA8PCAzMCkgfCAoc1s1XSA+Pj4gMik7XHJcbiAgICAgICAgICAgIGIyMiA9IChzWzE0XSA8PCA2KSB8IChzWzE1XSA+Pj4gMjYpO1xyXG4gICAgICAgICAgICBiMjMgPSAoc1sxNV0gPDwgNikgfCAoc1sxNF0gPj4+IDI2KTtcclxuICAgICAgICAgICAgYjQgPSAoc1syNV0gPDwgMTEpIHwgKHNbMjRdID4+PiAyMSk7XHJcbiAgICAgICAgICAgIGI1ID0gKHNbMjRdIDw8IDExKSB8IChzWzI1XSA+Pj4gMjEpO1xyXG4gICAgICAgICAgICBiMzYgPSAoc1szNF0gPDwgMTUpIHwgKHNbMzVdID4+PiAxNyk7XHJcbiAgICAgICAgICAgIGIzNyA9IChzWzM1XSA8PCAxNSkgfCAoc1szNF0gPj4+IDE3KTtcclxuICAgICAgICAgICAgYjE4ID0gKHNbNDVdIDw8IDI5KSB8IChzWzQ0XSA+Pj4gMyk7XHJcbiAgICAgICAgICAgIGIxOSA9IChzWzQ0XSA8PCAyOSkgfCAoc1s0NV0gPj4+IDMpO1xyXG4gICAgICAgICAgICBiMTAgPSAoc1s2XSA8PCAyOCkgfCAoc1s3XSA+Pj4gNCk7XHJcbiAgICAgICAgICAgIGIxMSA9IChzWzddIDw8IDI4KSB8IChzWzZdID4+PiA0KTtcclxuICAgICAgICAgICAgYjQyID0gKHNbMTddIDw8IDIzKSB8IChzWzE2XSA+Pj4gOSk7XHJcbiAgICAgICAgICAgIGI0MyA9IChzWzE2XSA8PCAyMykgfCAoc1sxN10gPj4+IDkpO1xyXG4gICAgICAgICAgICBiMjQgPSAoc1syNl0gPDwgMjUpIHwgKHNbMjddID4+PiA3KTtcclxuICAgICAgICAgICAgYjI1ID0gKHNbMjddIDw8IDI1KSB8IChzWzI2XSA+Pj4gNyk7XHJcbiAgICAgICAgICAgIGI2ID0gKHNbMzZdIDw8IDIxKSB8IChzWzM3XSA+Pj4gMTEpO1xyXG4gICAgICAgICAgICBiNyA9IChzWzM3XSA8PCAyMSkgfCAoc1szNl0gPj4+IDExKTtcclxuICAgICAgICAgICAgYjM4ID0gKHNbNDddIDw8IDI0KSB8IChzWzQ2XSA+Pj4gOCk7XHJcbiAgICAgICAgICAgIGIzOSA9IChzWzQ2XSA8PCAyNCkgfCAoc1s0N10gPj4+IDgpO1xyXG4gICAgICAgICAgICBiMzAgPSAoc1s4XSA8PCAyNykgfCAoc1s5XSA+Pj4gNSk7XHJcbiAgICAgICAgICAgIGIzMSA9IChzWzldIDw8IDI3KSB8IChzWzhdID4+PiA1KTtcclxuICAgICAgICAgICAgYjEyID0gKHNbMThdIDw8IDIwKSB8IChzWzE5XSA+Pj4gMTIpO1xyXG4gICAgICAgICAgICBiMTMgPSAoc1sxOV0gPDwgMjApIHwgKHNbMThdID4+PiAxMik7XHJcbiAgICAgICAgICAgIGI0NCA9IChzWzI5XSA8PCA3KSB8IChzWzI4XSA+Pj4gMjUpO1xyXG4gICAgICAgICAgICBiNDUgPSAoc1syOF0gPDwgNykgfCAoc1syOV0gPj4+IDI1KTtcclxuICAgICAgICAgICAgYjI2ID0gKHNbMzhdIDw8IDgpIHwgKHNbMzldID4+PiAyNCk7XHJcbiAgICAgICAgICAgIGIyNyA9IChzWzM5XSA8PCA4KSB8IChzWzM4XSA+Pj4gMjQpO1xyXG4gICAgICAgICAgICBiOCA9IChzWzQ4XSA8PCAxNCkgfCAoc1s0OV0gPj4+IDE4KTtcclxuICAgICAgICAgICAgYjkgPSAoc1s0OV0gPDwgMTQpIHwgKHNbNDhdID4+PiAxOCk7XHJcbiAgICAgICAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XHJcbiAgICAgICAgICAgIHNbMV0gPSBiMSBeICh+YjMgJiBiNSk7XHJcbiAgICAgICAgICAgIHNbMTBdID0gYjEwIF4gKH5iMTIgJiBiMTQpO1xyXG4gICAgICAgICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcclxuICAgICAgICAgICAgc1syMF0gPSBiMjAgXiAofmIyMiAmIGIyNCk7XHJcbiAgICAgICAgICAgIHNbMjFdID0gYjIxIF4gKH5iMjMgJiBiMjUpO1xyXG4gICAgICAgICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcclxuICAgICAgICAgICAgc1szMV0gPSBiMzEgXiAofmIzMyAmIGIzNSk7XHJcbiAgICAgICAgICAgIHNbNDBdID0gYjQwIF4gKH5iNDIgJiBiNDQpO1xyXG4gICAgICAgICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcclxuICAgICAgICAgICAgc1syXSA9IGIyIF4gKH5iNCAmIGI2KTtcclxuICAgICAgICAgICAgc1szXSA9IGIzIF4gKH5iNSAmIGI3KTtcclxuICAgICAgICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XHJcbiAgICAgICAgICAgIHNbMTNdID0gYjEzIF4gKH5iMTUgJiBiMTcpO1xyXG4gICAgICAgICAgICBzWzIyXSA9IGIyMiBeICh+YjI0ICYgYjI2KTtcclxuICAgICAgICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XHJcbiAgICAgICAgICAgIHNbMzJdID0gYjMyIF4gKH5iMzQgJiBiMzYpO1xyXG4gICAgICAgICAgICBzWzMzXSA9IGIzMyBeICh+YjM1ICYgYjM3KTtcclxuICAgICAgICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XHJcbiAgICAgICAgICAgIHNbNDNdID0gYjQzIF4gKH5iNDUgJiBiNDcpO1xyXG4gICAgICAgICAgICBzWzRdID0gYjQgXiAofmI2ICYgYjgpO1xyXG4gICAgICAgICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xyXG4gICAgICAgICAgICBzWzE0XSA9IGIxNCBeICh+YjE2ICYgYjE4KTtcclxuICAgICAgICAgICAgc1sxNV0gPSBiMTUgXiAofmIxNyAmIGIxOSk7XHJcbiAgICAgICAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xyXG4gICAgICAgICAgICBzWzI1XSA9IGIyNSBeICh+YjI3ICYgYjI5KTtcclxuICAgICAgICAgICAgc1szNF0gPSBiMzQgXiAofmIzNiAmIGIzOCk7XHJcbiAgICAgICAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xyXG4gICAgICAgICAgICBzWzQ0XSA9IGI0NCBeICh+YjQ2ICYgYjQ4KTtcclxuICAgICAgICAgICAgc1s0NV0gPSBiNDUgXiAofmI0NyAmIGI0OSk7XHJcbiAgICAgICAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XHJcbiAgICAgICAgICAgIHNbN10gPSBiNyBeICh+YjkgJiBiMSk7XHJcbiAgICAgICAgICAgIHNbMTZdID0gYjE2IF4gKH5iMTggJiBiMTApO1xyXG4gICAgICAgICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcclxuICAgICAgICAgICAgc1syNl0gPSBiMjYgXiAofmIyOCAmIGIyMCk7XHJcbiAgICAgICAgICAgIHNbMjddID0gYjI3IF4gKH5iMjkgJiBiMjEpO1xyXG4gICAgICAgICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcclxuICAgICAgICAgICAgc1szN10gPSBiMzcgXiAofmIzOSAmIGIzMSk7XHJcbiAgICAgICAgICAgIHNbNDZdID0gYjQ2IF4gKH5iNDggJiBiNDApO1xyXG4gICAgICAgICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcclxuICAgICAgICAgICAgc1s4XSA9IGI4IF4gKH5iMCAmIGIyKTtcclxuICAgICAgICAgICAgc1s5XSA9IGI5IF4gKH5iMSAmIGIzKTtcclxuICAgICAgICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XHJcbiAgICAgICAgICAgIHNbMTldID0gYjE5IF4gKH5iMTEgJiBiMTMpO1xyXG4gICAgICAgICAgICBzWzI4XSA9IGIyOCBeICh+YjIwICYgYjIyKTtcclxuICAgICAgICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XHJcbiAgICAgICAgICAgIHNbMzhdID0gYjM4IF4gKH5iMzAgJiBiMzIpO1xyXG4gICAgICAgICAgICBzWzM5XSA9IGIzOSBeICh+YjMxICYgYjMzKTtcclxuICAgICAgICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XHJcbiAgICAgICAgICAgIHNbNDldID0gYjQ5IF4gKH5iNDEgJiBiNDMpO1xyXG4gICAgICAgICAgICBzWzBdIF49IFNoYTMuUk9VTkRfQ09OU1RBTlRTW25dO1xyXG4gICAgICAgICAgICBzWzFdIF49IFNoYTMuUk9VTkRfQ09OU1RBTlRTW24gKyAxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyogUGFkZGluZyB0byB1c2UgZm9yIEtlY2NhayAqL1xyXG5TaGEzLktFQ0NBS19QQURESU5HID0gbmV3IFVpbnQzMkFycmF5KFsxLCAyNTYsIDY1NTM2LCAxNjc3NzIxNl0pO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuU2hhMy5TSElGVCA9IG5ldyBVaW50OEFycmF5KFswLCA4LCAxNiwgMjRdKTtcclxuLyogQGludGVybmFsICovXHJcblNoYTMuUk9VTkRfQ09OU1RBTlRTID0gbmV3IFVpbnQzMkFycmF5KFsxLCAwLCAzMjg5OCwgMCwgMzI5MDYsIDIxNDc0ODM2NDgsIDIxNDc1MTY0MTYsIDIxNDc0ODM2NDgsIDMyOTA3LCAwLCAyMTQ3NDgzNjQ5LFxyXG4gICAgMCwgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI3NzcsIDIxNDc0ODM2NDgsIDEzOCwgMCwgMTM2LCAwLCAyMTQ3NTE2NDI1LCAwLFxyXG4gICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXHJcbiAgICAyMTQ3NDgzNjQ4LCAzMjc3MCwgMjE0NzQ4MzY0OCwgMTI4LCAyMTQ3NDgzNjQ4LCAzMjc3OCwgMCwgMjE0NzQ4MzY1OCwgMjE0NzQ4MzY0OCxcclxuICAgIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyODk2LCAyMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ5LCAwLCAyMTQ3NTE2NDI0LCAyMTQ3NDgzNjQ4XSk7XHJcbmV4cG9ydHMuU2hhMyA9IFNoYTM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWMyaGhNeTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV2RsYzNSekwzTm9ZVE11ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJMRFJGUVVGNVJUdEJRVU42UlN4elJFRkJiVVE3UVVGRmJrUTdPMGRCUlVjN1FVRkRTRHRKUVhGRFNUczdPenM3VDBGTFJ6dEpRVU5JTEZsQlFWa3NTVUZCV1N4RlFVRkZMRTlCUVc5Q0xFVkJRVVVzVlVGQmEwSTdVVUZET1VRc1NVRkJTU3hEUVVGRExGRkJRVkVzUjBGQlJ5eFBRVUZQTEVOQlFVTTdVVUZEZUVJc1NVRkJTU3hEUVVGRExGZEJRVmNzUjBGQlJ5eFZRVUZWTEVOQlFVTTdVVUZET1VJc1NVRkJTU3hEUVVGRExGZEJRVmNzUjBGQlJ5eERRVUZETEVsQlFVa3NSMEZCUnl4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTTNReXhKUVVGSkxFTkJRVU1zVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUXl4WFFVRlhMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRM2hETEVsQlFVa3NRMEZCUXl4aFFVRmhMRWRCUVVjc1ZVRkJWU3hKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU55UXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhIUVVGSExFTkJRVU1zVlVGQlZTeEhRVUZITEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVVeFF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNN1NVRkRha0lzUTBGQlF6dEpRVVZFT3p0UFFVVkhPMGxCUTBrc1MwRkJTenRSUVVOU0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTI1Q0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTJoQ0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTJoQ0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVkQlFVY3NTVUZCU1N4WFFVRlhMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnlSQ3hKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEVsQlFVa3NWMEZCVnl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8wbEJRM1JETEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeE5RVUZOTEVOQlFVTXNTMEZCYTBJN1VVRkROVUlzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVWQlFVVXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRek5ETEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExHdERRVUZyUXl4RFFVRkRMRU5CUVVNN1VVRkRPVVFzUTBGQlF6dFJRVU5FTEUxQlFVMHNUMEZCVHl4SFFVRmxMRWxCUVVrc1ZVRkJWU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzFGQlEyeEVMRTFCUVUwc1RVRkJUU3hIUVVGSExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTTdVVUZET1VJc1NVRkJTU3hMUVVGTExFZEJRVWNzUTBGQlF5eERRVUZETzFGQlEyUXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkZUaXhQUVVGUExFdEJRVXNzUjBGQlJ5eE5RVUZOTEVWQlFVVXNRMEZCUXp0WlFVTndRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRFpDeEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJRenRuUWtGRGNFSXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRPMmRDUVVNNVFpeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNWMEZCVnl4SFFVRkhMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETzI5Q1FVTjRReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRuUWtGRGVFSXNRMEZCUXp0WlFVTk1MRU5CUVVNN1dVRkRSQ3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1JVRkJSU3hMUVVGTExFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTTdaMEpCUTI1RkxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhKUVVGSkxFOUJRVThzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4RkxFTkJRVU03V1VGRFJDeEpRVUZKTEVOQlFVTXNZMEZCWXl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVONFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNaQ0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU03WjBKQlEyeERMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU03WjBKQlF6ZERMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhYUVVGWExFVkJRVVVzUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXp0dlFrRkRjRU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOMFF5eERRVUZETzJkQ1FVTkVMRWxCUVVrc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEzQkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETzFsQlEzWkNMRU5CUVVNN1dVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dG5Ra0ZEU2l4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU53UWl4RFFVRkRPMUZCUTB3c1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hOUVVGTk8xRkJRMVFzU1VGQlNTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMUZCUldoQ0xFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVTldMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFJRVU5XTEUxQlFVMHNTMEZCU3l4SFFVRkhMRWxCUVVrc1EwRkJReXhYUVVGWExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEzQkRMRWxCUVVrc1RVRkJUU3hEUVVGRE8xRkJRMWdzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrSXNUVUZCVFN4SFFVRkhMRWxCUVVrc1YwRkJWeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEdGQlFXRXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU0xUkN4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFNpeE5RVUZOTEVkQlFVY3NTVUZCU1N4WFFVRlhMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03VVVGRGNFTXNRMEZCUXp0UlFVTkVMRTFCUVUwc1MwRkJTeXhIUVVGSExFbEJRVWtzVjBGQlZ5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUTNSRExFOUJRVThzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4aFFVRmhMRVZCUVVVc1EwRkJRenRaUVVNMVFpeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNWMEZCVnl4SlFVRkpMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zWVVGQllTeEZRVUZGTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU03WjBKQlEyNUZMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemxDTEVOQlFVTTdVVUZEVEN4RFFVRkRPMUZCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia0lzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETVVJc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RlFVRkZMRXRCUVVzc1EwRkJReXhEUVVGRE8xRkJRM0JETEVOQlFVTTdVVUZEUkN4SlFVRkpMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU03VVVGRllpeE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMGxCUTJ4Q0xFTkJRVU03U1VGRlJDeGxRVUZsTzBsQlExQXNVVUZCVVR0UlFVTmFMRWxCUVVrc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTTdVVUZETlVJc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkROME1zUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMR05CUVdNc1MwRkJTeXhKUVVGSkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXhReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMWxCUTJwRUxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF5eFhRVUZYTEVkQlFVY3NRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU03WjBKQlEzaERMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUTNoQ0xFTkJRVU03VVVGRFRDeERRVUZETzFGQlEwUXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRkpMRlZCUVZVc1EwRkJRenRSUVVOcVJDeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RlFVRkZMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU03V1VGRGNFTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1JETEVOQlFVTTdVVUZEUkN4SlFVRkpMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8wbEJRM2hETEVOQlFVTTdTVUZGUkN4bFFVRmxPMGxCUTFBc2FVSkJRV2xDTEVOQlFVTXNRMEZCWXp0UlFVTndReXgzUkVGQmQwUTdVVUZEZUVRc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUXk5RExFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVNNVJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUXpsRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXp0UlFVTnVSaXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhGUVVGRkxFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRPMWxCUTNwQ0xFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRekZETEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlF6RkRMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUXpGRExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRekZETEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlF6RkRMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUXpGRExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRekZETEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlF6RkRMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUXpGRExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJSVEZETEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1RExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRWaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFZc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOdVF5eERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU51UXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExWXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5XTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYmtNc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia01zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOV0xFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRWaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMjVETEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVml4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExWXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRWRCUVVjc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnVReXhEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOdVF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMVlzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOV0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJSVmdzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOV0xFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRWaXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGNFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU53UXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRjRU1zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzQkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOd1F5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY2tNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM0pETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTnNReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGJFTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU53UXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRja01zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzSkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOeVF5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY2tNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM0JETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTndReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4RExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU53UXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRjRU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzQkRMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOd1F5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY2tNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM0pETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTndReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4RExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5zUXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRjRU1zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOd1F5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY0VNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM0JETEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTndReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5zUXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRiRU1zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzSkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOeVF5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY0VNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM0JETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTndReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGNFTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVVZ3UXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGRrSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4SFFVRkhMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM1pDTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE0wSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4SFFVRkhMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM1pDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNSMEZCUnl4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOMlFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE0wSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNSMEZCUnl4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOMlFpeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVkQlFVY3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRka0lzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE0wSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVkQlFVY3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRka0lzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeEhRVUZITEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUTNaQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE0wSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeEhRVUZITEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUTNaQ0xFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTjJRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE0wSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUlROQ0xFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4SlFVRkpMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyaERMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeEpRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU40UXl4RFFVRkRPMGxCUTB3c1EwRkJRenM3UVVGb1ZrUXNLMEpCUVN0Q08wRkJRMUlzYlVKQlFXTXNSMEZCWjBJc1NVRkJTU3hYUVVGWExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNSMEZCUnl4RlFVRkZMRXRCUVVzc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETzBGQlEyaEhMR1ZCUVdVN1FVRkRVeXhWUVVGTExFZEJRV1VzU1VGQlNTeFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUXpORkxHVkJRV1U3UVVGRFV5eHZRa0ZCWlN4SFFVRm5RaXhKUVVGSkxGZEJRVmNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1MwRkJTeXhGUVVGRkxFTkJRVU1zUlVGQlJTeExRVUZMTEVWQlFVVXNWVUZCVlN4RlFVRkZMRlZCUVZVc1JVRkJSU3hWUVVGVkxFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTXNSVUZCUlN4VlFVRlZPMGxCUTI1S0xFTkJRVU1zUlVGQlJTeFZRVUZWTEVWQlFVVXNWVUZCVlN4RlFVRkZMRXRCUVVzc1JVRkJSU3hWUVVGVkxFVkJRVVVzUjBGQlJ5eEZRVUZGTEVOQlFVTXNSVUZCUlN4SFFVRkhMRVZCUVVVc1EwRkJReXhGUVVGRkxGVkJRVlVzUlVGQlJTeERRVUZETzBsQlF6TkZMRlZCUVZVc1JVRkJSU3hEUVVGRExFVkJRVVVzVlVGQlZTeEZRVUZGTEVOQlFVTXNSVUZCUlN4SFFVRkhMRVZCUVVVc1ZVRkJWU3hGUVVGRkxFdEJRVXNzUlVGQlJTeFZRVUZWTEVWQlFVVXNTMEZCU3p0SlFVTjJSU3hWUVVGVkxFVkJRVVVzUzBGQlN5eEZRVUZGTEZWQlFWVXNSVUZCUlN4SFFVRkhMRVZCUVVVc1ZVRkJWU3hGUVVGRkxFdEJRVXNzUlVGQlJTeERRVUZETEVWQlFVVXNWVUZCVlN4RlFVRkZMRlZCUVZVN1NVRkRhRVlzVlVGQlZTeEZRVUZGTEZWQlFWVXNSVUZCUlN4TFFVRkxMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGVkJRVlVzUlVGQlJTeERRVUZETEVWQlFVVXNWVUZCVlN4RlFVRkZMRlZCUVZVc1EwRkJReXhEUVVGRExFTkJRVU03UVVGV00wWXNiMEpCYTFaREluMD1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL2RpZ2VzdHMvc2hhMy50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBjcnlwdG9FcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgSVNwb25nZSB1c2luZyBDdXJsIGFsZ29yaXRobS5cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2lvdGFsZWRnZXIvaW90YS5saWIuanMvYmxvYi9tYXN0ZXIvbGliL2NyeXB0by9jdXJsL2N1cmwuanNcclxuICovXHJcbmNsYXNzIEN1cmwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQ3VybC5cclxuICAgICAqIEBwYXJhbSByb3VuZHMgVGhlIG51bWJlciBvZiByb3VuZHMgdG8gdXNlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihyb3VuZHMgPSBDdXJsLk5VTUJFUl9PRl9ST1VORFMpIHtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZlJvdW5kcyA9IHJvdW5kcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjb25zdGFudCBmb3IgdGhlIHNwb25lLlxyXG4gICAgICogQG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnRhbnQgdG8gZ2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbnN0YW50LlxyXG4gICAgICovXHJcbiAgICBnZXRDb25zdGFudChuYW1lKSB7XHJcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJOVU1CRVJfT0ZfUk9VTkRTXCI6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJPZlJvdW5kcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwiSEFTSF9MRU5HVEhcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlNUQVRFX0xFTkdUSFwiOlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDdXJsW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihgVW5rbm93biBjb25zdGFudCByZXF1ZXN0ZWQgJHtuYW1lfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdGF0ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0U3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXNlIHRoZSBoYXNoZXIuXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIGluaXRpYWwgc3RhdGUgZm9yIHRoZSBoYXNoZXIuXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxpemUoc3RhdGUpIHtcclxuICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gbmV3IEludDhBcnJheShDdXJsLlNUQVRFX0xFTkdUSCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgaGFzaGVyLlxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWJzb3JiIHRyaXRzIGludG8gdGhlIGhhc2guXHJcbiAgICAgKiBAcGFyYW0gdHJpdHMgVGhlIHRyaXRzIHRvIGFic29yYi5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBpbnRvIHRoZSB0cml0cyB0byBhYnNvcmIgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIG51bWJlciBvZiB0cml0cyB0byBhYnNvcmIuXHJcbiAgICAgKi9cclxuICAgIGFic29yYih0cml0cywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJpdHMsIEludDhBcnJheSkgfHwgdHJpdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVHJpdHMgbXVzdCBiZSBhIG5vbiBlbXB0eSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJPZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiTGVuZ3RoIG11c3QgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCArIG9mZnNldCA+IHRyaXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIHRyaXRzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbG9jYWxPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgbGV0IGxvY2FsTGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IGxvY2FsTGVuZ3RoIDwgQ3VybC5IQVNIX0xFTkdUSCA/IGxvY2FsTGVuZ3RoIDogQ3VybC5IQVNIX0xFTkdUSDtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBsaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVbaSsrXSA9IHRyaXRzW2xvY2FsT2Zmc2V0KytdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGxvY2FsTGVuZ3RoIC09IEN1cmwuSEFTSF9MRU5HVEg7XHJcbiAgICAgICAgfSB3aGlsZSAobG9jYWxMZW5ndGggPiAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3F1ZWV6ZSB0cml0cyBpbnRvIHRoZSBoYXNoLlxyXG4gICAgICogQHBhcmFtIHRyaXRzIFRoZSB0cml0cyB0byBzcXVlZXplLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IGludG8gdGhlIHRyaXRzIHRvIHNxdWVlemUgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIG51bWJlciBvZiB0cml0cyB0byBzcXVlZXplLlxyXG4gICAgICovXHJcbiAgICBzcXVlZXplKHRyaXRzLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cml0cywgSW50OEFycmF5KSB8fCB0cml0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUcml0cyBtdXN0IGJlIGEgbm9uIGVtcHR5IEludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIk9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJMZW5ndGggbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoICsgb2Zmc2V0ID4gdHJpdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG9mZnNldCArIGxlbmd0aCBpcyBiZXlvbmQgdGhlIGxlbmd0aCBvZiB0aGUgdHJpdHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsb2NhbE9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICBsZXQgbG9jYWxMZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gbG9jYWxMZW5ndGggPCBDdXJsLkhBU0hfTEVOR1RIID8gbGVuZ3RoIDogQ3VybC5IQVNIX0xFTkdUSDtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBsaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdHJpdHNbbG9jYWxPZmZzZXQrK10gPSB0aGlzLl9zdGF0ZVtpKytdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGxvY2FsTGVuZ3RoIC09IEN1cmwuSEFTSF9MRU5HVEg7XHJcbiAgICAgICAgfSB3aGlsZSAobG9jYWxMZW5ndGggPiAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIHRoZSBoYXNoLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHRyYW5zZm9ybSgpIHtcclxuICAgICAgICBsZXQgc3RhdGVDb3B5O1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgcm91bmQgPSAwOyByb3VuZCA8IHRoaXMuX251bWJlck9mUm91bmRzOyByb3VuZCsrKSB7XHJcbiAgICAgICAgICAgIHN0YXRlQ29weSA9IG5ldyBJbnQ4QXJyYXkodGhpcy5fc3RhdGUuc2xpY2UoKSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ3VybC5TVEFURV9MRU5HVEg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVbaV0gPSBDdXJsLlRSVVRIX1RBQkxFW3N0YXRlQ29weVtpbmRleF0gKyAoc3RhdGVDb3B5W2luZGV4ICs9IChpbmRleCA8IDM2NSA/IDM2NCA6IC0zNjUpXSA8PCAyKSArIDVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkN1cmwuSEFTSF9MRU5HVEggPSAyNDM7XHJcbkN1cmwuTlVNQkVSX09GX1JPVU5EUyA9IDgxO1xyXG5DdXJsLlNUQVRFX0xFTkdUSCA9IEN1cmwuSEFTSF9MRU5HVEggKiAzO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuQ3VybC5UUlVUSF9UQUJMRSA9IG5ldyBJbnQ4QXJyYXkoWzEsIDAsIC0xLCAyLCAxLCAtMSwgMCwgMiwgLTEsIDEsIDBdKTtcclxuZXhwb3J0cy5DdXJsID0gQ3VybDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWTNWeWJDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5emNHOXVaMlZ6TDJOMWNtd3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQkxEUkZRVUY1UlR0QlFVTjZSU3cwUlVGQmVVVTdRVUZEZWtVc2MwUkJRVzFFTzBGQlIyNUVPenM3UjBGSFJ6dEJRVU5JTzBsQllVazdPenRQUVVkSE8wbEJRMGdzV1VGQldTeFRRVUZwUWl4SlFVRkpMRU5CUVVNc1owSkJRV2RDTzFGQlF6bERMRWxCUVVrc1EwRkJReXhsUVVGbExFZEJRVWNzVFVGQlRTeERRVUZETzBsQlEyeERMRU5CUVVNN1NVRkZSRHM3T3p0UFFVbEhPMGxCUTBrc1YwRkJWeXhEUVVGRExFbEJRVms3VVVGRE0wSXNUVUZCVFN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5ZTEV0QlFVc3NhMEpCUVd0Q0xFVkJRVVVzUTBGQlF6dG5Ra0ZEZEVJc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTTdXVUZEYUVNc1EwRkJRenRaUVVORUxFdEJRVXNzWVVGQllTeERRVUZETzFsQlEyNUNMRXRCUVVzc1kwRkJZenRuUWtGRGJrSXNRMEZCUXp0dlFrRkRSeXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOMFFpeERRVUZETzFsQlEwUXNVMEZCVXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5dzRRa0ZCT0VJc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVU42UlN4RFFVRkRPMGxCUTB3c1EwRkJRenRKUVVWRU96czdUMEZIUnp0SlFVTkpMRkZCUVZFN1VVRkRXQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXp0SlFVTjJRaXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1ZVRkJWU3hEUVVGRExFdEJRV2xDTzFGQlF5OUNMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEVWl4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF6dFJRVU40UWl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFNpeEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRWxCUVVrc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXp0UlFVTnVSQ3hEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVVZFT3p0UFFVVkhPMGxCUTBrc1MwRkJTenRSUVVOU0xFbEJRVWtzUTBGQlF5eFZRVUZWTEVWQlFVVXNRMEZCUXp0SlFVTjBRaXhEUVVGRE8wbEJSVVE3T3pzN08wOUJTMGM3U1VGRFNTeE5RVUZOTEVOQlFVTXNTMEZCWjBJc1JVRkJSU3hOUVVGakxFVkJRVVVzVFVGQll6dFJRVU14UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1JVRkJSU3hUUVVGVExFTkJRVU1zU1VGQlNTeExRVUZMTEVOQlFVTXNUVUZCVFN4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGREwwUXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zY1VOQlFYRkRMRU5CUVVNc1EwRkJRenRSUVVOcVJTeERRVUZETzFGQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTm9SQ3hOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl3NFFrRkJPRUlzUTBGQlF5eERRVUZETzFGQlF6RkVMRU5CUVVNN1VVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMmhFTEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExEaENRVUU0UWl4RFFVRkRMRU5CUVVNN1VVRkRNVVFzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhOUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha01zVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2RVUkJRWFZFTEVOQlFVTXNRMEZCUXp0UlFVTnVSaXhEUVVGRE8xRkJSVVFzU1VGQlNTeFhRVUZYTEVkQlFVY3NUVUZCVFN4RFFVRkRPMUZCUTNwQ0xFbEJRVWtzVjBGQlZ5eEhRVUZITEUxQlFVMHNRMEZCUXp0UlFVVjZRaXhIUVVGSExFTkJRVU03V1VGRFFTeEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRWaXhOUVVGTkxFdEJRVXNzUjBGQlJ5eFhRVUZYTEVkQlFVY3NTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRExFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRE8xbEJSVGxGTEU5QlFVOHNRMEZCUXl4SFFVRkhMRXRCUVVzc1JVRkJSU3hEUVVGRE8yZENRVU5tTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eExRVUZMTEVOQlFVTXNWMEZCVnl4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVNMVF5eERRVUZETzFsQlJVUXNTVUZCU1N4RFFVRkRMRk5CUVZNc1JVRkJSU3hEUVVGRE8xbEJSV3BDTEZkQlFWY3NTVUZCU1N4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRE8xRkJRM0JETEVOQlFVTXNVVUZCVVN4WFFVRlhMRWRCUVVjc1EwRkJReXhGUVVGRk8wbEJRemxDTEVOQlFVTTdTVUZGUkRzN096czdUMEZMUnp0SlFVTkpMRTlCUVU4c1EwRkJReXhMUVVGblFpeEZRVUZGTEUxQlFXTXNSVUZCUlN4TlFVRmpPMUZCUXpORUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eEZRVUZGTEZOQlFWTXNRMEZCUXl4SlFVRkpMRXRCUVVzc1EwRkJReXhOUVVGTkxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXZSQ3hOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4eFEwRkJjVU1zUTBGQlF5eERRVUZETzFGQlEycEZMRU5CUVVNN1VVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMmhFTEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExEaENRVUU0UWl4RFFVRkRMRU5CUVVNN1VVRkRNVVFzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYUVRc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNPRUpCUVRoQ0xFTkJRVU1zUTBGQlF6dFJRVU14UkN4RFFVRkRPMUZCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeEhRVUZITEUxQlFVMHNSMEZCUnl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5xUXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eDFSRUZCZFVRc1EwRkJReXhEUVVGRE8xRkJRMjVHTEVOQlFVTTdVVUZGUkN4SlFVRkpMRmRCUVZjc1IwRkJSeXhOUVVGTkxFTkJRVU03VVVGRGVrSXNTVUZCU1N4WFFVRlhMRWRCUVVjc1RVRkJUU3hEUVVGRE8xRkJSWHBDTEVkQlFVY3NRMEZCUXp0WlFVVkJMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU5XTEUxQlFVMHNTMEZCU3l4SFFVRkhMRmRCUVZjc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTTdXVUZGZWtVc1QwRkJUeXhEUVVGRExFZEJRVWNzUzBGQlN5eEZRVUZGTEVOQlFVTTdaMEpCUTJZc1MwRkJTeXhEUVVGRExGZEJRVmNzUlVGQlJTeERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlF6VkRMRU5CUVVNN1dVRkZSQ3hKUVVGSkxFTkJRVU1zVTBGQlV5eEZRVUZGTEVOQlFVTTdXVUZGYWtJc1YwRkJWeXhKUVVGSkxFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTTdVVUZEY0VNc1EwRkJReXhSUVVGUkxGZEJRVmNzUjBGQlJ5eERRVUZETEVWQlFVVTdTVUZET1VJc1EwRkJRenRKUVVWRU96czdUMEZIUnp0SlFVTkxMRk5CUVZNN1VVRkRZaXhKUVVGSkxGTkJRVzlDTEVOQlFVTTdVVUZEZWtJc1NVRkJTU3hMUVVGTExFZEJRVWNzUTBGQlF5eERRVUZETzFGQlJXUXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hMUVVGTExFZEJRVWNzUTBGQlF5eEZRVUZGTEV0QlFVc3NSMEZCUnl4SlFVRkpMRU5CUVVNc1pVRkJaU3hGUVVGRkxFdEJRVXNzUlVGQlJTeEZRVUZGTEVOQlFVTTdXVUZEZUVRc1UwRkJVeXhIUVVGSExFbEJRVWtzVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVVV2UXl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhaUVVGWkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXp0blFrRkZla01zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEZOQlFWTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExGTkJRVk1zUTBGQlF5eExRVUZMTEVsQlFVa3NRMEZCUXl4TFFVRkxMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOd1NDeERRVUZETzFGQlEwd3NRMEZCUXp0SlFVTk1MRU5CUVVNN08wRkJOMHB6UWl4blFrRkJWeXhIUVVGWExFZEJRVWNzUTBGQlF6dEJRVU14UWl4eFFrRkJaMElzUjBGQlZ5eEZRVUZGTEVOQlFVTTdRVUZET1VJc2FVSkJRVmtzUjBGQlZ5eEpRVUZKTEVOQlFVTXNWMEZCVnl4SFFVRkhMRU5CUVVNc1EwRkJRenRCUVVWdVJTeGxRVUZsTzBGQlExTXNaMEpCUVZjc1IwRkJZeXhKUVVGSkxGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBGQlRucEhMRzlDUVN0S1F5SjlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL3Nwb25nZXMvY3VybC50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBzaGEzXzEgPSByZXF1aXJlKFwiLi4vZGlnZXN0cy9zaGEzXCIpO1xyXG5jb25zdCBjcnlwdG9FcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG5jb25zdCBiaWdJbnRlZ2VySGVscGVyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9iaWdJbnRlZ2VySGVscGVyXCIpO1xyXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgSVNwb25nZSB1c2luZyBLZXJsIGFsZ29yaXRobS5cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2lvdGFsZWRnZXIvaXJpL2Jsb2IvZGV2L3NyYy9tYWluL2phdmEvY29tL2lvdGEvaXJpL2hhc2gvS2VybC5qYXZhXHJcbiAqL1xyXG5jbGFzcyBLZXJsIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEtlcmwuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2tlY2NhayA9IG5ldyBzaGEzXzEuU2hhMygzODQsIHNoYTNfMS5TaGEzLktFQ0NBS19QQURESU5HLCAzODQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNvbnN0YW50IGZvciB0aGUgc3BvbmUuXHJcbiAgICAgKiBAbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29udGFudCB0byBnZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29uc3RhbnQuXHJcbiAgICAgKi9cclxuICAgIGdldENvbnN0YW50KG5hbWUpIHtcclxuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkhBU0hfTEVOR1RIXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJCSVRfSEFTSF9MRU5HVEhcIjpcclxuICAgICAgICAgICAgY2FzZSBcIkJZVEVfSEFTSF9MRU5HVEhcIjpcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gS2VybFtuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoYFVua25vd24gY29uc3RhbnQgcmVxdWVzdGVkICR7bmFtZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RhdGUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIGdldFN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpc2UgdGhlIGhhc2hlci5cclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgaW5pdGlhbCBzdGF0ZSBmb3IgdGhlIGhhc2hlci5cclxuICAgICAqL1xyXG4gICAgaW5pdGlhbGl6ZShzdGF0ZSkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgaGFzaGVyLlxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9rZWNjYWsucmVzZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWJzb3JiIHRyaXRzIGludG8gdGhlIGhhc2guXHJcbiAgICAgKiBAcGFyYW0gdHJpdHMgVGhlIHRyaXRzIHRvIGFic29yYi5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBpbnRvIHRoZSB0cml0cyB0byBhYnNvcmIgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIG51bWJlciBvZiB0cml0cyB0byBhYnNvcmIuXHJcbiAgICAgKi9cclxuICAgIGFic29yYih0cml0cywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJpdHMsIEludDhBcnJheSkgfHwgdHJpdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVHJpdHMgbXVzdCBiZSBhIG5vbiBlbXB0eSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJPZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiTGVuZ3RoIG11c3QgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCArIG9mZnNldCA+IHRyaXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIHRyaXRzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoICUgMjQzICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7S2VybC5IQVNIX0xFTkdUSH1gLCB7IGxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxvY2FsT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIGxldCBsb2NhbExlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyaXRTdGF0ZSA9IHRyaXRzLnNsaWNlKGxvY2FsT2Zmc2V0LCBsb2NhbE9mZnNldCArIEtlcmwuSEFTSF9MRU5HVEgpO1xyXG4gICAgICAgICAgICB0cml0U3RhdGVbS2VybC5IQVNIX0xFTkdUSCAtIDFdID0gMDtcclxuICAgICAgICAgICAgY29uc3QgYmlnSW50ID0gYmlnSW50ZWdlckhlbHBlcl8xLkJpZ0ludGVnZXJIZWxwZXIudHJpdHNUb0JpZ0ludGVnZXIodHJpdFN0YXRlLCAwLCB0cml0U3RhdGUubGVuZ3RoKTtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZVN0YXRlID0gbmV3IEFycmF5QnVmZmVyKEtlcmwuQllURV9IQVNIX0xFTkdUSCk7XHJcbiAgICAgICAgICAgIGJpZ0ludGVnZXJIZWxwZXJfMS5CaWdJbnRlZ2VySGVscGVyLmJpZ0ludGVnZXJUb0J5dGVzKGJpZ0ludCwgYnl0ZVN0YXRlLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fa2VjY2FrLnVwZGF0ZShieXRlU3RhdGUpO1xyXG4gICAgICAgICAgICBsb2NhbE9mZnNldCArPSBLZXJsLkhBU0hfTEVOR1RIO1xyXG4gICAgICAgICAgICBsb2NhbExlbmd0aCAtPSBLZXJsLkhBU0hfTEVOR1RIO1xyXG4gICAgICAgIH0gd2hpbGUgKGxvY2FsTGVuZ3RoID4gMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNxdWVlemUgdHJpdHMgaW50byB0aGUgaGFzaC5cclxuICAgICAqIEBwYXJhbSB0cml0cyBUaGUgdHJpdHMgdG8gc3F1ZWV6ZS5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBpbnRvIHRoZSB0cml0cyB0byBzcXVlZXplIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgdHJpdHMgdG8gc3F1ZWV6ZS5cclxuICAgICAqL1xyXG4gICAgc3F1ZWV6ZSh0cml0cywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJpdHMsIEludDhBcnJheSkgfHwgdHJpdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVHJpdHMgbXVzdCBiZSBhIG5vbiBlbXB0eSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJPZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiTGVuZ3RoIG11c3QgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCArIG9mZnNldCA+IHRyaXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIHRyaXRzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoICUgMjQzICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7S2VybC5IQVNIX0xFTkdUSH1gLCB7IGxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxvY2FsT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIGxldCBsb2NhbExlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVTdGF0ZUJ1ZmZlciA9IHRoaXMuX2tlY2Nhay5kaWdlc3QoKTtcclxuICAgICAgICAgICAgY29uc3QgYmlnSW50ID0gYmlnSW50ZWdlckhlbHBlcl8xLkJpZ0ludGVnZXJIZWxwZXIuYnl0ZXNUb0JpZ0ludGVnZXIoYnl0ZVN0YXRlQnVmZmVyLCAwLCBLZXJsLkJZVEVfSEFTSF9MRU5HVEgpO1xyXG4gICAgICAgICAgICBjb25zdCB0cml0U3RhdGUgPSBuZXcgSW50OEFycmF5KEtlcmwuSEFTSF9MRU5HVEgpO1xyXG4gICAgICAgICAgICBiaWdJbnRlZ2VySGVscGVyXzEuQmlnSW50ZWdlckhlbHBlci5iaWdJbnRlZ2VyVG9Ucml0cyhiaWdJbnQsIHRyaXRTdGF0ZSwgMCwgS2VybC5IQVNIX0xFTkdUSCk7XHJcbiAgICAgICAgICAgIHRyaXRTdGF0ZVtLZXJsLkhBU0hfTEVOR1RIIC0gMV0gPSAwO1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgS2VybC5IQVNIX0xFTkdUSCkge1xyXG4gICAgICAgICAgICAgICAgdHJpdHNbbG9jYWxPZmZzZXQrK10gPSB0cml0U3RhdGVbaSsrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhieXRlU3RhdGVCdWZmZXIpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZHYuYnl0ZUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBkdi5zZXRVaW50OChpLCBkdi5nZXRVaW50OChpKSBeIDB4RkYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2tlY2Nhay51cGRhdGUoYnl0ZVN0YXRlQnVmZmVyKTtcclxuICAgICAgICAgICAgbG9jYWxMZW5ndGggLT0gS2VybC5IQVNIX0xFTkdUSDtcclxuICAgICAgICB9IHdoaWxlIChsb2NhbExlbmd0aCA+IDApO1xyXG4gICAgfVxyXG59XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5LZXJsLkhBU0hfTEVOR1RIID0gMjQzO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuS2VybC5CSVRfSEFTSF9MRU5HVEggPSAzODQ7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5LZXJsLkJZVEVfSEFTSF9MRU5HVEggPSBLZXJsLkJJVF9IQVNIX0xFTkdUSCAvIDg7XHJcbmV4cG9ydHMuS2VybCA9IEtlcmw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWEyVnliQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXpjRzl1WjJWekwydGxjbXd1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJMRFJGUVVGNVJUdEJRVU42UlN3MFJVRkJlVVU3UVVGRGVrVXNNRU5CUVhWRE8wRkJRM1pETEhORVFVRnRSRHRCUVVOdVJDeHJSVUZCSzBRN1FVRkhMMFE3T3p0SFFVZEhPMEZCUTBnN1NVRlhTVHM3VDBGRlJ6dEpRVU5JTzFGQlEwa3NTVUZCU1N4RFFVRkRMRTlCUVU4c1IwRkJSeXhKUVVGSkxGZEJRVWtzUTBGQlF5eEhRVUZITEVWQlFVVXNWMEZCU1N4RFFVRkRMR05CUVdNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF6dEpRVU16UkN4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRmRCUVZjc1EwRkJReXhKUVVGWk8xRkJRek5DTEUxQlFVMHNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFdDeExRVUZMTEdGQlFXRXNRMEZCUXp0WlFVTnVRaXhMUVVGTExHbENRVUZwUWl4RFFVRkRPMWxCUTNaQ0xFdEJRVXNzYTBKQlFXdENPMmRDUVVOMlFpeERRVUZETzI5Q1FVTkhMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdaMEpCUTNSQ0xFTkJRVU03V1VGRFJDeFRRVUZUTEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExEaENRVUU0UWl4SlFVRkpMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRM3BGTEVOQlFVTTdTVUZEVEN4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NVVUZCVVR0UlFVTllMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU03U1VGRGNrSXNRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5KTEZWQlFWVXNRMEZCUXl4TFFVRnBRanRKUVVOdVF5eERRVUZETzBsQlJVUTdPMDlCUlVjN1NVRkRTU3hMUVVGTE8xRkJRMUlzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJRenRKUVVONlFpeERRVUZETzBsQlJVUTdPenM3TzA5QlMwYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1MwRkJaMElzUlVGQlJTeE5RVUZqTEVWQlFVVXNUVUZCWXp0UlFVTXhSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJTeFRRVUZUTEVOQlFVTXNTVUZCU1N4TFFVRkxMRU5CUVVNc1RVRkJUU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETDBRc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNjVU5CUVhGRExFTkJRVU1zUTBGQlF6dFJRVU5xUlN4RFFVRkRPMUZCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOb1JDeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXc0UWtGQk9FSXNRMEZCUXl4RFFVRkRPMUZCUXpGRUxFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyaEVMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETERoQ1FVRTRRaXhEUVVGRExFTkJRVU03VVVGRE1VUXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUjBGQlJ5eE5RVUZOTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFrTXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zZFVSQlFYVkVMRU5CUVVNc1EwRkJRenRSUVVOdVJpeERRVUZETzFGQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hIUVVGSExFZEJRVWNzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNKQ0xFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMR2REUVVGblF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RlFVRkZMRVZCUVVVc1JVRkJSU3hOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETzFGQlF6RkdMRU5CUVVNN1VVRkZSQ3hKUVVGSkxGZEJRVmNzUjBGQlJ5eE5RVUZOTEVOQlFVTTdVVUZEZWtJc1NVRkJTU3hYUVVGWExFZEJRVWNzVFVGQlRTeERRVUZETzFGQlJYcENMRWRCUVVjc1EwRkJRenRaUVVOQkxFMUJRVTBzVTBGQlV5eEhRVUZITEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1YwRkJWeXhGUVVGRkxGZEJRVmNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNN1dVRkZNMFVzVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRlhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlEzQkRMRTFCUVUwc1RVRkJUU3hIUVVGSExHMURRVUZuUWl4RFFVRkRMR2xDUVVGcFFpeERRVUZETEZOQlFWTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFsQlEyeEdMRTFCUVUwc1UwRkJVeXhIUVVGSExFbEJRVWtzVjBGQlZ5eERRVUZETEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUTBGQlF5eERRVUZETzFsQlEzcEVMRzFEUVVGblFpeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFMUJRVTBzUlVGQlJTeFRRVUZUTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkZla1FzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU03V1VGRkwwSXNWMEZCVnl4SlFVRkpMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVU03V1VGRGFFTXNWMEZCVnl4SlFVRkpMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVU03VVVGRGNFTXNRMEZCUXl4UlFVRlJMRmRCUVZjc1IwRkJSeXhEUVVGRExFVkJRVVU3U1VGRE9VSXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1QwRkJUeXhEUVVGRExFdEJRV2RDTEVWQlFVVXNUVUZCWXl4RlFVRkZMRTFCUVdNN1VVRkRNMFFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVWQlFVVXNVMEZCVXl4RFFVRkRMRWxCUVVrc1MwRkJTeXhEUVVGRExFMUJRVTBzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXk5RUxFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMSEZEUVVGeFF5eERRVUZETEVOQlFVTTdVVUZEYWtVc1EwRkJRenRSUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFFUXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zT0VKQlFUaENMRU5CUVVNc1EwRkJRenRSUVVNeFJDeERRVUZETzFGQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTm9SQ3hOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl3NFFrRkJPRUlzUTBGQlF5eERRVUZETzFGQlF6RkVMRU5CUVVNN1VVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVkQlFVY3NUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEycERMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEhWRVFVRjFSQ3hEUVVGRExFTkJRVU03VVVGRGJrWXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUjBGQlJ5eEhRVUZITEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOeVFpeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhuUTBGQlowTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1JVRkJSU3hGUVVGRkxFVkJRVVVzVFVGQlRTeEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTXhSaXhEUVVGRE8xRkJSVVFzU1VGQlNTeFhRVUZYTEVkQlFVY3NUVUZCVFN4RFFVRkRPMUZCUTNwQ0xFbEJRVWtzVjBGQlZ5eEhRVUZITEUxQlFVMHNRMEZCUXp0UlFVVjZRaXhIUVVGSExFTkJRVU03V1VGRFFTeE5RVUZOTEdWQlFXVXNSMEZCUnl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETzFsQlJUbERMRTFCUVUwc1RVRkJUU3hIUVVGSExHMURRVUZuUWl4RFFVRkRMR2xDUVVGcFFpeERRVUZETEdWQlFXVXNSVUZCUlN4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExHZENRVUZuUWl4RFFVRkRMRU5CUVVNN1dVRkZOMFlzVFVGQlRTeFRRVUZUTEVkQlFXTXNTVUZCU1N4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETzFsQlF6ZEVMRzFEUVVGblFpeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFMUJRVTBzUlVGQlJTeFRRVUZUTEVWQlFVVXNRMEZCUXl4RlFVRkZMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVU1zUTBGQlF6dFpRVVV6UlN4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkZjRU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUTFZc1QwRkJUeXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NSVUZCUlN4RFFVRkRPMmRDUVVNeFFpeExRVUZMTEVOQlFVTXNWMEZCVnl4RlFVRkZMRU5CUVVNc1IwRkJSeXhUUVVGVExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTXhReXhEUVVGRE8xbEJSVVFzVFVGQlRTeEZRVUZGTEVkQlFVY3NTVUZCU1N4UlFVRlJMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU03V1VGRGVrTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSVUZCUlN4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETzJkQ1FVTnFReXhGUVVGRkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUXpGRExFTkJRVU03V1VGRlJDeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF6dFpRVVZ5UXl4WFFVRlhMRWxCUVVrc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF6dFJRVU53UXl4RFFVRkRMRkZCUVZFc1YwRkJWeXhIUVVGSExFTkJRVU1zUlVGQlJUdEpRVU01UWl4RFFVRkRPenRCUVc1S1JDeGxRVUZsTzBGQlExTXNaMEpCUVZjc1IwRkJWeXhIUVVGSExFTkJRVU03UVVGRGJFUXNaVUZCWlR0QlFVTlRMRzlDUVVGbExFZEJRVmNzUjBGQlJ5eERRVUZETzBGQlEzUkVMR1ZCUVdVN1FVRkRVeXh4UWtGQlowSXNSMEZCVnl4SlFVRkpMRU5CUVVNc1pVRkJaU3hIUVVGSExFTkJRVU1zUTBGQlF6dEJRVTVvUml4dlFrRnhTa01pZlE9PVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvc3Bvbmdlcy9rZXJsLnRzIiwidmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmltcG9ydC1uYW1lXHJcbmNvbnN0IGJpZ19pbnRlZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZy1pbnRlZ2VyXCIpKTtcclxuY29uc3QgY3J5cHRvRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9jcnlwdG9FcnJvclwiKTtcclxuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyB0byBjb252ZXJ0IGJldHdlZW4gQmlnSW50ZWdlciBhbmQgb3RoZXIgdHlwZXMuXHJcbiAqIENvbnZlcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9pb3RhbGVkZ2VyL2lyaS9ibG9iL2Rldi9zcmMvbWFpbi9qYXZhL2NvbS9pb3RhL2lyaS9oYXNoL0tlcmwuamF2YVxyXG4gKi9cclxuY2xhc3MgQmlnSW50ZWdlckhlbHBlciB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdHJpdHMgdG8gYSBiaWdJbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHRyaXRzIFRoZSB0cml0cyB0byBjb252ZXJ0LlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgd2l0aGluIHRoZSBhcnJheSB0byBzdGFydC5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgdHJpdHMgYXJyYXkgdG8gY29udmVydC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRyaXRzVG9CaWdJbnRlZ2VyKHRyaXRzLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cml0cywgSW50OEFycmF5KSB8fCB0cml0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgdHJpdHMgbXVzdCBiZSBhIG5vbiBlbXB0eSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgb2Zmc2V0IG11c3QgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgbGVuZ3RoIG11c3QgYmUgYSBudW1iZXIgPiAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2Zmc2V0ICsgbGVuZ3RoID4gdHJpdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG9mZnNldCArIGxlbmd0aCBpcyBiZXlvbmQgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB2YWx1ZSA9IGJpZ19pbnRlZ2VyXzEuZGVmYXVsdC56ZXJvO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm11bHRpcGx5KEJpZ0ludGVnZXJIZWxwZXIuUkFESVgpLmFkZChiaWdfaW50ZWdlcl8xLmRlZmF1bHQodHJpdHNbb2Zmc2V0ICsgaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IGJpZ0ludGVnZXIgdG8gdHJpdHMuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGJpZ0ludGVnZXIgdG8gY29udmVydCB0byB0cml0cy5cclxuICAgICAqIEBwYXJhbSB0cml0cyBUaGUgYXJyYXkgdG8gcmVjZWl2ZSB0aGUgdHJpdHMuXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgdG8gcGxhY2UgdGhlIHRyaXRzIGluIHRoZSBhcnJheS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBiaWdJbnRlZ2VyVG9Ucml0cyh2YWx1ZSwgdHJpdHMsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHZhbHVlLCBiaWdfaW50ZWdlcl8xLmRlZmF1bHQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHZhbHVlIG11c3QgYmUgYSBiaWdJbnRlZ2VyIHR5cGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cml0cywgSW50OEFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSB0cml0cyBtdXN0IGJlIGFuIEludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlciA+IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvZmZzZXQgKyBsZW5ndGggPiB0cml0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgb2Zmc2V0ICsgbGVuZ3RoIGlzIGJleW9uZCB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGFic29sdXRlVmFsdWUgPSB2YWx1ZS5jb21wYXJlVG8oYmlnX2ludGVnZXJfMS5kZWZhdWx0Lnplcm8pIDwgMCA/IHZhbHVlLm5lZ2F0ZSgpIDogdmFsdWU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkaXZSZW1haW5kZXIgPSBhYnNvbHV0ZVZhbHVlLmRpdm1vZChCaWdJbnRlZ2VySGVscGVyLlJBRElYKTtcclxuICAgICAgICAgICAgYWJzb2x1dGVWYWx1ZSA9IGRpdlJlbWFpbmRlci5xdW90aWVudDtcclxuICAgICAgICAgICAgbGV0IHJlbWFpbmRlciA9IGRpdlJlbWFpbmRlci5yZW1haW5kZXI7XHJcbiAgICAgICAgICAgIGlmIChyZW1haW5kZXIgPiBCaWdJbnRlZ2VySGVscGVyLk1BWF9UUklUX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSBCaWdJbnRlZ2VySGVscGVyLk1JTl9UUklUX1ZBTFVFO1xyXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVWYWx1ZSA9IGFic29sdXRlVmFsdWUuYWRkKGJpZ19pbnRlZ2VyXzEuZGVmYXVsdFtcIjFcIl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyaXRzW29mZnNldCArIGldID0gcmVtYWluZGVyLnRvSlNOdW1iZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlLmNvbXBhcmVUbyhiaWdfaW50ZWdlcl8xLmRlZmF1bHQuemVybykgPCAwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIG5lZ2F0aXZlIHplcm9cclxuICAgICAgICAgICAgICAgIHRyaXRzW29mZnNldCArIGldID0gdHJpdHNbb2Zmc2V0ICsgaV0gPT09IDAgPyAwIDogLXRyaXRzW29mZnNldCArIGldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSBiaWdJbnRlZ2VyIGludG8gYnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb24gVGhlIGRlc3RpbmF0aW9uIGFycmF5IHRvIHN0b3JlIHRoZSBieXRlcy5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB3aXRoaW4gdGhlIGFycmF5IHRvIHN0b3JlIHRoZSBieXRlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJpZ0ludGVnZXJUb0J5dGVzKHZhbHVlLCBkZXN0aW5hdGlvbiwgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHZhbHVlLCBiaWdfaW50ZWdlcl8xLmRlZmF1bHQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHZhbHVlIG11c3QgYmUgYSBiaWdJbnRlZ2VyIHR5cGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShkZXN0aW5hdGlvbiwgQXJyYXlCdWZmZXIpIHx8IGRlc3RpbmF0aW9uLmJ5dGVMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgZGVzdGluYXRpb24gbXVzdCBiZSBhbiBhcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVzdGluYXRpb24uYnl0ZUxlbmd0aCAtIG9mZnNldCA8IEJpZ0ludGVnZXJIZWxwZXIuQllURV9IQVNIX0xFTkdUSCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihgRGVzdGluYXRpb24gYXJyYXkgaGFzIGludmFsaWQgc2l6ZSwgaXQgbXVzdCBiZSBhdCBsZWFzdCAke0JpZ0ludGVnZXJIZWxwZXIuQllURV9IQVNIX0xFTkdUSH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtZW1iZXIgaWYgaXQgaXMgbmVnYXRpdmUgZm9yIGxhdGVyXHJcbiAgICAgICAgY29uc3QgaXNOZWcgPSB2YWx1ZS5pc05lZ2F0aXZlKCkgPyAtMSA6IDA7XHJcbiAgICAgICAgbGV0IGhleFN0cmluZyA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICBpZiAoaXNOZWcgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIEJ1dCByZW1vdmUgaXQgZm9yIG5vd1xyXG4gICAgICAgICAgICBoZXhTdHJpbmcgPSBoZXhTdHJpbmcuc2xpY2UoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdyBtYWtlIHN1cmUgdGhlIGhleCBzdHJpbmcgaXMgYW4gZXZlbiBsZW5ndGggc28gdGhlIHJlZ2V4IHdvcmtzXHJcbiAgICAgICAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyID09PSAxKSB7XHJcbiAgICAgICAgICAgIGhleFN0cmluZyA9IGAwJHtoZXhTdHJpbmd9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGhleFN0cmluZy5tYXRjaCgvWzAtOWEtZl17Mn0vZyk7XHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgaGV4IHRvIG51bWJlcnNcclxuICAgICAgICBjb25zdCBzaWduZWRCeXRlcyA9IG5ldyBJbnQ4QXJyYXkobWF0Y2hlc1xyXG4gICAgICAgICAgICAubWFwKGhleCA9PiBwYXJzZUludChgMHgke2hleH1gLCAxNikpKTtcclxuICAgICAgICBpZiAoaXNOZWcgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIEJpZ0ludGVnZXJIZWxwZXIudHdvc0NvbXBsZW1lbnQoc2lnbmVkQnl0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhkZXN0aW5hdGlvbik7XHJcbiAgICAgICAgLy8gUGFkIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVyIHdpdGggdGhlIG5lZyB2YWx1ZVxyXG4gICAgICAgIGxldCBpID0gb2Zmc2V0O1xyXG4gICAgICAgIHdoaWxlIChpICsgc2lnbmVkQnl0ZXMubGVuZ3RoIDwgQmlnSW50ZWdlckhlbHBlci5CWVRFX0hBU0hfTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldEludDgoaSsrLCBpc05lZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFuZCBjb3B5IGluIHRoZSBhY3R1YWwgYnl0ZXNcclxuICAgICAgICBmb3IgKGxldCBqID0gc2lnbmVkQnl0ZXMubGVuZ3RoOyBqLS0gPiAwOykge1xyXG4gICAgICAgICAgICBkYXRhVmlldy5zZXRJbnQ4KGkrKywgc2lnbmVkQnl0ZXNbc2lnbmVkQnl0ZXMubGVuZ3RoIC0gMSAtIGpdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgYnl0ZXMgdG8gYSBiaWdJbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHNvdXJjZSBUaGUgc291cmNlIGJ5dGVzLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IHdpdGhpbiB0aGUgYnl0ZXMgdG8gc3RhcnQgY29udmVyc2lvbi5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgYnl0ZXMgdG8gdXNlIGZvciBjb252ZXJzaW9uLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXNUb0JpZ0ludGVnZXIoc291cmNlLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzb3VyY2UsIEFycmF5QnVmZmVyKSB8fCBzb3VyY2UuYnl0ZUxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBzb3VyY2UgbXVzdCBiZSBhIG5vbiBlbXB0eSBudW1iZXIgYXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgb2Zmc2V0IG11c3QgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgbGVuZ3RoIG11c3QgYmUgYSBudW1iZXIgPiAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc291cmNlLmJ5dGVMZW5ndGggLSBvZmZzZXQgPCBCaWdJbnRlZ2VySGVscGVyLkJZVEVfSEFTSF9MRU5HVEgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoYFNvdXJjZSBhcnJheSBoYXMgaW52YWxpZCBzaXplLCBpdCBtdXN0IGJlIGF0IGxlYXN0ICR7QmlnSW50ZWdlckhlbHBlci5CWVRFX0hBU0hfTEVOR1RIfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzb3VyY2UpO1xyXG4gICAgICAgIGxldCBzaWduZWRCeXRlcyA9IG5ldyBJbnQ4QXJyYXkoZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBkYXRhVmlldy5ieXRlTGVuZ3RoOyBiKyspIHtcclxuICAgICAgICAgICAgc2lnbmVkQnl0ZXNbYl0gPSBkYXRhVmlldy5nZXRJbnQ4KGIgKyBvZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGluaXRpYWwgcGFkZGluZyBsZWF2aW5nIGF0IGxlYXN0IG9uZSBieXRlXHJcbiAgICAgICAgbGV0IHBhZGRpbmdPZmZzZXQgPSAwO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IHNpZ25lZEJ5dGVzWzBdO1xyXG4gICAgICAgIGNvbnN0IGlzTmVnID0gZmlyc3RCeXRlIDwgMDtcclxuICAgICAgICAvLyBJZiB0aGUgZmlyc3QgcGFkZGluZyBjaGFyYWN0ZXIgaXMgbmVnYXRpdmUgdGhlbiByZXZlcnNlIHRoZSAycyBjb21wbGVtZW50XHJcbiAgICAgICAgLy8gYnV0IGZpcnN0IHN0cmlwIG9mIHRoZSBsZWFkaW5nIHBhZGRpbmdcclxuICAgICAgICBpZiAoZmlyc3RCeXRlID09PSAwIHx8IGZpcnN0Qnl0ZSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHNpZ25lZEJ5dGVzW3BhZGRpbmdPZmZzZXRdID09PSBmaXJzdEJ5dGUgJiYgcGFkZGluZ09mZnNldCA8IHNpZ25lZEJ5dGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIHBhZGRpbmdPZmZzZXQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdHJpcCBhbnkgcGFkZGluZ1xyXG4gICAgICAgICAgICBzaWduZWRCeXRlcyA9IHNpZ25lZEJ5dGVzLnNsaWNlKHBhZGRpbmdPZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOZWcpIHtcclxuICAgICAgICAgICAgQmlnSW50ZWdlckhlbHBlci50d29zQ29tcGxlbWVudChzaWduZWRCeXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBoZXhTdHJpbmcgPSBpc05lZyA/IFwiLVwiIDogXCJcIjtcclxuICAgICAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhzaWduZWRCeXRlcy5idWZmZXIpO1xyXG4gICAgICAgIGZvciAobGV0IGggPSAwOyBoIDwgZHYuYnl0ZUxlbmd0aDsgaCsrKSB7XHJcbiAgICAgICAgICAgIGhleFN0cmluZyArPSBgMDAke2R2LmdldFVpbnQ4KGgpLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdChoZXhTdHJpbmcsIDE2KTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIHR3b3NDb21wbGVtZW50KHNpZ25lZEJ5dGVzKSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIHdob2xlIG51bWJlciBpcyBuZWdhdGl2ZSB0aGVuXHJcbiAgICAgICAgLy8gY2hhbmdlIHRvIDIncyBjb21wbGVtZW50cyBieSBub3RpbmcgYWxsIHRoZSBudW1iZXJzXHJcbiAgICAgICAgLy8gYW5kIGFkZGluZyAxIHRvIHRoZSBsYXN0IGkuZS4gfmJpZ251bSsxXHJcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBzaWduZWRCeXRlcy5sZW5ndGg7IGIrKykge1xyXG4gICAgICAgICAgICBzaWduZWRCeXRlc1tiXSA9IH5zaWduZWRCeXRlc1tiXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIDEgdG8gbGFzdCBudW1iZXIsIGlmIHRoZSBudW1iZXIgaXMgMHhGRiBjb250aW51ZSB0byBjYXJyeVxyXG4gICAgICAgIGxldCBjID0gc2lnbmVkQnl0ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHNpZ25lZEJ5dGVzW2NdKys7XHJcbiAgICAgICAgfSB3aGlsZSAoc2lnbmVkQnl0ZXNbYy0tXSA9PT0gMCAmJiBjID4gMCk7XHJcbiAgICB9XHJcbn1cclxuLyogQGludGVybmFsICovXHJcbkJpZ0ludGVnZXJIZWxwZXIuUkFESVggPSBiaWdfaW50ZWdlcl8xLmRlZmF1bHQoMyk7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5CaWdJbnRlZ2VySGVscGVyLk1BWF9UUklUX1ZBTFVFID0gQmlnSW50ZWdlckhlbHBlci5SQURJWC5taW51cygxKS5kaXZpZGUoMik7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5CaWdJbnRlZ2VySGVscGVyLk1JTl9UUklUX1ZBTFVFID0gQmlnSW50ZWdlckhlbHBlci5NQVhfVFJJVF9WQUxVRS5uZWdhdGUoKTtcclxuLyogQGludGVybmFsICovXHJcbkJpZ0ludGVnZXJIZWxwZXIuQklUX0hBU0hfTEVOR1RIID0gMzg0O1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuQmlnSW50ZWdlckhlbHBlci5CWVRFX0hBU0hfTEVOR1RIID0gQmlnSW50ZWdlckhlbHBlci5CSVRfSEFTSF9MRU5HVEggLyA4O1xyXG5leHBvcnRzLkJpZ0ludGVnZXJIZWxwZXIgPSBCaWdJbnRlZ2VySGVscGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZbWxuU1c1MFpXZGxja2hsYkhCbGNpNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5b1pXeHdaWEp6TDJKcFowbHVkR1ZuWlhKSVpXeHdaWEl1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN096dEJRVUZCTERSRlFVRjVSVHRCUVVONlJTdzBSVUZCZVVVN1FVRkRla1VzZFVOQlFYVkRPMEZCUTNaRExEaEVRVUZwUXp0QlFVTnFReXh6UkVGQmJVUTdRVUZGYmtRN096dEhRVWRITzBGQlEwZzdTVUZoU1RzN096czdUMEZMUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4TFFVRm5RaXhGUVVGRkxFMUJRV01zUlVGQlJTeE5RVUZqTzFGQlF6VkZMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhGUVVGRkxGTkJRVk1zUTBGQlF5eEpRVUZKTEV0QlFVc3NRMEZCUXl4TlFVRk5MRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU12UkN4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eDVRMEZCZVVNc1EwRkJReXhEUVVGRE8xRkJRM0pGTEVOQlFVTTdVVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJoRUxFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMR3REUVVGclF5eERRVUZETEVOQlFVTTdVVUZET1VRc1EwRkJRenRSUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NUVUZCVFN4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFrUXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zYVVOQlFXbERMRU5CUVVNc1EwRkJRenRSUVVNM1JDeERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hIUVVGSExFMUJRVTBzUjBGQlJ5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOcVF5eE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXgxUkVGQmRVUXNRMEZCUXl4RFFVRkRPMUZCUTI1R0xFTkJRVU03VVVGRlJDeEpRVUZKTEV0QlFVc3NSMEZCUnl4eFFrRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dFJRVVY0UWl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXp0WlFVTnVReXhMUVVGTExFZEJRVWNzUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4blFrRkJaMElzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc2NVSkJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5zUml4RFFVRkRPMUZCUlVRc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dEpRVU5xUWl4RFFVRkRPMGxCUlVRN096czdPenRQUVUxSE8wbEJRMGtzVFVGQlRTeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFdEJRWGRDTEVWQlFVVXNTMEZCWjBJc1JVRkJSU3hOUVVGakxFVkJRVVVzVFVGQll6dFJRVU4wUnl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1JVRkJSU3h4UWtGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNSRExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMSEZEUVVGeFF5eERRVUZETEVOQlFVTTdVVUZEYWtVc1EwRkJRenRSUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eEZRVUZGTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONlF5eE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhuUTBGQlowTXNRMEZCUXl4RFFVRkRPMUZCUXpWRUxFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyaEVMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEd0RFFVRnJReXhEUVVGRExFTkJRVU03VVVGRE9VUXNRMEZCUXp0UlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzVFVGQlRTeEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha1FzVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2FVTkJRV2xETEVOQlFVTXNRMEZCUXp0UlFVTTNSQ3hEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRTFCUVUwc1IwRkJSeXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnFReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4MVJFRkJkVVFzUTBGQlF5eERRVUZETzFGQlEyNUdMRU5CUVVNN1VVRkZSQ3hKUVVGSkxHRkJRV0VzUjBGQlJ5eExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMSEZDUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJRenRSUVVVNVJTeEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRE8xbEJRemxDTEUxQlFVMHNXVUZCV1N4SFFVRkhMR0ZCUVdFc1EwRkJReXhOUVVGTkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03V1VGRGJFVXNZVUZCWVN4SFFVRkhMRmxCUVZrc1EwRkJReXhSUVVGUkxFTkJRVU03V1VGRGRFTXNTVUZCU1N4VFFVRlRMRWRCUVVjc1dVRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF6dFpRVVYyUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhUUVVGVExFZEJRVWNzWjBKQlFXZENMRU5CUVVNc1kwRkJZeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZET1VNc1UwRkJVeXhIUVVGSExHZENRVUZuUWl4RFFVRkRMR05CUVdNc1EwRkJRenRuUWtGRE5VTXNZVUZCWVN4SFFVRkhMR0ZCUVdFc1EwRkJReXhIUVVGSExFTkJRVU1zY1VKQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMjVFTEVOQlFVTTdXVUZEUkN4TFFVRkxMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEZOQlFWTXNRMEZCUXl4VlFVRlZMRVZCUVVVc1EwRkJRenRSUVVNdlF5eERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eHhRa0ZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYmtNc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXp0blFrRkRPVUlzYzBKQlFYTkNPMmRDUVVOMFFpeExRVUZMTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZSU3hEUVVGRE8xRkJRMHdzUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZGUkRzN096czdUMEZMUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4TFFVRjNRaXhGUVVGRkxGZEJRWGRDTEVWQlFVVXNUVUZCWXp0UlFVTTVSaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJTeHhRa0ZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM1JETEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExIRkRRVUZ4UXl4RFFVRkRMRU5CUVVNN1VVRkRha1VzUTBGQlF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RlFVRkZMRmRCUVZjc1EwRkJReXhKUVVGSkxGZEJRVmNzUTBGQlF5eFZRVUZWTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOcVJpeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhyUTBGQmEwTXNRMEZCUXl4RFFVRkRPMUZCUXpsRUxFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyaEVMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEd0RFFVRnJReXhEUVVGRExFTkJRVU03VVVGRE9VUXNRMEZCUXp0UlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExGZEJRVmNzUTBGQlF5eFZRVUZWTEVkQlFVY3NUVUZCVFN4SFFVRkhMR2RDUVVGblFpeERRVUZETEdkQ1FVRm5RaXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4wUlN4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5d3lSRUZCTWtRc1owSkJRV2RDTEVOQlFVTXNaMEpCUVdkQ0xFVkJRVVVzUTBGQlF5eERRVUZETzFGQlF6RklMRU5CUVVNN1VVRkZSQ3gxUTBGQmRVTTdVVUZEZGtNc1RVRkJUU3hMUVVGTExFZEJRVWNzUzBGQlN5eERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUlRGRExFbEJRVWtzVTBGQlV5eEhRVUZITEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRmJrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTm1MSGRDUVVGM1FqdFpRVU40UWl4VFFVRlRMRWRCUVVjc1UwRkJVeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnVReXhEUVVGRE8xRkJRMFFzYjBWQlFXOUZPMUZCUTNCRkxFVkJRVVVzUTBGQlF5eERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETjBJc1UwRkJVeXhIUVVGSExFbEJRVWtzVTBGQlV5eEZRVUZGTEVOQlFVTTdVVUZEYUVNc1EwRkJRenRSUVVORUxFMUJRVTBzVDBGQlR5eEhRVUZITEZOQlFWTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1kwRkJZeXhEUVVGRExFTkJRVU03VVVGRmFFUXNOa0pCUVRaQ08xRkJRemRDTEUxQlFVMHNWMEZCVnl4SFFVRkhMRWxCUVVrc1UwRkJVeXhEUVVGRExFOUJRVTg3WVVGRGNFTXNSMEZCUnl4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NSMEZCUnl4RlFVRkZMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlJUTkRMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRaaXhuUWtGQlowSXNRMEZCUXl4alFVRmpMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU03VVVGRGFrUXNRMEZCUXp0UlFVVkVMRTFCUVUwc1VVRkJVU3hIUVVGSExFbEJRVWtzVVVGQlVTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMUZCUlRORExHbEVRVUZwUkR0UlFVTnFSQ3hKUVVGSkxFTkJRVU1zUjBGQlJ5eE5RVUZOTEVOQlFVTTdVVUZEWml4UFFVRlBMRU5CUVVNc1IwRkJSeXhYUVVGWExFTkJRVU1zVFVGQlRTeEhRVUZITEdkQ1FVRm5RaXhEUVVGRExHZENRVUZuUWl4RlFVRkZMRU5CUVVNN1dVRkRhRVVzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRVZCUVVVc1JVRkJSU3hMUVVGTExFTkJRVU1zUTBGQlF6dFJRVU5xUXl4RFFVRkRPMUZCUTBRc0swSkJRU3RDTzFGQlF5OUNMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEZkQlFWY3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTTdXVUZEZUVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVWQlFVVXNSVUZCUlN4WFFVRlhMRU5CUVVNc1YwRkJWeXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOdVJTeERRVUZETzBsQlEwd3NRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1RVRkJUU3hEUVVGRExHbENRVUZwUWl4RFFVRkRMRTFCUVcxQ0xFVkJRVVVzVFVGQll5eEZRVUZGTEUxQlFXTTdVVUZETDBVc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFVkJRVVVzVjBGQlZ5eERRVUZETEVsQlFVa3NUVUZCVFN4RFFVRkRMRlZCUVZVc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzWkZMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETERaRFFVRTJReXhEUVVGRExFTkJRVU03VVVGRGVrVXNRMEZCUXp0UlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRhRVFzVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2EwTkJRV3RETEVOQlFVTXNRMEZCUXp0UlFVTTVSQ3hEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4TlFVRk5MRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5xUkN4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eHBRMEZCYVVNc1EwRkJReXhEUVVGRE8xRkJRemRFTEVOQlFVTTdVVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlZTeEhRVUZITEUxQlFVMHNSMEZCUnl4blFrRkJaMElzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFrVXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zYzBSQlFYTkVMR2RDUVVGblFpeERRVUZETEdkQ1FVRm5RaXhGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVU55U0N4RFFVRkRPMUZCUlVRc1RVRkJUU3hSUVVGUkxFZEJRVWNzU1VGQlNTeFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkZkRU1zU1VGQlNTeFhRVUZYTEVkQlFVY3NTVUZCU1N4VFFVRlRMRU5CUVVNc1VVRkJVU3hEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETzFGQlEzSkVMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1VVRkJVU3hEUVVGRExGVkJRVlVzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRPMWxCUXpORExGZEJRVmNzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUjBGQlJ5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTnNSQ3hEUVVGRE8xRkJSVVFzZFVSQlFYVkVPMUZCUTNaRUxFbEJRVWtzWVVGQllTeEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVTjBRaXhOUVVGTkxGTkJRVk1zUjBGQlJ5eFhRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRha01zVFVGQlRTeExRVUZMTEVkQlFVY3NVMEZCVXl4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVVMVFpdzBSVUZCTkVVN1VVRkROVVVzZVVOQlFYbERPMUZCUTNwRExFVkJRVVVzUTBGQlF5eERRVUZETEZOQlFWTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1UwRkJVeXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjBReXhQUVVGUExGZEJRVmNzUTBGQlF5eGhRVUZoTEVOQlFVTXNTMEZCU3l4VFFVRlRMRWxCUVVrc1lVRkJZU3hIUVVGSExGZEJRVmNzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNN1owSkJRM2hHTEdGQlFXRXNSVUZCUlN4RFFVRkRPMWxCUTNCQ0xFTkJRVU03V1VGRFJDeHZRa0ZCYjBJN1dVRkRjRUlzVjBGQlZ5eEhRVUZITEZkQlFWY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1lVRkJZU3hEUVVGRExFTkJRVU03VVVGRGJrUXNRMEZCUXp0UlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEVWl4blFrRkJaMElzUTBGQlF5eGpRVUZqTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNN1VVRkRha1FzUTBGQlF6dFJRVVZFTEVsQlFVa3NVMEZCVXl4SFFVRkhMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNN1VVRkRha01zVFVGQlRTeEZRVUZGTEVkQlFVY3NTVUZCU1N4UlFVRlJMRU5CUVVNc1YwRkJWeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlF6VkRMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRExGVkJRVlVzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRPMWxCUTNKRExGTkJRVk1zU1VGQlNTeExRVUZMTEVWQlFVVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZET1VRc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eHhRa0ZCVFN4RFFVRkRMRk5CUVZNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEpRVU5xUXl4RFFVRkRPMGxCUlVRc1pVRkJaVHRKUVVOUUxFMUJRVTBzUTBGQlF5eGpRVUZqTEVOQlFVTXNWMEZCYzBJN1VVRkRhRVFzZFVOQlFYVkRPMUZCUTNaRExITkVRVUZ6UkR0UlFVTjBSQ3d3UTBGQk1FTTdVVUZETVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhYUVVGWExFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNN1dVRkRNVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzSkRMRU5CUVVNN1VVRkRSQ3huUlVGQlowVTdVVUZEYUVVc1NVRkJTU3hEUVVGRExFZEJRVWNzVjBGQlZ5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRMMElzUjBGQlJ5eERRVUZETzFsQlEwRXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU03VVVGRGNrSXNRMEZCUXl4UlFVRlJMRmRCUVZjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRk8wbEJRemxETEVOQlFVTTdPMEZCYUU5RUxHVkJRV1U3UVVGRFV5eHpRa0ZCU3l4SFFVRnpRaXh4UWtGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUXpkRUxHVkJRV1U3UVVGRFV5d3JRa0ZCWXl4SFFVRnpRaXhuUWtGQlowSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRCUVVOMFJ5eGxRVUZsTzBGQlExTXNLMEpCUVdNc1IwRkJjMElzWjBKQlFXZENMRU5CUVVNc1kwRkJZeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETzBGQlJYSkhMR1ZCUVdVN1FVRkRVeXhuUTBGQlpTeEhRVUZYTEVkQlFVY3NRMEZCUXp0QlFVTjBSQ3hsUVVGbE8wRkJRMU1zYVVOQlFXZENMRWRCUVZjc1owSkJRV2RDTEVOQlFVTXNaVUZCWlN4SFFVRkhMRU5CUVVNc1EwRkJRenRCUVZnMVJpdzBRMEZyVDBNaWZRPT1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL2hlbHBlcnMvYmlnSW50ZWdlckhlbHBlci50cyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zOF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIHtcImFtZFwiOlwiYmlnLWludGVnZXJcIixcImNvbW1vbmpzXCI6XCJiaWctaW50ZWdlclwiLFwiY29tbW9uanMyXCI6XCJiaWctaW50ZWdlclwiLFwicm9vdFwiOlwiYmlnSW50XCJ9XG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHNwb25nZUZhY3RvcnlfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NyeXB0by9kaXN0L2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5XCIpO1xyXG5jb25zdCB0cml0c18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJpdHNcIik7XHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgZm9yIGFkZHJlc3Mgc2lnbmluZy5cclxuICogT3JpZ2luYWwgaHR0cHM6Ly9naXRodWIuY29tL2lvdGFsZWRnZXIvaW90YS5saWIuanMvYmxvYi9tYXN0ZXIvbGliL2NyeXB0by9zaWduaW5nL3NpZ25pbmcuanNcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBBZGRyZXNzSGVscGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgY2hlY2tzdW0gZm9yIHRoZSB0cml0cy5cclxuICAgICAqIEBwYXJhbSB0cml0cyBUaGUgdHJpdHMgdG8gY3JlYXRlIHRoZSBjaGVja3N1bSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gY2hlY2tzdW1MZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgY2hlY2tzdW0uXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgY2hlY2tzdW0gYXMgdHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlQ2hlY2tzdW0odHJpdHMsIGNoZWNrc3VtTGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3Qga2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFwia2VybFwiKTtcclxuICAgICAgICBrZXJsLmluaXRpYWxpemUoKTtcclxuICAgICAgICBrZXJsLmFic29yYih0cml0cywgMCwgdHJpdHMubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBjaGVja3N1bVRyaXRzID0gbmV3IEludDhBcnJheShrZXJsLmdldENvbnN0YW50KFwiSEFTSF9MRU5HVEhcIikpO1xyXG4gICAgICAgIGtlcmwuc3F1ZWV6ZShjaGVja3N1bVRyaXRzLCAwLCBjaGVja3N1bVRyaXRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGNoZWNrc3VtVHJpdHMpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoODEgLSBjaGVja3N1bUxlbmd0aCwgODEpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQWRkcmVzc0hlbHBlciA9IEFkZHJlc3NIZWxwZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVlXUmtjbVZ6YzBobGJIQmxjaTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OW9aV3h3WlhKekwyRmtaSEpsYzNOSVpXeHdaWEl1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJMR3RHUVVFclJUdEJRVU12UlN3eVJFRkJkMFE3UVVGRmVFUTdPenM3UjBGSlJ6dEJRVU5JTzBsQlEwazdPenM3TzA5QlMwYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1kwRkJZeXhEUVVGRExFdEJRV2RDTEVWQlFVVXNZMEZCYzBJN1VVRkRha1VzVFVGQlRTeEpRVUZKTEVkQlFVY3NOa0pCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRja1FzU1VGQlNTeERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRPMUZCUld4Q0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1JVRkJSU3hMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZGY0VNc1RVRkJUU3hoUVVGaExFZEJRVWNzU1VGQlNTeFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzSkZMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zWVVGQllTeEZRVUZGTEVOQlFVTXNSVUZCUlN4aFFVRmhMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03VVVGRmNrUXNUVUZCVFN4RFFVRkRMR0ZCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zWVVGQllTeERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVTBGQlV5eERRVUZETEVWQlFVVXNSMEZCUnl4alFVRmpMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03U1VGRGJrY3NRMEZCUXp0RFFVTktPMEZCYkVKRUxITkRRV3RDUXlKOVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvaGVscGVycy9hZGRyZXNzSGVscGVyLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBzcG9uZ2VGYWN0b3J5XzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jcnlwdG8vZGlzdC9mYWN0b3JpZXMvc3BvbmdlRmFjdG9yeVwiKTtcclxuY29uc3Qgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRcIik7XHJcbmNvbnN0IHRyaXRzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cml0c1wiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cnl0ZXNcIik7XHJcbi8qKlxyXG4gKiBIYXNoZWQgTWVzc2FnZSBBdXRoZW50aWNhdGlvbiBDb2RlIHVzaW5nIEN1cmwuXHJcbiAqL1xyXG5jbGFzcyBIbWFjQ3VybCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgSG1hY0N1cmwuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gc2VlZCB3aXRoLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcclxuICAgICAgICB0aGlzLl9rZXlUcml0cyA9IHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyhrZXkpLnRvQXJyYXkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGJ1bmRsZSB0byB0aGUgSE1BQy5cclxuICAgICAqL1xyXG4gICAgYWRkSE1BQyhidW5kbGUpIHtcclxuICAgICAgICBjb25zdCBjdXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXCJjdXJsXCIsIEhtYWNDdXJsLkhNQUNfUk9VTkRTKTtcclxuICAgICAgICBjb25zdCBoYXNoTGVuZ3RoID0gY3VybC5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuX2tleVRyaXRzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS52YWx1ZS50b051bWJlcigpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVuZGxlSGFzaFRyaXRzID0gdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uYnVuZGxlLnRvVHJ5dGVzKCkpLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhtYWMgPSBuZXcgSW50OEFycmF5KGhhc2hMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY3VybC5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICBjdXJsLmFic29yYihrZXksIDAsIGtleS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY3VybC5hYnNvcmIoYnVuZGxlSGFzaFRyaXRzLCAwLCBidW5kbGVIYXNoVHJpdHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGN1cmwuc3F1ZWV6ZShobWFjLCAwLCBobWFjLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBobWFjVHJ5dGVzID0gdHJpdHNfMS5Ucml0cy5mcm9tQXJyYXkoaG1hYykudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdCA9IGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LnRvVHJ5dGVzKCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoODEsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEgpO1xyXG4gICAgICAgICAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPVxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKGhtYWNUcnl0ZXMgKyByZXN0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyogQGludGVybmFsICovXHJcbkhtYWNDdXJsLkhNQUNfUk9VTkRTID0gMjc7XHJcbmV4cG9ydHMuSG1hY0N1cmwgPSBIbWFjQ3VybDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYUcxaFkwTjFjbXd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZjMmxuYmk5b2JXRmpRM1Z5YkM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzYTBaQlFTdEZPMEZCUlM5RkxHbEhRVUU0Ump0QlFVTTVSaXd5UkVGQmQwUTdRVUZEZUVRc05rUkJRVEJFTzBGQlJURkVPenRIUVVWSE8wRkJRMGc3U1VGTlNUczdPMDlCUjBjN1NVRkRTQ3haUVVGWkxFZEJRVmM3VVVGRGJrSXNTVUZCU1N4RFFVRkRMRk5CUVZNc1IwRkJSeXhoUVVGTExFTkJRVU1zVlVGQlZTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRE8wbEJRM0pFTEVOQlFVTTdTVUZGUkRzN1QwRkZSenRKUVVOSkxFOUJRVThzUTBGQlF5eE5RVUZqTzFGQlEzcENMRTFCUVUwc1NVRkJTU3hIUVVGSExEWkNRVUZoTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUlVGQlJTeFJRVUZSTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNN1VVRkRNMFVzVFVGQlRTeFZRVUZWTEVkQlFVY3NTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlF6dFJRVU51UkN4TlFVRk5MRWRCUVVjc1IwRkJSeXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETzFGQlF6TkNMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJRenRaUVVOc1JDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4UlFVRlJMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTTVReXhOUVVGTkxHVkJRV1VzUjBGQlJ5eGhRVUZMTEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTTdaMEpCUXpkR0xFMUJRVTBzU1VGQlNTeEhRVUZITEVsQlFVa3NVMEZCVXl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRE8yZENRVU4yUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFTkJRVU03WjBKQlEyeENMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEyaERMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zWlVGQlpTeEZRVUZGTEVOQlFVTXNSVUZCUlN4bFFVRmxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEzaEVMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNSVUZCUlN4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEyNURMRTFCUVUwc1ZVRkJWU3hIUVVGSExHRkJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdaMEpCUXk5RUxFMUJRVTBzU1VGQlNTeEhRVUZITEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zZDBKQlFYZENMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVMEZCVXl4RFFVRkRMRVZCUVVVc1JVRkJSU3h0UkVGQmQwSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRuUWtGRGJFa3NUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eDNRa0ZCZDBJN2IwSkJRek5ETEcxRVFVRjNRaXhEUVVGRExGVkJRVlVzUTBGQlF5eGxRVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRlZCUVZVc1IwRkJSeXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyeEdMRU5CUVVNN1VVRkRUQ3hEUVVGRE8wbEJRMHdzUTBGQlF6czdRVUZzUTBRc1pVRkJaVHRCUVVOVExHOUNRVUZYTEVkQlFWY3NSVUZCUlN4RFFVRkRPMEZCUm5KRUxEUkNRVzlEUXlKOVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvc2lnbi9obWFjQ3VybC50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgYXJyYXlIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3Qgc3BvbmdlRmFjdG9yeV8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnlcIik7XHJcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2FkZHJlc3NcIik7XHJcbmNvbnN0IHRyaXRzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cml0c1wiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cnl0ZXNcIik7XHJcbmNvbnN0IGJ1c2luZXNzRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9idXNpbmVzc0Vycm9yXCIpO1xyXG4vKipcclxuICogQWRkcmVzcyB1c2luZyBtdWx0aXBsZSBzaWduYXR1cmVzLlxyXG4gKi9cclxuY2xhc3MgTXVsdGlTaWdBZGRyZXNzIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBNdWx0aVNpZ0FkZHJlc3MuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2tlcmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcImtlcmxcIik7XHJcbiAgICAgICAgdGhpcy5faGFzaExlbmd0aCA9IHRoaXMuX2tlcmwuZ2V0Q29uc3RhbnQoXCJIQVNIX0xFTkdUSFwiKTtcclxuICAgICAgICB0aGlzLl9rZXJsLmluaXRpYWxpemUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWJzb3JiIGtleSBkaWdlc3RzLlxyXG4gICAgICogQHBhcmFtIGRpZ2VzdHMgVGhlIGRpZ2VzdHMgaGFzaGVzIHRvIGFic29yYi5cclxuICAgICAqL1xyXG4gICAgYWJzb3JiKGRpZ2VzdHMpIHtcclxuICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChkaWdlc3RzLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBkaWdlc3RzIHNob3VsZCBiZSBhbiBhcnJheSBvZiB0eXBlIFRyeXRlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWdlc3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpZ2VzdFRyaXRzID0gdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKGRpZ2VzdHNbaV0pLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgdGhpcy5fa2VybC5hYnNvcmIoZGlnZXN0VHJpdHMsIDAsIGRpZ2VzdFRyaXRzLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5hbGl6ZXMgYW5kIHJldHVybnMgdGhlIG11bHRpc2lnIGFkZHJlc3MgaW4gdHJ5dGVzLlxyXG4gICAgICogQHBhcmFtIGRpZ2VzdHMgVGhlIGZpbmFsIGRpZ2VzdHMgaGFzaGVzIHRvIGFic29yYi5cclxuICAgICAqIEByZXR1cm5zIFRoZSBtdWx0aSBzaWduYXR1cmUgYWRkcmVzcy5cclxuICAgICAqL1xyXG4gICAgZmluYWxpemUoZGlnZXN0cykge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkoZGlnZXN0cykpIHtcclxuICAgICAgICAgICAgdGhpcy5hYnNvcmIoZGlnZXN0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFkZHJlc3NUcml0cyA9IG5ldyBJbnQ4QXJyYXkodGhpcy5faGFzaExlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fa2VybC5zcXVlZXplKGFkZHJlc3NUcml0cywgMCwgYWRkcmVzc1RyaXRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGFkZHJlc3NfMS5BZGRyZXNzLmZyb21Ucnl0ZXModHJpdHNfMS5Ucml0cy5mcm9tQXJyYXkoYWRkcmVzc1RyaXRzKS50b1RyeXRlcygpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk11bHRpU2lnQWRkcmVzcyA9IE11bHRpU2lnQWRkcmVzcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYlhWc2RHbFRhV2RCWkdSeVpYTnpMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyMTFiSFJwVTJsbkwyMTFiSFJwVTJsblFXUmtjbVZ6Y3k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzTUVWQlFYVkZPMEZCUTNaRkxEUkZRVUY1UlR0QlFVTjZSU3hyUmtGQkswVTdRVUZGTDBVc0swUkJRVFJFTzBGQlF6VkVMREpFUVVGM1JEdEJRVU40UkN3MlJFRkJNRVE3UVVGRE1VUXNNRVJCUVhWRU8wRkJSWFpFT3p0SFFVVkhPMEZCUTBnN1NVRlBTVHM3VDBGRlJ6dEpRVU5JTzFGQlEwa3NTVUZCU1N4RFFVRkRMRXRCUVVzc1IwRkJSeXcyUWtGQllTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVU55UkN4SlFVRkpMRU5CUVVNc1YwRkJWeXhIUVVGSExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCVnl4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRE8xRkJRM3BFTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFTkJRVU03U1VGRE5VSXNRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4UFFVRnBRanRSUVVNelFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNSVUZCUlN4bFFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGVFTXNUVUZCVFN4SlFVRkpMRFpDUVVGaExFTkJRVU1zSzBOQlFTdERMRU5CUVVNc1EwRkJRenRSUVVNM1JTeERRVUZETzFGQlEwUXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTTdXVUZEZEVNc1RVRkJUU3hYUVVGWExFZEJRVWNzWVVGQlN5eERRVUZETEZWQlFWVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXp0WlFVVXpSQ3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4WFFVRlhMRVZCUVVVc1EwRkJReXhGUVVGRkxGZEJRVmNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTXhSQ3hEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeFJRVUZSTEVOQlFVTXNUMEZCYTBJN1VVRkRPVUlzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha01zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVONlFpeERRVUZETzFGQlJVUXNUVUZCVFN4WlFVRlpMRWRCUVVjc1NVRkJTU3hUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMUZCUTNKRUxFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRmxCUVZrc1JVRkJSU3hEUVVGRExFVkJRVVVzV1VGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUlhwRUxFMUJRVTBzUTBGQlF5eHBRa0ZCVHl4RFFVRkRMRlZCUVZVc1EwRkJReXhoUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU03U1VGRGVFVXNRMEZCUXp0RFFVTktPMEZCT1VORUxEQkRRVGhEUXlKOVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvbXVsdGlTaWcvbXVsdGlTaWdBZGRyZXNzLnRzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lvdGEtcGljby1idXNpbmVzcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pb3RhLXBpY28tcGFsLWJyb3dzZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG5ldHdvcmtFcnJvcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2Vycm9yL25ldHdvcmtFcnJvclwiKTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBzdHJpbmdIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL3N0cmluZ0hlbHBlclwiKTtcclxuY29uc3QgbnVsbExvZ2dlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2xvZ2dlcnMvbnVsbExvZ2dlclwiKTtcclxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgbm9kZSBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cclxuICovXHJcbmNsYXNzIE5ldHdvcmtDbGllbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgTmV0d29ya0NsaWVudC5cclxuICAgICAqIEBwYXJhbSBuZXR3b3JrRW5kUG9pbnQgVGhlIGVuZHBvaW50IHRvIHVzZSBmb3IgdGhlIGNsaWVudC5cclxuICAgICAqIEBwYXJhbSBsb2dnZXIgTG9nZ2VyIHRvIHNlbmQgY29tbXVuaWNhdGlvbiBpbmZvIHRvLlxyXG4gICAgICogQHBhcmFtIHRpbWVvdXRNcyBUaGUgdGltZW91dCBpbiBtcyBiZWZvcmUgYWJvcnRpbmcuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmtFbmRQb2ludCwgbG9nZ2VyLCB0aW1lb3V0TXMgPSAwKSB7XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KG5ldHdvcmtFbmRQb2ludCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IG5ldHdvcmtFcnJvcl8xLk5ldHdvcmtFcnJvcihcIlRoZSBuZXR3b3JrRW5kUG9pbnQgbXVzdCBiZSBkZWZpbmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIodGltZW91dE1zKSB8fCB0aW1lb3V0TXMgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBuZXR3b3JrRXJyb3JfMS5OZXR3b3JrRXJyb3IoXCJUaGUgdGltZW91dE1zIG11c3QgYmUgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbmV0d29ya0VuZFBvaW50ID0gbmV0d29ya0VuZFBvaW50O1xyXG4gICAgICAgIHRoaXMuX3RpbWVvdXRNcyA9IHRpbWVvdXRNcztcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXIgfHwgbmV3IG51bGxMb2dnZXJfMS5OdWxsTG9nZ2VyKCk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmJhbm5lcihcIk5ldHdvcmsgQ2xpZW50XCIsIHsgZW5kUG9pbnQ6IHRoaXMuX25ldHdvcmtFbmRQb2ludCB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGRhdGEgYXN5bmNocm9ub3VzbHkuXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbFBhdGggQW4gYWRkaXRpb25hbCBwYXRoIGFwcGVuZCB0byB0aGUgZW5kcG9pbnQgcGF0aC5cclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsSGVhZGVycyBFeHRyYSBoZWFkZXJzIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdC5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG9iamVjdCByZXR1cm5lZCBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldChhZGRpdGlvbmFsUGF0aCwgYWRkaXRpb25hbEhlYWRlcnMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gTmV0d29ya0NsaWVudDo6R0VUIFNlbmRcIik7XHJcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZG9SZXF1ZXN0KFwiR0VUXCIsIHVuZGVmaW5lZCwgYWRkaXRpb25hbFBhdGgsIGFkZGl0aW9uYWxIZWFkZXJzKTtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gTmV0d29ya0NsaWVudDo6R0VUIFJlY2VpdmVkXCIsIHJlc3ApO1xyXG4gICAgICAgIHJldHVybiByZXNwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3N0IGRhdGEgYXN5bmNocm9ub3VzbHkuXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbFBhdGggQW4gYWRkaXRpb25hbCBwYXRoIGFwcGVuZCB0byB0aGUgZW5kcG9pbnQgcGF0aC5cclxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHNlbmQuXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEhlYWRlcnMgRXh0cmEgaGVhZGVycyB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBvYmplY3QgcmV0dXJuZWQgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBwb3N0KGRhdGEsIGFkZGl0aW9uYWxQYXRoLCBhZGRpdGlvbmFsSGVhZGVycykge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBOZXR3b3JrQ2xpZW50OjpQT1NUIFNlbmRcIiwgZGF0YSk7XHJcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZG9SZXF1ZXN0KFwiUE9TVFwiLCBkYXRhLCBhZGRpdGlvbmFsUGF0aCwgYWRkaXRpb25hbEhlYWRlcnMpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBOZXR3b3JrQ2xpZW50OjpQT1NUIFJlY2VpdmVkXCIsIHJlc3ApO1xyXG4gICAgICAgIHJldHVybiByZXNwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgZGF0YSBhcyBKU09OIGFzeW5jaHJvbm91c2x5LlxyXG4gICAgICogQHR5cGVwYXJhbSBVIFRoZSBnZW5lcmljIHR5cGUgZm9yIHRoZSByZXR1cm5lZCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbFBhdGggQW4gYWRkaXRpb25hbCBwYXRoIGFwcGVuZCB0byB0aGUgZW5kcG9pbnQgcGF0aC5cclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsSGVhZGVycyBFeHRyYSBoZWFkZXJzIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdC5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG9iamVjdCByZXR1cm5lZCBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEpzb24oYWRkaXRpb25hbFBhdGgsIGFkZGl0aW9uYWxIZWFkZXJzKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IE5ldHdvcmtDbGllbnQ6OkdFVCBTZW5kXCIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvUmVxdWVzdChcIkdFVFwiLCB1bmRlZmluZWQsIGFkZGl0aW9uYWxQYXRoLCBhZGRpdGlvbmFsSGVhZGVycylcclxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gTmV0d29ya0NsaWVudDo6R0VUIFJlY2VpdmVkXCIsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gTmV0d29ya0NsaWVudDo6R0VUIFBhcnNlIEZhaWxlZFwiLCByZXNwb25zZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgKG5ldyBuZXR3b3JrRXJyb3JfMS5OZXR3b3JrRXJyb3IoXCJGYWlsZWQgR0VUIHJlcXVlc3QsIHVuYWJsZSB0byBwYXJzZSByZXNwb25zZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kUG9pbnQ6IHRoaXMuX25ldHdvcmtFbmRQb2ludC5nZXRVcmkoKSxcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VEYXRhXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUG9zdCBkYXRhIGFzIEpTT04gYXN5bmNocm9ub3VzbHkuXHJcbiAgICAgKiBAdHlwZXBhcmFtIFQgVGhlIGdlbmVyaWMgdHlwZSBmb3IgdGhlIG9iamVjdCB0byBzZW5kLlxyXG4gICAgICogQHR5cGVwYXJhbSBVIFRoZSBnZW5lcmljIHR5cGUgZm9yIHRoZSByZXR1cm5lZCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBzZW5kLlxyXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxQYXRoIEFuIGFkZGl0aW9uYWwgcGF0aCBhcHBlbmQgdG8gdGhlIGVuZHBvaW50IHBhdGguXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEhlYWRlcnMgRXh0cmEgaGVhZGVycyB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBvYmplY3QgcmV0dXJuZWQgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBwb3N0SnNvbihkYXRhLCBhZGRpdGlvbmFsUGF0aCwgYWRkaXRpb25hbEhlYWRlcnMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gTmV0d29ya0NsaWVudDo6UE9TVCBTZW5kXCIpO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhZGRpdGlvbmFsSGVhZGVycyB8fCB7fTtcclxuICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9SZXF1ZXN0KFwiUE9TVFwiLCBKU09OLnN0cmluZ2lmeShkYXRhKSwgYWRkaXRpb25hbFBhdGgsIGhlYWRlcnMpXHJcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZURhdGEpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwb25zZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IE5ldHdvcmtDbGllbnQ6OlBPU1QgUmVjZWl2ZWRcIiwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBOZXR3b3JrQ2xpZW50OjpHRVQgUGFyc2UgRmFpbGVkXCIsIHJlc3BvbnNlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyAobmV3IG5ldHdvcmtFcnJvcl8xLk5ldHdvcmtFcnJvcihcIkZhaWxlZCBQT1NUIHJlcXVlc3QsIHVuYWJsZSB0byBwYXJzZSByZXNwb25zZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kUG9pbnQ6IHRoaXMuX25ldHdvcmtFbmRQb2ludC5nZXRVcmkoKSxcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VEYXRhXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgYXN5bmMgZG9SZXF1ZXN0KG1ldGhvZCwgZGF0YSwgYWRkaXRpb25hbFBhdGgsIGFkZGl0aW9uYWxIZWFkZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGFkZGl0aW9uYWxIZWFkZXJzIHx8IHt9O1xyXG4gICAgICAgICAgICBsZXQgdXJpID0gdGhpcy5fbmV0d29ya0VuZFBvaW50LmdldFVyaSgpO1xyXG4gICAgICAgICAgICBpZiAoIXN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KGFkZGl0aW9uYWxQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXBwZWQgPSBgLyR7YWRkaXRpb25hbFBhdGgucmVwbGFjZSgvXlxcLyovLCBcIlwiKX1gO1xyXG4gICAgICAgICAgICAgICAgdXJpICs9IHN0cmlwcGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGltZW91dE1zID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVxLnRpbWVvdXQgPSB0aGlzLl90aW1lb3V0TXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVxLm9udGltZW91dCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcIjw9PT0gTmV0d29ya0NsaWVudDo6VGltZWQgT3V0XCIpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBuZXR3b3JrRXJyb3JfMS5OZXR3b3JrRXJyb3IoYEZhaWxlZCAke21ldGhvZH0gcmVxdWVzdCwgdGltZWQgb3V0YCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZFBvaW50OiB1cmksXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXNwb25zZUNvZGU6IHJlcS5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXNwb25zZTogcmVxLnJlc3BvbnNlVGV4dCB8fCByZXEuc3RhdHVzVGV4dFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXEub25lcnJvciA9IChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcIjw9PT0gTmV0d29ya0NsaWVudDo6RXJyb3JlZFwiKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgbmV0d29ya0Vycm9yXzEuTmV0d29ya0Vycm9yKGBGYWlsZWQgJHttZXRob2R9IHJlcXVlc3RgLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kUG9pbnQ6IHVyaSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlQ29kZTogcmVxLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlOiByZXEucmVzcG9uc2VUZXh0IHx8IHJlcS5zdGF0dXNUZXh0XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcS5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXEucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBOZXR3b3JrQ2xpZW50OjpSZWNlaXZlZCBGYWlsXCIsIHsgY29kZTogcmVxLnN0YXR1cywgZGF0YTogcmVxLnJlc3BvbnNlVGV4dCB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IG5ldHdvcmtFcnJvcl8xLk5ldHdvcmtFcnJvcihgRmFpbGVkICR7bWV0aG9kfSByZXF1ZXN0YCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRQb2ludDogdXJpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlQ29kZTogcmVxLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXNwb25zZTogcmVxLnJlc3BvbnNlVGV4dCB8fCByZXEuc3RhdHVzVGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxLm9wZW4obWV0aG9kLCB1cmksIHRydWUpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IE5ldHdvcmtDbGllbnQ6OlNlbmRcIiwgeyBkYXRhIH0pO1xyXG4gICAgICAgICAgICByZXEuc2VuZChkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk5ldHdvcmtDbGllbnQgPSBOZXR3b3JrQ2xpZW50O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2libVYwZDI5eWEwTnNhV1Z1ZEM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl1WlhSM2IzSnJMMjVsZEhkdmNtdERiR2xsYm5RdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTERCRlFVRjFSVHRCUVVOMlJTdzBSVUZCZVVVN1FVRkRla1VzTkVWQlFYbEZPMEZCUTNwRkxEUkZRVUY1UlR0QlFVbDZSU3gzUlVGQmNVVTdRVUZGY2tVN08wZEJSVWM3UVVGRFNEdEpRVkZKT3pzN096dFBRVXRITzBsQlEwZ3NXVUZCV1N4bFFVRnBReXhGUVVGRkxFMUJRV2RDTEVWQlFVVXNXVUZCYjBJc1EwRkJRenRSUVVOc1JpeEZRVUZGTEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRlRU1zVFVGQlRTeEpRVUZKTERKQ1FVRlpMRU5CUVVNc2NVTkJRWEZETEVOQlFVTXNRMEZCUXp0UlFVTnNSU3hEUVVGRE8xRkJRMFFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4VFFVRlRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4wUkN4TlFVRk5MRWxCUVVrc01rSkJRVmtzUTBGQlF5dzBRa0ZCTkVJc1EwRkJReXhEUVVGRE8xRkJRM3BFTEVOQlFVTTdVVUZEUkN4SlFVRkpMRU5CUVVNc1owSkJRV2RDTEVkQlFVY3NaVUZCWlN4RFFVRkRPMUZCUTNoRExFbEJRVWtzUTBGQlF5eFZRVUZWTEVkQlFVY3NVMEZCVXl4RFFVRkRPMUZCUXpWQ0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVkQlFVY3NUVUZCVFN4SlFVRkpMRWxCUVVrc2RVSkJRVlVzUlVGQlJTeERRVUZETzFGQlJURkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEdkQ1FVRm5RaXhGUVVGRkxFVkJRVVVzVVVGQlVTeEZRVUZGTEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZETDBVc1EwRkJRenRKUVVWRU96czdPenRQUVV0SE8wbEJRMGtzUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4alFVRjFRaXhGUVVGRkxHbENRVUZuUkR0UlFVTjBSaXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl3NFFrRkJPRUlzUTBGQlF5eERRVUZETzFGQlEyeEVMRTFCUVUwc1NVRkJTU3hIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4TFFVRkxMRVZCUVVVc1UwRkJVeXhGUVVGRkxHTkJRV01zUlVGQlJTeHBRa0ZCYVVJc1EwRkJReXhEUVVGRE8xRkJRM1pHTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExHdERRVUZyUXl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRelZFTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRhRUlzUTBGQlF6dEpRVVZFT3pzN096czdUMEZOUnp0SlFVTkpMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQldTeEZRVUZGTEdOQlFYVkNMRVZCUVVVc2FVSkJRV2RFTzFGQlEzSkhMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEN0Q1FVRXJRaXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEzcEVMRTFCUVUwc1NVRkJTU3hIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRVZCUVVVc1NVRkJTU3hGUVVGRkxHTkJRV01zUlVGQlJTeHBRa0ZCYVVJc1EwRkJReXhEUVVGRE8xRkJRMjVHTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExHMURRVUZ0UXl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRemRFTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRhRUlzUTBGQlF6dEpRVVZFT3pzN096czdUMEZOUnp0SlFVTkpMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVWtzWTBGQmRVSXNSVUZCUlN4cFFrRkJaMFE3VVVGRE4wWXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zT0VKQlFUaENMRU5CUVVNc1EwRkJRenRSUVVOc1JDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFVkJRVVVzVTBGQlV5eEZRVUZGTEdOQlFXTXNSVUZCUlN4cFFrRkJhVUlzUTBGQlF6dGhRVU55UlN4SlFVRkpMRU5CUVVNc1EwRkJReXhaUVVGWkxFVkJRVVVzUlVGQlJUdFpRVU51UWl4SlFVRkpMRU5CUVVNN1owSkJRMFFzVFVGQlRTeFJRVUZSTEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF6dG5Ra0ZETVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNhME5CUVd0RExFVkJRVVVzVVVGQlVTeERRVUZETEVOQlFVTTdaMEpCUTJoRkxFMUJRVTBzUTBGQlNTeFJRVUZSTEVOQlFVTTdXVUZEZGtJc1EwRkJRenRaUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMWdzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc2MwTkJRWE5ETEVWQlFVVXNXVUZCV1N4RFFVRkRMRU5CUVVNN1owSkJRM2hGTEUxQlFVc3NRMEZCUXl4SlFVRkpMREpDUVVGWkxFTkJRVU1zT0VOQlFUaERMRVZCUVVVN2IwSkJRMjVGTEZGQlFWRXNSVUZCUlN4SlFVRkpMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNUVUZCVFN4RlFVRkZPMjlDUVVONFF5eFJRVUZSTEVWQlFVVXNXVUZCV1R0cFFrRkRla0lzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEVWl4RFFVRkRPMUZCUTB3c1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFdDeERRVUZETzBsQlJVUTdPenM3T3pzN08wOUJVVWM3U1VGRFNTeExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRlBMRWxCUVU4c1JVRkJSU3hqUVVGMVFpeEZRVUZGTEdsQ1FVRm5SRHRSUVVNeFJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXdyUWtGQkswSXNRMEZCUXl4RFFVRkRPMUZCUlc1RUxFMUJRVTBzVDBGQlR5eEhRVUZITEdsQ1FVRnBRaXhKUVVGSkxFVkJRVVVzUTBGQlF6dFJRVU40UXl4UFFVRlBMRU5CUVVNc1kwRkJZeXhEUVVGRExFZEJRVWNzYTBKQlFXdENMRU5CUVVNN1VVRkZOME1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hGUVVGRkxFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1kwRkJZeXhGUVVGRkxFOUJRVThzUTBGQlF6dGhRVU4yUlN4SlFVRkpMRU5CUVVNc1EwRkJReXhaUVVGWkxFVkJRVVVzUlVGQlJUdFpRVU51UWl4SlFVRkpMRU5CUVVNN1owSkJRMFFzVFVGQlRTeFJRVUZSTEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF6dG5Ra0ZETVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNiVU5CUVcxRExFVkJRVVVzVVVGQlVTeERRVUZETEVOQlFVTTdaMEpCUTJwRkxFMUJRVTBzUTBGQlNTeFJRVUZSTEVOQlFVTTdXVUZEZGtJc1EwRkJRenRaUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMWdzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc2MwTkJRWE5ETEVWQlFVVXNXVUZCV1N4RFFVRkRMRU5CUVVNN1owSkJRM2hGTEUxQlFVc3NRMEZCUXl4SlFVRkpMREpDUVVGWkxFTkJRVU1zSzBOQlFTdERMRVZCUVVVN2IwSkJRM0JGTEZGQlFWRXNSVUZCUlN4SlFVRkpMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNUVUZCVFN4RlFVRkZPMjlDUVVONFF5eFJRVUZSTEVWQlFVVXNXVUZCV1R0cFFrRkRla0lzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEVWl4RFFVRkRPMUZCUTB3c1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFdDeERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlFMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQll5eEZRVUZGTEVsQlFWa3NSVUZCUlN4alFVRjFRaXhGUVVGRkxHbENRVUZuUkR0UlFVTXpTQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeFBRVUZQTEVOQlFWTXNRMEZCUXl4UFFVRlBMRVZCUVVVc1RVRkJUU3hGUVVGRkxFVkJRVVU3V1VGRE0wTXNUVUZCVFN4UFFVRlBMRWRCUVVjc2FVSkJRV2xDTEVsQlFVa3NSVUZCUlN4RFFVRkRPMWxCUlhoRExFbEJRVWtzUjBGQlJ5eEhRVUZITEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXp0WlFVVjZReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1QwRkJUeXhEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRlRU1zVFVGQlRTeFJRVUZSTEVkQlFVY3NTVUZCU1N4alFVRmpMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUlVGQlJTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRPMmRDUVVNeFJDeEhRVUZITEVsQlFVa3NVVUZCVVN4RFFVRkRPMWxCUTNCQ0xFTkJRVU03V1VGRlJDeE5RVUZOTEVkQlFVY3NSMEZCUnl4SlFVRkpMR05CUVdNc1JVRkJSU3hEUVVGRE8xbEJSV3BETEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhWUVVGVkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRkRUlzUjBGQlJ5eERRVUZETEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRE8xbEJRMnhETEVOQlFVTTdXVUZGUkN4SFFVRkhMRU5CUVVNc1UwRkJVeXhIUVVGSExFZEJRVWNzUlVGQlJUdG5Ra0ZEYWtJc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eExRVUZMTEVOQlFVTXNLMEpCUVN0Q0xFTkJRVU1zUTBGQlF6dG5Ra0ZGY0VRc1RVRkJUU3hEUVVGRExFbEJRVWtzTWtKQlFWa3NRMEZCUXl4VlFVRlZMRTFCUVUwc2NVSkJRWEZDTEVWQlFVVTdiMEpCUXpORUxGRkJRVkVzUlVGQlJTeEhRVUZITzI5Q1FVTmlMR2xDUVVGcFFpeEZRVUZGTEVkQlFVY3NRMEZCUXl4TlFVRk5PMjlDUVVNM1FpeGhRVUZoTEVWQlFVVXNSMEZCUnl4RFFVRkRMRmxCUVZrc1NVRkJTU3hIUVVGSExFTkJRVU1zVlVGQlZUdHBRa0ZEY0VRc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFVpeERRVUZETEVOQlFVTTdXVUZGUml4SFFVRkhMRU5CUVVNc1QwRkJUeXhIUVVGSExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVWQlFVVTdaMEpCUTJ4Q0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RFFVRkRMRFpDUVVFMlFpeERRVUZETEVOQlFVTTdaMEpCUld4RUxFMUJRVTBzUTBGQlF5eEpRVUZKTERKQ1FVRlpMRU5CUVVNc1ZVRkJWU3hOUVVGTkxGVkJRVlVzUlVGQlJUdHZRa0ZEYUVRc1VVRkJVU3hGUVVGRkxFZEJRVWM3YjBKQlEySXNhVUpCUVdsQ0xFVkJRVVVzUjBGQlJ5eERRVUZETEUxQlFVMDdiMEpCUXpkQ0xHRkJRV0VzUlVGQlJTeEhRVUZITEVOQlFVTXNXVUZCV1N4SlFVRkpMRWRCUVVjc1EwRkJReXhWUVVGVk8ybENRVU53UkN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOU0xFTkJRVU1zUTBGQlF6dFpRVVZHTEVkQlFVY3NRMEZCUXl4TlFVRk5MRWRCUVVjc1IwRkJSeXhGUVVGRk8yZENRVU5rTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhOUVVGTkxFdEJRVXNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkRja0lzVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJRenRuUWtGRE9VSXNRMEZCUXp0blFrRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dHZRa0ZEU2l4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eHRRMEZCYlVNc1JVRkJSU3hGUVVGRkxFbEJRVWtzUlVGQlJTeEhRVUZITEVOQlFVTXNUVUZCVFN4RlFVRkZMRWxCUVVrc1JVRkJSU3hIUVVGSExFTkJRVU1zV1VGQldTeEZRVUZGTEVOQlFVTXNRMEZCUXp0dlFrRkRja2NzVFVGQlRTeERRVUZETEVsQlFVa3NNa0pCUVZrc1EwRkJReXhWUVVGVkxFMUJRVTBzVlVGQlZTeEZRVUZGTzNkQ1FVTm9SQ3hSUVVGUkxFVkJRVVVzUjBGQlJ6dDNRa0ZEWWl4cFFrRkJhVUlzUlVGQlJTeEhRVUZITEVOQlFVTXNUVUZCVFR0M1FrRkROMElzWVVGQllTeEZRVUZGTEVkQlFVY3NRMEZCUXl4WlFVRlpMRWxCUVVrc1IwRkJSeXhEUVVGRExGVkJRVlU3Y1VKQlEzQkVMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU5TTEVOQlFVTTdXVUZEVEN4RFFVRkRMRU5CUVVNN1dVRkZSaXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNSVUZCUlN4SFFVRkhMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRk5VSXNSMEZCUnl4RFFVRkRMRU5CUVVNc1RVRkJUU3hIUVVGSExFbEJRVWtzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRlRUlzUjBGQlJ5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExFZEJRVWNzUlVGQlJTeFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNMVF5eERRVUZETzFsQlJVUXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zTUVKQlFUQkNMRVZCUVVVc1JVRkJSU3hKUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETzFsQlJYaEVMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEYmtJc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFVDeERRVUZETzBOQlEwbzdRVUUzUzBRc2MwTkJOa3RESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvbmV0d29yay9uZXR3b3JrQ2xpZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lvdGEtcGljby1wb3ctd2ViZ2wvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmRlZmF1bHQgPSByZXF1aXJlKFwiLi4vZGlzdC9pbmRleC1hbGxcIik7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGtnL2Jvb3RzdHJhcC5qcyIsImZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBDb21iaW5lZCBpbmRleCBvZiBhbGwgdGhlIG1vZHVsZXMuXHJcbiAqL1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCJAaW90YS1waWNvL2FwaVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCJAaW90YS1waWNvL2NyeXB0b1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCJAaW90YS1waWNvL2J1c2luZXNzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIkBpb3RhLXBpY28vcGFsLWJyb3dzZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiQGlvdGEtcGljby9wb3ctYm94XCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIkBpb3RhLXBpY28vcG93LWpzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIkBpb3RhLXBpY28vcG93LXdhc21cIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiQGlvdGEtcGljby9wb3ctd2ViZ2xcIikpO1xyXG5jb25zdCBwYWxfYnJvd3Nlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vcGFsLWJyb3dzZXJcIik7XHJcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY3J5cHRvXCIpO1xyXG5jb25zdCBwb3dfanNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL3Bvdy1qc1wiKTtcclxuY29uc3QgcG93X2JveF8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vcG93LWJveFwiKTtcclxuY29uc3QgcG93X3dlYmdsXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9wb3ctd2ViZ2xcIik7XHJcbmNvbnN0IHBvd193YXNtXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9wb3ctd2FzbVwiKTtcclxuKGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgIGF3YWl0IHBhbF9icm93c2VyXzEuUEFMLmluaXRpYWxpemUoKTtcclxuICAgIGNyeXB0b18xLlByb29mT2ZXb3JrRmFjdG9yeS5pbnN0YW5jZSgpLnJlZ2lzdGVyKFwianNcIiwgKC4uLmFyZ3MpID0+IG5ldyBwb3dfanNfMS5Qcm9vZk9mV29ya0pzKCkpO1xyXG4gICAgY3J5cHRvXzEuUHJvb2ZPZldvcmtGYWN0b3J5Lmluc3RhbmNlKCkucmVnaXN0ZXIoXCJ3ZWJnbFwiLCAoLi4uYXJncykgPT4gbmV3IHBvd193ZWJnbF8xLlByb29mT2ZXb3JrV2ViR2woYXJnc1swXSkpO1xyXG4gICAgY3J5cHRvXzEuUHJvb2ZPZldvcmtGYWN0b3J5Lmluc3RhbmNlKCkucmVnaXN0ZXIoXCJib3hcIiwgKC4uLmFyZ3MpID0+IG5ldyBwb3dfYm94XzEuUHJvb2ZPZldvcmtCb3goYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSkpO1xyXG4gICAgY3J5cHRvXzEuUHJvb2ZPZldvcmtGYWN0b3J5Lmluc3RhbmNlKCkucmVnaXN0ZXIoXCJ3YXNtXCIsICguLi5hcmdzKSA9PiBuZXcgcG93X3dhc21fMS5Qcm9vZk9mV29ya1dhc20oYXJnc1swXSkpO1xyXG59KSgpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndFlXeHNMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZjM0pqTDJsdVpHVjRMV0ZzYkM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdPMEZCUVVFN08wZEJSVWM3UVVGRFNDeHhRMEZCWjBNN1FVRkRhRU1zY1VOQlFXZERPMEZCUTJoRExHOURRVUVyUWp0QlFVTXZRaXgxUTBGQmEwTTdRVUZEYkVNc2VVTkJRVzlETzBGQlEzQkRMRFJEUVVGMVF6dEJRVU4yUXl4M1EwRkJiVU03UVVGRGJrTXNkVU5CUVd0RE8wRkJRMnhETEhsRFFVRnZRenRCUVVOd1F5d3dRMEZCY1VNN1FVRkZja01zZDBSQlFUWkRPMEZCUXpkRExEaERRVUYxUkR0QlFVTjJSQ3c0UTBGQmEwUTdRVUZEYkVRc1owUkJRVzlFTzBGQlEzQkVMRzlFUVVGM1JEdEJRVU40UkN4clJFRkJjMFE3UVVGRmRFUXNRMEZCUXl4TFFVRkxPMGxCUTBZc1RVRkJUU3hwUWtGQlJ5eERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRPMGxCUTNaQ0xESkNRVUZyUWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRWxCUVVrc1JVRkJSU3hGUVVGRkxFTkJRVU1zU1VGQlNTeHpRa0ZCWVN4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVNdlJTd3lRa0ZCYTBJc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNc1IwRkJSeXhKUVVGSkxFVkJRVVVzUlVGQlJTeERRVUZETEVsQlFVa3NORUpCUVdkQ0xFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNMVJpd3lRa0ZCYTBJc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1IwRkJSeXhKUVVGSkxFVkJRVVVzUlVGQlJTeERRVUZETEVsQlFVa3NkMEpCUVdNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRNVWNzTWtKQlFXdENMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRWRCUVVjc1NVRkJTU3hGUVVGRkxFVkJRVVVzUTBGQlF5eEpRVUZKTERCQ1FVRmxMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0QlFVTTVSaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zcmMvaW5kZXgtYWxsLnRzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGFycmF5SGVscGVyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9hcnJheUhlbHBlclwiKTtcclxuY29uc3QgZXJyb3JIZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2Vycm9ySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3Qgc3RyaW5nSGVscGVyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zdHJpbmdIZWxwZXJcIik7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBJTG9nZ2VyIHdoaWNoIHNlbmRzIHRvIHRoZSB0aGlzLl9sb2dnaW5nT2JqZWN0LlxyXG4gKi9cclxuLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxyXG5jbGFzcyBDb25zb2xlTG9nZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuZCBpbnN0YW5jZSBvZiB0aGUgY29uc29sZSBsb2dnZXIuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvZ2dpbmdPYmplY3QpIHtcclxuICAgICAgICB0aGlzLl9sb2dnaW5nT2JqZWN0ID0gbG9nZ2luZ09iamVjdCB8fCBjb25zb2xlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGJhbm5lciB0byB0aGUgbG9nZ2VyLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxyXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cclxuICAgICAqL1xyXG4gICAgYmFubmVyKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2dnaW5nT2JqZWN0LmxvZyhcIj1cIi5yZXBlYXQoODApKTtcclxuICAgICAgICB0aGlzLl9sb2dnaW5nT2JqZWN0LmxvZyhtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmxvZ0FyZ3ModGhpcy5fbG9nZ2luZ09iamVjdC5sb2csIGFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dpbmdPYmplY3QubG9nKFwiPVwiLnJlcGVhdCg4MCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGxvZyB0byB0aGUgbG9nZ2VyLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxyXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cclxuICAgICAqL1xyXG4gICAgbG9nKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2dnaW5nT2JqZWN0LmxvZyhtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmxvZ0FyZ3ModGhpcy5fbG9nZ2luZ09iamVjdC5sb2csIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGluZm9ybWF0aW9uIHRvIHRoZSBsb2dnZXIuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXHJcbiAgICAgKiBAcGFyYW0gYXJncyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gbG9nLlxyXG4gICAgICovXHJcbiAgICBpbmZvKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2dnaW5nT2JqZWN0LmluZm8obWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5sb2dBcmdzKHRoaXMuX2xvZ2dpbmdPYmplY3QuaW5mbywgYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgd2FybmluZyB0byB0aGUgbG9nZ2VyLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxyXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cclxuICAgICAqL1xyXG4gICAgd2FybmluZyhtZXNzYWdlLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2luZ09iamVjdC53YXJuKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMubG9nQXJncyh0aGlzLl9sb2dnaW5nT2JqZWN0Lndhcm4sIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGVycm9yIHRvIHRoZSBsb2dnZXIuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXHJcbiAgICAgKiBAcGFyYW0gZXJyIEFuIGVycm9yIG9iamVjdCB0byBsb2cuXHJcbiAgICAgKiBAcGFyYW0gYXJncyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gbG9nLlxyXG4gICAgICovXHJcbiAgICBlcnJvcihtZXNzYWdlLCBlcnIsIC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2dnaW5nT2JqZWN0LmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkoZXJyKSkge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGVycm9ySGVscGVyXzEuRXJyb3JIZWxwZXIuZm9ybWF0KGVyciwgdHJ1ZSkuc3BsaXQoXCJcXG5cIik7XHJcbiAgICAgICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnaW5nT2JqZWN0LmVycm9yKGBcXHQke2xpbmV9YCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvZ0FyZ3ModGhpcy5fbG9nZ2luZ09iamVjdC5lcnJvciwgYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGxvZ0FyZ3MobG9nTWV0aG9kLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkoYXJncykpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZW50ID0gXCJcXHRcIjtcclxuICAgICAgICAgICAgbGV0IG91dHB1dCA9IFwiXCI7XHJcbiAgICAgICAgICAgIGFyZ3MuZm9yRWFjaCgoYXJnLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHRoaXMuY3JlYXRlSXRlbShpbmRlbnQsIFwiXCIsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBhcmdzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYCR7aW5kZW50fSR7XCItXCIucmVwZWF0KDcwKX1cXG5gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nTWV0aG9kKG91dHB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBjcmVhdGVJdGVtKGluZGVudCwga2V5LCBpdGVtLCBzaW5nbGVJdGVtTGluZUJyZWFrID0gXCJcXG5cIikge1xyXG4gICAgICAgIGxldCBvdXRwdXQgPSBcIlwiO1xyXG4gICAgICAgIGlmIChhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzQXJyYXkoaXRlbSkpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3SW5kZW50ID0gYCR7aW5kZW50fVxcdGA7XHJcbiAgICAgICAgICAgIGlmIChzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNFbXB0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYCR7aW5kZW50fVtcXG5gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGAke2luZGVudH0ke2tleX06IFtcXG5gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGl0ZW0uZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCArPSB0aGlzLmNyZWF0ZUl0ZW0obmV3SW5kZW50LCBcIlwiLCBlbGVtZW50LCBgJHtpbmRleCA8IGl0ZW0ubGVuZ3RoIC0gMSA/IFwiLFwiIDogXCJcIn1cXG5gKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG91dHB1dCArPSBgJHtpbmRlbnR9XVxcbmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc09iamVjdChpdGVtKSkge1xyXG4gICAgICAgICAgICBjb25zdCBvYlN0cmluZyA9IGl0ZW0udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKG9iU3RyaW5nID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJbmRlbnQgPSBgJHtpbmRlbnR9XFx0YDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNFbXB0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGAke2luZGVudH17XFxuYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBgJHtpbmRlbnR9JHtrZXl9OiB7XFxuYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpdGVtKTtcclxuICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaCgoaXRlbUtleSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdGhpcy5jcmVhdGVJdGVtKG5ld0luZGVudCwgaXRlbUtleSwgaXRlbVtpdGVtS2V5XSwgYCR7aW5kZXggPCBrZXlzLmxlbmd0aCAtIDEgPyBcIixcIiA6IFwiXCJ9XFxuYCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBgJHtpbmRlbnR9fVxcbmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdGhpcy5jcmVhdGVJdGVtKGluZGVudCwga2V5LCBvYlN0cmluZy5yZXBsYWNlKC9cXG4vZywgYFxcbiR7aW5kZW50fWApLCBzaW5nbGVJdGVtTGluZUJyZWFrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBgJHtpbmRlbnR9JHtvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShpdGVtKSA/IGl0ZW0gOiBpdGVtLnRvU3RyaW5nKCl9JHtzaW5nbGVJdGVtTGluZUJyZWFrfWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYCR7aW5kZW50fSR7a2V5fTogJHtvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShpdGVtKSA/IGl0ZW0gOiBpdGVtLnRvU3RyaW5nKCl9JHtzaW5nbGVJdGVtTGluZUJyZWFrfWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvbnNvbGVMb2dnZXIgPSBDb25zb2xlTG9nZ2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZMjl1YzI5c1pVeHZaMmRsY2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlzYjJkblpYSnpMMk52Ym5OdmJHVk1iMmRuWlhJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTEhkRVFVRnhSRHRCUVVOeVJDeDNSRUZCY1VRN1FVRkRja1FzTUVSQlFYVkVPMEZCUTNaRUxEQkVRVUYxUkR0QlFVZDJSRHM3UjBGRlJ6dEJRVU5JTERSQ1FVRTBRanRCUVVNMVFqdEpRVWxKT3p0UFFVVkhPMGxCUTBnc1dVRkJXU3hoUVVGMVFqdFJRVU12UWl4SlFVRkpMRU5CUVVNc1kwRkJZeXhIUVVGSExHRkJRV0VzU1VGQlNTeFBRVUZQTEVOQlFVTTdTVUZEYmtRc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVDBGQlpTeEZRVUZGTEVkQlFVY3NTVUZCVnp0UlFVTjZReXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVNc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkRha01zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExFZEJRVWNzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTTFReXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETlVNc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hIUVVGSExFTkJRVU1zVDBGQlpTeEZRVUZGTEVkQlFVY3NTVUZCVnp0UlFVTjBReXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEVkQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVOcVF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhqUVVGakxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUTJoRUxFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGtzU1VGQlNTeERRVUZETEU5QlFXVXNSVUZCUlN4SFFVRkhMRWxCUVZjN1VVRkRka01zU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03VVVGRGJFTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEVsQlFVa3NSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVOcVJDeERRVUZETzBsQlJVUTdPenM3VDBGSlJ6dEpRVU5KTEU5QlFVOHNRMEZCUXl4UFFVRmxMRVZCUVVVc1IwRkJSeXhKUVVGWE8xRkJRekZETEVsQlFVa3NRMEZCUXl4alFVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzFGQlEyeERMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRGFrUXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1MwRkJTeXhEUVVGRExFOUJRV1VzUlVGQlJTeEhRVUZUTEVWQlFVVXNSMEZCUnl4SlFVRlhPMUZCUTI1RUxFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRMjVETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemRDTEUxQlFVMHNTMEZCU3l4SFFVRkhMSGxDUVVGWExFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEZUVRc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlR0blFrRkRha0lzU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhKUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETzFsQlF6TkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMUFzUTBGQlF6dFJRVU5FTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eExRVUZMTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRiRVFzUTBGQlF6dEpRVVZFTEdWQlFXVTdTVUZEVUN4UFFVRlBMRU5CUVVNc1UwRkJiME1zUlVGQlJTeEpRVUZYTzFGQlF6ZEVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zZVVKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6ZENMRTFCUVUwc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF6dFpRVU53UWl4SlFVRkpMRTFCUVUwc1IwRkJSeXhGUVVGRkxFTkJRVU03V1VGRGFFSXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFZEJRVWNzUlVGQlJTeExRVUZMTEVWQlFVVXNSVUZCUlR0blFrRkRlRUlzVFVGQlRTeEpRVUZKTEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXp0blFrRkRNME1zUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkRNVUlzVFVGQlRTeEpRVUZKTEVkQlFVY3NUVUZCVFN4SFFVRkhMRWRCUVVjc1EwRkJReXhOUVVGTkxFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXp0blFrRkROME1zUTBGQlF6dFpRVU5NTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTBnc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlEzUkNMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJSVVFzWlVGQlpUdEpRVU5RTEZWQlFWVXNRMEZCUXl4TlFVRmpMRVZCUVVVc1IwRkJWeXhGUVVGRkxFbEJRVk1zUlVGQlJTeHpRa0ZCT0VJc1NVRkJTVHRSUVVONlJpeEpRVUZKTEUxQlFVMHNSMEZCUnl4RlFVRkZMRU5CUVVNN1VVRkRhRUlzUlVGQlJTeERRVUZETEVOQlFVTXNlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpWQ0xFMUJRVTBzVTBGQlV5eEhRVUZITEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNN1dVRkRhRU1zUlVGQlJTeERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNMVFpeE5RVUZOTEVsQlFVa3NSMEZCUnl4TlFVRk5MRXRCUVVzc1EwRkJRenRaUVVNM1FpeERRVUZETzFsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1owSkJRMG9zVFVGQlRTeEpRVUZKTEVkQlFVY3NUVUZCVFN4SFFVRkhMRWRCUVVjc1QwRkJUeXhEUVVGRE8xbEJRM0pETEVOQlFVTTdXVUZEUkN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zVDBGQldTeEZRVUZGTEV0QlFXRXNSVUZCUlN4RlFVRkZPMmRDUVVONlF5eE5RVUZOTEVsQlFVa3NTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhUUVVGVExFVkJRVVVzUlVGQlJTeEZRVUZGTEU5QlFVOHNSVUZCUlN4SFFVRkhMRXRCUVVzc1IwRkJSeXhKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTJwSExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEwZ3NUVUZCVFN4SlFVRkpMRWRCUVVjc1RVRkJUU3hMUVVGTExFTkJRVU03VVVGRE4wSXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY2tNc1RVRkJUU3hSUVVGUkxFZEJRVWNzU1VGQlNTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMWxCUldwRExFVkJRVVVzUTBGQlF5eERRVUZETEZGQlFWRXNTMEZCU3l4cFFrRkJhVUlzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTJwRExFMUJRVTBzVTBGQlV5eEhRVUZITEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNN1owSkJRMmhETEVWQlFVVXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRE5VSXNUVUZCVFN4SlFVRkpMRWRCUVVjc1RVRkJUU3hMUVVGTExFTkJRVU03WjBKQlF6ZENMRU5CUVVNN1owSkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdiMEpCUTBvc1RVRkJUU3hKUVVGSkxFZEJRVWNzVFVGQlRTeEhRVUZITEVkQlFVY3NUMEZCVHl4RFFVRkRPMmRDUVVOeVF5eERRVUZETzJkQ1FVTkVMRTFCUVUwc1NVRkJTU3hIUVVGSExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1owSkJReTlDTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhQUVVGbExFVkJRVVVzUzBGQllTeEZRVUZGTEVWQlFVVTdiMEpCUXpWRExFMUJRVTBzU1VGQlNTeEpRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMRk5CUVZNc1JVRkJSU3hQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RlFVRkZMRWRCUVVjc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1owSkJRelZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOSUxFMUJRVTBzU1VGQlNTeEhRVUZITEUxQlFVMHNTMEZCU3l4RFFVRkRPMWxCUXpkQ0xFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0blFrRkRTaXhOUVVGTkxFbEJRVWtzU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRVZCUVVVc1IwRkJSeXhGUVVGRkxGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RlFVRkZMRXRCUVVzc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeHRRa0ZCYlVJc1EwRkJReXhEUVVGRE8xbEJRM2hITEVOQlFVTTdVVUZEVEN4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFNpeEZRVUZGTEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRelZDTEUxQlFVMHNTVUZCU1N4SFFVRkhMRTFCUVUwc1IwRkJSeXd5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFZEJRVWNzYlVKQlFXMUNMRVZCUVVVc1EwRkJRenRaUVVOMFJ5eERRVUZETzFsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1owSkJRMG9zVFVGQlRTeEpRVUZKTEVkQlFVY3NUVUZCVFN4SFFVRkhMRWRCUVVjc1MwRkJTeXd5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFZEJRVWNzYlVKQlFXMUNMRVZCUVVVc1EwRkJRenRaUVVNNVJ5eERRVUZETzFGQlEwd3NRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRGJFSXNRMEZCUXp0RFFVTktPMEZCT1VoRUxITkRRVGhJUXlKOVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvbG9nZ2Vycy9jb25zb2xlTG9nZ2VyLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBuZXR3b3JrRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9uZXR3b3JrRXJyb3JcIik7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3Qgc3RyaW5nSGVscGVyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zdHJpbmdIZWxwZXJcIik7XHJcbi8qKlxyXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGEgbmV0d29yayBlbmRwb2ludC5cclxuICovXHJcbmNsYXNzIE5ldHdvcmtFbmRQb2ludCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBOZXR3b3JrRW5kUG9pbnQuXHJcbiAgICAgKiBAcGFyYW0gcHJvdG9jb2wgVGhlIHByb3RvY29sIHRvIGFjY2VzcyB0aGUgZW5kcG9pbnQgd2l0aC5cclxuICAgICAqIEBwYXJhbSBob3N0IFRoZSBob3N0IG5hbWUgb3IgaXAgb2YgdGhlIGVuZHBvaW50LlxyXG4gICAgICogQHBhcmFtIHBvcnQgVGhlIHBvcnQgb2YgdGhlIGVuZHBvaW50LlxyXG4gICAgICogQHBhcmFtIHJvb3RQYXRoIFRoZSBwYXRoIHRvIHRoZSBlbmRwb2ludC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdG9jb2wsIGhvc3QsIHBvcnQsIHJvb3RQYXRoKSB7XHJcbiAgICAgICAgaWYgKCFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNTdHJpbmcocHJvdG9jb2wpIHx8ICEvaHR0cHxodHRwcy8udGVzdChwcm90b2NvbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IG5ldHdvcmtFcnJvcl8xLk5ldHdvcmtFcnJvcihcIlRoZSBwcm90b2NvbCBtdXN0IGJlIGRlZmluZWQgYXMgaHR0cCBvciBodHRwc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNTdHJpbmcoaG9zdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IG5ldHdvcmtFcnJvcl8xLk5ldHdvcmtFcnJvcihcIlRoZSBob3N0IG11c3QgYmUgZGVmaW5lZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHBvcnQpIHx8IHBvcnQgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV0d29ya0Vycm9yXzEuTmV0d29ya0Vycm9yKFwiVGhlIHBvcnQgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gemVyb1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShyb290UGF0aCkgJiYgIXN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc1N0cmluZyhyb290UGF0aCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IG5ldHdvcmtFcnJvcl8xLk5ldHdvcmtFcnJvcihcIlRoZSByb290UGF0aCBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHByb3RvY29sO1xyXG4gICAgICAgIHRoaXMuX2hvc3QgPSBob3N0LnJlcGxhY2UoL15cXC8qLywgXCJcIikucmVwbGFjZSgvXFwvKiQvLCBcIlwiKTtcclxuICAgICAgICB0aGlzLl9wb3J0ID0gcG9ydDtcclxuICAgICAgICB0aGlzLl9yb290UGF0aCA9IChyb290UGF0aCB8fCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiXCIpLnJlcGxhY2UoL1xcLyokLywgXCJcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwcm90b2NvbCB0byBhY2Nlc3MgdGhlIGVuZHBvaW50IHdpdGguXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBwcm90b2NvbC5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJvdG9jb2woKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaG9zdCBuYW1lIG9yIGlwIG9mIHRoZSBlbmRwb2ludC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBob3N0LlxyXG4gICAgICovXHJcbiAgICBnZXRIb3N0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ob3N0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgZW5kcG9pbnQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcGF0aC5cclxuICAgICAqL1xyXG4gICAgZ2V0Um9vdFBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RQYXRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcG9ydCBvZiB0aGUgZW5kcG9pbnQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcG9ydC5cclxuICAgICAqL1xyXG4gICAgZ2V0UG9ydCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbXBsZXRlIHVyaS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB1cmkuXHJcbiAgICAgKi9cclxuICAgIGdldFVyaSgpIHtcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5fcHJvdG9jb2x9Oi8vJHt0aGlzLl9ob3N0fToke3RoaXMuX3BvcnR9LyR7dGhpcy5fcm9vdFBhdGh9YDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk5ldHdvcmtFbmRQb2ludCA9IE5ldHdvcmtFbmRQb2ludDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYm1WMGQyOXlhMFZ1WkZCdmFXNTBMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyNWxkSGR2Y21zdmJtVjBkMjl5YTBWdVpGQnZhVzUwTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3gzUkVGQmNVUTdRVUZEY2tRc01FUkJRWFZFTzBGQlEzWkVMREJFUVVGMVJEdEJRVU4yUkN3d1JFRkJkVVE3UVVGSmRrUTdPMGRCUlVjN1FVRkRTRHRKUVZWSk96czdPenM3VDBGTlJ6dEpRVU5JTEZsQlFWa3NVVUZCZVVJc1JVRkJSU3hKUVVGWkxFVkJRVVVzU1VGQldTeEZRVUZGTEZGQlFXbENPMUZCUTJoR0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhSUVVGUkxFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnVSU3hOUVVGTkxFbEJRVWtzTWtKQlFWa3NRMEZCUXl3clEwRkJLME1zUTBGQlF5eERRVUZETzFGQlF6VkZMRU5CUVVNN1VVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXZRaXhOUVVGTkxFbEJRVWtzTWtKQlFWa3NRMEZCUXl3d1FrRkJNRUlzUTBGQlF5eERRVUZETzFGQlEzWkVMRU5CUVVNN1VVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVsQlFVa3NTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemRETEUxQlFVMHNTVUZCU1N3eVFrRkJXU3hEUVVGRExEWkRRVUUyUXl4RFFVRkRMRU5CUVVNN1VVRkRNVVVzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZGQlFWRXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRFVXNUVUZCVFN4SlFVRkpMREpDUVVGWkxFTkJRVU1zY1VOQlFYRkRMRU5CUVVNc1EwRkJRenRSUVVOc1JTeERRVUZETzFGQlEwUXNTVUZCU1N4RFFVRkRMRk5CUVZNc1IwRkJSeXhSUVVGUkxFTkJRVU03VVVGRE1VSXNTVUZCU1N4RFFVRkRMRXRCUVVzc1IwRkJSeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUXpGRUxFbEJRVWtzUTBGQlF5eExRVUZMTEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTJ4Q0xFbEJRVWtzUTBGQlF5eFRRVUZUTEVkQlFVY3NRMEZCUXl4UlFVRlJMRWxCUVVrc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMGxCUXpsRkxFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hYUVVGWE8xRkJRMlFzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNN1NVRkRNVUlzUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxFOUJRVTg3VVVGRFZpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJRenRKUVVOMFFpeERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzVjBGQlZ6dFJRVU5rTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRE8wbEJRekZDTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeFBRVUZQTzFGQlExWXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU03U1VGRGRFSXNRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5KTEUxQlFVMDdVVUZEVkN4TlFVRk5MRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zVTBGQlV5eE5RVUZOTEVsQlFVa3NRMEZCUXl4TFFVRkxMRWxCUVVrc1NVRkJTU3hEUVVGRExFdEJRVXNzU1VGQlNTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RlFVRkZMRU5CUVVNN1NVRkRMMFVzUTBGQlF6dERRVU5LTzBGQk0wVkVMREJEUVRKRlF5SjlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL25ldHdvcmsvbmV0d29ya0VuZFBvaW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lvdGEtcGljby1jb3JlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW90YS1waWNvLWNvcmUvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pb3RhLXBpY28tY29yZS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGpzb25IZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL2pzb25IZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBzdHJpbmdIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL3N0cmluZ0hlbHBlclwiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiLi4vZGF0YS90cnl0ZXNcIik7XHJcbmNvbnN0IGRhdGFFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2RhdGFFcnJvclwiKTtcclxuY29uc3QgYXNjaWlUcnl0ZXNDb252ZXJ0ZXJfMSA9IHJlcXVpcmUoXCIuL2FzY2lpVHJ5dGVzQ29udmVydGVyXCIpO1xyXG4vKipcclxuICogVHJ5dGVzIGNvbnZlcnRlciB0aGF0IGNvbnZlcnRzIHRvIGFuZCBmcm9tIGFuIG9iamVjdC5cclxuICogQHR5cGVwYXJhbSBUIFRoZSBnZW5lcmljIHR5cGUgZm9yIHRoZSBjb252ZXJzaW9uIG1ldGhvZHMuXHJcbiAqL1xyXG5jbGFzcyBPYmplY3RUcnl0ZXNDb252ZXJ0ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IGFuIG9iamVjdCB2YWx1ZSBpbnRvIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBvYmplY3QgdG8gY29udmVydCBpbnRvIHRyeXRlcy5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG8odmFsdWUpIHtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgY2FuIG5vdCBiZSBlbXB0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGpzb247XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAganNvbiA9IGpzb25IZWxwZXJfMS5Kc29uSGVscGVyLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZXJlIHdhcyBhIHByb2JsZW0gY29udmVydGluZyB0aGUgb2JqZWN0IHRvIEpTT05cIiwgeyBlcnIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgYXNjaWlUcnl0ZXNDb252ZXJ0ZXJfMS5Bc2NpaVRyeXRlc0NvbnZlcnRlcigpLnRvKHN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5lbmNvZGVOb25BU0NJSShqc29uKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdHJ5dGVzIGludG8gYSBzdHJpbmcgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gdHJ5dGVzIHRvIGNvbnZlcnQgaW50byBhIHN0cmluZyB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgdmFsdWUgY29udmVydGVkIGZyb20gdGhlIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgZnJvbSh0cnl0ZXMpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJ5dGVzLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdHJ5dGVzIHBhcmFtZXRlciBpcyBlbXB0eSBvciBub3QgdGhlIGNvcnJlY3QgdHlwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXNjaWkgPSBuZXcgYXNjaWlUcnl0ZXNDb252ZXJ0ZXJfMS5Bc2NpaVRyeXRlc0NvbnZlcnRlcigpLmZyb20odHJ5dGVzKTtcclxuICAgICAgICAvLyBNdXN0IGhhdmUgYSBhIHN0YXJ0IGFuZCBjbG9zaW5nIHBhaXJzXHJcbiAgICAgICAgaWYgKGFzY2lpLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSB0cnl0ZXMgZG8gbm90IHJlcHJlc2VudCBhbiBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBzdGFydCBhbmQgZW5kIG11c3QgYmUgZWl0aGVyIHt9IG9yIFwiXCIgdG8gcmVwcmVzZW50IGEgSlNPTiBvYmplY3RcclxuICAgICAgICBpZiAoISgoYXNjaWlbMF0gPT09IFwie1wiICYmIGFzY2lpW2FzY2lpLmxlbmd0aCAtIDFdID09PSBcIn1cIikgfHwgKGFzY2lpWzBdID09PSBcIlxcXCJcIiAmJiBhc2NpaVthc2NpaS5sZW5ndGggLSAxXSA9PT0gXCJcXFwiXCIpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHRyeXRlcyBkbyBub3QgcmVwcmVzZW50IGFuIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IHN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5kZWNvZGVOb25BU0NJSShhc2NpaSk7XHJcbiAgICAgICAgbGV0IG9iajtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBvYmogPSBKU09OLnBhcnNlKGRlY29kZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGVyZSB3YXMgYSBwcm9ibGVtIGNvbnZlcnRpbmcgdGhlIG9iamVjdCBmcm9tIEpTT05cIiwgeyBlcnIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5PYmplY3RUcnl0ZXNDb252ZXJ0ZXIgPSBPYmplY3RUcnl0ZXNDb252ZXJ0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWIySnFaV04wVkhKNWRHVnpRMjl1ZG1WeWRHVnlMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyTnZiblpsY25SbGNuTXZiMkpxWldOMFZISjVkR1Z6UTI5dWRtVnlkR1Z5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3gzUlVGQmNVVTdRVUZEY2tVc05FVkJRWGxGTzBGQlEzcEZMRFJGUVVGNVJUdEJRVU42UlN3eVEwRkJkME03UVVGRGVFTXNhMFJCUVN0RE8wRkJSUzlETEdsRlFVRTRSRHRCUVVVNVJEczdPMGRCUjBjN1FVRkRTRHRKUVVOSk96czdPMDlCU1VjN1NVRkRTU3hGUVVGRkxFTkJRVU1zUzBGQlVUdFJRVU5rTEVWQlFVVXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNNVFpeE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXcwUWtGQk5FSXNRMEZCUXl4RFFVRkRPMUZCUTNSRUxFTkJRVU03VVVGRlJDeEpRVUZKTEVsQlFVa3NRMEZCUXp0UlFVTlVMRWxCUVVrc1EwRkJRenRaUVVORUxFbEJRVWtzUjBGQlJ5eDFRa0ZCVlN4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dFJRVU4yUXl4RFFVRkRPMUZCUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTllMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEcxRVFVRnRSQ3hGUVVGRkxFVkJRVVVzUjBGQlJ5eEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTjBSaXhEUVVGRE8xRkJSVVFzVFVGQlRTeERRVUZETEVsQlFVa3NNa05CUVc5Q0xFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhqUVVGakxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTTFSU3hEUVVGRE8wbEJSVVE3T3pzN1QwRkpSenRKUVVOSkxFbEJRVWtzUTBGQlF5eE5RVUZqTzFGQlEzUkNMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hGUVVGRkxHVkJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjJReXhOUVVGTkxFbEJRVWtzY1VKQlFWTXNRMEZCUXl4MVJFRkJkVVFzUTBGQlF5eERRVUZETzFGQlEycEdMRU5CUVVNN1VVRkZSQ3hOUVVGTkxFdEJRVXNzUjBGQlJ5eEpRVUZKTERKRFFVRnZRaXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUlhSRUxIZERRVUYzUXp0UlFVTjRReXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrSXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zZFVOQlFYVkRMRU5CUVVNc1EwRkJRenRSUVVOcVJTeERRVUZETzFGQlJVUXNkVVZCUVhWRk8xRkJRM1pGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4SFFVRkhMRWxCUVVrc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRXRCUVVzc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1NVRkJTU3hKUVVGSkxFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhMUVVGTExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNSSUxFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMSFZEUVVGMVF5eERRVUZETEVOQlFVTTdVVUZEYWtVc1EwRkJRenRSUVVWRUxFMUJRVTBzVDBGQlR5eEhRVUZITERKQ1FVRlpMRU5CUVVNc1kwRkJZeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzFGQlJXNUVMRWxCUVVrc1IwRkJSeXhEUVVGRE8xRkJRMUlzU1VGQlNTeERRVUZETzFsQlEwUXNSMEZCUnl4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdVVUZET1VJc1EwRkJRenRSUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRXQ3hOUVVGTkxFbEJRVWtzY1VKQlFWTXNRMEZCUXl4eFJFRkJjVVFzUlVGQlJTeEZRVUZGTEVkQlFVY3NSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRlRVlzUTBGQlF6dFJRVVZFTEUxQlFVMHNRMEZCU1N4SFFVRkhMRU5CUVVNN1NVRkRiRUlzUTBGQlF6dERRVU5LTzBGQmRFUkVMSE5FUVhORVF5SjlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL2NvbnZlcnRlcnMvb2JqZWN0VHJ5dGVzQ29udmVydGVyLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBhcnJheUhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXJcIik7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3Qgc3RyaW5nSGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9zdHJpbmdIZWxwZXJcIik7XHJcbmNvbnN0IG51bGxMb2dnZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9sb2dnZXJzL251bGxMb2dnZXJcIik7XHJcbmNvbnN0IGFwaUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvYXBpRXJyb3JcIik7XHJcbi8qKlxyXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGFuIGFwaSBjbGllbnQuXHJcbiAqL1xyXG5jbGFzcyBBcGlDbGllbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXBpQ2xpZW50LlxyXG4gICAgICogQHBhcmFtIG5ldHdvcmtDbGllbnQgVGhlIG5ldHdvcmsgY2xpZW50IHRvIGNvbW11bmljYXRlIHRocm91Z2guXHJcbiAgICAgKiBAcGFyYW0gYXBpVmVyc2lvbiBUaGUgQVBJIHZlcnNpb24gdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0c1xyXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxIZWFkZXJzIEV4dHJhIGhlYWRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0cy5cclxuICAgICAqIEBwYXJhbSBsb2dnZXIgTG9nZ2VyIHRvIHNlbmQgY29tbXVuaWNhdGlvbiBpbmZvIHRvLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrQ2xpZW50LCBhcGlWZXJzaW9uID0gXCIxXCIsIGFkZGl0aW9uYWxIZWFkZXJzLCBsb2dnZXIpIHtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkobmV0d29ya0NsaWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgbmV0d29ya0NsaWVudCBtdXN0IGJlIGRlZmluZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNFbXB0eShhcGlWZXJzaW9uKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSBhcGlWZXJzaW9uIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9uZXR3b3JrQ2xpZW50ID0gbmV0d29ya0NsaWVudDtcclxuICAgICAgICB0aGlzLl9hcGlWZXJzaW9uID0gYXBpVmVyc2lvbjtcclxuICAgICAgICB0aGlzLl9hZGRpdGlvbmFsSGVhZGVycyA9IGFkZGl0aW9uYWxIZWFkZXJzO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlciB8fCBuZXcgbnVsbExvZ2dlcl8xLk51bGxMb2dnZXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB5b3VyIG5vZGUuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBnZXROb2RlSW5mbyByZXNwb25zZSBvYmplY3Qgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXROb2RlSW5mbygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kQ29tbWFuZChcImdldE5vZGVJbmZvXCIsIHt9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2V0IG9mIG5laWdoYm9ycyB5b3UgYXJlIGNvbm5lY3RlZCB3aXRoLCBhcyB3ZWxsIGFzIHRoZWlyIGFjdGl2aXR5IGNvdW50LlxyXG4gICAgICogVGhlIGFjdGl2aXR5IGNvdW50ZXIgaXMgcmVzZXQgYWZ0ZXIgcmVzdGFydGluZyBJUkkuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBnZXROZWlnaGJvcnMgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0TmVpZ2hib3JzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRDb21tYW5kKFwiZ2V0TmVpZ2hib3JzXCIsIHt9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgbGlzdCBvZiBuZWlnaGJvcnMgdG8geW91ciBub2RlLiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCB0aGlzIGlzIG9ubHkgdGVtcG9yYXJ5LFxyXG4gICAgICogYW5kIHRoZSBhZGRlZCBuZWlnaGJvcnMgd2lsbCBiZSByZW1vdmVkIGZyb20geW91ciBzZXQgb2YgbmVpZ2hib3JzIGFmdGVyIHlvdSByZWxhdW5jaCBJUkkuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBhZGROZWlnaGJvcnMgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWRkTmVpZ2hib3JzKHJlcXVlc3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgcmVxdWVzdCBtdXN0IGJlIGRlZmluZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC51cmlzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0LnVyaXMgbXVzdCBub3QgYmUgZW1wdHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRDb21tYW5kKFwiYWRkTmVpZ2hib3JzXCIsIHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgbGlzdCBvZiBuZWlnaGJvcnMgZnJvbSB5b3VyIG5vZGUuIFRoaXMgaXMgb25seSB0ZW1wb3JhcnksIGFuZCBpZiB5b3UgaGF2ZSB5b3VyXHJcbiAgICAgKiBuZWlnaGJvcnMgYWRkZWQgdmlhIHRoZSBjb21tYW5kIGxpbmUsIHRoZXkgd2lsbCBiZSByZXRhaW5lZCBhZnRlciB5b3UgcmVzdGFydCB5b3VyIG5vZGUuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZW1vdmVOZWlnaGJvcnMgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVtb3ZlTmVpZ2hib3JzKHJlcXVlc3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgcmVxdWVzdCBtdXN0IGJlIGRlZmluZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC51cmlzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0LnVyaXMgbXVzdCBub3QgYmUgZW1wdHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRDb21tYW5kKFwicmVtb3ZlTmVpZ2hib3JzXCIsIHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHRpcHMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBnZXRUaXBzIHJlc3BvbnNlIG9iamVjdCBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRpcHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZENvbW1hbmQoXCJnZXRUaXBzXCIsIHt9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgdHJhbnNhY3Rpb25zIHdoaWNoIG1hdGNoIHRoZSBzcGVjaWZpZWQgaW5wdXQgYW5kIHJldHVybi4gQWxsIGlucHV0IHZhbHVlcyBhcmUgbGlzdHMsXHJcbiAgICAgKiBmb3Igd2hpY2ggYSBsaXN0IG9mIHJldHVybiB2YWx1ZXMgKHRyYW5zYWN0aW9uIGhhc2hlcyksIGluIHRoZSBzYW1lIG9yZGVyLCBpcyByZXR1cm5lZCBmb3IgYWxsXHJcbiAgICAgKiBpbmRpdmlkdWFsIGVsZW1lbnRzLiBUaGUgaW5wdXQgZmllbGRzIGNhbiBlaXRoZXIgYmUgYnVuZGxlcywgYWRkcmVzc2VzLCB0YWdzIG9yIGFwcHJvdmVlcy5cclxuICAgICAqIFVzaW5nIG11bHRpcGxlIG9mIHRoZXNlIGlucHV0IGZpZWxkcyByZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGZpbmRUcmFuc2FjdGlvbnMgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmluZFRyYW5zYWN0aW9ucyhyZXF1ZXN0KSB7XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlcXVlc3QpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFwiVGhlIHJlcXVlc3QgbXVzdCBiZSBkZWZpbmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBidW5kbGVzRW1wdHkgPSBhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC5idW5kbGVzKTtcclxuICAgICAgICBjb25zdCBhZGRyZXNzZXNFbXB0eSA9IGFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNFbXB0eShyZXF1ZXN0LmFkZHJlc3Nlcyk7XHJcbiAgICAgICAgY29uc3QgdGFnc0VtcHR5ID0gYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc0VtcHR5KHJlcXVlc3QudGFncyk7XHJcbiAgICAgICAgY29uc3QgYXBwcm92ZWVzRW1wdHkgPSBhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC5hcHByb3ZlZXMpO1xyXG4gICAgICAgIGlmIChidW5kbGVzRW1wdHkgJiYgYWRkcmVzc2VzRW1wdHkgJiYgdGFnc0VtcHR5ICYmIGFwcHJvdmVlc0VtcHR5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFwiT25lIG9mIHRoZSBidW5kbGUsIGFkZHJlc3NlcywgdGFncyBvciBhcHByb3ZlZXMgbXVzdCBub3QgYmUgZW1wdHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRDb21tYW5kKFwiZmluZFRyYW5zYWN0aW9uc1wiLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmF3IHRyYW5zYWN0aW9uIGRhdGEgKHRyeXRlcykgb2YgYSBzcGVjaWZpYyB0cmFuc2FjdGlvbi5cclxuICAgICAqIFRoZXNlIHRyeXRlcyBjYW4gdGhlbiBiZSBlYXNpbHkgY29udmVydGVkIGludG8gdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBmaW5kVHJhbnNhY3Rpb25zIHJlc3BvbnNlIG9iamVjdCBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRyeXRlcyhyZXF1ZXN0KSB7XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlcXVlc3QpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFwiVGhlIHJlcXVlc3QgbXVzdCBiZSBkZWZpbmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc0VtcHR5KHJlcXVlc3QuaGFzaGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0Lmhhc2hlcyBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZENvbW1hbmQoXCJnZXRUcnl0ZXNcIiwgcmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaW5jbHVzaW9uIHN0YXRlcyBvZiBhIHNldCBvZiB0cmFuc2FjdGlvbnMuIFRoaXMgaXMgZm9yIGRldGVybWluaW5nIGlmIGEgdHJhbnNhY3Rpb25cclxuICAgICAqIHdhcyBhY2NlcHRlZCBhbmQgY29uZmlybWVkIGJ5IHRoZSBuZXR3b3JrIG9yIG5vdC4gWW91IGNhbiBzZWFyY2ggZm9yIG11bHRpcGxlIHRpcHMgKGFuZCB0aHVzLFxyXG4gICAgICogbWlsZXN0b25lcykgdG8gZ2V0IHBhc3QgaW5jbHVzaW9uIHN0YXRlcyBvZiB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBnZXRJbmNsdXNpb25TdGF0ZXMgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0SW5jbHVzaW9uU3RhdGVzKHJlcXVlc3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgcmVxdWVzdCBtdXN0IGJlIGRlZmluZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC50cmFuc2FjdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFwiVGhlIHJlcXVlc3QudHJhbnNhY3Rpb25zIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc0VtcHR5KHJlcXVlc3QudGlwcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgcmVxdWVzdC50aXBzIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kQ29tbWFuZChcImdldEluY2x1c2lvblN0YXRlc1wiLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29uZmlybWVkIGJhbGFuY2Ugd2hpY2ggYSBsaXN0IG9mIGFkZHJlc3NlcyBoYXZlIGF0IHRoZSBsYXRlc3QgY29uZmlybWVkIG1pbGVzdG9uZS5cclxuICAgICAqIEluIGFkZGl0aW9uIHRvIHRoZSBiYWxhbmNlcywgaXQgYWxzbyByZXR1cm5zIHRoZSBtaWxlc3RvbmUgYXMgd2VsbCBhcyB0aGUgaW5kZXggd2l0aCB3aGljaCB0aGVcclxuICAgICAqIGNvbmZpcm1lZCBiYWxhbmNlIHdhcyBkZXRlcm1pbmVkLiBUaGUgYmFsYW5jZXMgaXMgcmV0dXJuZWQgYXMgYSBsaXN0IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxyXG4gICAgICogYWRkcmVzc2VzIHdlcmUgcHJvdmlkZWQgYXMgaW5wdXQuXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUgZ2V0QmFsYW5jZXMgcmVxdWVzdCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBnZXRCYWxhbmNlcyByZXNwb25zZSBvYmplY3Qgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRCYWxhbmNlcyhyZXF1ZXN0KSB7XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlcXVlc3QpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFwiVGhlIHJlcXVlc3QgbXVzdCBiZSBkZWZpbmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc0VtcHR5KHJlcXVlc3QuYWRkcmVzc2VzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0LmFkZHJlc3NlcyBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHJlcXVlc3QudGhyZXNob2xkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0LnRocmVzaG9sZCBtdXN0IGJlIGEgdmFsaWQgbnVtYmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kQ29tbWFuZChcImdldEJhbGFuY2VzXCIsIHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaXAgc2VsZWN0aW9uIHdoaWNoIHJldHVybnMgdHJ1bmtUcmFuc2FjdGlvbiBhbmQgYnJhbmNoVHJhbnNhY3Rpb24uIFRoZSBpbnB1dCB2YWx1ZSBpcyBkZXB0aCxcclxuICAgICAqIHdoaWNoIGJhc2ljYWxseSBkZXRlcm1pbmVzIGhvdyBtYW55IGJ1bmRsZXMgdG8gZ28gYmFjayB0byBmb3IgZmluZGluZyB0aGUgdHJhbnNhY3Rpb25zIHRvIGFwcHJvdmUuXHJcbiAgICAgKiBUaGUgaGlnaGVyIHlvdXIgZGVwdGggdmFsdWUsIHRoZSBtb3JlIFwiYmFieXNpdHRpbmdcIiB5b3UgZG8gZm9yIHRoZSBuZXR3b3JrIChhcyB5b3UgaGF2ZSB0byBjb25maXJtIG1vcmUgdHJhbnNhY3Rpb25zKS5cclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBnZXRUcmFuc2FjdGlvbnNUb0FwcHJvdmUgcmVxdWVzdCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBnZXRUcmFuc2FjdGlvbnNUb0FwcHJvdmUgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zVG9BcHByb3ZlKHJlcXVlc3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgcmVxdWVzdCBtdXN0IGJlIGRlZmluZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihyZXF1ZXN0LmRlcHRoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0LmRlcHRoIG11c3QgYmUgYSB2YWxpZCBudW1iZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdC5yZWZlcmVuY2UpICYmIHN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KHJlcXVlc3QucmVmZXJlbmNlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0LnJlZmVyZW5jZSBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShyZXF1ZXN0Lm51bVdhbGtzKSAmJiAhbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihyZXF1ZXN0Lm51bVdhbGtzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0Lm51bVdhbGtzIG11c3QgYmUgYSB2YWxpZCBudW1iZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRDb21tYW5kKFwiZ2V0VHJhbnNhY3Rpb25zVG9BcHByb3ZlXCIsIHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyB0aGUgc3BlY2lmaWVkIHRyYW5zYWN0aW9ucyAodHJ5dGVzKSB0byB0aGUgVGFuZ2xlIGJ5IGRvaW5nIFByb29mIG9mIFdvcmsuIFlvdSBuZWVkIHRvIHN1cHBseVxyXG4gICAgICogYnJhbmNoVHJhbnNhY3Rpb24gYXMgd2VsbCBhcyB0cnVua1RyYW5zYWN0aW9uIChiYXNpY2FsbHkgdGhlIHRpcHMgd2hpY2ggeW91J3JlIGdvaW5nIHRvIHZhbGlkYXRlIGFuZFxyXG4gICAgICogcmVmZXJlbmNlIHdpdGggdGhpcyB0cmFuc2FjdGlvbikgLSBib3RoIG9mIHdoaWNoIHlvdSdsbCBnZXQgdGhyb3VnaCB0aGUgZ2V0VHJhbnNhY3Rpb25zVG9BcHByb3ZlIEFQSSBjYWxsLlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgVGhlIGF0dGFjaFRvVGFuZ2xlIHJlcXVlc3Qgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgYXR0YWNoVG9UYW5nbGUgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgYXR0YWNoVG9UYW5nbGUocmVxdWVzdCkge1xyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShyZXF1ZXN0KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0IG11c3QgYmUgZGVmaW5lZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KHJlcXVlc3QudHJ1bmtUcmFuc2FjdGlvbikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgcmVxdWVzdC50cnVua1RyYW5zYWN0aW9uIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RyaW5nSGVscGVyXzEuU3RyaW5nSGVscGVyLmlzRW1wdHkocmVxdWVzdC5icmFuY2hUcmFuc2FjdGlvbikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgcmVxdWVzdC5icmFuY2hUcmFuc2FjdGlvbiBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHJlcXVlc3QubWluV2VpZ2h0TWFnbml0dWRlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0Lm1pbldlaWdodE1hZ25pdHVkZSBtdXN0IGJlIGEgdmFsaWQgbnVtYmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc0VtcHR5KHJlcXVlc3QudHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0LnRyeXRlcyBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZENvbW1hbmQoXCJhdHRhY2hUb1RhbmdsZVwiLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJydXB0cyBhbmQgY29tcGxldGVseSBhYm9ydHMgdGhlIGF0dGFjaFRvVGFuZ2xlIHByb2Nlc3NcclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCBlbXB0eSByZXNwb25zZSBvYmplY3Qgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBpbnRlcnJ1cHRBdHRhY2hpbmdUb1RhbmdsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kQ29tbWFuZChcImludGVycnVwdEF0dGFjaGluZ1RvVGFuZ2xlXCIsIHt9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQnJvYWRjYXN0IGEgbGlzdCBvZiB0cmFuc2FjdGlvbnMgdG8gYWxsIG5laWdoYm9ycy4gVGhlIGlucHV0IHRyeXRlcyBmb3IgdGhpcyBjYWxsIGFyZSBwcm92aWRlZCBieSBhdHRhY2hUb1RhbmdsZS5cclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBicm9hZGNhc3RUcmFuc2FjdGlvbnMgcmVxdWVzdCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggZW1wdHkgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgYnJvYWRjYXN0VHJhbnNhY3Rpb25zKHJlcXVlc3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgcmVxdWVzdCBtdXN0IGJlIGRlZmluZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC50cnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFwiVGhlIHJlcXVlc3QudHJ5dGVzIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kQ29tbWFuZChcImJyb2FkY2FzdFRyYW5zYWN0aW9uc1wiLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcmUgdHJhbnNhY3Rpb25zIGludG8gdGhlIGxvY2FsIHN0b3JhZ2UuIFRoZSB0cnl0ZXMgdG8gYmUgdXNlZCBmb3IgdGhpcyBjYWxsIGFyZSByZXR1cm5lZCBieSBhdHRhY2hUb1RhbmdsZS5cclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBzdG9yZVRyYW5zYWN0aW9ucyByZXF1ZXN0IG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCBlbXB0eSByZXNwb25zZSBvYmplY3Qgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzdG9yZVRyYW5zYWN0aW9ucyhyZXF1ZXN0KSB7XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlcXVlc3QpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFwiVGhlIHJlcXVlc3QgbXVzdCBiZSBkZWZpbmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc0VtcHR5KHJlcXVlc3QudHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0LnRyeXRlcyBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZENvbW1hbmQoXCJzdG9yZVRyYW5zYWN0aW9uc1wiLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRyYW5zYWN0aW9ucyB3aXRoIG1pc3NpbmcgcmVmZXJlbmNlcy5cclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBnZXRNaXNzaW5nVHJhbnNhY3Rpb25zIHJlcXVlc3Qgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgZ2V0TWlzc2luZ1RyYW5zYWN0aW9ucyByZXNwb25zZSBvYmplY3Qgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRNaXNzaW5nVHJhbnNhY3Rpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRDb21tYW5kKFwiZ2V0TWlzc2luZ1RyYW5zYWN0aW9uc1wiLCB7fSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHRoZSBjb25zaXN0ZW5jeSBvZiB0YWlsIGhhc2hlcy5cclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBjaGVja0NvbnNpc3RlbmN5IHJlcXVlc3Qgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgY2hlY2tDb25zaXN0ZW5jeSByZXNwb25zZSBvYmplY3Qgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBjaGVja0NvbnNpc3RlbmN5KHJlcXVlc3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgcmVxdWVzdCBtdXN0IGJlIGRlZmluZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC50YWlscykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgcmVxdWVzdC50YWlscyBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZENvbW1hbmQoXCJjaGVja0NvbnNpc3RlbmN5XCIsIHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIYXZlIHRoZSByZXF1ZXN0ZWQgYWRkcmVzc2VzIGJlZW4gc3BlbnQgZnJvbSBhbHJlYWR5LlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgVGhlIHdlcmVBZGRyZXNzZXNTcGVudEZyb20gcmVxdWVzdCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSB3ZXJlQWRkcmVzc2VzU3BlbnRGcm9tIHJlc3BvbnNlIG9iamVjdCBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHdlcmVBZGRyZXNzZXNTcGVudEZyb20ocmVxdWVzdCkge1xyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShyZXF1ZXN0KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcIlRoZSByZXF1ZXN0IG11c3QgYmUgZGVmaW5lZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNFbXB0eShyZXF1ZXN0LmFkZHJlc3NlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXCJUaGUgcmVxdWVzdC5hZGRyZXNzZXMgbXVzdCBub3QgYmUgZW1wdHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRDb21tYW5kKFwid2VyZUFkZHJlc3Nlc1NwZW50RnJvbVwiLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgYXN5bmMgc2VuZENvbW1hbmQoY29tbWFuZCwgcmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGA9PT0+IEFwaUNsaWVudDo6JHtjb21tYW5kfWAsIHJlcXVlc3QpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1ZXN0LCBcImNvbW1hbmRcIiwge1xyXG4gICAgICAgICAgICB2YWx1ZTogY29tbWFuZCxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uZXR3b3JrQ2xpZW50LnBvc3RKc29uKHJlcXVlc3QsIHVuZGVmaW5lZCwgdGhpcy5jcmVhdGVIZWFkZXJzKCkpXHJcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgPT09PiAke2NvbW1hbmR9YCwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGA9PT0+ICR7Y29tbWFuZH0gRXJyb3JgLCBlcnIpO1xyXG4gICAgICAgICAgICBpZiAoZXJyLmFkZGl0aW9uYWwgJiYgZXJyLmFkZGl0aW9uYWwuZXJyb3JSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IEpTT04ucGFyc2UoZXJyLmFkZGl0aW9uYWwuZXJyb3JSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwaUVycm9yLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlcnIuYWRkaXRpb25hbC5lcnJvclJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIuYWRkaXRpb25hbC5hcGlFcnJvciA9IGFwaUVycm9yLmVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcGlFcnJvci5leGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVyci5hZGRpdGlvbmFsLmVycm9yUmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5hZGRpdGlvbmFsLmFwaUVycm9yID0gYXBpRXJyb3IuZXhjZXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBjcmVhdGVIZWFkZXJzKCkge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLl9hZGRpdGlvbmFsSGVhZGVycyB8fCB7fTtcclxuICAgICAgICBoZWFkZXJzW1wiWC1JT1RBLUFQSS1WZXJzaW9uXCJdID0gdGhpcy5fYXBpVmVyc2lvbjtcclxuICAgICAgICByZXR1cm4gaGVhZGVycztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkFwaUNsaWVudCA9IEFwaUNsaWVudDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWVhCcFEyeHBaVzUwTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMk5zYVdWdWRDOWhjR2xEYkdsbGJuUXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQkxEQkZRVUYxUlR0QlFVTjJSU3cwUlVGQmVVVTdRVUZEZWtVc05FVkJRWGxGTzBGQlEzcEZMRFJGUVVGNVJUdEJRVWQ2UlN4M1JVRkJjVVU3UVVGRGNrVXNaMFJCUVRaRE8wRkJPRUkzUXpzN1IwRkZSenRCUVVOSU8wbEJWVWs3T3pzN096dFBRVTFITzBsQlEwZ3NXVUZCV1N4aFFVRTJRaXhGUVVGRkxHRkJRWEZDTEVkQlFVY3NSVUZCUlN4cFFrRkJaMFFzUlVGQlJTeE5RVUZuUWp0UlFVTnVTU3hGUVVGRkxFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZEVNc1RVRkJUU3hKUVVGSkxHMUNRVUZSTEVOQlFVTXNiVU5CUVcxRExFTkJRVU1zUTBGQlF6dFJRVU0xUkN4RFFVRkRPMUZCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRTFCUVUwc1NVRkJTU3h0UWtGQlVTeERRVUZETEd0RFFVRnJReXhEUVVGRExFTkJRVU03VVVGRE0wUXNRMEZCUXp0UlFVTkVMRWxCUVVrc1EwRkJReXhqUVVGakxFZEJRVWNzWVVGQllTeERRVUZETzFGQlEzQkRMRWxCUVVrc1EwRkJReXhYUVVGWExFZEJRVWNzVlVGQlZTeERRVUZETzFGQlF6bENMRWxCUVVrc1EwRkJReXhyUWtGQmEwSXNSMEZCUnl4cFFrRkJhVUlzUTBGQlF6dFJRVU0xUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhIUVVGSExFMUJRVTBzU1VGQlNTeEpRVUZKTEhWQ1FVRlZMRVZCUVVVc1EwRkJRenRKUVVNNVF5eERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzUzBGQlN5eERRVUZETEZkQlFWYzdVVUZEY0VJc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFUSkNMR0ZCUVdFc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEpRVU42UlN4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRXRCUVVzc1EwRkJReXhaUVVGWk8xRkJRM0pDTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVFMFFpeGpRVUZqTEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1NVRkRNMFVzUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeExRVUZMTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTlCUVRaQ08xRkJRMjVFTEVWQlFVVXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOb1F5eE5RVUZOTEVsQlFVa3NiVUpCUVZFc1EwRkJReXcyUWtGQk5rSXNRMEZCUXl4RFFVRkRPMUZCUTNSRUxFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JETEUxQlFVMHNTVUZCU1N4dFFrRkJVU3hEUVVGRExHOURRVUZ2UXl4RFFVRkRMRU5CUVVNN1VVRkROMFFzUTBGQlF6dFJRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVFNFF5eGpRVUZqTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRiRWNzUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeExRVUZMTEVOQlFVTXNaVUZCWlN4RFFVRkRMRTlCUVdkRE8xRkJRM3BFTEVWQlFVVXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOb1F5eE5RVUZOTEVsQlFVa3NiVUpCUVZFc1EwRkJReXcyUWtGQk5rSXNRMEZCUXl4RFFVRkRPMUZCUTNSRUxFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JETEUxQlFVMHNTVUZCU1N4dFFrRkJVU3hEUVVGRExHOURRVUZ2UXl4RFFVRkRMRU5CUVVNN1VVRkROMFFzUTBGQlF6dFJRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGdlJDeHBRa0ZCYVVJc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU16Unl4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NTMEZCU3l4RFFVRkRMRTlCUVU4N1VVRkRhRUlzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVhWQ0xGTkJRVk1zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0SlFVTnFSU3hEUVVGRE8wbEJSVVE3T3pzN096dFBRVTFITzBsQlEwa3NTMEZCU3l4RFFVRkRMR2RDUVVGblFpeERRVUZETEU5QlFXbERPMUZCUXpORUxFVkJRVVVzUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTm9ReXhOUVVGTkxFbEJRVWtzYlVKQlFWRXNRMEZCUXl3MlFrRkJOa0lzUTBGQlF5eERRVUZETzFGQlEzUkVMRU5CUVVNN1VVRkRSQ3hOUVVGTkxGbEJRVmtzUjBGQlJ5eDVRa0ZCVnl4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdVVUZETVVRc1RVRkJUU3hqUVVGakxFZEJRVWNzZVVKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETzFGQlF6bEVMRTFCUVUwc1UwRkJVeXhIUVVGSExIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU53UkN4TlFVRk5MR05CUVdNc1IwRkJSeXg1UWtGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU03VVVGRE9VUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1dVRkJXU3hKUVVGSkxHTkJRV01zU1VGQlNTeFRRVUZUTEVsQlFVa3NZMEZCWXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOb1JTeE5RVUZOTEVsQlFVa3NiVUpCUVZFc1EwRkJReXh0UlVGQmJVVXNRMEZCUXl4RFFVRkRPMUZCUXpWR0xFTkJRVU03VVVGRFJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJjMFFzYTBKQlFXdENMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRE9VY3NRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFOUJRVEJDTzFGQlF6ZERMRVZCUVVVc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5vUXl4TlFVRk5MRWxCUVVrc2JVSkJRVkVzUTBGQlF5dzJRa0ZCTmtJc1EwRkJReXhEUVVGRE8xRkJRM1JFTEVOQlFVTTdVVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXg1UWtGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzUkRMRTFCUVUwc1NVRkJTU3h0UWtGQlVTeERRVUZETEhORFFVRnpReXhEUVVGRExFTkJRVU03VVVGREwwUXNRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUYzUXl4WFFVRlhMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRGVrWXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1MwRkJTeXhEUVVGRExHdENRVUZyUWl4RFFVRkRMRTlCUVcxRE8xRkJReTlFTEVWQlFVVXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOb1F5eE5RVUZOTEVsQlFVa3NiVUpCUVZFc1EwRkJReXcyUWtGQk5rSXNRMEZCUXl4RFFVRkRPMUZCUTNSRUxFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRelZETEUxQlFVMHNTVUZCU1N4dFFrRkJVU3hEUVVGRExEUkRRVUUwUXl4RFFVRkRMRU5CUVVNN1VVRkRja1VzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFTXNUVUZCVFN4SlFVRkpMRzFDUVVGUkxFTkJRVU1zYjBOQlFXOURMRU5CUVVNc1EwRkJRenRSUVVNM1JDeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVEJFTEc5Q1FVRnZRaXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzBsQlEzQklMRU5CUVVNN1NVRkZSRHM3T3pzN096dFBRVTlITzBsQlEwa3NTMEZCU3l4RFFVRkRMRmRCUVZjc1EwRkJReXhQUVVFMFFqdFJRVU5xUkN4RlFVRkZMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFFTXNUVUZCVFN4SlFVRkpMRzFDUVVGUkxFTkJRVU1zTmtKQlFUWkNMRU5CUVVNc1EwRkJRenRSUVVOMFJDeERRVUZETzFGQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc2VVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU42UXl4TlFVRk5MRWxCUVVrc2JVSkJRVkVzUTBGQlF5eDVRMEZCZVVNc1EwRkJReXhEUVVGRE8xRkJRMnhGTEVOQlFVTTdVVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTlCUVU4c1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETjBNc1RVRkJUU3hKUVVGSkxHMUNRVUZSTEVOQlFVTXNPRU5CUVRoRExFTkJRVU1zUTBGQlF6dFJRVU4yUlN4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFUUkRMR0ZCUVdFc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU12Uml4RFFVRkRPMGxCUlVRN096czdPenRQUVUxSE8wbEJRMGtzUzBGQlN5eERRVUZETEhkQ1FVRjNRaXhEUVVGRExFOUJRWGxETzFGQlF6TkZMRVZCUVVVc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5vUXl4TlFVRk5MRWxCUVVrc2JVSkJRVkVzUTBGQlF5dzJRa0ZCTmtJc1EwRkJReXhEUVVGRE8xRkJRM1JFTEVOQlFVTTdVVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZWtNc1RVRkJUU3hKUVVGSkxHMUNRVUZSTEVOQlFVTXNNRU5CUVRCRExFTkJRVU1zUTBGQlF6dFJRVU51UlN4RFFVRkRPMUZCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMFJpeE5RVUZOTEVsQlFVa3NiVUpCUVZFc1EwRkJReXhyUkVGQmEwUXNRMEZCUXl4RFFVRkRPMUZCUXpORkxFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZGtZc1RVRkJUU3hKUVVGSkxHMUNRVUZSTEVOQlFVTXNOa05CUVRaRExFTkJRVU1zUTBGQlF6dFJRVU4wUlN4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFYTkZMREJDUVVFd1FpeEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUTNSSkxFTkJRVU03U1VGRlJEczdPenM3TzA5QlRVYzdTVUZEU1N4TFFVRkxMRU5CUVVNc1kwRkJZeXhEUVVGRExFOUJRU3RDTzFGQlEzWkVMRVZCUVVVc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5vUXl4TlFVRk5MRWxCUVVrc2JVSkJRVkVzUTBGQlF5dzJRa0ZCTmtJc1EwRkJReXhEUVVGRE8xRkJRM1JFTEVOQlFVTTdVVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha1FzVFVGQlRTeEpRVUZKTEcxQ1FVRlJMRU5CUVVNc1owUkJRV2RFTEVOQlFVTXNRMEZCUXp0UlFVTjZSU3hEUVVGRE8xRkJRMFFzUlVGQlJTeERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEdsQ1FVRnBRaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyeEVMRTFCUVUwc1NVRkJTU3h0UWtGQlVTeERRVUZETEdsRVFVRnBSQ3hEUVVGRExFTkJRVU03VVVGRE1VVXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1QwRkJUeXhEUVVGRExHdENRVUZyUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM1JFTEUxQlFVMHNTVUZCU1N4dFFrRkJVU3hEUVVGRExIVkVRVUYxUkN4RFFVRkRMRU5CUVVNN1VVRkRhRVlzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRFTXNUVUZCVFN4SlFVRkpMRzFDUVVGUkxFTkJRVU1zYzBOQlFYTkRMRU5CUVVNc1EwRkJRenRSUVVNdlJDeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRV3RFTEdkQ1FVRm5RaXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzBsQlEzaEhMRU5CUVVNN1NVRkZSRHM3TzA5QlIwYzdTVUZEU1N4TFFVRkxMRU5CUVVNc01FSkJRVEJDTzFGQlEyNURMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZ6UWl3MFFrRkJORUlzUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0SlFVTnVSaXhEUVVGRE8wbEJSVVE3T3pzN1QwRkpSenRKUVVOSkxFdEJRVXNzUTBGQlF5eHhRa0ZCY1VJc1EwRkJReXhQUVVGelF6dFJRVU55UlN4RlFVRkZMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFFTXNUVUZCVFN4SlFVRkpMRzFDUVVGUkxFTkJRVU1zTmtKQlFUWkNMRU5CUVVNc1EwRkJRenRSUVVOMFJDeERRVUZETzFGQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc2VVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4wUXl4TlFVRk5MRWxCUVVrc2JVSkJRVkVzUTBGQlF5eHpRMEZCYzBNc1EwRkJReXhEUVVGRE8xRkJReTlFTEVOQlFVTTdVVUZEUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQmFVUXNkVUpCUVhWQ0xFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdTVUZET1Vjc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hMUVVGTExFTkJRVU1zYVVKQlFXbENMRU5CUVVNc1QwRkJhME03VVVGRE4wUXNSVUZCUlN4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMmhETEUxQlFVMHNTVUZCU1N4dFFrRkJVU3hEUVVGRExEWkNRVUUyUWl4RFFVRkRMRU5CUVVNN1VVRkRkRVFzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRFTXNUVUZCVFN4SlFVRkpMRzFDUVVGUkxFTkJRVU1zYzBOQlFYTkRMRU5CUVVNc1EwRkJRenRSUVVNdlJDeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVFpETEcxQ1FVRnRRaXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzBsQlEzUkhMRU5CUVVNN1NVRkZSRHM3T3p0UFFVbEhPMGxCUTBrc1MwRkJTeXhEUVVGRExITkNRVUZ6UWp0UlFVTXZRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCYzBNc2QwSkJRWGRDTEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1NVRkRMMFlzUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeExRVUZMTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zVDBGQmFVTTdVVUZETTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyaERMRTFCUVUwc1NVRkJTU3h0UWtGQlVTeERRVUZETERaQ1FVRTJRaXhEUVVGRExFTkJRVU03VVVGRGRFUXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY2tNc1RVRkJUU3hKUVVGSkxHMUNRVUZSTEVOQlFVTXNjVU5CUVhGRExFTkJRVU1zUTBGQlF6dFJRVU01UkN4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFYTkVMR3RDUVVGclFpeEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUXpsSExFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGtzUzBGQlN5eERRVUZETEhOQ1FVRnpRaXhEUVVGRExFOUJRWFZETzFGQlEzWkZMRVZCUVVVc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5vUXl4TlFVRk5MRWxCUVVrc2JVSkJRVkVzUTBGQlF5dzJRa0ZCTmtJc1EwRkJReXhEUVVGRE8xRkJRM1JFTEVOQlFVTTdVVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXg1UWtGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzcERMRTFCUVUwc1NVRkJTU3h0UWtGQlVTeERRVUZETEhsRFFVRjVReXhEUVVGRExFTkJRVU03VVVGRGJFVXNRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZyUlN4M1FrRkJkMElzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTm9TU3hEUVVGRE8wbEJSVVFzWlVGQlpUdEpRVU5RTEV0QlFVc3NRMEZCUXl4WFFVRlhMRU5CUVN0Q0xFOUJRV1VzUlVGQlJTeFBRVUZWTzFGQlF5OUZMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEcxQ1FVRnRRaXhQUVVGUExFVkJRVVVzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTjZSQ3hOUVVGTkxFTkJRVU1zWTBGQll5eERRVUZETEU5QlFVOHNSVUZCUlN4VFFVRlRMRVZCUVVVN1dVRkRkRU1zUzBGQlN5eEZRVUZGTEU5QlFVODdXVUZEWkN4VlFVRlZMRVZCUVVVc1NVRkJTVHRUUVVOdVFpeERRVUZETEVOQlFVTTdVVUZEU0N4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eFJRVUZSTEVOQlFVOHNUMEZCVHl4RlFVRkZMRk5CUVZNc1JVRkJSU3hKUVVGSkxFTkJRVU1zWVVGQllTeEZRVUZGTEVOQlFVTTdZVUZET1VVc1NVRkJTU3hEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVWQlFVVTdXVUZEWml4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEU5QlFVOHNSVUZCUlN4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8xbEJReTlETEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNN1VVRkRjRUlzUTBGQlF5eERRVUZETzJGQlEwUXNTMEZCU3l4RFFVRkRMRU5CUVVNc1IwRkJZU3hGUVVGRkxFVkJRVVU3V1VGRGNrSXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGTExFTkJRVU1zVVVGQlVTeFBRVUZQTEZGQlFWRXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVOcVJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJWU3hKUVVGSkxFZEJRVWNzUTBGQlF5eFZRVUZWTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGFrUXNTVUZCU1N4RFFVRkRPMjlDUVVORUxFMUJRVTBzVVVGQlVTeEhRVUZITEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVlVzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXp0dlFrRkRNVVFzUlVGQlJTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03ZDBKQlEycENMRTlCUVU4c1IwRkJSeXhEUVVGRExGVkJRVlVzUTBGQlF5eGhRVUZoTEVOQlFVTTdkMEpCUTNCRExFZEJRVWNzUTBGQlF5eFZRVUZWTEVOQlFVTXNVVUZCVVN4SFFVRkhMRkZCUVZFc1EwRkJReXhMUVVGTExFTkJRVU03YjBKQlF6ZERMRU5CUVVNN2IwSkJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzNkQ1FVTTFRaXhQUVVGUExFZEJRVWNzUTBGQlF5eFZRVUZWTEVOQlFVTXNZVUZCWVN4RFFVRkRPM2RDUVVOd1F5eEhRVUZITEVOQlFVTXNWVUZCVlN4RFFVRkRMRkZCUVZFc1IwRkJSeXhSUVVGUkxFTkJRVU1zVTBGQlV5eERRVUZETzI5Q1FVTnFSQ3hEUVVGRE8yZENRVU5NTEVOQlFVTTdaMEpCUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRZaXhEUVVGRE8xbEJRMHdzUTBGQlF6dFpRVU5FTEUxQlFVMHNSMEZCUnl4RFFVRkRPMUZCUTJRc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFdDeERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlFMR0ZCUVdFN1VVRkRha0lzVFVGQlRTeFBRVUZQTEVkQlFVY3NTVUZCU1N4RFFVRkRMR3RDUVVGclFpeEpRVUZKTEVWQlFVVXNRMEZCUXp0UlFVTTVReXhQUVVGUExFTkJRVU1zYjBKQlFXOUNMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETzFGQlEycEVMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU03U1VGRGJrSXNRMEZCUXp0RFFVTktPMEZCY0ZWRUxEaENRVzlWUXlKOVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvY2xpZW50L2FwaUNsaWVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pb3RhLXBpY28tYXBpL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW90YS1waWNvLWFwaS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lvdGEtcGljby1hcGkvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBmYWN0b3J5QmFzZV8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2ZhY3Rvcmllcy9mYWN0b3J5QmFzZVwiKTtcclxuLyoqXHJcbiAqIEZhY3RvcnkgdG8gZ2VuZXJhdGUgcHJvb2Ygb2Ygd29yay5cclxuICovXHJcbmNsYXNzIFByb29mT2ZXb3JrRmFjdG9yeSBleHRlbmRzIGZhY3RvcnlCYXNlXzEuRmFjdG9yeUJhc2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEb24ndCBhbGxvdyBtYW51YWwgY29uc3RydWN0aW9uIG9mIHRoZSBmYWN0b3J5LlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaW5zdGFuY2Ugb2YgdGhlIGZhY3RvcnkuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmFjdG9yeSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGluc3RhbmNlKCkge1xyXG4gICAgICAgIGlmICghUHJvb2ZPZldvcmtGYWN0b3J5Ll9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBQcm9vZk9mV29ya0ZhY3RvcnkuX2luc3RhbmNlID0gbmV3IFByb29mT2ZXb3JrRmFjdG9yeSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvb2ZPZldvcmtGYWN0b3J5Ll9pbnN0YW5jZTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgZ2V0SW5zdGFuY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb29mT2ZXb3JrRmFjdG9yeS5pbnN0YW5jZSgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUHJvb2ZPZldvcmtGYWN0b3J5ID0gUHJvb2ZPZldvcmtGYWN0b3J5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljSEp2YjJaUFpsZHZjbXRHWVdOMGIzSjVMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyWmhZM1J2Y21sbGN5OXdjbTl2Wms5bVYyOXlhMFpoWTNSdmNua3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQkxEUkZRVUY1UlR0QlFVZDZSVHM3UjBGRlJ6dEJRVU5JTEhkQ1FVRm5ReXhUUVVGUkxIbENRVUY1UWp0SlFVazNSRHM3TzA5QlIwYzdTVUZEU0R0UlFVTkpMRXRCUVVzc1JVRkJSU3hEUVVGRE8wbEJRMW9zUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxFMUJRVTBzUTBGQlF5eFJRVUZSTzFGQlEyeENMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5vUXl4clFrRkJhMElzUTBGQlF5eFRRVUZUTEVkQlFVY3NTVUZCU1N4clFrRkJhMElzUlVGQlJTeERRVUZETzFGQlF6VkVMRU5CUVVNN1VVRkRSQ3hOUVVGTkxFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1UwRkJVeXhEUVVGRE8wbEJRM2hETEVOQlFVTTdTVUZGUkN4bFFVRmxPMGxCUTB3c1YwRkJWenRSUVVOcVFpeE5RVUZOTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdTVUZEZWtNc1EwRkJRenREUVVOS08wRkJNMEpFTEdkRVFUSkNReUo5XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9mYWN0b3JpZXMvcHJvb2ZPZldvcmtGYWN0b3J5LnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBhcnJheUhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXJcIik7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgdGltZVNlcnZpY2VfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9zZXJ2aWNlcy90aW1lU2VydmljZVwiKTtcclxuY29uc3QgaXNzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jcnlwdG8vZGlzdC9oYXNoL2lzc1wiKTtcclxuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvYWRkcmVzc1wiKTtcclxuY29uc3QgYnVuZGxlXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9idW5kbGVcIik7XHJcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2hhc2hcIik7XHJcbmNvbnN0IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XCIpO1xyXG5jb25zdCB0YWdfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RhZ1wiKTtcclxuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyYW5zYWN0aW9uXCIpO1xyXG5jb25zdCB0cmFuc2Zlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJhbnNmZXJcIik7XHJcbmNvbnN0IHRyaXRzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cml0c1wiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cnl0ZXNcIik7XHJcbmNvbnN0IGJ1c2luZXNzRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9idXNpbmVzc0Vycm9yXCIpO1xyXG5jb25zdCBidW5kbGVIZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2J1bmRsZUhlbHBlclwiKTtcclxuY29uc3QgbXVsdGlTaWdBZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9tdWx0aVNpZ0FkZHJlc3NcIik7XHJcbi8qKlxyXG4gKiBNdWx0aXBsZSBzaWduYXR1cmVzLlxyXG4gKiBDb252ZXJ0ZWQgaHR0cHM6Ly9naXRodWIuY29tL2lvdGFsZWRnZXIvaW90YS5saWIuanMvYmxvYi9tYXN0ZXIvbGliL211bHRpc2lnL211bHRpc2lnLmpzXHJcbiAqL1xyXG5jbGFzcyBNdWx0aVNpZ0NsaWVudCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTXVsdGlTaWdDbGllbnQuXHJcbiAgICAgKiBAcGFyYW0gYXBpQ2xpZW50IEFuIEFQSSBDbGllbnQgdG8gY29tbXVuaWNhdGUgdGhyb3VnaC5cclxuICAgICAqIEBwYXJhbSB0aW1lU2VydmljZSBBIGNsYXNzIHdoaWNoIGNhbiBwcm92aWRlIHRoZSB0aW1lLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIHRpbWVTZXJ2aWNlID0gbmV3IHRpbWVTZXJ2aWNlXzEuVGltZVNlcnZpY2UoKSkge1xyXG4gICAgICAgIHRoaXMuX2FwaUNsaWVudCA9IGFwaUNsaWVudDtcclxuICAgICAgICB0aGlzLl90aW1lU2VydmljZSA9IHRpbWVTZXJ2aWNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGtleSB2YWx1ZSBvZiBhIHNlZWQuXHJcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZCB0byBnZXQgdGhlIGtleSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGFkZHJlc3MgaW5kZXggdG8gdXNlLlxyXG4gICAgICogQHBhcmFtIHNlY3VyaXR5IFRoZSBzZWN1cml0eSBsZXZlbCB0byB1c2UuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJ5dGVzIGZvciB0aGUga2V5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0S2V5KHNlZWQsIGluZGV4LCBzZWN1cml0eSkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlZWQgc2hvdWxkIGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihpbmRleCkgfHwgaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBpbmRleCBzaG91bGQgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHNlY3VyaXR5KSB8fCBzZWN1cml0eSA8IDEgfHwgc2VjdXJpdHkgPiAzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBzZWN1cml0eSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgM1wiLCB7IHNlY3VyaXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJpdHNfMS5Ucml0cy5mcm9tQXJyYXkoaXNzXzEuSVNTLmtleShzZWVkLCBpbmRleCwgc2VjdXJpdHkpKS50b1RyeXRlcygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRpZ2VzdCB2YWx1ZSBvZiBhIHNlZWQuXHJcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZCB0byBnZXQgdGhlIGRpZ2VzdCBmb3IuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGFkZHJlc3MgaW5kZXggdG8gdXNlLlxyXG4gICAgICogQHBhcmFtIHNlY3VyaXR5IFRoZSBzZWN1cml0eSBsZXZlbCB0byB1c2UuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJ5dGVzIGZvciB0aGUgZGlnZXN0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RGlnZXN0KHNlZWQsIGluZGV4LCBzZWN1cml0eSkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlZWQgc2hvdWxkIGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihpbmRleCkgfHwgaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBpbmRleCBzaG91bGQgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHNlY3VyaXR5KSB8fCBzZWN1cml0eSA8IDEgfHwgc2VjdXJpdHkgPiAzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBzZWN1cml0eSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgM1wiLCB7IHNlY3VyaXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXkgPSBpc3NfMS5JU1Mua2V5KHNlZWQsIGluZGV4LCBzZWN1cml0eSk7XHJcbiAgICAgICAgcmV0dXJuIHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGlzc18xLklTUy5kaWdlc3RzKGtleSkpLnRvVHJ5dGVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIGFkZHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byB2YWxpZGF0ZSBhZ2FpbnN0IHRoZSBkaWdlc3RzLlxyXG4gICAgICogQHBhcmFtIGRpZ2VzdHMgVGhlIGRpZ2VzdHMgdG8gdXNlIHRvIHZhbGlkYXRlIHRoZSBhZGRyZXNzLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYWRkcmVzcyBtYXRjaGVzIHRoZSBkaWdlc3RzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdmFsaWRhdGVBZGRyZXNzKGFkZHJlc3MsIGRpZ2VzdHMpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoYWRkcmVzcywgYWRkcmVzc18xLkFkZHJlc3MpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBhZGRyZXNzIHNob3VsZCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBBZGRyZXNzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChkaWdlc3RzLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBkaWdlc3RzIHNob3VsZCBiZSBhbiBhcnJheSBvZiB0eXBlIFRyeXRlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpID09PVxyXG4gICAgICAgICAgICBuZXcgbXVsdGlTaWdBZGRyZXNzXzEuTXVsdGlTaWdBZGRyZXNzKCkuZmluYWxpemUoZGlnZXN0cykudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBjb3NpZ25lciBzaWduYXR1cmVzIHRvIHRoZSBjb3JyZXNwb25kaW5nIGJ1bmRsZSB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0gYnVuZGxlIFRoZSBidW5kbGUgdG8gc2lnbi5cclxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzIHRvIG1hdGNoIHRoZSB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25zIHdpdGguXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhZGRTaWduYXR1cmUoYnVuZGxlLCBhZGRyZXNzLCBrZXkpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoYnVuZGxlLCBidW5kbGVfMS5CdW5kbGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBidW5kbGUgc2hvdWxkIGJlIGFuIG9iamVjdCBvZiB0eXBlIEJ1bmRsZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYnVuZGxlLnRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGJ1bmRsZS50cmFuc2FjdGlvbnMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHR5cGUgVHJhbnNhY3Rpb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShhZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGFkZHJlc3Mgc2hvdWxkIGJlIGFuIG9iamVjdCBvZiB0eXBlIEFkZHJlc3NcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShrZXksIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGtleSBzaG91bGQgYmUgYW4gb2JqZWN0IG9mIHR5cGUgVHJ5dGVzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlUcml0cyA9IHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyhrZXkpLnRvQXJyYXkoKTtcclxuICAgICAgICAvLyBHZXQgdGhlIHNlY3VyaXR5IHVzZWQgZm9yIHRoZSBwcml2YXRlIGtleVxyXG4gICAgICAgIC8vIDEgc2VjdXJpdHkgbGV2ZWwgPSAyMTg3IHRyeXRlc1xyXG4gICAgICAgIGNvbnN0IHNlY3VyaXR5ID0ga2V5VHJpdHMubGVuZ3RoIC8gMyAvIDIxODc7XHJcbiAgICAgICAgLy8gRmlyc3QgZ2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgYWxyZWFkeSBzaWduZWQgdHJhbnNhY3Rpb25zXHJcbiAgICAgICAgLy8gdXNlIHRoYXQgZm9yIHRoZSBidW5kbGUgaGFzaCBjYWxjdWxhdGlvbiBhcyB3ZWxsIGFzIGtub3dpbmdcclxuICAgICAgICAvLyB3aGVyZSB0byBhZGQgdGhlIHNpZ25hdHVyZVxyXG4gICAgICAgIGxldCBudW1TaWduZWRUeHMgPSAwO1xyXG4gICAgICAgIGNvbnN0IGFkZHJlc3NUcnl0ZXMgPSBhZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09IGFkZHJlc3NUcnl0ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChidW5kbGUudHJhbnNhY3Rpb25zW2ldLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC50b1RyeXRlcygpLnRvU3RyaW5nKCkgIT09IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5FTVBUWS50b1RyeXRlcygpLnRvU3RyaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0cmFuc2FjdGlvbiBpcyBhbHJlYWR5IHNpZ25lZCwgaW5jcmVhc2UgY291bnRlclxyXG4gICAgICAgICAgICAgICAgICAgIG51bVNpZ25lZFR4cysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLnNpZ25UcmFuc2FjdGlvbnMoYnVuZGxlLCBpLCBudW1TaWduZWRUeHMgJSAzLCBrZXlUcml0cywgYWRkcmVzc1RyeXRlcywgc2VjdXJpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWF0ZXMgdGhlIGNyZWF0aW9uIG9mIGEgbmV3IHRyYW5zZmVyIGJ5IGdlbmVyYXRpbmcgYW4gZW1wdHkgYnVuZGxlIHdpdGggdGhlIGNvcnJlY3QgbnVtYmVyXHJcbiAgICAgKiBvZiBidW5kbGUgZW50cmllcyB0byBiZSBsYXRlciB1c2VkIGZvciB0aGUgc2lnbmluZyBwcm9jZXNzLlxyXG4gICAgICogQHBhcmFtIGFkZHJlc3MgQWRkcmVzcyB3aGljaCBoYXMgc3VmZmljaWVudCBiYWxhbmNlIGFuZCBpcyBjb250cm9sbGVkIGJ5IHRoZSBjby1zaWduZXJzLlxyXG4gICAgICogQHBhcmFtIHNlY3VyaXR5U3VtIHRoZSBzdW0gb2YgdGhlIHNlY3VyaXR5IGxldmVscyBmcm9tIGFsbCBjb3NpZ25lcnMgY2hvc2VuIGR1cmluZyB0aGUgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiAoZ2V0S2V5IC8gZ2V0RGlnZXN0KVxyXG4gICAgICogQHBhcmFtIGJhbGFuY2UgVGhlIGJhbGFuY2UgYXZhaWxhYmxlIGZvciB0aGUgdHJhbnNmZXIsIGlmIDAgd2lsbCBjYWxsIGdldEJhbGFuY2VzIHRvIGxvb2t1cCBhdmFpbGFibGUuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJzIFRoZSB0cmFuc2ZlcnMgdG8gcGVyZm9ybS5cclxuICAgICAqIEBwYXJhbSByZW1haW5kZXJBZGRyZXNzIElmIHRoZXJlIGlzIGEgcmVtYWluZGVyIGFmdGVyIHRoZSB0cmFuc2ZlciB0aGVuIHNlbmQgdGhlIGFtb3VudCB0byB0aGlzIGFkZHJlc3MuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHByZXBhcmVUcmFuc2ZlcihhZGRyZXNzLCBzZWN1cml0eVN1bSwgYmFsYW5jZSwgdHJhbnNmZXJzLCByZW1haW5kZXJBZGRyZXNzKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgYWRkcmVzcyBzaG91bGQgYmUgYW4gb2JqZWN0IG9mIHR5cGUgQWRkcmVzc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHNlY3VyaXR5U3VtKSB8fCBzZWN1cml0eVN1bSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlY3VyaXR5U3VtIHNob3VsZCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoYmFsYW5jZSkgfHwgYmFsYW5jZSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGJhbGFuY2Ugc2hvdWxkIGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyYW5zZmVycywgdHJhbnNmZXJfMS5UcmFuc2ZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHRyYW5zZmVycyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgdHlwZSBUcmFuc2ZlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShyZW1haW5kZXJBZGRyZXNzKSAmJiAhb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShyZW1haW5kZXJBZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHJlbWFpbmRlckFkZHJlc3Mgc2hvdWxkIGJlIGFuIG9iamVjdCBvZiB0eXBlIEFkZHJlc3NcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVtcHR5VHJ5dGVzID0gdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoXCJcIik7XHJcbiAgICAgICAgLy8gSWYgbWVzc2FnZSBvciB0YWcgaXMgbm90IHN1cHBsaWVkLCBwcm92aWRlIGl0XHJcbiAgICAgICAgdHJhbnNmZXJzLmZvckVhY2goKHRyYW5zZmVyKSA9PiB7XHJcbiAgICAgICAgICAgIHRyYW5zZmVyLm1lc3NhZ2UgPSB0cmFuc2Zlci5tZXNzYWdlID8gdHJhbnNmZXIubWVzc2FnZSA6IGVtcHR5VHJ5dGVzO1xyXG4gICAgICAgICAgICB0cmFuc2Zlci50YWcgPSB0cmFuc2Zlci50YWcgfHwgdGFnXzEuVGFnLkVNUFRZO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHByZXBhcmVkID0gYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLnByZXBhcmVCdW5kbGUodGhpcy5fdGltZVNlcnZpY2UsIHRyYW5zZmVycyk7XHJcbiAgICAgICAgaWYgKHByZXBhcmVkLnRvdGFsVmFsdWUgPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHRvdGFsIHRyYW5zZmVyIHZhbHVlIGlzIDAsIHRoZSB0cmFuc2ZlciBkb2VzIG5vdCByZXF1aXJlIGEgc2lnbmF0dXJlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHRvdGFsQmFsYW5jZSA9IGJhbGFuY2U7XHJcbiAgICAgICAgICAgIGlmICh0b3RhbEJhbGFuY2UgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBbYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCldLFxyXG4gICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMTAwXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9hcGlDbGllbnQuZ2V0QmFsYW5jZXMocmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICB0b3RhbEJhbGFuY2UgPSBwYXJzZUludChyZXNwb25zZS5iYWxhbmNlc1swXSwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZC50b3RhbFZhbHVlID4gdG90YWxCYWxhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJOb3QgZW5vdWdoIGJhbGFuY2UgdG8gc2F0aXNmeSB0aGUgdmFsdWVcIiwgeyB0b3RhbFZhbHVlOiBwcmVwYXJlZC50b3RhbFZhbHVlLCB0b3RhbEJhbGFuY2UgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5mbG9vcih0aGlzLl90aW1lU2VydmljZS5tc1NpbmNlRXBvY2goKSAvIDEwMDApO1xyXG4gICAgICAgICAgICAvLyBBZGQgaW5wdXQgYXMgYnVuZGxlIGVudHJ5XHJcbiAgICAgICAgICAgIC8vIE9ubHkgYSBzaW5nbGUgZW50cnksIHNpZ25hdHVyZXMgd2lsbCBiZSBhZGRlZCBsYXRlclxyXG4gICAgICAgICAgICBwcmVwYXJlZC5idW5kbGUuYWRkVHJhbnNhY3Rpb25zKHNlY3VyaXR5U3VtLCBhZGRyZXNzLCAtdG90YWxCYWxhbmNlLCBwcmVwYXJlZC5sYXN0VGFnLCB0aW1lc3RhbXApO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlbWFpbmRlciB2YWx1ZVxyXG4gICAgICAgICAgICAvLyBBZGQgZXh0cmEgb3V0cHV0IHRvIHNlbmQgcmVtYWluaW5nIGZ1bmRzIHRvXHJcbiAgICAgICAgICAgIGlmICh0b3RhbEJhbGFuY2UgPiBwcmVwYXJlZC50b3RhbFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVtYWluZGVyQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUcmFuc2ZlciBoYXMgcmVtYWluZGVyIGJ1dCBubyByZW1haW5kZXIgYWRkcmVzcyB3YXMgcHJvdmlkZWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmVwYXJlZC5idW5kbGUuYWRkVHJhbnNhY3Rpb25zKDEsIHJlbWFpbmRlckFkZHJlc3MsIHRvdGFsQmFsYW5jZSAtIHByZXBhcmVkLnRvdGFsVmFsdWUsIHByZXBhcmVkLmxhc3RUYWcsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLmZpbmFsaXplQnVuZGxlKHByZXBhcmVkLmJ1bmRsZSk7XHJcbiAgICAgICAgICAgIHByZXBhcmVkLmJ1bmRsZS5hZGRTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzKHByZXBhcmVkLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJlcGFyZWQuYnVuZGxlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTXVsdGlTaWdDbGllbnQgPSBNdWx0aVNpZ0NsaWVudDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYlhWc2RHbFRhV2REYkdsbGJuUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdmJYVnNkR2xUYVdjdmJYVnNkR2xUYVdkRGJHbGxiblF1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVVkJMREJGUVVGMVJUdEJRVU4yUlN3MFJVRkJlVVU3UVVGRGVrVXNORVZCUVhsRk8wRkJSWHBGTERKRlFVRjNSVHRCUVVONFJTeDVSRUZCYzBRN1FVRkRkRVFzSzBSQlFUUkVPMEZCUlRWRUxEWkVRVUV3UkR0QlFVTXhSQ3g1UkVGQmMwUTdRVUZEZEVRc2FVZEJRVGhHTzBGQlF6bEdMSFZFUVVGdlJEdEJRVU53UkN4MVJVRkJiMFU3UVVGRGNFVXNhVVZCUVRoRU8wRkJRemxFTERKRVFVRjNSRHRCUVVONFJDdzJSRUZCTUVRN1FVRkRNVVFzTUVSQlFYVkVPMEZCUTNaRUxEQkVRVUYxUkR0QlFVTjJSQ3gxUkVGQmIwUTdRVUZGY0VRN096dEhRVWRITzBGQlEwZzdTVUZOU1RzN096dFBRVWxITzBsQlEwZ3NXVUZCV1N4VFFVRnhRaXhGUVVGRkxHTkJRVFJDTEVsQlFVa3NlVUpCUVZjc1JVRkJSVHRSUVVNMVJTeEpRVUZKTEVOQlFVTXNWVUZCVlN4SFFVRkhMRk5CUVZNc1EwRkJRenRSUVVNMVFpeEpRVUZKTEVOQlFVTXNXVUZCV1N4SFFVRkhMRmRCUVZjc1EwRkJRenRKUVVOd1F5eERRVUZETzBsQlJVUTdPenM3T3p0UFFVMUhPMGxCUTBrc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZWTEVWQlFVVXNTMEZCWVN4RlFVRkZMRkZCUVhsQ08xRkJRM0pGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RlFVRkZMRmRCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU51UXl4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5d3lRMEZCTWtNc1EwRkJReXhEUVVGRE8xRkJRM3BGTEVOQlFVTTdVVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFdEJRVXNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpsRExFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMRzFEUVVGdFF5eERRVUZETEVOQlFVTTdVVUZEYWtVc1EwRkJRenRSUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NVVUZCVVN4SFFVRkhMRU5CUVVNc1NVRkJTU3hSUVVGUkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTndSU3hOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4elEwRkJjME1zUlVGQlJTeEZRVUZGTEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRiRVlzUTBGQlF6dFJRVVZFTEUxQlFVMHNRMEZCUXl4aFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExGTkJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RlFVRkZMRXRCUVVzc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMGxCUTNSRkxFTkJRVU03U1VGRlJEczdPenM3TzA5QlRVYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVlVzUlVGQlJTeExRVUZoTEVWQlFVVXNVVUZCZVVJN1VVRkRlRVVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVWQlFVVXNWMEZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMjVETEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExESkRRVUV5UXl4RFFVRkRMRU5CUVVNN1VVRkRla1VzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1MwRkJTeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZET1VNc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNiVU5CUVcxRExFTkJRVU1zUTBGQlF6dFJRVU5xUlN4RFFVRkRPMUZCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhSUVVGUkxFTkJRVU1zU1VGQlNTeFJRVUZSTEVkQlFVY3NRMEZCUXl4SlFVRkpMRkZCUVZFc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkZMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEhORFFVRnpReXhGUVVGRkxFVkJRVVVzVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTnNSaXhEUVVGRE8xRkJSVVFzVFVGQlRTeEhRVUZITEVkQlFVY3NVMEZCUnl4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFVkJRVVVzUzBGQlN5eEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRPMUZCUlRORExFMUJRVTBzUTBGQlF5eGhRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRk5CUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRKUVVONFJDeERRVUZETzBsQlJVUTdPenM3TzA5QlMwYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1pVRkJaU3hEUVVGRExFOUJRV2RDTEVWQlFVVXNUMEZCYVVJN1VVRkROMFFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eFBRVUZQTEVWQlFVVXNhVUpCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU42UXl4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5eHBSRUZCYVVRc1EwRkJReXhEUVVGRE8xRkJReTlGTEVOQlFVTTdVVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1JVRkJSU3hsUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZUVNc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNLME5CUVN0RExFTkJRVU1zUTBGQlF6dFJRVU0zUlN4RFFVRkRPMUZCUlVRc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVN1dVRkRjRUlzU1VGQlNTeHBRMEZCWlN4RlFVRkZMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8wbEJRMnhHTEVOQlFVTTdTVUZGUkRzN096czdUMEZMUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zVFVGQll5eEZRVUZGTEU5QlFXZENMRVZCUVVVc1IwRkJWenRSUVVOd1JTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEUxQlFVMHNSVUZCUlN4bFFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRrTXNUVUZCVFN4SlFVRkpMRFpDUVVGaExFTkJRVU1zSzBOQlFTdERMRU5CUVVNc1EwRkJRenRSUVVNM1JTeERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXg1UWtGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1dVRkJXU3hGUVVGRkxIbENRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRla1FzVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc1owVkJRV2RGTEVOQlFVTXNRMEZCUXp0UlFVTTVSaXhEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eFBRVUZQTEVWQlFVVXNhVUpCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU42UXl4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5eHBSRUZCYVVRc1EwRkJReXhEUVVGRE8xRkJReTlGTEVOQlFVTTdVVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1JVRkJSU3hsUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY0VNc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNORU5CUVRSRExFTkJRVU1zUTBGQlF6dFJRVU14UlN4RFFVRkRPMUZCUlVRc1RVRkJUU3hSUVVGUkxFZEJRVWNzWVVGQlN5eERRVUZETEZWQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF6dFJRVVZxUkN3MFEwRkJORU03VVVGRE5VTXNhVU5CUVdsRE8xRkJRMnBETEUxQlFVMHNVVUZCVVN4SFFVRkhMRkZCUVZFc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXp0UlFVVTFReXcwUkVGQk5FUTdVVUZETlVRc09FUkJRVGhFTzFGQlF6bEVMRFpDUVVFMlFqdFJRVU0zUWl4SlFVRkpMRmxCUVZrc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRmNrSXNUVUZCVFN4aFFVRmhMRWRCUVVjc1QwRkJUeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMUZCUlhCRUxFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF6dFpRVU5zUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNTMEZCU3l4aFFVRmhMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU42UlN4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMSGRDUVVGM1FpeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hMUVVGTExHMUVRVUYzUWl4RFFVRkRMRXRCUVVzc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRMnBKTEhGRVFVRnhSRHR2UWtGRGNrUXNXVUZCV1N4RlFVRkZMRU5CUVVNN1owSkJRMjVDTEVOQlFVTTdaMEpCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03YjBKQlEwb3NNa0pCUVZrc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxGbEJRVmtzUjBGQlJ5eERRVUZETEVWQlFVVXNVVUZCVVN4RlFVRkZMR0ZCUVdFc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dHZRa0ZET1VZc1MwRkJTeXhEUVVGRE8yZENRVU5XTEVOQlFVTTdXVUZEVEN4RFFVRkRPMUZCUTB3c1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRlJEczdPenM3T3pzN1QwRlJSenRKUVVOSkxFdEJRVXNzUTBGQlF5eGxRVUZsTEVOQlFVTXNUMEZCWjBJc1JVRkJSU3hYUVVGdFFpeEZRVUZGTEU5QlFXVXNSVUZCUlN4VFFVRnhRaXhGUVVGRkxHZENRVUV3UWp0UlFVTnNTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUlVGQlJTeHBRa0ZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM3BETEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExHbEVRVUZwUkN4RFFVRkRMRU5CUVVNN1VVRkRMMFVzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNWMEZCVnl4RFFVRkRMRWxCUVVrc1YwRkJWeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETVVRc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNlVU5CUVhsRExFTkJRVU1zUTBGQlF6dFJRVU4yUlN4RFFVRkRPMUZCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeFBRVUZQTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOc1JDeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXh4UTBGQmNVTXNRMEZCUXl4RFFVRkRPMUZCUTI1RkxFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEZOQlFWTXNSVUZCUlN4dFFrRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6VkRMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEcxRVFVRnRSQ3hEUVVGRExFTkJRVU03VVVGRGFrWXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEdkQ1FVRm5RaXhGUVVGRkxHbENRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkROMFlzVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc01FUkJRVEJFTEVOQlFVTXNRMEZCUXp0UlFVTjRSaXhEUVVGRE8xRkJSVVFzVFVGQlRTeFhRVUZYTEVkQlFVY3NaVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVVV4UXl4blJFRkJaMFE3VVVGRGFFUXNVMEZCVXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeEZRVUZGTzFsQlF6TkNMRkZCUVZFc1EwRkJReXhQUVVGUExFZEJRVWNzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNWMEZCVnl4RFFVRkRPMWxCUTNKRkxGRkJRVkVzUTBGQlF5eEhRVUZITEVkQlFVY3NVVUZCVVN4RFFVRkRMRWRCUVVjc1NVRkJTU3hUUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETzFGQlF6ZERMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVWdzVFVGQlRTeFJRVUZSTEVkQlFVY3NNa0pCUVZrc1EwRkJReXhoUVVGaExFTkJRVU1zU1VGQlNTeERRVUZETEZsQlFWa3NSVUZCUlN4VFFVRlRMRU5CUVVNc1EwRkJRenRSUVVVeFJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1ZVRkJWU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETlVJc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNNRVZCUVRCRkxFTkJRVU1zUTBGQlF6dFJRVU40Unl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFNpeEpRVUZKTEZsQlFWa3NSMEZCUnl4UFFVRlBMRU5CUVVNN1dVRkRNMElzUlVGQlJTeERRVUZETEVOQlFVTXNXVUZCV1N4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzSkNMRTFCUVUwc1QwRkJUeXhIUVVGM1FqdHZRa0ZEYWtNc1UwRkJVeXhGUVVGRkxFTkJRVVVzVDBGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRk8yOUNRVU0xUXl4VFFVRlRMRVZCUVVVc1IwRkJSenRwUWtGRGFrSXNRMEZCUXp0blFrRkZSaXhOUVVGTkxGRkJRVkVzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1YwRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzJkQ1FVVTFSQ3haUVVGWkxFZEJRVWNzVVVGQlVTeERRVUZETEZGQlFWRXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEZEVRc1EwRkJRenRaUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4VlFVRlZMRWRCUVVjc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEY2tNc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNlVU5CUVhsRExFVkJRVVVzUlVGQlJTeFZRVUZWTEVWQlFVVXNVVUZCVVN4RFFVRkRMRlZCUVZVc1JVRkJSU3haUVVGWkxFVkJRVVVzUTBGQlF5eERRVUZETzFsQlF6RklMRU5CUVVNN1dVRkZSQ3hOUVVGTkxGTkJRVk1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zV1VGQldTeEZRVUZGTEVkQlFVY3NTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkZkRVVzTkVKQlFUUkNPMWxCUXpWQ0xITkVRVUZ6UkR0WlFVTjBSQ3hSUVVGUkxFTkJRVU1zVFVGQlRTeERRVUZETEdWQlFXVXNRMEZCUXl4WFFVRlhMRVZCUVVVc1QwRkJUeXhGUVVGRkxFTkJRVU1zV1VGQldTeEZRVUZGTEZGQlFWRXNRMEZCUXl4UFFVRlBMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU03V1VGRmJFY3NaME5CUVdkRE8xbEJRMmhETERoRFFVRTRRenRaUVVNNVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4WlFVRlpMRWRCUVVjc1VVRkJVU3hEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNKRExFVkJRVVVzUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1QwRkJUeXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU42UXl4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5dzRSRUZCT0VRc1EwRkJReXhEUVVGRE8yZENRVU0xUml4RFFVRkRPMmRDUVVWRUxGRkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNc1JVRkJSU3huUWtGQlowSXNSVUZCUlN4WlFVRlpMRWRCUVVjc1VVRkJVU3hEUVVGRExGVkJRVlVzUlVGQlJTeFJRVUZSTEVOQlFVTXNUMEZCVHl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8xbEJRekZJTEVOQlFVTTdXVUZGUkN3eVFrRkJXU3hEUVVGRExHTkJRV01zUTBGQlF5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1dVRkROME1zVVVGQlVTeERRVUZETEUxQlFVMHNRMEZCUXl3MFFrRkJORUlzUTBGQlF5eFJRVUZSTEVOQlFVTXNlVUpCUVhsQ0xFTkJRVU1zUTBGQlF6dFJRVU55Uml4RFFVRkRPMUZCUlVRc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZETTBJc1EwRkJRenREUVVWS08wRkJOMDFFTEhkRFFUWk5ReUo5XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9tdWx0aVNpZy9tdWx0aVNpZ0NsaWVudC50cyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcblxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXCJyZWdlbmVyYXRvclJ1bnRpbWVcIikgPj0gMDtcblxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuXG5pZiAoaGFkUnVudGltZSkge1xuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XG59IGVsc2Uge1xuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxuICB0cnkge1xuICAgIGRlbGV0ZSBnLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lvdGEtcGljby1idXNpbmVzcy9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lvdGEtcGljby1idXNpbmVzcy9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGFycmF5SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlclwiKTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBudWxsTG9nZ2VyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvbG9nZ2Vycy9udWxsTG9nZ2VyXCIpO1xyXG5jb25zdCBiYWNrZ3JvdW5kVGFza1NlcnZpY2VfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9zZXJ2aWNlcy9iYWNrZ3JvdW5kVGFza1NlcnZpY2VcIik7XHJcbmNvbnN0IHRpbWVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3Qvc2VydmljZXMvdGltZVNlcnZpY2VcIik7XHJcbmNvbnN0IGlzc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvaGFzaC9pc3NcIik7XHJcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2FkZHJlc3NcIik7XHJcbmNvbnN0IGFkZHJlc3NTZWN1cml0eV8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvYWRkcmVzc1NlY3VyaXR5XCIpO1xyXG5jb25zdCBidW5kbGVfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2J1bmRsZVwiKTtcclxuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvaGFzaFwiKTtcclxuY29uc3QgaW5wdXRfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2lucHV0XCIpO1xyXG5jb25zdCB0YWdfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RhZ1wiKTtcclxuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyYW5zYWN0aW9uXCIpO1xyXG5jb25zdCB0cmFuc2Zlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJhbnNmZXJcIik7XHJcbmNvbnN0IHRyaXRzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cml0c1wiKTtcclxuY29uc3QgdHJ5dGVOdW1iZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlTnVtYmVyXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlc1wiKTtcclxuY29uc3QgYnVzaW5lc3NFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2J1c2luZXNzRXJyb3JcIik7XHJcbmNvbnN0IGFkZHJlc3NIZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2FkZHJlc3NIZWxwZXJcIik7XHJcbmNvbnN0IGJ1bmRsZUhlbHBlcl8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvYnVuZGxlSGVscGVyXCIpO1xyXG4vKipcclxuICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSVRyYW5zYWN0aW9uQ2xpZW50LlxyXG4gKi9cclxuY2xhc3MgVHJhbnNhY3Rpb25DbGllbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFRyYW5zYWN0aW9uQ2xpZW50LlxyXG4gICAgICogQHBhcmFtIGFwaUNsaWVudCBBbiBBUEkgQ2xpZW50IHRvIGNvbW11bmljYXRlIHRocm91Z2guXHJcbiAgICAgKiBAcGFyYW0gcHJvb2ZPZldvcmsgUHJvb2Ygb2Ygd29yayBtb2R1bGUgdG8gdXNlLCBpZiB1bmRlZmluZWQgd2lsbCB1c2UgcmVtb3RlLlxyXG4gICAgICogQHBhcmFtIHRpbWVTZXJ2aWNlIEEgY2xhc3Mgd2hpY2ggY2FuIHByb3ZpZGUgdGhlIHRpbWUuXHJcbiAgICAgKiBAcGFyYW0gYmFja2dyb3VuZFRhc2tTZXJ2aWNlIEEgY2xhc3Mgd2hpY2ggY2FuIHByb3ZpZGUgYmFja2dyb3VuZCB0YXNrcy5cclxuICAgICAqIEBwYXJhbSBsb2dnZXIgTG9nZ2VyIHRvIHNlbmQgdHJhbnNhY3Rpb24gaW5mbyB0by5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBwcm9vZk9mV29yaywgdGltZVNlcnZpY2UsIGJhY2tncm91bmRUYXNrU2VydmljZSwgbG9nZ2VyKSB7XHJcbiAgICAgICAgdGhpcy5fYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xyXG4gICAgICAgIHRoaXMuX3Byb29mT2ZXb3JrID0gcHJvb2ZPZldvcms7XHJcbiAgICAgICAgdGhpcy5fdGltZVNlcnZpY2UgPSB0aW1lU2VydmljZSB8fCBuZXcgdGltZVNlcnZpY2VfMS5UaW1lU2VydmljZSgpO1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRUYXNrU2VydmljZSA9IGJhY2tncm91bmRUYXNrU2VydmljZSB8fCBuZXcgYmFja2dyb3VuZFRhc2tTZXJ2aWNlXzEuQmFja2dyb3VuZFRhc2tTZXJ2aWNlKCk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyIHx8IG5ldyBudWxsTG9nZ2VyXzEuTnVsbExvZ2dlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9uIGluIHByb2dyZXNzLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byBhIGxpc3Qgb2YgaGFzaGVzIG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zSW5Qcm9ncmVzcygpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldFRyYW5zYWN0aW9uc0luUHJvZ3Jlc3NcIik7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9hcGlDbGllbnQuZ2V0VGlwcygpO1xyXG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5oYXNoZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcCA9IHJlc3BvbnNlLmhhc2hlcy5tYXAoaGFzaCA9PiBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKGhhc2gpKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6Z2V0VHJhbnNhY3Rpb25zSW5Qcm9ncmVzc1wiLCByZXNwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OmdldFRyYW5zYWN0aW9uc0luUHJvZ3Jlc3NcIiwgW10pO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSB0cmFuc2FjdGlvbnMgd2hpY2ggbWF0Y2ggdGhlIHNwZWNpZmllZCBpbnB1dCBhbmQgcmV0dXJuLiBBbGwgaW5wdXQgdmFsdWVzIGFyZSBsaXN0cyxcclxuICAgICAqIGZvciB3aGljaCBhIGxpc3Qgb2YgcmV0dXJuIHZhbHVlcyAodHJhbnNhY3Rpb24gaGFzaGVzKSwgaW4gdGhlIHNhbWUgb3JkZXIsIGlzIHJldHVybmVkIGZvciBhbGxcclxuICAgICAqIGluZGl2aWR1YWwgZWxlbWVudHMuIFVzaW5nIG11bHRpcGxlIG9mIHRoZXNlIGlucHV0IGZpZWxkcyByZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSBidW5kbGVzIEJ1bmRsZXMgdG8gbG9va3VwIHRyYW5zYWN0aW9uIGhhc2hlcyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIEFkZHJlc3NlcyB0byBsb29rdXAgdHJhbnNhY3Rpb24gaGFzaGVzIGZvci5cclxuICAgICAqIEBwYXJhbSB0YWdzIFRhZ3MgdG8gbG9va3VwIHRyYW5zYWN0aW9uIGhhc2hlcyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYXBwcm92ZWVzIEFwcHJvdmVlcyB0byBsb29rdXAgdHJhbnNhY3Rpb24gaGFzaGVzIGZvci5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCBhIGxpc3Qgb2YgaGFzaGVzIG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmluZFRyYW5zYWN0aW9ucyhidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3MsIGFwcHJvdmVlcykge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6ZmluZFRyYW5zYWN0aW9uc1wiLCBidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3MsIGFwcHJvdmVlcyk7XHJcbiAgICAgICAgY29uc3QgaGFzQnVuZGxlID0gYnVuZGxlcyAhPT0gdW5kZWZpbmVkICYmIGJ1bmRsZXMgIT09IG51bGwgJiYgYnVuZGxlcy5sZW5ndGggPiAwO1xyXG4gICAgICAgIGNvbnN0IGhhc0FkZHJlc3NlcyA9IGFkZHJlc3NlcyAhPT0gdW5kZWZpbmVkICYmIGFkZHJlc3NlcyAhPT0gbnVsbCAmJiBhZGRyZXNzZXMubGVuZ3RoID4gMDtcclxuICAgICAgICBjb25zdCBoYXNUYWdzID0gdGFncyAhPT0gdW5kZWZpbmVkICYmIHRhZ3MgIT09IG51bGwgJiYgdGFncy5sZW5ndGggPiAwO1xyXG4gICAgICAgIGNvbnN0IGhhc0FwcHJvdmVlcyA9IGFwcHJvdmVlcyAhPT0gdW5kZWZpbmVkICYmIGFwcHJvdmVlcyAhPT0gbnVsbCAmJiBhcHByb3ZlZXMubGVuZ3RoID4gMDtcclxuICAgICAgICBpZiAoaGFzQnVuZGxlICYmICFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYnVuZGxlcywgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBidW5kbGVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzQWRkcmVzc2VzICYmICFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYWRkcmVzc2VzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGFkZHJlc3NlcyBtdXN0IGJlIGFuIGFycmF5IG9mIHR5cGUgQWRkcmVzc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc1RhZ3MgJiYgIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZCh0YWdzLCB0YWdfMS5UYWcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSB0YWdzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHlwZSBUYWdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNBcHByb3ZlZXMgJiYgIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChhcHByb3ZlZXMsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgYXBwcm92ZWVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWhhc0J1bmRsZSAmJiAhaGFzQWRkcmVzc2VzICYmICFoYXNUYWdzICYmICFoYXNBcHByb3ZlZXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiWW91IG11c3QgcHJvdmlkZSBidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3Mgb3IgYXBwcm92ZWVzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBidW5kbGVzOiBoYXNCdW5kbGUgPyBidW5kbGVzLm1hcChidW5kbGUgPT4gYnVuZGxlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZHJlc3NlczogaGFzQWRkcmVzc2VzID8gYWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IGFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgdGFnczogaGFzVGFncyA/IHRhZ3MubWFwKHRhZyA9PiB0YWcudG9Ucnl0ZXMoKS50b1N0cmluZygpKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYXBwcm92ZWVzOiBoYXNBcHByb3ZlZXMgPyBhcHByb3ZlZXMubWFwKGFwcHJvdmVlID0+IGFwcHJvdmVlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSkgOiB1bmRlZmluZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fYXBpQ2xpZW50LmZpbmRUcmFuc2FjdGlvbnMocmVxdWVzdCk7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmhhc2hlcykge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwID0gcmVzcG9uc2UuaGFzaGVzLm1hcChoYXNoID0+IGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoaGFzaCkpKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpmaW5kVHJhbnNhY3Rpb25zXCIsIHJlc3ApO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6ZmluZFRyYW5zYWN0aW9uc1wiLCBbXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdHJhbnNhY3Rpb24gZGV0YWlscyBvZiBzcGVjaWZpYyB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9ucyBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uc09iamVjdHModHJhbnNhY3Rpb25IYXNoZXMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldFRyYW5zYWN0aW9uc09iamVjdHNcIiwgdHJhbnNhY3Rpb25IYXNoZXMpO1xyXG4gICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyYW5zYWN0aW9uSGFzaGVzLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHRyYW5zYWN0aW9uSGFzaGVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBoYXNoZXM6IHRyYW5zYWN0aW9uSGFzaGVzLm1hcChoYXNoID0+IGhhc2gudG9Ucnl0ZXMoKS50b1N0cmluZygpKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9hcGlDbGllbnQuZ2V0VHJ5dGVzKHJlcXVlc3QpO1xyXG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS50cnl0ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcCA9IHJlc3BvbnNlLnRyeXRlcy5tYXAodHJ5dGVzID0+IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cnl0ZXMpKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6Z2V0VHJhbnNhY3Rpb25zT2JqZWN0c1wiLCByZXNwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OmdldFRyYW5zYWN0aW9uc09iamVjdHNcIiwgW10pO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGluY2x1c2lvbiBzdGF0ZXMgb2YgYSBsaXN0IG9mIHRyYW5zYWN0aW9uIGhhc2hlcy5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgaW5jbHVzaW9uIHN0YXRlcyBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldExhdGVzdEluY2x1c2lvbih0cmFuc2FjdGlvbkhhc2hlcykge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6dHJhbnNhY3Rpb25IYXNoZXNcIik7XHJcbiAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQodHJhbnNhY3Rpb25IYXNoZXMsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgdHJhbnNhY3Rpb25IYXNoZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5vZGVJbmZvID0gYXdhaXQgdGhpcy5fYXBpQ2xpZW50LmdldE5vZGVJbmZvKCk7XHJcbiAgICAgICAgaWYgKG5vZGVJbmZvICYmIG51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobm9kZUluZm8ubGF0ZXN0U29saWRTdWJ0YW5nbGVNaWxlc3RvbmUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9uSGFzaGVzLm1hcChoYXNoID0+IGhhc2gudG9Ucnl0ZXMoKS50b1N0cmluZygpKSxcclxuICAgICAgICAgICAgICAgIHRpcHM6IFtub2RlSW5mby5sYXRlc3RTb2xpZFN1YnRhbmdsZU1pbGVzdG9uZV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9hcGlDbGllbnQuZ2V0SW5jbHVzaW9uU3RhdGVzKHJlcXVlc3QpO1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OnRyYW5zYWN0aW9uSGFzaGVzXCIsIHJlc3BvbnNlLnN0YXRlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uuc3RhdGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50Ojp0cmFuc2FjdGlvbkhhc2hlc1wiLCBbXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBub2RlIGNvdWxkIG5vdCBwcm92aWRlIHRoZSBsYXRlc3RTb2xpZFN1YnRhbmdsZU1pbGVzdG9uZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhZGRyZXNzZXMgd2l0aCBpbmRleC1iYXNlZCBvciB1c2luZyBhcGlzLlxyXG4gICAgICogQHBhcmFtIHNlZWQgVGhlIHNlZWQgdG8gZ2VuZXJhdGUgdGhlIGFkZHJlc3NlcyBmcm9tLlxyXG4gICAgICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IHRvIGdlbmVyYXRlIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBlbmRJbmRleCBUaGUgZW5kIGluZGV4IHRvIGdlbmVyYXRlIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBpbmNsdWRlQ2hlY2tzdW0gSW5jbHVkZXMgdGhlIGNoZWNrc3VtIG9uIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBzZWN1cml0eSBUaGUgc2VjdXJpdHkgbGV2ZWwgYXQgd2hpY2ggdG8gY3JlYXRlIHRoZSBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIGFkZHJlc3NlcyBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldE5ld0FkZHJlc3Moc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgc2VjdXJpdHkpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldE5ld0FkZHJlc3NcIiwgc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgc2VjdXJpdHkpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlZWQgbXVzdCBiZSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkoc3RhcnRJbmRleCkgJiYgIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc3RhcnRJbmRleCwgTnVtYmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgc3RhcnRJbmRleCBtdXN0IGJlIGFuIGludGVnZXJcIiwgeyBzdGFydEluZGV4IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsb2NhbFN0YXJ0SW5kZXggPSBzdGFydEluZGV4IHx8IDA7XHJcbiAgICAgICAgaWYgKGxvY2FsU3RhcnRJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHN0YXJ0SW5kZXggbXVzdCBiZSA+PSAwXCIsIHsgbG9jYWxTdGFydEluZGV4IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoYXNFbmRJbmRleCA9IG51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoZW5kSW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsU2VjdXJpdHkgPSBzZWN1cml0eSB8fCBhZGRyZXNzU2VjdXJpdHlfMS5BZGRyZXNzU2VjdXJpdHkubWVkaXVtO1xyXG4gICAgICAgIGxldCBhZGRyZXNzZXM7XHJcbiAgICAgICAgaWYgKGhhc0VuZEluZGV4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gZW5kSW5kZXggLSBzdGFydEluZGV4ICsgMTtcclxuICAgICAgICAgICAgaWYgKHRvdGFsIDw9IDAgfHwgdG90YWwgPiBUcmFuc2FjdGlvbkNsaWVudC5NQVhfSU5QVVRTKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoYFRoZSB0b3RhbCBtdXN0IGJlID4gMCBhbmQgPD0gJHtUcmFuc2FjdGlvbkNsaWVudC5NQVhfSU5QVVRTfWAsIHsgdG90YWwgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkcmVzc2VzID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzZXNCeUluZGV4KHNlZWQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBpbmNsdWRlQ2hlY2tzdW0sIGxvY2FsU2VjdXJpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWRkcmVzc2VzID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzZXNUb1VudXNlZChzZWVkLCBzdGFydEluZGV4LCBpbmNsdWRlQ2hlY2tzdW0sIGxvY2FsU2VjdXJpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OmdldE5ld0FkZHJlc3NcIiwgYWRkcmVzc2VzKTtcclxuICAgICAgICByZXR1cm4gYWRkcmVzc2VzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgbmV3IGFkZHJlc3NlcyBpbmRleC1iYXNlZC5cclxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIGdlbmVyYXRlIHRoZSBhZGRyZXNzZXMgZnJvbS5cclxuICAgICAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCB0byBnZW5lcmF0ZSBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcGFyYW0gZW5kSW5kZXggVGhlIGVuZCBpbmRleCB0byBnZW5lcmF0ZSBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcGFyYW0gaW5jbHVkZUNoZWNrc3VtIEluY2x1ZGVzIHRoZSBjaGVja3N1bSBvbiBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsIGF0IHdoaWNoIHRvIGNyZWF0ZSB0aGUgYWRkcmVzc2VzLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbGlzdCBvZiBhZGRyZXNzZXMgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRBZGRyZXNzZXNCeUluZGV4KHNlZWQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBpbmNsdWRlQ2hlY2tzdW0sIHNlY3VyaXR5KSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRBZGRyZXNzZXNCeUluZGV4XCIsIHNlZWQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBpbmNsdWRlQ2hlY2tzdW0sIHNlY3VyaXR5KTtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2VlZCwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBzZWVkIG11c3QgYmUgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc3RhcnRJbmRleCkgfHwgc3RhcnRJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHN0YXJ0SW5kZXggbXVzdCBiZSBhIG51bWJlciA+PSAwXCIsIHsgc3RhcnRJbmRleCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGVuZEluZGV4KSB8fCBlbmRJbmRleCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBlbmRJbmRleCBtdXN0IGJlIGEgbnVtYmVyID4gMFwiLCB7IGVuZEluZGV4IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0b3RhbCA9IGVuZEluZGV4IC0gc3RhcnRJbmRleCArIDE7XHJcbiAgICAgICAgaWYgKHRvdGFsIDw9IDAgfHwgdG90YWwgPiBUcmFuc2FjdGlvbkNsaWVudC5NQVhfSU5QVVRTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihgVGhlIHRvdGFsIG11c3QgYmUgPiAwIGFuZCA8PSAke1RyYW5zYWN0aW9uQ2xpZW50Lk1BWF9JTlBVVFN9YCwgeyB0b3RhbCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHNlY3VyaXR5KSB8fCBzZWN1cml0eSA8IDEgfHwgc2VjdXJpdHkgPiAzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBzZWN1cml0eSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgM1wiLCB7IHNlY3VyaXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcclxuICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2godGhpcy5nZW5lcmF0ZUFkZHJlc3Moc2VlZCwgc3RhcnRJbmRleCArIGksIHNlY3VyaXR5LCBpbmNsdWRlQ2hlY2tzdW0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRBZGRyZXNzZXNCeUluZGV4XCIsIGFkZHJlc3Nlcyk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhZGRyZXNzZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgbmV3IGFkZHJlc3Mgd2hpY2ggaGF2ZW50IGJlZW4gdXNlZCB1c2luZyBhcGlzLlxyXG4gICAgICogQHBhcmFtIHNlZWQgVGhlIHNlZWQgdG8gZ2VuZXJhdGUgdGhlIGFkZHJlc3NlcyBmcm9tLlxyXG4gICAgICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IHRvIGdlbmVyYXRlIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBpbmNsdWRlQ2hlY2tzdW0gSW5jbHVkZXMgdGhlIGNoZWNrc3VtIG9uIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBzZWN1cml0eSBUaGUgc2VjdXJpdHkgbGV2ZWwgYXQgd2hpY2ggdG8gY3JlYXRlIHRoZSBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGFuIGFkZHJlc3NlcyBsaXN0LCB0aGUgZmlyc3QgdW51c2VkIGFkZHJlc3MgaXMgdGhlIGxhc3QgaW4gdGhlIGxpc3Qgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRBZGRyZXNzZXNUb1VudXNlZChzZWVkLCBzdGFydEluZGV4LCBpbmNsdWRlQ2hlY2tzdW0sIHNlY3VyaXR5KSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRBZGRyZXNzZXNUb1VudXNlZFwiLCBzZWVkLCBzdGFydEluZGV4LCBpbmNsdWRlQ2hlY2tzdW0sIHNlY3VyaXR5KTtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2VlZCwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBzZWVkIG11c3QgYmUgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc3RhcnRJbmRleCkgfHwgc3RhcnRJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHN0YXJ0SW5kZXggbXVzdCBiZSBhIG51bWJlciA+PSAwXCIsIHsgc3RhcnRJbmRleCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHNlY3VyaXR5KSB8fCBzZWN1cml0eSA8IDEgfHwgc2VjdXJpdHkgPiAzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBzZWN1cml0eSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgM1wiLCB7IHNlY3VyaXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbG9jYWxTdGFydEluZGV4ID0gc3RhcnRJbmRleDtcclxuICAgICAgICBsZXQgaXNVc2VkO1xyXG4gICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtdO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuZ2VuZXJhdGVBZGRyZXNzKHNlZWQsIGxvY2FsU3RhcnRJbmRleCsrLCBzZWN1cml0eSwgaW5jbHVkZUNoZWNrc3VtKTtcclxuICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NOb0NoZWNrc3VtID0gYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNwZW50RnJvbVJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IFthZGRyZXNzTm9DaGVja3N1bV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3Qgc3BlbnRGcm9tUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9hcGlDbGllbnQud2VyZUFkZHJlc3Nlc1NwZW50RnJvbShzcGVudEZyb21SZXF1ZXN0KTtcclxuICAgICAgICAgICAgaXNVc2VkID0gc3BlbnRGcm9tUmVzcG9uc2UgJiYgc3BlbnRGcm9tUmVzcG9uc2Uuc3RhdGVzICYmIHNwZW50RnJvbVJlc3BvbnNlLnN0YXRlcy5sZW5ndGggPiAwID8gc3BlbnRGcm9tUmVzcG9uc2Uuc3RhdGVzWzBdIDogZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICghaXNVc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5kVHJhbnNhY3Rpb25zUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IFthZGRyZXNzTm9DaGVja3N1bV1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5kUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9hcGlDbGllbnQuZmluZFRyYW5zYWN0aW9ucyhmaW5kVHJhbnNhY3Rpb25zUmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICBpc1VzZWQgPSBmaW5kUmVzcG9uc2UgJiYgZmluZFJlc3BvbnNlLmhhc2hlcyAmJiBmaW5kUmVzcG9uc2UuaGFzaGVzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChpc1VzZWQpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6Z2V0QWRkcmVzc2VzVG9VbnVzZWRcIiwgYWRkcmVzc2VzKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFkZHJlc3Nlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaW5wdXQgZGF0YSBmb3IgYSByYW5nZSBvZiBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZCB0byBnZXQgdGhlIGlucHV0IGRhdGEgZm9yLlxyXG4gICAgICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IHRvIGdldCB0aGUgYWRkcmVzc2VzLlxyXG4gICAgICogQHBhcmFtIGVuZEluZGV4IFRoZSBlbmQgaW5kZXggdG8gZ2V0IHRoZSBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsIHVzZWQgdG8gY3JlYXRlIHRoZSBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcGFyYW0gdG90YWxSZXF1aXJlZCBUaGUgdGhyZXNob2xkIGF0IHdoaWNoIHRvdGFsIGJhbGFuY2UgdG8gc3RvcCBnYXRoZXJpbmcgYWRkcmVzc2VzLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgaW5wdXRzIGZvciBlYWNoIGFkZHJlc3Mgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRJbnB1dHMoc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHNlY3VyaXR5LCB0b3RhbFJlcXVpcmVkKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRJbnB1dHNcIiwgc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHNlY3VyaXR5LCB0b3RhbFJlcXVpcmVkKTtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2VlZCwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBzZWVkIG11c3QgYmUgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc3RhcnRJbmRleCkgfHwgc3RhcnRJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHN0YXJ0SW5kZXggbXVzdCBiZSBhIG51bWJlciA+PSAwXCIsIHsgc3RhcnRJbmRleCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHNlY3VyaXR5KSB8fCBzZWN1cml0eSA8IDEgfHwgc2VjdXJpdHkgPiAzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBzZWN1cml0eSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgM1wiLCB7IHNlY3VyaXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIodG90YWxSZXF1aXJlZCkgfHwgdG90YWxSZXF1aXJlZCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHRvdGFsUmVxdWlyZWQgbXVzdCBiZSA+PSAwXCIsIHsgdG90YWxSZXF1aXJlZCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgdGhpcy5nZXROZXdBZGRyZXNzKHNlZWQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBmYWxzZSwgc2VjdXJpdHkpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLm1hcChhZGQgPT4gYWRkLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSksXHJcbiAgICAgICAgICAgIHRocmVzaG9sZDogMTAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2FwaUNsaWVudC5nZXRCYWxhbmNlcyhyZXF1ZXN0KTtcclxuICAgICAgICBjb25zdCBpbnB1dHMgPSBbXTtcclxuICAgICAgICBsZXQgdG90YWxCYWxhbmNlID0gMDtcclxuICAgICAgICBpZiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBwYXJzZUludChyZXNwb25zZS5iYWxhbmNlc1tpXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhbGFuY2UgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2goaW5wdXRfMS5JbnB1dC5mcm9tUGFyYW1zKGFkZHJlc3Nlc1tpXSwgc2VjdXJpdHksIHN0YXJ0SW5kZXggKyBpLCBiYWxhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxCYWxhbmNlICs9IGJhbGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsUmVxdWlyZWQgPiAwICYmIHRvdGFsQmFsYW5jZSA+PSB0b3RhbFJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXNwID0geyBpbnB1dHMsIHRvdGFsQmFsYW5jZSB9O1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6Z2V0SW5wdXRzXCIsIHJlc3ApO1xyXG4gICAgICAgIGlmICh0b3RhbFJlcXVpcmVkID4gMCAmJiB0b3RhbEJhbGFuY2UgPCB0b3RhbFJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIk5vdCBlbm91Z2ggY29tYmluZWQgYmFsYW5jZSBpbiB0aGUgYWRkcmVzc2VzIHRvIHNhdGlzZnkgdGhlIHRvdGFsIHJlcXVpcmVkXCIsIHsgdG90YWxSZXF1aXJlZCwgdG90YWxCYWxhbmNlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJlcGFyZXMgdHJhbnNmZXIgYnkgZ2VuZXJhdGluZyBidW5kbGUsIGZpbmRpbmcgYW5kIHNpZ25pbmcgaW5wdXRzLlxyXG4gICAgICogQHBhcmFtIHNlZWQgVGhlIHNlZWQgdG8gcHJlcGFyZSB0aGUgdHJhbnNmZXIgZm9yLlxyXG4gICAgICogQHBhcmFtIHRyYW5zZmVycyBUaGUgdHJhbnNmZXJzIHRvIHByZXBhcmUuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJPcHRpb25zXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBpbnB1dHMgTGlzdCBvZiBpbnB1dHMgdXNlZCBmb3IgZnVuZGluZyB0aGUgdHJhbnNmZXIuXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBzZWN1cml0eSBTZWN1cml0eSBsZXZlbCB0byBiZSB1c2VkIGZvciB0aGUgcHJpdmF0ZSBrZXkgLyBhZGRyZXNzZXMuXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSByZW1haW5kZXJBZGRyZXNzIElmIGRlZmluZWQsIHRoaXMgYWRkcmVzcyB3aWxsIGJlIHVzZWQgZm9yIHNlbmRpbmcgdGhlIHJlbWFpbmRlciB2YWx1ZSAob2YgdGhlIGlucHV0cykgdG8uXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBobWFjS2V5IEhtYWMga2V5IHRvIHNpZ24gdGhlIGJ1bmRsZS5cclxuICAgICAqICAgICAgQHByb3BlcnR5IHJlZmVyZW5jZSBUaGUgdHJhbnNhY3Rpb24gdG8gcmVmZXJlbmNlLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgYXJyYXkgb2YgVHJ5dGVzIGZvciB0aGUgdHJhbnNmZXIgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBwcmVwYXJlVHJhbnNmZXJzKHNlZWQsIHRyYW5zZmVycywgdHJhbnNmZXJPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IFRyYW5zYWN0aW9uQ2xpZW50OjpwcmVwYXJlVHJhbnNmZXJzXCIsIHNlZWQsIHRyYW5zZmVycywgdHJhbnNmZXJPcHRpb25zKTtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2VlZCwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBzZWVkIG11c3QgYmUgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZCh0cmFuc2ZlcnMsIHRyYW5zZmVyXzEuVHJhbnNmZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSB0cmFuc2ZlcnMgbXVzdCBiZSBhbiBhcnJheSBvZiBUcmFuc2ZlciBvYmplY3RzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsb2NhbFRyYW5zZmVyT3B0aW9ucyA9IHRyYW5zZmVyT3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBsb2NhbFRyYW5zZmVyT3B0aW9ucy5zZWN1cml0eSA9IGxvY2FsVHJhbnNmZXJPcHRpb25zLnNlY3VyaXR5IHx8IGFkZHJlc3NTZWN1cml0eV8xLkFkZHJlc3NTZWN1cml0eS5tZWRpdW07XHJcbiAgICAgICAgY29uc3QgZW1wdHlUcnl0ZXMgPSB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhcIlwiKTtcclxuICAgICAgICBjb25zdCBhZGRITUFDID0gIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KGxvY2FsVHJhbnNmZXJPcHRpb25zLmhtYWNLZXkpO1xyXG4gICAgICAgIGxldCBhZGRlZEhNQUMgPSBmYWxzZTtcclxuICAgICAgICAvLyBJZiBtZXNzYWdlIG9yIHRhZyBpcyBub3Qgc3VwcGxpZWQsIHByb3ZpZGUgaXRcclxuICAgICAgICB0cmFuc2ZlcnMuZm9yRWFjaCh0cmFuc2ZlciA9PiB7XHJcbiAgICAgICAgICAgIHRyYW5zZmVyLm1lc3NhZ2UgPSB0cmFuc2Zlci5tZXNzYWdlID8gdHJhbnNmZXIubWVzc2FnZSA6IGVtcHR5VHJ5dGVzO1xyXG4gICAgICAgICAgICB0cmFuc2Zlci50YWcgPSB0cmFuc2Zlci50YWcgfHwgdGFnXzEuVGFnLkVNUFRZO1xyXG4gICAgICAgICAgICBpZiAoYWRkSE1BQyAmJiB0cmFuc2Zlci52YWx1ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZmVyLm1lc3NhZ2UgPSB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhUcmFuc2FjdGlvbkNsaWVudC5OVUxMX0hBU0hfVFJZVEVTICsgdHJhbnNmZXIubWVzc2FnZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIGFkZGVkSE1BQyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgYnVuZGxlXHJcbiAgICAgICAgY29uc3QgcHJlcGFyZWQgPSBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIucHJlcGFyZUJ1bmRsZSh0aGlzLl90aW1lU2VydmljZSwgdHJhbnNmZXJzKTtcclxuICAgICAgICBjb25zdCBidW5kbGUgPSBwcmVwYXJlZC5idW5kbGU7XHJcbiAgICAgICAgY29uc3QgbGFzdFRhZyA9IHByZXBhcmVkLmxhc3RUYWc7XHJcbiAgICAgICAgY29uc3QgdG90YWxWYWx1ZSA9IHByZXBhcmVkLnRvdGFsVmFsdWU7XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyA9IHByZXBhcmVkLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHM7XHJcbiAgICAgICAgLy8gR2V0IGlucHV0cyBpZiB3ZSBhcmUgc2VuZGluZyB0b2tlbnNcclxuICAgICAgICBpZiAodG90YWxWYWx1ZSkge1xyXG4gICAgICAgICAgICAvLyAgQ2FzZSAxOiB1c2VyIHByb3ZpZGVkIGlucHV0c1xyXG4gICAgICAgICAgICAvLyAgVmFsaWRhdGUgdGhlIGlucHV0cyBieSBjYWxsaW5nIGdldEJhbGFuY2VzXHJcbiAgICAgICAgICAgIGlmIChsb2NhbFRyYW5zZmVyT3B0aW9ucy5pbnB1dHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBsb2NhbFRyYW5zZmVyT3B0aW9ucy5pbnB1dHMubWFwKGlucHV0ID0+IGlucHV0LmFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpKSxcclxuICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDEwMFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5fYXBpQ2xpZW50LmdldEJhbGFuY2VzKHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkSW5wdXRzID0gW107XHJcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxCYWxhbmNlID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFsYW5jZXMuYmFsYW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gcGFyc2VJbnQoYmFsYW5jZXMuYmFsYW5jZXNbaV0sIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpbnB1dCBoYXMgYmFsYW5jZSwgYWRkIGl0IHRvIGNvbmZpcm1lZElucHV0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYWxhbmNlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEJhbGFuY2UgKz0gYmFsYW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxUcmFuc2Zlck9wdGlvbnMuaW5wdXRzW2ldLmJhbGFuY2UgPSBiYWxhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtZWRJbnB1dHMucHVzaChsb2NhbFRyYW5zZmVyT3B0aW9ucy5pbnB1dHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IHJlYWNoZWQgdGhlIGludGVuZGVkIGlucHV0IHZhbHVlLCBicmVhayBvdXQgb2YgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxCYWxhbmNlID49IHRvdGFsVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIG5vdCBlbm91Z2ggYmFsYW5jZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsVmFsdWUgPiB0b3RhbEJhbGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJOb3QgZW5vdWdoIGJhbGFuY2UgaW4gdGhlIGlucHV0IGFkZHJlc3NlcyB0byBzYXRpc2Z5IHRoZSB0b3RhbCBmb3IgdGhlIHRyYW5zZmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGRSZW1haW5kZXIoc2VlZCwgYnVuZGxlLCBsb2NhbFRyYW5zZmVyT3B0aW9ucywgY29uZmlybWVkSW5wdXRzLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLCB0b3RhbFZhbHVlLCBsYXN0VGFnLCBhZGRlZEhNQUMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gaW5wdXRzIHN1cHBsaWVkIHNvIHdlIG5lZWQgdG8gZ2V0IHNvbWVcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0c1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRJbnB1dHMoc2VlZCwgMCwgdW5kZWZpbmVkLCBsb2NhbFRyYW5zZmVyT3B0aW9ucy5zZWN1cml0eSwgdG90YWxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFkZFJlbWFpbmRlcihzZWVkLCBidW5kbGUsIGxvY2FsVHJhbnNmZXJPcHRpb25zLCBpbnB1dHNSZXNwb25zZS5pbnB1dHMsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMsIHRvdGFsVmFsdWUsIGxhc3RUYWcsIGFkZGVkSE1BQyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGlucHV0IHJlcXVpcmVkLCBkb24ndCBzaWduIGFuZCBzaW1wbHkgZmluYWxpemUgdGhlIGJ1bmRsZVxyXG4gICAgICAgICAgICBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuZmluYWxpemVCdW5kbGUoYnVuZGxlKTtcclxuICAgICAgICAgICAgYnVuZGxlLmFkZFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1bmRsZS50cmFuc2FjdGlvbnMgPSBidW5kbGUudHJhbnNhY3Rpb25zLnJldmVyc2UoKTtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OnByZXBhcmVUcmFuc2ZlcnNcIiwgYnVuZGxlKTtcclxuICAgICAgICByZXR1cm4gYnVuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggdGhlIHRyYW5zYWN0aW9ucyB0byB0aGUgdGFuZ2xlIGJ5IGRvaW5nIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKiBAcGFyYW0gYnVuZGxlIFRoZSBidW5kbGUgb2YgdHJhbnNhY3Rpb25zIHRvIGF0dGFjaC5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBWYWx1ZSB0aGF0IGRldGVybWluZXMgaG93IGZhciB0byBnbyBmb3IgdGlwIHNlbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZSBmb3IgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgdG8gc2VuZCB3aXRoIHRoZSB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBidW5kbGUgb2YgdHJhbnNhY3Rpb25zIGNyZWF0ZWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBhdHRhY2hUb1RhbmdsZShidW5kbGUsIGRlcHRoLCBtaW5XZWlnaHRNYWduaXR1ZGUsIHJlZmVyZW5jZSkge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6YXR0YWNoVG9UYW5nbGVcIiwgYnVuZGxlLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlLCByZWZlcmVuY2UpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShidW5kbGUsIGJ1bmRsZV8xLkJ1bmRsZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGJ1bmRsZSBtdXN0IGJlIGFuIGFycmF5IG9mIHR5cGUgQnVuZGxlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChidW5kbGUudHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgYnVuZGxlLnRyYW5zYWN0aW9ucyBtdXN0IGJlIGFuIGFycmF5IG9mIHR5cGUgVHJhbnNhY3Rpb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihkZXB0aCkgfHwgZGVwdGggPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgZGVwdGggbXVzdCBiZSBhIG51bWJlciA+IDBcIiwgeyBkZXB0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG1pbldlaWdodE1hZ25pdHVkZSkgfHwgbWluV2VpZ2h0TWFnbml0dWRlIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIG1pbldlaWdodE1hZ25pdHVkZSBtdXN0IGJlIGEgbnVtYmVyID4gMFwiLCB7IG1pbldlaWdodE1hZ25pdHVkZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zVG9BcHByb3ZlUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgZGVwdGgsXHJcbiAgICAgICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlID8gcmVmZXJlbmNlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zVG9BcHByb3ZlID0gYXdhaXQgdGhpcy5fYXBpQ2xpZW50LmdldFRyYW5zYWN0aW9uc1RvQXBwcm92ZSh0cmFuc2FjdGlvbnNUb0FwcHJvdmVSZXF1ZXN0KTtcclxuICAgICAgICBsZXQgcG93VHJhbnNhY3Rpb25zO1xyXG4gICAgICAgIGlmICh0aGlzLl9wcm9vZk9mV29yaykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJvb2ZPZldvcmsucGVyZm9ybXNTaW5nbGUoKSkge1xyXG4gICAgICAgICAgICAgICAgcG93VHJhbnNhY3Rpb25zID0gYXdhaXQgdGhpcy5wcm9vZk9mV29ya0l0ZXJhdGUoaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cmFuc2FjdGlvbnNUb0FwcHJvdmUudHJ1bmtUcmFuc2FjdGlvbikpLCBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRyYW5zYWN0aW9uc1RvQXBwcm92ZS5icmFuY2hUcmFuc2FjdGlvbikpLCBidW5kbGUudHJhbnNhY3Rpb25zLCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsVHJ5dGVzID0gYXdhaXQgdGhpcy5fcHJvb2ZPZldvcmsucG93KGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodHJhbnNhY3Rpb25zVG9BcHByb3ZlLnRydW5rVHJhbnNhY3Rpb24pKSwgaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cmFuc2FjdGlvbnNUb0FwcHJvdmUuYnJhbmNoVHJhbnNhY3Rpb24pKSwgYnVuZGxlLnRyYW5zYWN0aW9ucy5tYXAodCA9PiB0LnRvVHJ5dGVzKCkpLCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xyXG4gICAgICAgICAgICAgICAgcG93VHJhbnNhY3Rpb25zID0gYWxsVHJ5dGVzLm1hcChyZXR1cm5Ucnl0ZXMgPT4gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tVHJ5dGVzKHJldHVyblRyeXRlcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBhdHRhY2hUb1RhbmdsZVJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICB0cnVua1RyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbnNUb0FwcHJvdmUudHJ1bmtUcmFuc2FjdGlvbixcclxuICAgICAgICAgICAgICAgIGJyYW5jaFRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbnNUb0FwcHJvdmUuYnJhbmNoVHJhbnNhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBtaW5XZWlnaHRNYWduaXR1ZGU6IG1pbldlaWdodE1hZ25pdHVkZSxcclxuICAgICAgICAgICAgICAgIHRyeXRlczogYnVuZGxlLnRyYW5zYWN0aW9ucy5tYXAodCA9PiB0LnRvVHJ5dGVzKCkudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgYXR0YWNoVG9UYW5nbGVSZXNwb25zZSA9IGF3YWl0IHRoaXMuX2FwaUNsaWVudC5hdHRhY2hUb1RhbmdsZShhdHRhY2hUb1RhbmdsZVJlcXVlc3QpO1xyXG4gICAgICAgICAgICBwb3dUcmFuc2FjdGlvbnMgPSBhdHRhY2hUb1RhbmdsZVJlc3BvbnNlLnRyeXRlcy5tYXAocmV0dXJuVHJ5dGVzID0+IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhyZXR1cm5Ucnl0ZXMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld0J1bmRsZSA9IG5ldyBidW5kbGVfMS5CdW5kbGUoKTtcclxuICAgICAgICBuZXdCdW5kbGUudHJhbnNhY3Rpb25zID0gcG93VHJhbnNhY3Rpb25zO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6YXR0YWNoVG9UYW5nbGVcIiwgbmV3QnVuZGxlKTtcclxuICAgICAgICByZXR1cm4gbmV3QnVuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcGVyIGZ1bmN0aW9uIHRoYXQgZG9lcyBhdHRhY2hUb1RhbmdsZSBhbmQgdGhlbiBzdG9yZXMgYW5kIGJyb2FkY2FzdHMgdGhlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSBidW5kbGUgVGhlIGJ1bmRsZSBvZiB0cmFuc2FjdGlvbnMgdG8gc2VuZC5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBWYWx1ZSB0aGF0IGRldGVybWluZXMgaG93IGZhciB0byBnbyBmb3IgdGlwIHNlbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZSBmb3IgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgdG8gc2VuZCB3aXRoIHRoZSB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBidW5kbGUgb2YgdHJhbnNhY3Rpb25zIGNyZWF0ZWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb25zKGJ1bmRsZSwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgcmVmZXJlbmNlKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IFRyYW5zYWN0aW9uQ2xpZW50OjpzZW5kVHJhbnNhY3Rpb25zXCIsIGJ1bmRsZSwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgcmVmZXJlbmNlKTtcclxuICAgICAgICBjb25zdCBhdHRhY2hlZFRyYW5zYWN0aW9uc0J1bmRsZSA9IGF3YWl0IHRoaXMuYXR0YWNoVG9UYW5nbGUoYnVuZGxlLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlLCByZWZlcmVuY2UpO1xyXG4gICAgICAgIGNvbnN0IHN0b3JlVHJhbnNhY3Rpb25zUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgdHJ5dGVzOiBhdHRhY2hlZFRyYW5zYWN0aW9uc0J1bmRsZS50cmFuc2FjdGlvbnMubWFwKHQgPT4gdC50b1RyeXRlcygpLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBhd2FpdCB0aGlzLl9hcGlDbGllbnQuc3RvcmVUcmFuc2FjdGlvbnMoc3RvcmVUcmFuc2FjdGlvbnNSZXF1ZXN0KTtcclxuICAgICAgICBjb25zdCBicm9hZGNhc3RUcmFuc2FjdGlvbnNSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICB0cnl0ZXM6IHN0b3JlVHJhbnNhY3Rpb25zUmVxdWVzdC50cnl0ZXNcclxuICAgICAgICB9O1xyXG4gICAgICAgIGF3YWl0IHRoaXMuX2FwaUNsaWVudC5icm9hZGNhc3RUcmFuc2FjdGlvbnMoYnJvYWRjYXN0VHJhbnNhY3Rpb25zUmVxdWVzdCk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpzZW5kVHJhbnNhY3Rpb25zXCIsIGF0dGFjaGVkVHJhbnNhY3Rpb25zQnVuZGxlKTtcclxuICAgICAgICByZXR1cm4gYXR0YWNoZWRUcmFuc2FjdGlvbnNCdW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyYXBwZXIgZnVuY3Rpb24gdGhhdCBkb2VzIHByZXBhcmVUcmFuc2ZlcnMgYW5kIHRoZW4gc2VuZFRyYW5zYWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIHNlbmQgdGhlIHRyYW5zZmVyIGZvci5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBWYWx1ZSB0aGF0IGRldGVybWluZXMgaG93IGZhciB0byBnbyBmb3IgdGlwIHNlbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZSBmb3IgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJzIFRoZSB0cmFuc2ZlcnMgdG8gc2VuZC5cclxuICAgICAqIEBwYXJhbSB0cmFuc2Zlck9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgdHJhbnNmZXIuXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBpbnB1dHMgTGlzdCBvZiBpbnB1dHMgdXNlZCBmb3IgZnVuZGluZyB0aGUgdHJhbnNmZXIuXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBzZWN1cml0eSBTZWN1cml0eSBsZXZlbCB0byBiZSB1c2VkIGZvciB0aGUgcHJpdmF0ZSBrZXkgLyBhZGRyZXNzZXMuXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSByZW1haW5kZXJBZGRyZXNzIElmIGRlZmluZWQsIHRoaXMgYWRkcmVzcyB3aWxsIGJlIHVzZWQgZm9yIHNlbmRpbmcgdGhlIHJlbWFpbmRlciB2YWx1ZSAob2YgdGhlIGlucHV0cykgdG8uXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBobWFjS2V5IEhtYWMga2V5IHRvIHNpZ24gdGhlIGJ1bmRsZS5cclxuICAgICAqIEBwYXJhbSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSB0byBzZW5kIHdpdGggdGhlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIGNyZWF0ZWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzZW5kVHJhbnNmZXIoc2VlZCwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgdHJhbnNmZXJzLCB0cmFuc2Zlck9wdGlvbnMsIHJlZmVyZW5jZSkge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6c2VuZFRyYW5zZmVyXCIsIHNlZWQsIGRlcHRoLCBtaW5XZWlnaHRNYWduaXR1ZGUsIHRyYW5zZmVycywgdHJhbnNmZXJPcHRpb25zLCByZWZlcmVuY2UpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZmVyVHJ5dGVzID0gYXdhaXQgdGhpcy5wcmVwYXJlVHJhbnNmZXJzKHNlZWQsIHRyYW5zZmVycywgdHJhbnNmZXJPcHRpb25zKTtcclxuICAgICAgICBjb25zdCBzZW50QnVuZGxlID0gYXdhaXQgdGhpcy5zZW5kVHJhbnNhY3Rpb25zKHRyYW5zZmVyVHJ5dGVzLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlLCByZWZlcmVuY2UpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6c2VuZFRyYW5zZmVyXCIsIHNlbnRCdW5kbGUpO1xyXG4gICAgICAgIHJldHVybiBzZW50QnVuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIG91dCBpZiBhIHRyYW5zYWN0aW9uIGlzIHByb21vdGFibGUuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25UYWlsIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBwcm9tb3RlZC5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgcHJvbW90YWJsZSByZWplY3RzIHdpdGggYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGlzUHJvbW90YWJsZSh0cmFuc2FjdGlvblRhaWwpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmlzUHJvbW90YWJsZVwiLCB0cmFuc2FjdGlvblRhaWwpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cmFuc2FjdGlvblRhaWwsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgdHJhbnNhY3Rpb25UYWlsIG11c3QgYmUgYW4gb2JqZWN0IG9mIHR5cGUgSGFzaFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hlY2tDb25zaXN0ZW5jeVJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIHRhaWxzOiBbdHJhbnNhY3Rpb25UYWlsLnRvVHJ5dGVzKCkudG9TdHJpbmcoKV1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGNoZWNrQ29uc2lzdGVuY3lSZXNwb25zZSA9IGF3YWl0IHRoaXMuX2FwaUNsaWVudC5jaGVja0NvbnNpc3RlbmN5KGNoZWNrQ29uc2lzdGVuY3lSZXF1ZXN0KTtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OmlzUHJvbW90YWJsZVwiLCBjaGVja0NvbnNpc3RlbmN5UmVzcG9uc2Uuc3RhdGUpO1xyXG4gICAgICAgIHJldHVybiBjaGVja0NvbnNpc3RlbmN5UmVzcG9uc2Uuc3RhdGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB5b3Ugc2hvdWxkIHJlcGxheSBhIHRyYW5zYWN0aW9uIG9yIG1ha2UgYSBuZXcgb25lIChlaXRoZXIgd2l0aCB0aGUgc2FtZSBpbnB1dCwgb3IgYSBkaWZmZXJlbnQgb25lKS5cclxuICAgICAqIEBwYXJhbSBhZGRyZXNzZXMgSW5wdXQgYWRkcmVzcyB5b3Ugd2FudCB0byBoYXZlIHRlc3RlZC5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgYWRkcmVzc2VzIGFyZSByZWF0dGFjaGFibGUgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBpc1JlYXR0YWNoYWJsZShhZGRyZXNzZXMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmlzUmVhdHRhY2hhYmxlXCIsIGFkZHJlc3Nlcyk7XHJcbiAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYWRkcmVzc2VzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGFkZHJlc3NlcyBtdXN0IGJlIGFuIG9iamVjdCBvZiB0eXBlIEFkZHJlc3NcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFkZHJzVHhzTWFwID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzc1N0cmluZyA9IGFkZHJlc3Nlc1tpXS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGFkZHJzVHhzTWFwW2FkZHJlc3NTdHJpbmddID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGF3YWl0IHRoaXMuZmluZFRyYW5zYWN0aW9uT2JqZWN0cyh1bmRlZmluZWQsIGFkZHJlc3Nlcyk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVUcmFuc2FjdGlvbnMgPSBbXTtcclxuICAgICAgICB0cmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnZhbHVlLnRvTnVtYmVyKCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eEFkZHJlc3MgPSB0cmFuc2FjdGlvbi5hZGRyZXNzO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHhIYXNoID0gYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLnRyYW5zYWN0aW9uSGFzaCh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBhZGRyc1R4c01hcFt0eEFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpXS5wdXNoKHR4SGFzaCk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZVRyYW5zYWN0aW9ucy5wdXNoKHR4SGFzaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgcmVzdWx0cztcclxuICAgICAgICBpZiAodmFsdWVUcmFuc2FjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmNsdXNpb25TdGF0ZXMgPSBhd2FpdCB0aGlzLmdldExhdGVzdEluY2x1c2lvbih2YWx1ZVRyYW5zYWN0aW9ucyk7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSBhZGRyZXNzZXMubWFwKChhZGRyZXNzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkUmVhdHRhY2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHhzID0gYWRkcnNUeHNNYXBbYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCldO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eEluZGV4ID0gdmFsdWVUcmFuc2FjdGlvbnMuaW5kZXhPZih0eHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlYXR0YWNoID0gIWluY2x1c2lvblN0YXRlc1t0eEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJlYXR0YWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRSZWF0dGFjaDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50Ojppc1JlYXR0YWNoYWJsZVwiLCByZXN1bHRzKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvbW90ZXMgYSB0cmFuc2FjdGlvbiBieSBhZGRpbmcgc3BhbSBvbiB0b3Agb2YgaXQsIGFzIGxvbmcgYXMgaXQgaXMgcHJvbW90YWJsZS5cclxuICAgICAqIFdpbGwgcHJvbW90ZSBieSBhZGRpbmcgdHJhbnNmZXJzIG9uIHRvcCBvZiB0aGUgY3VycmVudCBvbmUgd2l0aCBkZWxheSBpbnRlcnZhbC5cclxuICAgICAqIFVzZSBwcm9tb3RlT3B0aW9ucy5pbnRlcnJ1cHQgdG8gdGVybWluYXRlIHRoZSBwcm9tb3Rpb24uXHJcbiAgICAgKiBJZiBwcm9tb3RlT3B0aW9ucy5kZWxheSBpcyBzZXQgdG8gMCBvbmx5IG9uZSBwcm9tb3Rpb24gdHJhbnNmZXIgd2lsbCBiZSBzZW50LlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uVGFpbCBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgcHJvbW90ZWQuXHJcbiAgICAgKiBAcGFyYW0gZGVwdGggVmFsdWUgdGhhdCBkZXRlcm1pbmVzIGhvdyBmYXIgdG8gZ28gZm9yIHRpcCBzZWxlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gbWluV2VpZ2h0TWFnbml0dWRlIFRoZSBtaW5pbXVtIHdlaWdodCBtYWduaXR1ZGUgZm9yIHRoZSBwcm9vZiBvZiB3b3JrLlxyXG4gICAgICogQHBhcmFtIHRyYW5zZmVycyBUaGUgdHJhbnNmZXJzIHRvIHNlbmQuXHJcbiAgICAgKiBAcGFyYW0gcHJvbW90ZU9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcHJvbW90ZS5cclxuICAgICAqICAgICAgQHByb3BlcnR5IGRlbGF5IERlbGF5IGJldHdlZW4gcHJvbW90aW9uIHRyYW5zZmVyc1xyXG4gICAgICogICAgICBAcHJvcGVydHkgaW50ZXJydXB0IEZsYWcgb3IgbWV0aG9kIHRvIHRlcm1pbmF0ZSBwcm9tb3Rpb24uXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9ucyBjcmVhdGVkIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcHJvbW90ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uVGFpbCwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgdHJhbnNmZXJzLCBwcm9tb3RlT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6cHJvbW90ZVRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uVGFpbCwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgdHJhbnNmZXJzLCBwcm9tb3RlT3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyYW5zYWN0aW9uVGFpbCwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSB0cmFuc2FjdGlvblRhaWwgbXVzdCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoZGVwdGgpIHx8IGRlcHRoIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGRlcHRoIG11c3QgYmUgYSBudW1iZXIgPiAwXCIsIHsgZGVwdGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihtaW5XZWlnaHRNYWduaXR1ZGUpIHx8IG1pbldlaWdodE1hZ25pdHVkZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBtaW5XZWlnaHRNYWduaXR1ZGUgbXVzdCBiZSBhIG51bWJlciA+IDBcIiwgeyBtaW5XZWlnaHRNYWduaXR1ZGUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyYW5zZmVycywgdHJhbnNmZXJfMS5UcmFuc2ZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHRyYW5zZmVycyBtdXN0IGFuIGFycmF5IG9mIFRyYW5zZmVyIG9iamVjdHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxvY2FsUHJvbW90ZU9wdGlvbnMgPSBwcm9tb3RlT3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkobG9jYWxQcm9tb3RlT3B0aW9ucy5pbnRlcnJ1cHQpKSB7XHJcbiAgICAgICAgICAgIGxvY2FsUHJvbW90ZU9wdGlvbnMuaW50ZXJydXB0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb2NhbFByb21vdGVPcHRpb25zLmludGVycnVwdCA9PT0gZmFsc2UgfHwgKHR5cGVvZiBsb2NhbFByb21vdGVPcHRpb25zLmludGVycnVwdCA9PT0gXCJmdW5jdGlvblwiICYmICFsb2NhbFByb21vdGVPcHRpb25zLmludGVycnVwdCgpKSkge1xyXG4gICAgICAgICAgICBjb25zdCBpc1Byb21vdGFibGUgPSBhd2FpdCB0aGlzLmlzUHJvbW90YWJsZSh0cmFuc2FjdGlvblRhaWwpO1xyXG4gICAgICAgICAgICBpZiAoaXNQcm9tb3RhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZW5kVHJhbnNmZXJSZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZFRyYW5zZmVyKGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJhbnNmZXJzWzBdLmFkZHJlc3MudG9Ucnl0ZXMoKSksIGRlcHRoLCBtaW5XZWlnaHRNYWduaXR1ZGUsIHRyYW5zZmVycywgdW5kZWZpbmVkLCB0cmFuc2FjdGlvblRhaWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobG9jYWxQcm9tb3RlT3B0aW9ucy5kZWxheSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZFRhc2tTZXJ2aWNlLmNyZWF0ZShhc3luYyAoKSA9PiB0aGlzLnByb21vdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvblRhaWwsIGRlcHRoLCBtaW5XZWlnaHRNYWduaXR1ZGUsIHRyYW5zZmVycywgbG9jYWxQcm9tb3RlT3B0aW9ucyksIGxvY2FsUHJvbW90ZU9wdGlvbnMuZGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50Ojpwcm9tb3RlVHJhbnNhY3Rpb25cIiwgc2VuZFRyYW5zZmVyUmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kVHJhbnNmZXJSZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRyYW5zYWN0aW9uIGlzIG5vdCBwcm9tb3RhYmxlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OnByb21vdGVUcmFuc2FjdGlvblwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYXNzb2NpYXRlZCBidW5kbGUgdHJhbnNhY3Rpb25zIG9mIGEgc2luZ2xlIHRyYW5zYWN0aW9uLlxyXG4gICAgICogRG9lcyB2YWxpZGF0aW9uIG9mIHNpZ25hdHVyZXMsIHRvdGFsIHN1bSBhcyB3ZWxsIGFzIGJ1bmRsZSBvcmRlci5cclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbkhhc2ggSGFzaCBvZiBhIHRydW5rIG9yIGEgdGFpbCB0cmFuc2FjdGlvbiBvZiBhIGJ1bmRsZS5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGJ1bmRsZSB0cmFuc2FjdGlvbnMgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRCdW5kbGUodHJhbnNhY3Rpb25IYXNoKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRCdW5kbGVcIiwgdHJhbnNhY3Rpb25IYXNoKTtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJhbnNhY3Rpb25IYXNoLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHRyYW5zYWN0aW9uSGFzaCBtdXN0IGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGF3YWl0IHRoaXMudHJhdmVyc2VCdW5kbGUodHJhbnNhY3Rpb25IYXNoKTtcclxuICAgICAgICBjb25zdCBidW5kbGUgPSBuZXcgYnVuZGxlXzEuQnVuZGxlKCk7XHJcbiAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucztcclxuICAgICAgICBjb25zdCBpc1ZhbGlkID0gYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLmlzVmFsaWQoYnVuZGxlKTtcclxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiSW52YWxpZCBidW5kbGUgcHJvdmlkZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6Z2V0QnVuZGxlXCIsIGJ1bmRsZSk7XHJcbiAgICAgICAgcmV0dXJuIGJ1bmRsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2UgdGhlIEJ1bmRsZSBieSBnb2luZyBkb3duIHRoZSB0cnVua1RyYW5zYWN0aW9ucyB1bnRpbFxyXG4gICAgICogdGhlIGJ1bmRsZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBpcyBubyBsb25nZXIgdGhlIHNhbWUuXHJcbiAgICAgKiBAcGFyYW0gdHJ1bmtUcmFuc2FjdGlvbiBIYXNoIG9mIGEgdHJ1bmsgb3IgYSB0YWlsIHRyYW5zYWN0aW9uIG9mIGEgYnVuZGxlLlxyXG4gICAgICogQHBhcmFtIGJ1bmRsZUhhc2ggVGhlIGJ1bmRsZSBoYXNoIHRvIG1hdGNoLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgYnVuZGxlIHRyYW5zYWN0aW9ucyBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHRyYXZlcnNlQnVuZGxlKHRydW5rVHJhbnNhY3Rpb24sIGJ1bmRsZUhhc2gpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OnRyYXZlcnNlQnVuZGxlXCIsIHRydW5rVHJhbnNhY3Rpb24sIGJ1bmRsZUhhc2gpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cnVua1RyYW5zYWN0aW9uLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHRydW5rVHJhbnNhY3Rpb24gbXVzdCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhbGxCdW5kbGVUcmFuc2FjdGlvbnMgPSBbXTtcclxuICAgICAgICBsZXQgbmV3VHJ1bmtUcmFuc2FjdGlvbiA9IHRydW5rVHJhbnNhY3Rpb247XHJcbiAgICAgICAgbGV0IG5ld0J1bmRsZUhhc2ggPSBidW5kbGVIYXNoO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgY29uc3QgZ2V0VHJ5dGVzUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIGhhc2hlczogW25ld1RydW5rVHJhbnNhY3Rpb24udG9Ucnl0ZXMoKS50b1N0cmluZygpXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBnZXRUcnl0ZXNSZXNwb25zZSA9IGF3YWl0IHRoaXMuX2FwaUNsaWVudC5nZXRUcnl0ZXMoZ2V0VHJ5dGVzUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyeXRlcyA9ICFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShnZXRUcnl0ZXNSZXNwb25zZSkgJiZcclxuICAgICAgICAgICAgICAgICFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShnZXRUcnl0ZXNSZXNwb25zZS50cnl0ZXMpICYmXHJcbiAgICAgICAgICAgICAgICBnZXRUcnl0ZXNSZXNwb25zZS50cnl0ZXMubGVuZ3RoID4gMCA/IGdldFRyeXRlc1Jlc3BvbnNlLnRyeXRlc1swXSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHRyeXRlcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIkJ1bmRsZSB0cmFuc2FjdGlvbnMgbm90IHZpc2libGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbk9iamVjdCA9IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cnl0ZXMpKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIGZpcnN0IHRyYW5zYWN0aW9uIHRvIHNlYXJjaCBpcyBub3QgYSB0YWlsLCByZXR1cm4gZXJyb3JcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0hhc2ggPSAhb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkobmV3QnVuZGxlSGFzaCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0hhc2ggJiYgdHJhbnNhY3Rpb25PYmplY3QuY3VycmVudEluZGV4LnRvTnVtYmVyKCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJJbnZhbGlkIHRhaWwgdHJhbnNhY3Rpb24gc3VwcGxpZWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBidW5kbGUgaGFzaCwgZGVmaW5lIGl0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbEJ1bmRsZUhhc2ggPSBoYXNIYXNoID8gbmV3QnVuZGxlSGFzaCA6IHRyYW5zYWN0aW9uT2JqZWN0LmJ1bmRsZTtcclxuICAgICAgICAgICAgICAgIG5ld1RydW5rVHJhbnNhY3Rpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBuZXdCdW5kbGVIYXNoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgc2FtZSBidW5kbGUgaGFzaCBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsQnVuZGxlSGFzaC50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09IHRyYW5zYWN0aW9uT2JqZWN0LmJ1bmRsZS50b1RyeXRlcygpLnRvU3RyaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdHJhbnNhY3Rpb24gb2JqZWN0IHRvIGJ1bmRsZVxyXG4gICAgICAgICAgICAgICAgICAgIGFsbEJ1bmRsZVRyYW5zYWN0aW9ucy5wdXNoKHRyYW5zYWN0aW9uT2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBtb3JlIHRoYW4gb25lIGVsZW1lbnQgdGhlbiBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbk9iamVjdC5sYXN0SW5kZXgudG9OdW1iZXIoKSAhPT0gMCB8fCB0cmFuc2FjdGlvbk9iamVjdC5jdXJyZW50SW5kZXgudG9OdW1iZXIoKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUcnVua1RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25PYmplY3QudHJ1bmtUcmFuc2FjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QnVuZGxlSGFzaCA9IGxvY2FsQnVuZGxlSGFzaDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChuZXdUcnVua1RyYW5zYWN0aW9uICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6dHJhdmVyc2VCdW5kbGVcIiwgYWxsQnVuZGxlVHJhbnNhY3Rpb25zKTtcclxuICAgICAgICByZXR1cm4gYWxsQnVuZGxlVHJhbnNhY3Rpb25zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcGVyIHdoaWNoIGdldHMgYSBidW5kbGUgYW5kIHRoZW4gcmVwbGF5cyBhIHRyYW5zZmVyIGJ5IGRvaW5nIFByb29mIG9mIFdvcmsgYWdhaW4uXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25IYXNoIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBwcm9tb3RlZC5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBWYWx1ZSB0aGF0IGRldGVybWluZXMgaG93IGZhciB0byBnbyBmb3IgdGlwIHNlbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZSBmb3IgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9ucyBjcmVhdGVkIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVhdHRhY2hCdW5kbGUodHJhbnNhY3Rpb25IYXNoLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IFRyYW5zYWN0aW9uQ2xpZW50OjpyZWF0dGFjaEJ1bmRsZVwiLCB0cmFuc2FjdGlvbkhhc2gsIGRlcHRoLCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xyXG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IGF3YWl0IHRoaXMuZ2V0QnVuZGxlKHRyYW5zYWN0aW9uSGFzaCk7XHJcbiAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9ucyA9IGJ1bmRsZS50cmFuc2FjdGlvbnMucmV2ZXJzZSgpO1xyXG4gICAgICAgIGNvbnN0IHNlbmRUcmFuc2FjdGlvbnNSZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZFRyYW5zYWN0aW9ucyhidW5kbGUsIGRlcHRoLCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6cmVhdHRhY2hCdW5kbGVcIiwgc2VuZFRyYW5zYWN0aW9uc1Jlc3BvbnNlKTtcclxuICAgICAgICByZXR1cm4gc2VuZFRyYW5zYWN0aW9uc1Jlc3BvbnNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcGVyIHdoaWNoIGdldHMgYSBidW5kbGUgYW5kIHRoZW4gYnJvYWRjYXN0cyBpdC5cclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbkhhc2ggVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIHJlLWJyb2FkY2FzdC5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZWJyb2FkY2FzdEJ1bmRsZSh0cmFuc2FjdGlvbkhhc2gpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OnJlYnJvYWRjYXN0QnVuZGxlXCIsIHRyYW5zYWN0aW9uSGFzaCk7XHJcbiAgICAgICAgY29uc3QgYnVuZGxlID0gYXdhaXQgdGhpcy5nZXRCdW5kbGUodHJhbnNhY3Rpb25IYXNoKTtcclxuICAgICAgICBjb25zdCBicm9hZGNhc3RUcmFuc2FjdGlvbnNSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICB0cnl0ZXM6IGJ1bmRsZS50cmFuc2FjdGlvbnMucmV2ZXJzZSgpLm1hcChidCA9PiBidC50b1RyeXRlcygpLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBhd2FpdCB0aGlzLl9hcGlDbGllbnQuYnJvYWRjYXN0VHJhbnNhY3Rpb25zKGJyb2FkY2FzdFRyYW5zYWN0aW9uc1JlcXVlc3QpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6cmVicm9hZGNhc3RCdW5kbGVcIiwgYnVuZGxlKTtcclxuICAgICAgICByZXR1cm4gYnVuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdHJhbnNhY3Rpb24gb2JqZWN0cyBieSBmaXN0IHBlcmZvcm1pbmcgYSBmaW5kVHJhbnNhY3Rpb25zIGNhbGwuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdG8gZ2V0IHRoZSB0cmFuc2FjdGlvbiBvYmplY3RzIGZvci5cclxuICAgICAqIEBwYXJhbSBidW5kbGVzIEJ1bmRsZXMgdG8gbG9va3VwIHRyYW5zYWN0aW9ucyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIEFkZHJlc3NlcyB0byBsb29rdXAgdHJhbnNhY3Rpb25zIGZvci5cclxuICAgICAqIEBwYXJhbSB0YWdzIFRhZ3MgdG8gbG9va3VwIHRyYW5zYWN0aW9ucyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYXBwcm92ZWVzIEFwcHJvdmVlcyB0byBsb29rdXAgdHJhbnNhY3Rpb25zIGZvci5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmluZFRyYW5zYWN0aW9uT2JqZWN0cyhidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3MsIGFwcHJvdmVlcykge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6ZmluZFRyYW5zYWN0aW9uT2JqZWN0c1wiLCBidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3MsIGFwcHJvdmVlcyk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gYXdhaXQgdGhpcy5maW5kVHJhbnNhY3Rpb25zKGJ1bmRsZXMsIGFkZHJlc3NlcywgdGFncywgYXBwcm92ZWVzKTtcclxuICAgICAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25zT2JqZWN0cyh0cmFuc2FjdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OmZpbmRUcmFuc2FjdGlvbk9iamVjdHNcIiwgcmVzcCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpmaW5kVHJhbnNhY3Rpb25PYmplY3RzXCIsIFtdKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRyYW5zZmVycyB3aGljaCBhcmUgYXNzb2NpYXRlZCB3aXRoIGEgc2VlZC4gVGhlIHRyYW5zZmVycyBhcmUgZGV0ZXJtaW5lZCBieSBlaXRoZXIgY2FsY3VsYXRpbmdcclxuICAgICAqIGRldGVybWluaXN0aWNhbGx5IHdoaWNoIGFkZHJlc3NlcyB3ZXJlIGFscmVhZHkgdXNlZCwgb3IgYnkgcHJvdmlkaW5nIGEgbGlzdCBvZiBpbmRleGVzIHRvIGdldCB0aGVcclxuICAgICAqIGFkZHJlc3NlcyBhbmQgdGhlIGFzc29jaWF0ZWQgdHJhbnNmZXJzIGZyb20uIFRoZSB0cmFuc2ZlcnMgYXJlIHNvcnRlZCBieSB0aGVpciB0aW1lc3RhbXAuXHJcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3JcclxuICAgICAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gZW5kSW5kZXggVGhlIGVuZCBpbmRleCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsIGZvciB0aGUgdHJhbnNmZXJzLlxyXG4gICAgICogQHBhcmFtIGluY2x1c2lvblN0YXRlcyBEbyB5b3Ugd2FudCBpbmNsdXNpb24gc3RhdGVzIGluIHRoZSBidW5kbGVzLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcmVxdWVzdGVkIGJ1bmRsZXMgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRUcmFuc2ZlcnMoc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHNlY3VyaXR5LCBpbmNsdXNpb25TdGF0ZXMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldFRyYW5zZmVyc1wiLCBzZWVkLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc2VjdXJpdHksIGluY2x1c2lvblN0YXRlcyk7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHNlZWQsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgc2VlZCBtdXN0IGJlIG9mIHR5cGUgSGFzaFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxvY2FsU3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxvY2FsU3RhcnRJbmRleCkpIHtcclxuICAgICAgICAgICAgbG9jYWxTdGFydEluZGV4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgdGhpcy5nZXROZXdBZGRyZXNzKHNlZWQsIGxvY2FsU3RhcnRJbmRleCwgZW5kSW5kZXgsIGZhbHNlLCBzZWN1cml0eSk7XHJcbiAgICAgICAgY29uc3QgYnVuZGxlcyA9IGF3YWl0IHRoaXMuYnVuZGxlc0Zyb21BZGRyZXNzZXMoYWRkcmVzc2VzLCBpbmNsdXNpb25TdGF0ZXMpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6Z2V0VHJhbnNmZXJzXCIsIGJ1bmRsZXMpO1xyXG4gICAgICAgIHJldHVybiBidW5kbGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1pbGFyIHRvIGdldFRyYW5zZmVycywganVzdCB0aGF0IGl0IHJldHVybnMgYWRkaXRpb25hbCBhY2NvdW50IGRhdGEuXHJcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3JcclxuICAgICAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gZW5kSW5kZXggVGhlIGVuZCBpbmRleCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsIGZvciB0aGUgdHJhbnNmZXJzLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgYWNjb3VudCBkYXRhIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0QWNjb3VudERhdGEoc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHNlY3VyaXR5KSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRBY2NvdW50RGF0YVwiLCBzZWVkLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc2VjdXJpdHkpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlZWQgbXVzdCBiZSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsb2NhbFN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsb2NhbFN0YXJ0SW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGxvY2FsU3RhcnRJbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IHRoaXMuZ2V0TmV3QWRkcmVzcyhzZWVkLCBsb2NhbFN0YXJ0SW5kZXgsIGVuZEluZGV4LCBmYWxzZSwgc2VjdXJpdHkgfHwgYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5Lm1lZGl1bSk7XHJcbiAgICAgICAgY29uc3QgYnVuZGxlcyA9IGF3YWl0IHRoaXMuYnVuZGxlc0Zyb21BZGRyZXNzZXMoYWRkcmVzc2VzLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBhY2NvdW50RGF0YSA9IHtcclxuICAgICAgICAgICAgbGF0ZXN0QWRkcmVzczogYWRkcmVzc2VzLnBvcCgpLFxyXG4gICAgICAgICAgICBhZGRyZXNzZXMsXHJcbiAgICAgICAgICAgIHRyYW5zZmVyczogYnVuZGxlcyxcclxuICAgICAgICAgICAgaW5wdXRzOiBbXSxcclxuICAgICAgICAgICAgYmFsYW5jZTogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYmFsYW5jZVJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIGFkZHJlc3NlczogYWNjb3VudERhdGEuYWRkcmVzc2VzLm1hcChhZGQgPT4gYWRkLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSksXHJcbiAgICAgICAgICAgIHRocmVzaG9sZDogMTAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBiYWxhbmNlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9hcGlDbGllbnQuZ2V0QmFsYW5jZXMoYmFsYW5jZVJlcXVlc3QpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFsYW5jZVJlc3BvbnNlLmJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBwYXJzZUludChiYWxhbmNlUmVzcG9uc2UuYmFsYW5jZXNbaV0sIDEwKTtcclxuICAgICAgICAgICAgaWYgKGJhbGFuY2UgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50RGF0YS5pbnB1dHMucHVzaChpbnB1dF8xLklucHV0LmZyb21QYXJhbXMoYWNjb3VudERhdGEuYWRkcmVzc2VzW2ldLCBzZWN1cml0eSB8fCBhZGRyZXNzU2VjdXJpdHlfMS5BZGRyZXNzU2VjdXJpdHkubWVkaXVtLCBsb2NhbFN0YXJ0SW5kZXggKyBpLCBiYWxhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50RGF0YS5iYWxhbmNlICs9IGJhbGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRBY2NvdW50RGF0YVwiLCBhY2NvdW50RGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIGFjY291bnREYXRhO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBhc3luYyBidW5kbGVzRnJvbUFkZHJlc3NlcyhhZGRyZXNzZXMsIGluY2x1c2lvblN0YXRlcykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uT2JqZWN0cyA9IGF3YWl0IHRoaXMuZmluZFRyYW5zYWN0aW9uT2JqZWN0cyh1bmRlZmluZWQsIGFkZHJlc3NlcywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIC8vIHNldCBvZiB0YWlsIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgIGNvbnN0IHRhaWxUcmFuc2FjdGlvbnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgY29uc3Qgbm9uVGFpbEJ1bmRsZUhhc2hlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0cmFuc2FjdGlvbk9iamVjdHMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgLy8gU29ydCB0YWlsIGFuZCBub25UYWlsc1xyXG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uY3VycmVudEluZGV4LnRvTnVtYmVyKCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRhaWxUcmFuc2FjdGlvbnMuYWRkKGJ1bmRsZUhlbHBlcl8xLkJ1bmRsZUhlbHBlci50cmFuc2FjdGlvbkhhc2godHJhbnNhY3Rpb24pLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub25UYWlsQnVuZGxlSGFzaGVzLmFkZCh0cmFuc2FjdGlvbi5idW5kbGUudG9Ucnl0ZXMoKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChub25UYWlsQnVuZGxlSGFzaGVzLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vblRhaWxCdW5kbGVUcmFuc2FjdGlvbnMgPSBhd2FpdCB0aGlzLmZpbmRUcmFuc2FjdGlvbk9iamVjdHMoQXJyYXkuZnJvbShub25UYWlsQnVuZGxlSGFzaGVzKS5tYXAoaGFzaCA9PiBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKGhhc2gpKSkpO1xyXG4gICAgICAgICAgICBub25UYWlsQnVuZGxlVHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uY3VycmVudEluZGV4LnRvTnVtYmVyKCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0YWlsVHJhbnNhY3Rpb25zLmFkZChidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIudHJhbnNhY3Rpb25IYXNoKHRyYW5zYWN0aW9uKS50b1RyeXRlcygpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmluYWxCdW5kbGVzID0gW107XHJcbiAgICAgICAgY29uc3QgdGFpbFR4QXJyYXkgPSBBcnJheS5mcm9tKHRhaWxUcmFuc2FjdGlvbnMpO1xyXG4gICAgICAgIC8vIElmIGluY2x1c2lvblN0YXRlcywgZ2V0IHRoZSBjb25maXJtYXRpb24gc3RhdHVzXHJcbiAgICAgICAgLy8gb2YgdGhlIHRhaWwgdHJhbnNhY3Rpb25zLCBhbmQgdGh1cyB0aGUgYnVuZGxlc1xyXG4gICAgICAgIGxldCB0YWlsVHhTdGF0ZXM7XHJcbiAgICAgICAgaWYgKGluY2x1c2lvblN0YXRlcykge1xyXG4gICAgICAgICAgICB0YWlsVHhTdGF0ZXMgPSBhd2FpdCB0aGlzLmdldExhdGVzdEluY2x1c2lvbih0YWlsVHhBcnJheS5tYXAodGFpbCA9PiBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRhaWwpKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNYXAgZWFjaCB0YWlsIHRyYW5zYWN0aW9uIHRvIHRoZSBnZXRCdW5kbGUgZnVuY3Rpb25cclxuICAgICAgICAvLyBmb3JtYXQgdGhlIHJldHVybmVkIGJ1bmRsZXMgYW5kIGFkZCBpbmNsdXNpb24gc3RhdGVzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFpbFR4QXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYnVuZGxlID0gYXdhaXQgdGhpcy5nZXRCdW5kbGUoaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0YWlsVHhBcnJheVtpXSkpKTtcclxuICAgICAgICAgICAgYnVuZGxlLmluY2x1c2lvblN0YXRlID0gdGFpbFR4U3RhdGVzID8gdGFpbFR4U3RhdGVzW2ldIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBmaW5hbEJ1bmRsZXMucHVzaChidW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTb3J0IGJ1bmRsZXMgYnkgdGltZXN0YW1wXHJcbiAgICAgICAgZmluYWxCdW5kbGVzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeCA9IGEudHJhbnNhY3Rpb25zWzBdLmF0dGFjaG1lbnRUaW1lc3RhbXAudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgeSA9IGIudHJhbnNhY3Rpb25zWzBdLmF0dGFjaG1lbnRUaW1lc3RhbXAudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZpbmFsQnVuZGxlcztcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgZ2VuZXJhdGVBZGRyZXNzKHNlZWQsIGluZGV4LCBzZWN1cml0eSwgaW5jbHVkZUNoZWNrc3VtKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gaXNzXzEuSVNTLmtleShzZWVkLCBpbmRleCwgc2VjdXJpdHkpO1xyXG4gICAgICAgIGNvbnN0IGRpZ2VzdHMgPSBpc3NfMS5JU1MuZGlnZXN0cyhrZXkpO1xyXG4gICAgICAgIGNvbnN0IGFkZHJlc3NUcml0cyA9IGlzc18xLklTUy5hZGRyZXNzKGRpZ2VzdHMpO1xyXG4gICAgICAgIGxldCBhZGRyZXNzVHJ5dGVzU3RyaW5nID0gdHJpdHNfMS5Ucml0cy5mcm9tQXJyYXkoYWRkcmVzc1RyaXRzKS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVDaGVja3N1bSkge1xyXG4gICAgICAgICAgICBhZGRyZXNzVHJ5dGVzU3RyaW5nICs9IGFkZHJlc3NIZWxwZXJfMS5BZGRyZXNzSGVscGVyLmNyZWF0ZUNoZWNrc3VtKGFkZHJlc3NUcml0cywgOSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhZGRyZXNzXzEuQWRkcmVzcy5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKGFkZHJlc3NUcnl0ZXNTdHJpbmcpKTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgYXN5bmMgYWRkUmVtYWluZGVyKHNlZWQsIGJ1bmRsZSwgdHJhbnNmZXJPcHRpb25zLCBpbnB1dHMsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMsIHRvdGFsVmFsdWUsIHRhZywgYWRkZWRITUFDKSB7XHJcbiAgICAgICAgbGV0IHRvdGFsVHJhbnNmZXJWYWx1ZSA9IHRvdGFsVmFsdWU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5mbG9vcih0aGlzLl90aW1lU2VydmljZS5tc1NpbmNlRXBvY2goKSAvIDEwMDApO1xyXG4gICAgICAgICAgICAvLyBBZGQgaW5wdXQgYXMgYnVuZGxlIGVudHJ5XHJcbiAgICAgICAgICAgIGJ1bmRsZS5hZGRUcmFuc2FjdGlvbnMoaW5wdXRzW2ldLnNlY3VyaXR5LCBpbnB1dHNbaV0uYWRkcmVzcywgLWlucHV0c1tpXS5iYWxhbmNlLCB0YWcsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluZGVyIHZhbHVlXHJcbiAgICAgICAgICAgIC8vIEFkZCBleHRyYSBvdXRwdXQgdG8gc2VuZCByZW1haW5pbmcgZnVuZHMgdG9cclxuICAgICAgICAgICAgaWYgKGlucHV0c1tpXS5iYWxhbmNlID49IHRvdGFsVHJhbnNmZXJWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluZGVyID0gaW5wdXRzW2ldLmJhbGFuY2UgLSB0b3RhbFRyYW5zZmVyVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB1c2VyIGhhcyBwcm92aWRlZCByZW1haW5kZXIgYWRkcmVzcyB1c2UgaXQgdG8gc2VuZCByZW1haW5pbmcgZnVuZHMgdG9cclxuICAgICAgICAgICAgICAgIGlmIChyZW1haW5kZXIgPiAwICYmICFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh0cmFuc2Zlck9wdGlvbnMpICYmIG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJhbnNmZXJPcHRpb25zLnJlbWFpbmRlckFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWFpbmRlciBidW5kbGUgZW50cnlcclxuICAgICAgICAgICAgICAgICAgICBidW5kbGUuYWRkVHJhbnNhY3Rpb25zKDEsIHRyYW5zZmVyT3B0aW9ucy5yZW1haW5kZXJBZGRyZXNzLCByZW1haW5kZXIsIHRhZywgdGltZXN0YW1wKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbCBmdW5jdGlvbiBmb3Igc2lnbmluZyBpbnB1dHNcclxuICAgICAgICAgICAgICAgICAgICBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuc2lnbklucHV0cyhzZWVkLCBidW5kbGUsIHRyYW5zZmVyT3B0aW9ucywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cywgaW5wdXRzLCBhZGRlZEhNQUMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVtYWluZGVyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5tYXgoaW5wdXRzW2tdLmtleUluZGV4LCBzdGFydEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IHRoaXMuZ2V0QWRkcmVzc2VzVG9VbnVzZWQoc2VlZCwgc3RhcnRJbmRleCwgZmFsc2UsIHRyYW5zZmVyT3B0aW9ucy5zZWN1cml0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHMgPSBNYXRoLmZsb29yKHRoaXMuX3RpbWVTZXJ2aWNlLm1zU2luY2VFcG9jaCgpIC8gMTAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtYWluZGVyIGJ1bmRsZSBlbnRyeVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1bmRsZS5hZGRUcmFuc2FjdGlvbnMoMSwgYWRkcmVzc2VzW2FkZHJlc3Nlcy5sZW5ndGggLSAxXSwgcmVtYWluZGVyLCB0YWcsIHRzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbCBmdW5jdGlvbiBmb3Igc2lnbmluZyBpbnB1dHNcclxuICAgICAgICAgICAgICAgICAgICBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuc2lnbklucHV0cyhzZWVkLCBidW5kbGUsIHRyYW5zZmVyT3B0aW9ucywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cywgaW5wdXRzLCBhZGRlZEhNQUMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcmVtYWluZGVyLCBkbyBub3QgYWRkIHRyYW5zYWN0aW9uIHRvIGJ1bmRsZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbXBseSBzaWduIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuc2lnbklucHV0cyhzZWVkLCBidW5kbGUsIHRyYW5zZmVyT3B0aW9ucywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cywgaW5wdXRzLCBhZGRlZEhNQUMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgbXVsdGlwbGUgaW5wdXRzIHByb3ZpZGVkLCBzdWJ0cmFjdCB0aGUgdG90YWxUcmFuc2ZlclZhbHVlIGJ5XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5wdXRzIGJhbGFuY2VcclxuICAgICAgICAgICAgICAgIHRvdGFsVHJhbnNmZXJWYWx1ZSAtPSBpbnB1dHNbaV0uYmFsYW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgYXN5bmMgcHJvb2ZPZldvcmtJdGVyYXRlKHRydW5rVHJhbnNhY3Rpb24sIGJyYW5jaFRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbnMsIG1pbldlaWdodE1hZ25pdHVkZSkge1xyXG4gICAgICAgIGNvbnN0IGZpbmFsVHJhbnNhY3Rpb25zID0gW107XHJcbiAgICAgICAgbGV0IHByZXZpb3VzVHJhbnNhY3Rpb25IYXNoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggbGFzdCBpbmRleCB0cmFuc2FjdGlvblxyXG4gICAgICAgICAgICAvLyBBc3NpZ24gaXQgdGhlIHRydW5rIC8gYnJhbmNoIHdoaWNoIHRoZSB1c2VyIGhhcyBzdXBwbGllZFxyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGJ1bmRsZSwgY2hhaW4gdGhlIGJ1bmRsZSB0cmFuc2FjdGlvbnMgdmlhXHJcbiAgICAgICAgICAgIC8vIHRydW5rVHJhbnNhY3Rpb24gdG9nZXRoZXJcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zW2ldLmF0dGFjaG1lbnRUaW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIodGhpcy5fdGltZVNlcnZpY2UubXNTaW5jZUVwb2NoKCkpO1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnNbaV0uYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoMCk7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uc1tpXS5hdHRhY2htZW50VGltZXN0YW1wVXBwZXJCb3VuZCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbU51bWJlcihUcmFuc2FjdGlvbkNsaWVudC5NQVhfVElNRVNUQU1QX1ZBTFVFKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdHJhbnNhY3Rpb24sIHRvIGJlIHByb2Nlc3NlZFxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBpdCdzIHRoZSBsYXN0IGluIHRoZSBidW5kbGUgYW5kIHRoZW5cclxuICAgICAgICAgICAgLy8gYXNzaWduIGl0IHRoZSBzdXBwbGllZCB0cnVuayBhbmQgYnJhbmNoIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocHJldmlvdXNUcmFuc2FjdGlvbkhhc2gpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBsYXN0IHRyYW5zYWN0aW9uIGluIHRoZSBidW5kbGVcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbnNbaV0ubGFzdEluZGV4LnRvTnVtYmVyKCkgIT09IHRyYW5zYWN0aW9uc1tpXS5jdXJyZW50SW5kZXgudG9OdW1iZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIldyb25nIGJ1bmRsZSBvcmRlci4gVGhlIGJ1bmRsZSBzaG91bGQgYmUgb3JkZXJlZCBpbiBkZXNjZW5kaW5nIG9yZGVyIGZyb20gY3VycmVudEluZGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zW2ldLnRydW5rVHJhbnNhY3Rpb24gPSB0cnVua1RyYW5zYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zW2ldLmJyYW5jaFRyYW5zYWN0aW9uID0gYnJhbmNoVHJhbnNhY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnNbaV0udHJ1bmtUcmFuc2FjdGlvbiA9IHByZXZpb3VzVHJhbnNhY3Rpb25IYXNoO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zW2ldLmJyYW5jaFRyYW5zYWN0aW9uID0gdHJ1bmtUcmFuc2FjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBuZXdUcnl0ZXMgPSB0cmFuc2FjdGlvbnNbaV0udG9Ucnl0ZXMoKTtcclxuICAgICAgICAgICAgY29uc3QgcmV0dXJuZWRUcnl0ZXMgPSBhd2FpdCB0aGlzLl9wcm9vZk9mV29yay5wb3codHJ1bmtUcmFuc2FjdGlvbiwgYnJhbmNoVHJhbnNhY3Rpb24sIFtuZXdUcnl0ZXNdLCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnNbaV0ubm9uY2UgPSB0YWdfMS5UYWcuZnJvbVRyeXRlcyhyZXR1cm5lZFRyeXRlc1swXS5zdWIodHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5MRU5HVEggLSB0YWdfMS5UYWcuTEVOR1RILCB0YWdfMS5UYWcuTEVOR1RIKSk7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaGFzaCBvZiB0aGUgbmV3IHRyYW5zYWN0aW9uIHdpdGggbm9uY2UgYW5kIHVzZSB0aGF0IGFzIHRoZSBwcmV2aW91cyBoYXNoIGZvciBuZXh0IGVudHJ5XHJcbiAgICAgICAgICAgIGNvbnN0IHJldHVyblRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tVHJ5dGVzKHJldHVybmVkVHJ5dGVzWzBdKTtcclxuICAgICAgICAgICAgcHJldmlvdXNUcmFuc2FjdGlvbkhhc2ggPSBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIudHJhbnNhY3Rpb25IYXNoKHJldHVyblRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgZmluYWxUcmFuc2FjdGlvbnMucHVzaChyZXR1cm5UcmFuc2FjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldmVyc2UgdGhlIG9yZGVyIHNvIHRoYXQgaXQncyBhc2NlbmRpbmcgZnJvbSBjdXJyZW50SW5kZXhcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbmFsVHJhbnNhY3Rpb25zLnJldmVyc2UoKSk7XHJcbiAgICB9XHJcbn1cclxuLyogQGludGVybmFsICovXHJcblRyYW5zYWN0aW9uQ2xpZW50Lk5VTExfSEFTSF9UUllURVMgPSBcIjlcIi5yZXBlYXQoMjQzKTtcclxuLyogQGludGVybmFsICovXHJcblRyYW5zYWN0aW9uQ2xpZW50Lk1BWF9USU1FU1RBTVBfVkFMVUUgPSAoTWF0aC5wb3coMywgMjcpIC0gMSkgLyAyO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuVHJhbnNhY3Rpb25DbGllbnQuTUFYX0lOUFVUUyA9IDUwMDtcclxuZXhwb3J0cy5UcmFuc2FjdGlvbkNsaWVudCA9IFRyYW5zYWN0aW9uQ2xpZW50O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkSEpoYm5OaFkzUnBiMjVEYkdsbGJuUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdmRISmhibk5oWTNScGIyNXpMM1J5WVc1ellXTjBhVzl1UTJ4cFpXNTBMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGWFFTd3dSVUZCZFVVN1FVRkRka1VzTkVWQlFYbEZPMEZCUTNwRkxEUkZRVUY1UlR0QlFVbDZSU3gzUlVGQmNVVTdRVUZEY2tVc0swWkJRVFJHTzBGQlF6VkdMREpGUVVGM1JUdEJRVU40UlN4NVJFRkJjMFE3UVVGRmRFUXNLMFJCUVRSRU8wRkJRelZFTEN0RlFVRTBSVHRCUVVNMVJTdzJSRUZCTUVRN1FVRkRNVVFzZVVSQlFYTkVPMEZCUTNSRUxESkVRVUYzUkR0QlFVVjRSQ3gxUkVGQmIwUTdRVUZEY0VRc2RVVkJRVzlGTzBGQlEzQkZMR2xGUVVFNFJEdEJRVU01UkN3eVJFRkJkMFE3UVVGRGVFUXNkVVZCUVc5Rk8wRkJRM0JGTERaRVFVRXdSRHRCUVVNeFJDd3dSRUZCZFVRN1FVRkRka1FzTkVSQlFYbEVPMEZCUTNwRUxEQkVRVUYxUkR0QlFVMTJSRHM3UjBGRlJ6dEJRVU5JTzBsQmVVSkpPenM3T3pzN08wOUJUMGM3U1VGRFNDeFpRVUZaTEZOQlFYRkNMRVZCUTNKQ0xGZEJRVEJDTEVWQlF6RkNMRmRCUVRCQ0xFVkJRekZDTEhGQ1FVRTRReXhGUVVNNVF5eE5RVUZuUWp0UlFVTjRRaXhKUVVGSkxFTkJRVU1zVlVGQlZTeEhRVUZITEZOQlFWTXNRMEZCUXp0UlFVTTFRaXhKUVVGSkxFTkJRVU1zV1VGQldTeEhRVUZITEZkQlFWY3NRMEZCUXp0UlFVTm9ReXhKUVVGSkxFTkJRVU1zV1VGQldTeEhRVUZITEZkQlFWY3NTVUZCU1N4SlFVRkpMSGxDUVVGWExFVkJRVVVzUTBGQlF6dFJRVU55UkN4SlFVRkpMRU5CUVVNc2MwSkJRWE5DTEVkQlFVY3NjVUpCUVhGQ0xFbEJRVWtzU1VGQlNTdzJRMEZCY1VJc1JVRkJSU3hEUVVGRE8xRkJRMjVHTEVsQlFVa3NRMEZCUXl4UFFVRlBMRWRCUVVjc1RVRkJUU3hKUVVGSkxFbEJRVWtzZFVKQlFWVXNSVUZCUlN4RFFVRkRPMGxCUXpsRExFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hMUVVGTExFTkJRVU1zZVVKQlFYbENPMUZCUTJ4RExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRzFFUVVGdFJDeERRVUZETEVOQlFVTTdVVUZEZGtVc1RVRkJUU3hSUVVGUkxFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRE8xRkJRMnBFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1NVRkJTU3hSUVVGUkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTVRaXhOUVVGTkxFbEJRVWtzUjBGQlJ5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEZkQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia1lzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc2JVUkJRVzFFTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkROMFVzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0UlFVTm9RaXhEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEU2l4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eHRSRUZCYlVRc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU16UlN4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRE8xRkJRMlFzUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZGUkRzN096czdPenM3TzA5QlUwYzdTVUZEU1N4TFFVRkxMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNUMEZCWjBJc1JVRkJSU3hUUVVGeFFpeEZRVUZGTEVsQlFWa3NSVUZCUlN4VFFVRnJRanRSUVVOdVJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXd3UTBGQk1FTXNSVUZCUlN4UFFVRlBMRVZCUVVVc1UwRkJVeXhGUVVGRkxFbEJRVWtzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0UlFVVnVSeXhOUVVGTkxGTkJRVk1zUjBGQlJ5eFBRVUZQTEV0QlFVc3NVMEZCVXl4SlFVRkpMRTlCUVU4c1MwRkJTeXhKUVVGSkxFbEJRVWtzVDBGQlR5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRiRVlzVFVGQlRTeFpRVUZaTEVkQlFVY3NVMEZCVXl4TFFVRkxMRk5CUVZNc1NVRkJTU3hUUVVGVExFdEJRVXNzU1VGQlNTeEpRVUZKTEZOQlFWTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRE8xRkJRek5HTEUxQlFVMHNUMEZCVHl4SFFVRkhMRWxCUVVrc1MwRkJTeXhUUVVGVExFbEJRVWtzU1VGQlNTeExRVUZMTEVsQlFVa3NTVUZCU1N4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF6dFJRVU4yUlN4TlFVRk5MRmxCUVZrc1IwRkJSeXhUUVVGVExFdEJRVXNzVTBGQlV5eEpRVUZKTEZOQlFWTXNTMEZCU3l4SlFVRkpMRWxCUVVrc1UwRkJVeXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZGTTBZc1JVRkJSU3hEUVVGRExFTkJRVU1zVTBGQlV5eEpRVUZKTEVOQlFVTXNlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eEZRVUZGTEZkQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOdVJDeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXd5UTBGQk1rTXNRMEZCUXl4RFFVRkRPMUZCUTNwRkxFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4WlFVRlpMRWxCUVVrc1EwRkJReXg1UWtGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4VFFVRlRMRVZCUVVVc2FVSkJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXpSQ3hOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4blJFRkJaMFFzUTBGQlF5eERRVUZETzFGQlF6bEZMRU5CUVVNN1VVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVsQlFVa3NRMEZCUXl4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVWQlFVVXNVMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemRETEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExIVkRRVUYxUXl4RFFVRkRMRU5CUVVNN1VVRkRja1VzUTBGQlF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRmxCUVZrc1NVRkJTU3hEUVVGRExIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRk5CUVZNc1JVRkJSU3hYUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZUVRc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNOa05CUVRaRExFTkJRVU1zUTBGQlF6dFJRVU16UlN4RFFVRkRPMUZCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFRRVUZUTEVsQlFVa3NRMEZCUXl4WlFVRlpMRWxCUVVrc1EwRkJReXhQUVVGUExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpORUxFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMSGRFUVVGM1JDeERRVUZETEVOQlFVTTdVVUZEZEVZc1EwRkJRenRSUVVWRUxFMUJRVTBzVDBGQlR5eEhRVUUyUWp0WlFVTjBReXhQUVVGUExFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExFMUJRVTBzUTBGQlF5eEZRVUZGTEVOQlFVTXNUVUZCVFN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRk5CUVZNN1dVRkRjRVlzVTBGQlV5eEZRVUZGTEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCUlN4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhUUVVGVE8xbEJRemRHTEVsQlFVa3NSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVTBGQlV6dFpRVU4wUlN4VFFVRlRMRVZCUVVVc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMRkZCUVZFc1EwRkJReXhGUVVGRkxFTkJRVU1zVVVGQlVTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZOQlFWTTdVMEZEYkVjc1EwRkJRenRSUVVWR0xFMUJRVTBzVVVGQlVTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVOcVJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRWxCUVVrc1VVRkJVU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZET1VJc1RVRkJUU3hKUVVGSkxFZEJRVWNzVVVGQlVTeERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eFhRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMR1ZCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1R0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMREJEUVVFd1F5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTNCRkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEYUVJc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEwb3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zTUVOQlFUQkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGJFVXNUVUZCVFN4RFFVRkRMRVZCUVVVc1EwRkJRenRSUVVOa0xFTkJRVU03U1VGRFRDeERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzUzBGQlN5eERRVUZETEhOQ1FVRnpRaXhEUVVGRExHbENRVUY1UWp0UlFVTjZSQ3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4blJFRkJaMFFzUlVGQlJTeHBRa0ZCYVVJc1EwRkJReXhEUVVGRE8xRkJRM1pHTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc2VVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNhVUpCUVdsQ0xFVkJRVVVzVjBGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJoRUxFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMSEZFUVVGeFJDeERRVUZETEVOQlFVTTdVVUZEYmtZc1EwRkJRenRSUVVWRUxFMUJRVTBzVDBGQlR5eEhRVUZ6UWp0WlFVTXZRaXhOUVVGTkxFVkJRVVVzYVVKQlFXbENMRU5CUVVNc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzFOQlEzQkZMRU5CUVVNN1VVRkZSaXhOUVVGTkxGRkJRVkVzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1UwRkJVeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzFGQlF6RkVMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzU1VGQlNTeFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNNVFpeE5RVUZOTEVsQlFVa3NSMEZCUnl4UlFVRlJMRU5CUVVNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNSVUZCUlN4RFFVRkRMSGxDUVVGWExFTkJRVU1zVlVGQlZTeERRVUZETEdWQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6bEdMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEdkRVFVRm5SQ3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzFsQlF6RkZMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03VVVGRGFFSXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMG9zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1owUkJRV2RFTEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRlRVVzVFVGQlRTeERRVUZETEVWQlFVVXNRMEZCUXp0UlFVTmtMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1MwRkJTeXhEUVVGRExHdENRVUZyUWl4RFFVRkRMR2xDUVVGNVFqdFJRVU55UkN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5d3lRMEZCTWtNc1EwRkJReXhEUVVGRE8xRkJReTlFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc2VVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNhVUpCUVdsQ0xFVkJRVVVzVjBGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJoRUxFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMSEZFUVVGeFJDeERRVUZETEVOQlFVTTdVVUZEYmtZc1EwRkJRenRSUVVWRUxFMUJRVTBzVVVGQlVTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhYUVVGWExFVkJRVVVzUTBGQlF6dFJRVU55UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhSUVVGUkxFbEJRVWtzTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1VVRkJVU3hEUVVGRExEWkNRVUUyUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemRGTEUxQlFVMHNUMEZCVHl4SFFVRXJRanRuUWtGRGVFTXNXVUZCV1N4RlFVRkZMR2xDUVVGcFFpeERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRuUWtGRGRrVXNTVUZCU1N4RlFVRkZMRU5CUVVNc1VVRkJVU3hEUVVGRExEWkNRVUUyUWl4RFFVRkRPMkZCUTJwRUxFTkJRVU03V1VGRFJpeE5RVUZOTEZGQlFWRXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03V1VGRGJrVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hKUVVGSkxGRkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNNVFpeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXd5UTBGQk1rTXNSVUZCUlN4UlFVRlJMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEyaEdMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU1zVFVGQlRTeERRVUZETzFsQlF6TkNMRU5CUVVNN1dVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dG5Ra0ZEU2l4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5d3lRMEZCTWtNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dG5Ra0ZEYmtVc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF6dFpRVU5rTEVOQlFVTTdVVUZEVEN4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFNpeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXc0UkVGQk9FUXNRMEZCUXl4RFFVRkRPMUZCUXpWR0xFTkJRVU03U1VGRFRDeERRVUZETzBsQlJVUTdPenM3T3pzN08wOUJVVWM3U1VGRFNTeExRVUZMTEVOQlFVTXNZVUZCWVN4RFFVRkRMRWxCUVZVc1JVRkJSU3hWUVVGdFFpeEZRVUZGTEZGQlFXbENMRVZCUVVVc1pVRkJlVUlzUlVGQlJTeFJRVUV3UWp0UlFVTm9TU3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4MVEwRkJkVU1zUlVGQlJTeEpRVUZKTEVWQlFVVXNWVUZCVlN4RlFVRkZMRkZCUVZFc1JVRkJSU3hsUVVGbExFVkJRVVVzVVVGQlVTeERRVUZETEVOQlFVTTdVVUZEYkVnc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFVkJRVVVzVjBGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1RExFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMQ3RDUVVFclFpeERRVUZETEVOQlFVTTdVVUZETjBRc1EwRkJRenRSUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlZTeERRVUZETEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZWTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMmhHTEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExHMURRVUZ0UXl4RlFVRkZMRVZCUVVVc1ZVRkJWU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVU5xUml4RFFVRkRPMUZCUlVRc1RVRkJUU3hsUVVGbExFZEJRVWNzVlVGQlZTeEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVVjRReXhGUVVGRkxFTkJRVU1zUTBGQlF5eGxRVUZsTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMFFpeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXcyUWtGQk5rSXNSVUZCUlN4RlFVRkZMR1ZCUVdVc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGFFWXNRMEZCUXp0UlFVVkVMRTFCUVUwc1YwRkJWeXhIUVVGSExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8xRkJRM0pFTEUxQlFVMHNZVUZCWVN4SFFVRkhMRkZCUVZFc1NVRkJTU3hwUTBGQlpTeERRVUZETEUxQlFVMHNRMEZCUXp0UlFVVjZSQ3hKUVVGSkxGTkJRVk1zUTBGQlF6dFJRVU5rTEVWQlFVVXNRMEZCUXl4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFpDeE5RVUZOTEV0QlFVc3NSMEZCUnl4UlFVRlJMRWRCUVVjc1ZVRkJWU3hIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU40UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFbEJRVWtzUTBGQlF5eEpRVUZKTEV0QlFVc3NSMEZCUnl4cFFrRkJhVUlzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOeVJDeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXhuUTBGQlowTXNhVUpCUVdsQ0xFTkJRVU1zVlVGQlZTeEZRVUZGTEVWQlFVVXNSVUZCUlN4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM1pITEVOQlFVTTdXVUZGUkN4VFFVRlRMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1NVRkJTU3hGUVVGRkxGVkJRVlVzUlVGQlJTeFJRVUZSTEVWQlFVVXNaVUZCWlN4RlFVRkZMR0ZCUVdFc1EwRkJReXhEUVVGRE8xRkJRek5ITEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOS0xGTkJRVk1zUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4dlFrRkJiMElzUTBGQlF5eEpRVUZKTEVWQlFVVXNWVUZCVlN4RlFVRkZMR1ZCUVdVc1JVRkJSU3hoUVVGaExFTkJRVU1zUTBGQlF6dFJRVU5zUnl4RFFVRkRPMUZCUlVRc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNkVU5CUVhWRExFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTTdVVUZEZEVVc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF6dEpRVU55UWl4RFFVRkRPMGxCUlVRN096czdPenM3TzA5QlVVYzdTVUZEU1N4TFFVRkxMRU5CUVVNc2JVSkJRVzFDTEVOQlFVTXNTVUZCVlN4RlFVRkZMRlZCUVd0Q0xFVkJRVVVzVVVGQlowSXNSVUZCUlN4bFFVRjNRaXhGUVVGRkxGRkJRWGxDTzFGQlEyeEpMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETERaRFFVRTJReXhGUVVGRkxFbEJRVWtzUlVGQlJTeFZRVUZWTEVWQlFVVXNVVUZCVVN4RlFVRkZMR1ZCUVdVc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVVY0U0N4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1JVRkJSU3hYUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYmtNc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNLMEpCUVN0Q0xFTkJRVU1zUTBGQlF6dFJRVU0zUkN4RFFVRkRPMUZCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlNTeFZRVUZWTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONFJDeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXh6UTBGQmMwTXNSVUZCUlN4RlFVRkZMRlZCUVZVc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGNFWXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzVVVGQlVTeEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRja1FzVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc2JVTkJRVzFETEVWQlFVVXNSVUZCUlN4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJReTlGTEVOQlFVTTdVVUZEUkN4TlFVRk5MRXRCUVVzc1IwRkJSeXhSUVVGUkxFZEJRVWNzVlVGQlZTeEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVTjRReXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVsQlFVa3NRMEZCUXl4SlFVRkpMRXRCUVVzc1IwRkJSeXhwUWtGQmFVSXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0pFTEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExHZERRVUZuUXl4cFFrRkJhVUlzUTBGQlF5eFZRVUZWTEVWQlFVVXNSVUZCUlN4RlFVRkZMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGRrY3NRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzVVVGQlVTeEhRVUZITEVOQlFVTXNTVUZCU1N4UlFVRlJMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU53UlN4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5eHpRMEZCYzBNc1JVRkJSU3hGUVVGRkxGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTTdVVUZEYkVZc1EwRkJRenRSUVVWRUxFMUJRVTBzVTBGQlV5eEhRVUZqTEVWQlFVVXNRMEZCUXp0UlFVVm9ReXhIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFdEJRVXNzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRPMWxCUXpkQ0xGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMR1ZCUVdVc1EwRkJReXhKUVVGSkxFVkJRVVVzVlVGQlZTeEhRVUZITEVOQlFVTXNSVUZCUlN4UlFVRlJMRVZCUVVVc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU14Uml4RFFVRkRPMUZCUlVRc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNOa05CUVRaRExFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTTdVVUZETlVVc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNN1NVRkRkRU1zUTBGQlF6dEpRVVZFT3pzN096czdPMDlCVDBjN1NVRkRTU3hMUVVGTExFTkJRVU1zYjBKQlFXOUNMRU5CUVVNc1NVRkJWU3hGUVVGRkxGVkJRV3RDTEVWQlFVVXNaVUZCZDBJc1JVRkJSU3hSUVVGNVFqdFJRVU5xU0N4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5dzRRMEZCT0VNc1JVRkJSU3hKUVVGSkxFVkJRVVVzVlVGQlZTeEZRVUZGTEdWQlFXVXNSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJRenRSUVVNdlJ5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NSVUZCUlN4WFFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrTXNUVUZCVFN4SlFVRkpMRFpDUVVGaExFTkJRVU1zSzBKQlFTdENMRU5CUVVNc1EwRkJRenRSUVVNM1JDeERRVUZETzFGQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1NVRkJTU3hWUVVGVkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjRSQ3hOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4elEwRkJjME1zUlVGQlJTeEZRVUZGTEZWQlFWVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRjRVlzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1VVRkJVU3hIUVVGSExFTkJRVU1zU1VGQlNTeFJRVUZSTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOd1JTeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXh6UTBGQmMwTXNSVUZCUlN4RlFVRkZMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGJFWXNRMEZCUXp0UlFVVkVMRWxCUVVrc1pVRkJaU3hIUVVGSExGVkJRVlVzUTBGQlF6dFJRVU5xUXl4SlFVRkpMRTFCUVUwc1EwRkJRenRSUVVOWUxFMUJRVTBzVTBGQlV5eEhRVUZITEVWQlFVVXNRMEZCUXp0UlFVVnlRaXhIUVVGSExFTkJRVU03V1VGRFFTeE5RVUZOTEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNc1pVRkJaU3hEUVVGRExFbEJRVWtzUlVGQlJTeGxRVUZsTEVWQlFVVXNSVUZCUlN4UlFVRlJMRVZCUVVVc1pVRkJaU3hEUVVGRExFTkJRVU03V1VGRmVrWXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFpRVVY0UWl4TlFVRk5MR2xDUVVGcFFpeEhRVUZITEU5QlFVOHNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dFpRVVY0UkN4TlFVRk5MR2RDUVVGblFpeEhRVUZ0UXp0blFrRkRja1FzVTBGQlV5eEZRVUZGTEVOQlFVTXNhVUpCUVdsQ0xFTkJRVU03WVVGRGFrTXNRMEZCUXp0WlFVVkdMRTFCUVUwc2FVSkJRV2xDTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExITkNRVUZ6UWl4RFFVRkRMR2RDUVVGblFpeERRVUZETEVOQlFVTTdXVUZGZWtZc1RVRkJUU3hIUVVGSExHbENRVUZwUWl4SlFVRkpMR2xDUVVGcFFpeERRVUZETEUxQlFVMHNTVUZCU1N4cFFrRkJhVUlzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zYVVKQlFXbENMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNN1dVRkRjRWtzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU5XTEUxQlFVMHNkVUpCUVhWQ0xFZEJRVFpDTzI5Q1FVTjBSQ3hUUVVGVExFVkJRVVVzUTBGQlF5eHBRa0ZCYVVJc1EwRkJRenRwUWtGRGFrTXNRMEZCUXp0blFrRkZSaXhOUVVGTkxGbEJRVmtzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNkVUpCUVhWQ0xFTkJRVU1zUTBGQlF6dG5Ra0ZGY2tZc1RVRkJUU3hIUVVGSExGbEJRVmtzU1VGQlNTeFpRVUZaTEVOQlFVTXNUVUZCVFN4SlFVRkpMRmxCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTnVSaXhEUVVGRE8xRkJRMHdzUTBGQlF5eFJRVU5OTEUxQlFVMHNSVUZCUlR0UlFVVm1MRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETERoRFFVRTRReXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzFGQlF6ZEZMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRPMGxCUTNSRExFTkJRVU03U1VGRlJEczdPenM3T3pzN1QwRlJSenRKUVVOSkxFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCVlN4RlFVRkZMRlZCUVd0Q0xFVkJRVVVzVVVGQlowSXNSVUZCUlN4UlFVRjVRaXhGUVVGRkxHRkJRWEZDTzFGQlEzSklMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEcxRFFVRnRReXhGUVVGRkxFbEJRVWtzUlVGQlJTeFZRVUZWTEVWQlFVVXNVVUZCVVN4RlFVRkZMRkZCUVZFc1JVRkJSU3hoUVVGaExFTkJRVU1zUTBGQlF6dFJRVVUxUnl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1JVRkJSU3hYUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYmtNc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNLMEpCUVN0Q0xFTkJRVU1zUTBGQlF6dFJRVU0zUkN4RFFVRkRPMUZCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlNTeFZRVUZWTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONFJDeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXh6UTBGQmMwTXNSVUZCUlN4RlFVRkZMRlZCUVZVc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGNFWXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzVVVGQlVTeEhRVUZITEVOQlFVTXNTVUZCU1N4UlFVRlJMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU53UlN4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5eHpRMEZCYzBNc1JVRkJSU3hGUVVGRkxGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTTdVVUZEYkVZc1EwRkJRenRSUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zWVVGQllTeERRVUZETEVsQlFVa3NZVUZCWVN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE9VUXNUVUZCVFN4SlFVRkpMRFpDUVVGaExFTkJRVU1zWjBOQlFXZERMRVZCUVVVc1JVRkJSU3hoUVVGaExFVkJRVVVzUTBGQlF5eERRVUZETzFGQlEycEdMRU5CUVVNN1VVRkZSQ3hOUVVGTkxGTkJRVk1zUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4aFFVRmhMRU5CUVVNc1NVRkJTU3hGUVVGRkxGVkJRVlVzUlVGQlJTeFJRVUZSTEVWQlFVVXNTMEZCU3l4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8xRkJSWGhHTEUxQlFVMHNUMEZCVHl4SFFVRjNRanRaUVVOcVF5eFRRVUZUTEVWQlFVVXNVMEZCVXl4RFFVRkRMRWRCUVVjc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dFpRVU14UkN4VFFVRlRMRVZCUVVVc1IwRkJSenRUUVVOcVFpeERRVUZETzFGQlJVWXNUVUZCVFN4UlFVRlJMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zVlVGQlZTeERRVUZETEZkQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVVMVJDeE5RVUZOTEUxQlFVMHNSMEZCUnl4RlFVRkZMRU5CUVVNN1VVRkRiRUlzU1VGQlNTeFpRVUZaTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUlhKQ0xFVkJRVVVzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRXQ3hIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExGTkJRVk1zUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJRenRuUWtGRGVFTXNUVUZCVFN4UFFVRlBMRWRCUVVjc1VVRkJVU3hEUVVGRExGRkJRVkVzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03WjBKQlEyNUVMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVOa0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNZVUZCU3l4RFFVRkRMRlZCUVZVc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNVVUZCVVN4RlFVRkZMRlZCUVZVc1IwRkJSeXhEUVVGRExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkRMMFVzV1VGQldTeEpRVUZKTEU5QlFVOHNRMEZCUXp0dlFrRkZlRUlzUlVGQlJTeERRVUZETEVOQlFVTXNZVUZCWVN4SFFVRkhMRU5CUVVNc1NVRkJTU3haUVVGWkxFbEJRVWtzWVVGQllTeERRVUZETEVOQlFVTXNRMEZCUXp0M1FrRkRja1FzUzBGQlN5eERRVUZETzI5Q1FVTldMRU5CUVVNN1owSkJRMHdzUTBGQlF6dFpRVU5NTEVOQlFVTTdVVUZEVEN4RFFVRkRPMUZCUlVRc1RVRkJUU3hKUVVGSkxFZEJRVWNzUlVGQlJTeE5RVUZOTEVWQlFVVXNXVUZCV1N4RlFVRkZMRU5CUVVNN1VVRkRkRU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc2JVTkJRVzFETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkZOMFFzUlVGQlJTeERRVUZETEVOQlFVTXNZVUZCWVN4SFFVRkhMRU5CUVVNc1NVRkJTU3haUVVGWkxFZEJRVWNzWVVGQllTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTndSQ3hOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl3MFJVRkJORVVzUlVGQlJTeEZRVUZGTEdGQlFXRXNSVUZCUlN4WlFVRlpMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRek5KTEVOQlFVTTdVVUZGUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wbEJRMmhDTEVOQlFVTTdTVUZGUkRzN096czdPenM3T3pzN1QwRlhSenRKUVVOSkxFdEJRVXNzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhKUVVGVkxFVkJRVVVzVTBGQmNVSXNSVUZCUlN4bFFVRnBRenRSUVVNNVJpeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXd3UTBGQk1FTXNSVUZCUlN4SlFVRkpMRVZCUVVVc1UwRkJVeXhGUVVGRkxHVkJRV1VzUTBGQlF5eERRVUZETzFGQlJXaEhMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hGUVVGRkxGZEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnVReXhOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl3clFrRkJLMElzUTBGQlF5eERRVUZETzFGQlF6ZEVMRU5CUVVNN1VVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExGTkJRVk1zUlVGQlJTeHRRa0ZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRelZETEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExHOUVRVUZ2UkN4RFFVRkRMRU5CUVVNN1VVRkRiRVlzUTBGQlF6dFJRVVZFTEUxQlFVMHNiMEpCUVc5Q0xFZEJRVWNzWlVGQlpTeEpRVUZKTEVWQlFVVXNRMEZCUXp0UlFVTnVSQ3h2UWtGQmIwSXNRMEZCUXl4UlFVRlJMRWRCUVVjc2IwSkJRVzlDTEVOQlFVTXNVVUZCVVN4SlFVRkpMR2xEUVVGbExFTkJRVU1zVFVGQlRTeERRVUZETzFGQlJYaEdMRTFCUVUwc1YwRkJWeXhIUVVGSExHVkJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRNVU1zVFVGQlRTeFBRVUZQTEVkQlFVY3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eHZRa0ZCYjBJc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU53UlN4SlFVRkpMRk5CUVZNc1IwRkJSeXhMUVVGTExFTkJRVU03VVVGRmRFSXNaMFJCUVdkRU8xRkJRMmhFTEZOQlFWTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFVkJRVVU3V1VGRGVrSXNVVUZCVVN4RFFVRkRMRTlCUVU4c1IwRkJSeXhSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eFhRVUZYTEVOQlFVTTdXVUZEY2tVc1VVRkJVU3hEUVVGRExFZEJRVWNzUjBGQlJ5eFJRVUZSTEVOQlFVTXNSMEZCUnl4SlFVRkpMRk5CUVVjc1EwRkJReXhMUVVGTExFTkJRVU03V1VGRmVrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhKUVVGSkxGRkJRVkVzUTBGQlF5eExRVUZMTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGFFTXNVVUZCVVN4RFFVRkRMRTlCUVU4c1IwRkJSeXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEdsQ1FVRnBRaXhEUVVGRExHZENRVUZuUWl4SFFVRkhMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXp0blFrRkRka2NzVTBGQlV5eEhRVUZITEVsQlFVa3NRMEZCUXp0WlFVTnlRaXhEUVVGRE8xRkJRMHdzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZGU0N4elFrRkJjMEk3VVVGRGRFSXNUVUZCVFN4UlFVRlJMRWRCUVVjc01rSkJRVmtzUTBGQlF5eGhRVUZoTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmxCUVZrc1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF6dFJRVVV4UlN4TlFVRk5MRTFCUVUwc1IwRkJSeXhSUVVGUkxFTkJRVU1zVFVGQlRTeERRVUZETzFGQlF5OUNMRTFCUVUwc1QwRkJUeXhIUVVGSExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTTdVVUZEYWtNc1RVRkJUU3hWUVVGVkxFZEJRVWNzVVVGQlVTeERRVUZETEZWQlFWVXNRMEZCUXp0UlFVTjJReXhOUVVGTkxIbENRVUY1UWl4SFFVRkhMRkZCUVZFc1EwRkJReXg1UWtGQmVVSXNRMEZCUXp0UlFVVnlSU3h6UTBGQmMwTTdVVUZEZEVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTmlMR2REUVVGblF6dFpRVU5vUXl3NFEwRkJPRU03V1VGRE9VTXNSVUZCUlN4RFFVRkRMRU5CUVVNc2IwSkJRVzlDTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE9VSXNUVUZCVFN4UFFVRlBMRWRCUVhkQ08yOUNRVU5xUXl4VFFVRlRMRVZCUVVVc2IwSkJRVzlDTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhMUVVGTExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdiMEpCUTNoR0xGTkJRVk1zUlVGQlJTeEhRVUZITzJsQ1FVTnFRaXhEUVVGRE8yZENRVVZHTEUxQlFVMHNVVUZCVVN4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExGVkJRVlVzUTBGQlF5eFhRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1owSkJRelZFTEUxQlFVMHNaVUZCWlN4SFFVRkhMRVZCUVVVc1EwRkJRenRuUWtGRE0wSXNTVUZCU1N4WlFVRlpMRWRCUVVjc1EwRkJReXhEUVVGRE8yZENRVU55UWl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRkZCUVZFc1EwRkJReXhSUVVGUkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNN2IwSkJRMmhFTEUxQlFVMHNUMEZCVHl4SFFVRkhMRkZCUVZFc1EwRkJReXhSUVVGUkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8yOUNRVVZ1UkN4clJFRkJhMFE3YjBKQlEyeEVMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPM2RDUVVOa0xGbEJRVmtzU1VGQlNTeFBRVUZQTEVOQlFVTTdkMEpCUlhoQ0xHOUNRVUZ2UWl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVkQlFVY3NUMEZCVHl4RFFVRkRPM2RDUVVWcVJDeGxRVUZsTEVOQlFVTXNTVUZCU1N4RFFVRkRMRzlDUVVGdlFpeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8zZENRVVZ5UkN4MVJVRkJkVVU3ZDBKQlEzWkZMRVZCUVVVc1EwRkJReXhEUVVGRExGbEJRVmtzU1VGQlNTeFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPelJDUVVNM1FpeExRVUZMTEVOQlFVTTdkMEpCUTFZc1EwRkJRenR2UWtGRFRDeERRVUZETzJkQ1FVTk1MRU5CUVVNN1owSkJSVVFzYTBOQlFXdERPMmRDUVVOc1F5eEZRVUZGTEVOQlFVTXNRMEZCUXl4VlFVRlZMRWRCUVVjc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZETlVJc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNhVVpCUVdsR0xFTkJRVU1zUTBGQlF6dG5Ra0ZETDBjc1EwRkJRenRuUWtGRlJDeE5RVUZOTEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1NVRkJTU3hGUVVGRkxFMUJRVTBzUlVGQlJTeHZRa0ZCYjBJc1JVRkJSU3hsUVVGbExFVkJRVVVzZVVKQlFYbENMRVZCUVVVc1ZVRkJWU3hGUVVGRkxFOUJRVThzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0WlFVTTFTU3hEUVVGRE8xbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdaMEpCUTBvc05FTkJRVFJETzJkQ1FVTTFReXhOUVVGTkxHTkJRV01zUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUlVGQlJTeFRRVUZUTEVWQlFVVXNiMEpCUVc5Q0xFTkJRVU1zVVVGQlVTeEZRVUZGTEZWQlFWVXNRMEZCUXl4RFFVRkRPMmRDUVVVelJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1NVRkJTU3hGUVVGRkxFMUJRVTBzUlVGQlJTeHZRa0ZCYjBJc1JVRkJSU3hqUVVGakxFTkJRVU1zVFVGQlRTeEZRVUZGTEhsQ1FVRjVRaXhGUVVGRkxGVkJRVlVzUlVGQlJTeFBRVUZQTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1dVRkRiRW9zUTBGQlF6dFJRVU5NTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOS0xHdEZRVUZyUlR0WlFVTnNSU3d5UWtGQldTeERRVUZETEdOQlFXTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRaUVVOd1F5eE5RVUZOTEVOQlFVTXNORUpCUVRSQ0xFTkJRVU1zZVVKQlFYbENMRU5CUVVNc1EwRkJRenRSUVVOdVJTeERRVUZETzFGQlJVUXNUVUZCVFN4RFFVRkRMRmxCUVZrc1IwRkJSeXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRPMUZCUlhCRUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMREJEUVVFd1F5eEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUlhSRkxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZEYkVJc1EwRkJRenRKUVVWRU96czdPenM3TzA5QlQwYzdTVUZEU1N4TFFVRkxMRU5CUVVNc1kwRkJZeXhEUVVGRExFMUJRV01zUlVGQlJTeExRVUZoTEVWQlFVVXNhMEpCUVRCQ0xFVkJRVVVzVTBGQlowSTdVVUZEYmtjc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNkME5CUVhkRExFVkJRVVVzVFVGQlRTeEZRVUZGTEV0QlFVc3NSVUZCUlN4clFrRkJhMElzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0UlFVVXhSeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUlVGQlJTeGxRVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRka01zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc05FTkJRVFJETEVOQlFVTXNRMEZCUXp0UlFVTXhSU3hEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RlFVRkZMSGxDUVVGWExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZWtRc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNPRVJCUVRoRUxFTkJRVU1zUTBGQlF6dFJRVU0xUml4RFFVRkRPMUZCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeExRVUZMTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNdlF5eE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXhuUTBGQlowTXNSVUZCUlN4RlFVRkZMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGVrVXNRMEZCUXp0UlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc2EwSkJRV3RDTEVOQlFVTXNTVUZCU1N4clFrRkJhMElzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNwRkxFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMRFpEUVVFMlF5eEZRVUZGTEVWQlFVVXNhMEpCUVd0Q0xFVkJRVVVzUTBGQlF5eERRVUZETzFGQlEyNUhMRU5CUVVNN1VVRkZSQ3hOUVVGTkxEUkNRVUUwUWl4SFFVRnhRenRaUVVOdVJTeExRVUZMTzFsQlEwd3NVMEZCVXl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zVTBGQlV5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFRRVUZUTzFOQlEzSkZMRU5CUVVNN1VVRkZSaXhOUVVGTkxIRkNRVUZ4UWl4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExGVkJRVlVzUTBGQlF5eDNRa0ZCZDBJc1EwRkJReXcwUWtGQk5FSXNRMEZCUXl4RFFVRkRPMUZCUlROSExFbEJRVWtzWlVGQk9FSXNRMEZCUXp0UlFVTnVReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOd1FpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExHTkJRV01zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRja01zWlVGQlpTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMR3RDUVVGclFpeERRVUZETEZkQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eHhRa0ZCY1VJc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4RFFVRkRMRVZCUXpGRkxGZEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNaVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXh4UWtGQmNVSXNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eERRVUZETEVWQlF6TkZMRTFCUVUwc1EwRkJReXhaUVVGWkxFVkJRMjVDTEd0Q1FVRnJRaXhEUVVGRExFTkJRVU03V1VGRGVFVXNRMEZCUXp0WlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8yZENRVU5LTEUxQlFVMHNVMEZCVXl4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eEhRVUZITEVOQlFVTXNWMEZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEhGQ1FVRnhRaXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1JVRkRNVVVzVjBGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4bFFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExIRkNRVUZ4UWl4RFFVRkRMR2xDUVVGcFFpeERRVUZETEVOQlFVTXNSVUZETTBVc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNSVUZETVVNc2EwSkJRV3RDTEVOQlFVTXNRMEZCUXp0blFrRkZiRVVzWlVGQlpTeEhRVUZITEZOQlFWTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1dVRkJXU3hEUVVGRExFVkJRVVVzUTBGQlF5eDVRa0ZCVnl4RFFVRkRMRlZCUVZVc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6RkdMRU5CUVVNN1VVRkRUQ3hEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEU2l4TlFVRk5MSEZDUVVGeFFpeEhRVUV5UWp0blFrRkRiRVFzWjBKQlFXZENMRVZCUVVVc2NVSkJRWEZDTEVOQlFVTXNaMEpCUVdkQ08yZENRVU40UkN4cFFrRkJhVUlzUlVGQlJTeHhRa0ZCY1VJc1EwRkJReXhwUWtGQmFVSTdaMEpCUXpGRUxHdENRVUZyUWl4RlFVRkZMR3RDUVVGclFqdG5Ra0ZEZEVNc1RVRkJUU3hGUVVGRkxFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8yRkJRMmhGTEVOQlFVTTdXVUZGUml4TlFVRk5MSE5DUVVGelFpeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhqUVVGakxFTkJRVU1zY1VKQlFYRkNMRU5CUVVNc1EwRkJRenRaUVVVelJpeGxRVUZsTEVkQlFVY3NjMEpCUVhOQ0xFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4WlFVRlpMRU5CUVVNc1JVRkJSU3hEUVVGRExIbENRVUZYTEVOQlFVTXNWVUZCVlN4RFFVRkRMR1ZCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJwSkxFTkJRVU03VVVGRlJDeE5RVUZOTEZOQlFWTXNSMEZCUnl4SlFVRkpMR1ZCUVUwc1JVRkJSU3hEUVVGRE8xRkJReTlDTEZOQlFWTXNRMEZCUXl4WlFVRlpMRWRCUVVjc1pVRkJaU3hEUVVGRE8xRkJRM3BETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExIZERRVUYzUXl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8xRkJRM1pGTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNN1NVRkRja0lzUTBGQlF6dEpRVVZFT3pzN096czdPMDlCVDBjN1NVRkRTU3hMUVVGTExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1RVRkJZeXhGUVVGRkxFdEJRV0VzUlVGQlJTeHJRa0ZCTUVJc1JVRkJSU3hUUVVGblFqdFJRVU55Unl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5d3dRMEZCTUVNc1JVRkJSU3hOUVVGTkxFVkJRVVVzUzBGQlN5eEZRVUZGTEd0Q1FVRnJRaXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzFGQlJUVkhMRTFCUVUwc01FSkJRVEJDTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExFMUJRVTBzUlVGQlJTeExRVUZMTEVWQlFVVXNhMEpCUVd0Q0xFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTTdVVUZGTTBjc1RVRkJUU3gzUWtGQmQwSXNSMEZCT0VJN1dVRkRlRVFzVFVGQlRTeEZRVUZGTERCQ1FVRXdRaXhEUVVGRExGbEJRVmtzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNN1UwRkRjRVlzUTBGQlF6dFJRVVZHTEUxQlFVMHNTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4M1FrRkJkMElzUTBGQlF5eERRVUZETzFGQlJXeEZMRTFCUVUwc05FSkJRVFJDTEVkQlFXdERPMWxCUTJoRkxFMUJRVTBzUlVGQlJTeDNRa0ZCZDBJc1EwRkJReXhOUVVGTk8xTkJRekZETEVOQlFVTTdVVUZGUml4TlFVRk5MRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zY1VKQlFYRkNMRU5CUVVNc05FSkJRVFJDTEVOQlFVTXNRMEZCUXp0UlFVVXhSU3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl3d1EwRkJNRU1zUlVGQlJTd3dRa0ZCTUVJc1EwRkJReXhEUVVGRE8xRkJRekZHTEUxQlFVMHNRMEZCUXl3d1FrRkJNRUlzUTBGQlF6dEpRVU4wUXl4RFFVRkRPMGxCUlVRN096czdPenM3T3pzN096czdUMEZoUnp0SlFVTkpMRXRCUVVzc1EwRkJReXhaUVVGWkxFTkJRVU1zU1VGQlZTeEZRVUZGTEV0QlFXRXNSVUZCUlN4clFrRkJNRUlzUlVGQlJTeFRRVUZ4UWl4RlFVRkZMR1ZCUVdsRExFVkJRVVVzVTBGQlowSTdVVUZEZGtvc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNjME5CUVhORExFVkJRVVVzU1VGQlNTeEZRVUZGTEV0QlFVc3NSVUZCUlN4clFrRkJhMElzUlVGQlJTeFRRVUZUTEVWQlFVVXNaVUZCWlN4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8xRkJSV3hKTEUxQlFVMHNZMEZCWXl4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExHZENRVUZuUWl4RFFVRkRMRWxCUVVrc1JVRkJSU3hUUVVGVExFVkJRVVVzWlVGQlpTeERRVUZETEVOQlFVTTdVVUZGY2tZc1RVRkJUU3hWUVVGVkxFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zWTBGQll5eEZRVUZGTEV0QlFVc3NSVUZCUlN4clFrRkJhMElzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0UlFVTnlSeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4elEwRkJjME1zUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0UlFVTjBSU3hOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETzBsQlEzUkNMRU5CUVVNN1NVRkZSRHM3T3p0UFFVbEhPMGxCUTBrc1MwRkJTeXhEUVVGRExGbEJRVmtzUTBGQlF5eGxRVUZ4UWp0UlFVTXpReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4elEwRkJjME1zUlVGQlJTeGxRVUZsTEVOQlFVTXNRMEZCUXp0UlFVVXpSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExHVkJRV1VzUlVGQlJTeFhRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRPVU1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc2IwUkJRVzlFTEVOQlFVTXNRMEZCUXp0UlFVTnNSaXhEUVVGRE8xRkJSVVFzVFVGQlRTeDFRa0ZCZFVJc1IwRkJOa0k3V1VGRGRFUXNTMEZCU3l4RlFVRkZMRU5CUVVNc1pVRkJaU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMU5CUTJwRUxFTkJRVU03VVVGRlJpeE5RVUZOTEhkQ1FVRjNRaXhIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4blFrRkJaMElzUTBGQlF5eDFRa0ZCZFVJc1EwRkJReXhEUVVGRE8xRkJRMnBITEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExITkRRVUZ6UXl4RlFVRkZMSGRDUVVGM1FpeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUXpGR0xFMUJRVTBzUTBGQlF5eDNRa0ZCZDBJc1EwRkJReXhMUVVGTExFTkJRVU03U1VGRE1VTXNRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4TFFVRkxMRU5CUVVNc1kwRkJZeXhEUVVGRExGTkJRVzlDTzFGQlF6VkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEhkRFFVRjNReXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzFGQlEzWkZMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zZVVKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1UwRkJVeXhGUVVGRkxHbENRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRNME1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc2FVUkJRV2xFTEVOQlFVTXNRMEZCUXp0UlFVTXZSU3hEUVVGRE8xRkJSVVFzVFVGQlRTeFhRVUZYTEVkQlFXdERMRVZCUVVVc1EwRkJRenRSUVVWMFJDeEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEZOQlFWTXNRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF6dFpRVU40UXl4TlFVRk5MR0ZCUVdFc1IwRkJSeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU03V1VGRGVrUXNWMEZCVnl4RFFVRkRMR0ZCUVdFc1EwRkJReXhIUVVGSExFVkJRVVVzUTBGQlF6dFJRVU53UXl4RFFVRkRPMUZCUlVRc1RVRkJUU3haUVVGWkxFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNjMEpCUVhOQ0xFTkJRVU1zVTBGQlV5eEZRVUZGTEZOQlFWTXNRMEZCUXl4RFFVRkRPMUZCUlRkRkxFMUJRVTBzYVVKQlFXbENMRWRCUVZjc1JVRkJSU3hEUVVGRE8xRkJRM0pETEZsQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhYUVVGWExFVkJRVVVzUlVGQlJUdFpRVU5xUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhYUVVGWExFTkJRVU1zUzBGQlN5eERRVUZETEZGQlFWRXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEyNURMRTFCUVUwc1UwRkJVeXhIUVVGSExGZEJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTTdaMEpCUTNSRExFMUJRVTBzVFVGQlRTeEhRVUZITERKQ1FVRlpMRU5CUVVNc1pVRkJaU3hEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETzJkQ1FVVjZSQ3hYUVVGWExFTkJRVU1zVTBGQlV5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMmRDUVVVeFJDeHBRa0ZCYVVJc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdXVUZEYmtNc1EwRkJRenRSUVVOTUxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlJVZ3NTVUZCU1N4UFFVRnJRaXhEUVVGRE8xRkJRM1pDTEVWQlFVVXNRMEZCUXl4RFFVRkRMR2xDUVVGcFFpeERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJReTlDTEUxQlFVMHNaVUZCWlN4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExHdENRVUZyUWl4RFFVRkRMR2xDUVVGcFFpeERRVUZETEVOQlFVTTdXVUZEZWtVc1QwRkJUeXhIUVVGSExGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4UFFVRlBMRVZCUVVVc1JVRkJSVHRuUWtGRGFFTXNTVUZCU1N4alFVRmpMRWRCUVVjc1NVRkJTU3hEUVVGRE8yZENRVVV4UWl4TlFVRk5MRWRCUVVjc1IwRkJSeXhYUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU03WjBKQlJYWkVMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRPMjlDUVVOc1F5eE5RVUZOTEU5QlFVOHNSMEZCUnl4cFFrRkJhVUlzUTBGQlF5eFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlEyeEVMR05CUVdNc1IwRkJSeXhEUVVGRExHVkJRV1VzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0dlFrRkRNME1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJReXhEUVVGRE8zZENRVU5zUWl4TFFVRkxMRU5CUVVNN2IwSkJRMVlzUTBGQlF6dG5Ra0ZEVEN4RFFVRkRPMmRDUVVWRUxFMUJRVTBzUTBGQlF5eGpRVUZqTEVOQlFVTTdXVUZETVVJc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFVDeERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRTaXhQUVVGUExFZEJRVWNzUlVGQlJTeERRVUZETzFsQlJXSXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4VFFVRlRMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTTdaMEpCUTNoRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRka0lzUTBGQlF6dFJRVU5NTEVOQlFVTTdVVUZGUkN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eDNRMEZCZDBNc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU55UlN4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRE8wbEJRMjVDTEVOQlFVTTdTVUZGUkRzN096czdPenM3T3pzN096dFBRV0ZITzBsQlEwa3NTMEZCU3l4RFFVRkRMR3RDUVVGclFpeERRVUZETEdWQlFYRkNMRVZCUVVVc1MwRkJZU3hGUVVGRkxHdENRVUV3UWl4RlFVRkZMRk5CUVhGQ0xFVkJRVVVzWTBGQkswSTdVVUZEY0Vvc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNORU5CUVRSRExFVkJRVVVzWlVGQlpTeEZRVUZGTEV0QlFVc3NSVUZCUlN4clFrRkJhMElzUlVGQlJTeFRRVUZUTEVWQlFVVXNZMEZCWXl4RFFVRkRMRU5CUVVNN1VVRkZka2tzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eGxRVUZsTEVWQlFVVXNWMEZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemxETEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExHOUVRVUZ2UkN4RFFVRkRMRU5CUVVNN1VVRkRiRVlzUTBGQlF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1MwRkJTeXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETDBNc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNaME5CUVdkRExFVkJRVVVzUlVGQlJTeExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUTNwRkxFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEd0Q1FVRnJRaXhEUVVGRExFbEJRVWtzYTBKQlFXdENMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU42UlN4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5dzJRMEZCTmtNc1JVRkJSU3hGUVVGRkxHdENRVUZyUWl4RlFVRkZMRU5CUVVNc1EwRkJRenRSUVVOdVJ5eERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXg1UWtGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4VFFVRlRMRVZCUVVVc2JVSkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTFReXhOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4cFJFRkJhVVFzUTBGQlF5eERRVUZETzFGQlF5OUZMRU5CUVVNN1VVRkZSQ3hOUVVGTkxHMUNRVUZ0UWl4SFFVRkhMR05CUVdNc1NVRkJTU3hGUVVGRkxFTkJRVU03VVVGRGFrUXNSVUZCUlN4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNiVUpCUVcxQ0xFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNSRUxHMUNRVUZ0UWl4RFFVRkRMRk5CUVZNc1IwRkJSeXhMUVVGTExFTkJRVU03VVVGRE1VTXNRMEZCUXp0UlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExHMUNRVUZ0UWl4RFFVRkRMRk5CUVZNc1MwRkJTeXhMUVVGTExFbEJRVWtzUTBGQlF5eFBRVUZQTEcxQ1FVRnRRaXhEUVVGRExGTkJRVk1zUzBGQlN5eFZRVUZWTEVsQlFVa3NRMEZCUXl4dFFrRkJiVUlzUTBGQlF5eFRRVUZUTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMlNTeE5RVUZOTEZsQlFWa3NSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zWlVGQlpTeERRVUZETEVOQlFVTTdXVUZGT1VRc1JVRkJSU3hEUVVGRExFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRaaXhOUVVGTkxHOUNRVUZ2UWl4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eFhRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1JVRkJSU3hMUVVGTExFVkJRVVVzYTBKQlFXdENMRVZCUVVVc1UwRkJVeXhGUVVGRkxGTkJRVk1zUlVGQlJTeGxRVUZsTEVOQlFVTXNRMEZCUXp0blFrRkZla3NzUlVGQlJTeERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTndSQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEhOQ1FVRnpRaXhEUVVGRExFMUJRVTBzUTBGRGNrTXNTMEZCU3l4SlFVRkpMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1pVRkJaU3hGUVVGRkxFdEJRVXNzUlVGQlJTeHJRa0ZCYTBJc1JVRkJSU3hUUVVGVExFVkJRVVVzYlVKQlFXMUNMRU5CUVVNc1JVRkRMMGNzYlVKQlFXMUNMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03WjBKQlEyNURMRU5CUVVNN1owSkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdiMEpCUTBvc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNORU5CUVRSRExFVkJRVVVzYjBKQlFXOUNMRU5CUVVNc1EwRkJRenR2UWtGRGRFWXNUVUZCVFN4RFFVRkRMRzlDUVVGdlFpeERRVUZETzJkQ1FVTm9ReXhEUVVGRE8xbEJRMHdzUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOS0xFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMQ3RDUVVFclFpeERRVUZETEVOQlFVTTdXVUZETjBRc1EwRkJRenRSUVVOTUxFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTktMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETERSRFFVRTBReXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzFsQlF6TkZMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU03VVVGRGNrSXNRMEZCUXp0SlFVTk1MRU5CUVVNN1NVRkZSRHM3T3pzN1QwRkxSenRKUVVOSkxFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNaVUZCY1VJN1VVRkRlRU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc2JVTkJRVzFETEVWQlFVVXNaVUZCWlN4RFFVRkRMRU5CUVVNN1VVRkZlRVVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eGxRVUZsTEVWQlFVVXNWMEZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemxETEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExHOUVRVUZ2UkN4RFFVRkRMRU5CUVVNN1VVRkRiRVlzUTBGQlF6dFJRVVZFTEUxQlFVMHNXVUZCV1N4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXp0UlFVVm9SU3hOUVVGTkxFMUJRVTBzUjBGQlJ5eEpRVUZKTEdWQlFVMHNSVUZCUlN4RFFVRkRPMUZCUXpWQ0xFMUJRVTBzUTBGQlF5eFpRVUZaTEVkQlFVY3NXVUZCV1N4RFFVRkRPMUZCUlc1RExFMUJRVTBzVDBGQlR5eEhRVUZITERKQ1FVRlpMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlJUZERMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTllMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEhsQ1FVRjVRaXhEUVVGRExFTkJRVU03VVVGRGRrUXNRMEZCUXp0UlFVVkVMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEcxRFFVRnRReXhGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzFGQlF5OUVMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRGJFSXNRMEZCUXp0SlFVVkVPenM3T3pzN1QwRk5SenRKUVVOSkxFdEJRVXNzUTBGQlF5eGpRVUZqTEVOQlFVTXNaMEpCUVhOQ0xFVkJRVVVzVlVGQmFVSTdVVUZEYWtVc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNkME5CUVhkRExFVkJRVVVzWjBKQlFXZENMRVZCUVVVc1ZVRkJWU3hEUVVGRExFTkJRVU03VVVGRk1VWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4blFrRkJaMElzUlVGQlJTeFhRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRMME1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc2NVUkJRWEZFTEVOQlFVTXNRMEZCUXp0UlFVTnVSaXhEUVVGRE8xRkJSVVFzVFVGQlRTeHhRa0ZCY1VJc1IwRkJhMElzUlVGQlJTeERRVUZETzFGQlEyaEVMRWxCUVVrc2JVSkJRVzFDTEVkQlFVY3NaMEpCUVdkQ0xFTkJRVU03VVVGRE0wTXNTVUZCU1N4aFFVRmhMRWRCUVVjc1ZVRkJWU3hEUVVGRE8xRkJSUzlDTEVkQlFVY3NRMEZCUXp0WlFVTkJMRTFCUVUwc1owSkJRV2RDTEVkQlFYTkNPMmRDUVVONFF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4dFFrRkJiVUlzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRoUVVOMFJDeERRVUZETzFsQlJVWXNUVUZCVFN4cFFrRkJhVUlzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1UwRkJVeXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRU5CUVVNN1dVRkROVVVzVFVGQlRTeE5RVUZOTEVkQlFVY3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eHBRa0ZCYVVJc1EwRkJRenRuUWtGRGRrTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhOUVVGTkxFTkJRVU03WjBKQlF5OURMR2xDUVVGcFFpeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRk5CUVZNc1EwRkJRenRaUVVVNVJpeEZRVUZGTEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJReTlDTEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExHbERRVUZwUXl4RFFVRkRMRU5CUVVNN1dVRkRMMFFzUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOS0xFMUJRVTBzYVVKQlFXbENMRWRCUVVjc2VVSkJRVmNzUTBGQlF5eFZRVUZWTEVOQlFVTXNaVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVVTFSU3cyUkVGQk5rUTdaMEpCUXpkRUxFMUJRVTBzVDBGQlR5eEhRVUZITEVOQlFVTXNNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zWVVGQllTeERRVUZETEVOQlFVTTdaMEpCUTNKRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4SlFVRkpMR2xDUVVGcFFpeERRVUZETEZsQlFWa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTTVSQ3hOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4dFEwRkJiVU1zUTBGQlF5eERRVUZETzJkQ1FVTnFSU3hEUVVGRE8yZENRVVZFTEN0Q1FVRXJRanRuUWtGREwwSXNUVUZCVFN4bFFVRmxMRWRCUVVjc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRMR2xDUVVGcFFpeERRVUZETEUxQlFVMHNRMEZCUXp0blFrRkZNMFVzYlVKQlFXMUNMRWRCUVVjc1UwRkJVeXhEUVVGRE8yZENRVU5vUXl4aFFVRmhMRWRCUVVjc1UwRkJVeXhEUVVGRE8yZENRVVV4UWl3clFrRkJLMEk3WjBKQlF5OUNMRVZCUVVVc1EwRkJReXhEUVVGRExHVkJRV1VzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1MwRkJTeXhwUWtGQmFVSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVNelJpeHRRMEZCYlVNN2IwSkJRMjVETEhGQ1FVRnhRaXhEUVVGRExFbEJRVWtzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhEUVVGRE8yOUNRVVU1UXl4NVEwRkJlVU03YjBKQlEzcERMRVZCUVVVc1EwRkJReXhEUVVGRExHbENRVUZwUWl4RFFVRkRMRk5CUVZNc1EwRkJReXhSUVVGUkxFVkJRVVVzUzBGQlN5eERRVUZETEVsQlFVa3NhVUpCUVdsQ0xFTkJRVU1zV1VGQldTeERRVUZETEZGQlFWRXNSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03ZDBKQlEyeEhMRzFDUVVGdFFpeEhRVUZITEdsQ1FVRnBRaXhEUVVGRExHZENRVUZuUWl4RFFVRkRPM2RDUVVONlJDeGhRVUZoTEVkQlFVY3NaVUZCWlN4RFFVRkRPMjlDUVVOd1F5eERRVUZETzJkQ1FVTk1MRU5CUVVNN1dVRkRUQ3hEUVVGRE8xRkJRMHdzUTBGQlF5eFJRVUZSTEcxQ1FVRnRRaXhMUVVGTExGTkJRVk1zUlVGQlJUdFJRVVUxUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eDNRMEZCZDBNc1JVRkJSU3h4UWtGQmNVSXNRMEZCUXl4RFFVRkRPMUZCUTI1R0xFMUJRVTBzUTBGQlF5eHhRa0ZCY1VJc1EwRkJRenRKUVVOcVF5eERRVUZETzBsQlJVUTdPenM3T3p0UFFVMUhPMGxCUTBrc1MwRkJTeXhEUVVGRExHTkJRV01zUTBGQlF5eGxRVUZ4UWl4RlFVRkZMRXRCUVdFc1JVRkJSU3hyUWtGQk1FSTdVVUZEZUVZc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNkME5CUVhkRExFVkJRVVVzWlVGQlpTeEZRVUZGTEV0QlFVc3NSVUZCUlN4clFrRkJhMElzUTBGQlF5eERRVUZETzFGQlJYaEhMRTFCUVUwc1RVRkJUU3hIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1EwRkJRenRSUVVWeVJDeE5RVUZOTEVOQlFVTXNXVUZCV1N4SFFVRkhMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTTdVVUZGY0VRc1RVRkJUU3gzUWtGQmQwSXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4TlFVRk5MRVZCUVVVc1MwRkJTeXhGUVVGRkxHdENRVUZyUWl4RFFVRkRMRU5CUVVNN1VVRkRhRWNzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc2QwTkJRWGRETEVWQlFVVXNkMEpCUVhkQ0xFTkJRVU1zUTBGQlF6dFJRVU4wUml4TlFVRk5MRU5CUVVNc2QwSkJRWGRDTEVOQlFVTTdTVUZEY0VNc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hMUVVGTExFTkJRVU1zYVVKQlFXbENMRU5CUVVNc1pVRkJjVUk3VVVGRGFFUXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zTWtOQlFUSkRMRVZCUVVVc1pVRkJaU3hEUVVGRExFTkJRVU03VVVGRmFFWXNUVUZCVFN4TlFVRk5MRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEdWQlFXVXNRMEZCUXl4RFFVRkRPMUZCUlhKRUxFMUJRVTBzTkVKQlFUUkNMRWRCUVd0RE8xbEJRMmhGTEUxQlFVMHNSVUZCUlN4TlFVRk5MRU5CUVVNc1dVRkJXU3hEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRUUVVNMVJTeERRVUZETzFGQlJVWXNUVUZCVFN4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExIRkNRVUZ4UWl4RFFVRkRMRFJDUVVFMFFpeERRVUZETEVOQlFVTTdVVUZGTVVVc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNNa05CUVRKRExFVkJRVVVzVFVGQlRTeERRVUZETEVOQlFVTTdVVUZGZGtVc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dEpRVU5zUWl4RFFVRkRPMGxCUlVRN096czdPenM3TzA5QlVVYzdTVUZEU1N4TFFVRkxMRU5CUVVNc2MwSkJRWE5DTEVOQlFVTXNUMEZCWjBJc1JVRkJSU3hUUVVGeFFpeEZRVUZGTEVsQlFWa3NSVUZCUlN4VFFVRnJRanRSUVVONlJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhuUkVGQlowUXNSVUZCUlN4UFFVRlBMRVZCUVVVc1UwRkJVeXhGUVVGRkxFbEJRVWtzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0UlFVVjZSeXhOUVVGTkxGbEJRVmtzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUTBGQlF5eFBRVUZQTEVWQlFVVXNVMEZCVXl4RlFVRkZMRWxCUVVrc1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF6dFJRVU4wUml4RlFVRkZMRU5CUVVNc1EwRkJReXhaUVVGWkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRNVUlzVFVGQlRTeEpRVUZKTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc2MwSkJRWE5DTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNN1dVRkROMFFzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1owUkJRV2RFTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRNVVVzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0UlFVTm9RaXhEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEU2l4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eG5SRUZCWjBRc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU40UlN4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRE8xRkJRMlFzUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZGUkRzN096czdPenM3T3p0UFFWVkhPMGxCUTBrc1MwRkJTeXhEUVVGRExGbEJRVmtzUTBGQlF5eEpRVUZWTEVWQlFVVXNWVUZCYlVJc1JVRkJSU3hSUVVGcFFpeEZRVUZGTEZGQlFUQkNMRVZCUVVVc1pVRkJlVUk3VVVGREwwZ3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zYzBOQlFYTkRMRVZCUVVVc1NVRkJTU3hGUVVGRkxGVkJRVlVzUlVGQlJTeFJRVUZSTEVWQlFVVXNVVUZCVVN4RlFVRkZMR1ZCUVdVc1EwRkJReXhEUVVGRE8xRkJSV3BJTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RlFVRkZMRmRCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU51UXl4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5d3JRa0ZCSzBJc1EwRkJReXhEUVVGRE8xRkJRemRFTEVOQlFVTTdVVUZEUkN4SlFVRkpMR1ZCUVdVc1IwRkJSeXhWUVVGVkxFTkJRVU03VVVGRGFrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE0wTXNaVUZCWlN4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVONFFpeERRVUZETzFGQlJVUXNUVUZCVFN4VFFVRlRMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETEVsQlFVa3NSVUZCUlN4bFFVRmxMRVZCUVVVc1VVRkJVU3hGUVVGRkxFdEJRVXNzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXp0UlFVVTNSaXhOUVVGTkxFOUJRVThzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4dlFrRkJiMElzUTBGQlF5eFRRVUZUTEVWQlFVVXNaVUZCWlN4RFFVRkRMRU5CUVVNN1VVRkROVVVzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc2MwTkJRWE5ETEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkRia1VzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXp0SlFVTnVRaXhEUVVGRE8wbEJSVVE3T3pzN096czdUMEZQUnp0SlFVTkpMRXRCUVVzc1EwRkJReXhqUVVGakxFTkJRVU1zU1VGQlZTeEZRVUZGTEZWQlFXMUNMRVZCUVVVc1VVRkJhVUlzUlVGQlJTeFJRVUV3UWp0UlFVTjBSeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4M1EwRkJkME1zUlVGQlJTeEpRVUZKTEVWQlFVVXNWVUZCVlN4RlFVRkZMRkZCUVZFc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVVZzUnl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1JVRkJSU3hYUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYmtNc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNLMEpCUVN0Q0xFTkJRVU1zUTBGQlF6dFJRVU0zUkN4RFFVRkRPMUZCUTBRc1NVRkJTU3hsUVVGbExFZEJRVWNzVlVGQlZTeERRVUZETzFGQlEycERMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6TkRMR1ZCUVdVc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRGVFSXNRMEZCUXp0UlFVVkVMRTFCUVUwc1UwRkJVeXhIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEdGQlFXRXNRMEZCUXl4SlFVRkpMRVZCUVVVc1pVRkJaU3hGUVVGRkxGRkJRVkVzUlVGQlJTeExRVUZMTEVWQlFVVXNVVUZCVVN4SlFVRkpMR2xEUVVGbExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZGZGtnc1RVRkJUU3hQUVVGUExFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU1zVTBGQlV5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUldwRkxFMUJRVTBzVjBGQlZ5eEhRVUZuUWp0WlFVTTNRaXhoUVVGaExFVkJRVVVzVTBGQlV5eERRVUZETEVkQlFVY3NSVUZCUlR0WlFVTTVRaXhUUVVGVE8xbEJRMVFzVTBGQlV5eEZRVUZGTEU5QlFVODdXVUZEYkVJc1RVRkJUU3hGUVVGRkxFVkJRVVU3V1VGRFZpeFBRVUZQTEVWQlFVVXNRMEZCUXp0VFFVTmlMRU5CUVVNN1VVRkZSaXhOUVVGTkxHTkJRV01zUjBGQmQwSTdXVUZEZUVNc1UwRkJVeXhGUVVGRkxGZEJRVmNzUTBGQlF5eFRRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8xbEJRM1JGTEZOQlFWTXNSVUZCUlN4SFFVRkhPMU5CUTJwQ0xFTkJRVU03VVVGRlJpeE5RVUZOTEdWQlFXVXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zVjBGQlZ5eERRVUZETEdOQlFXTXNRMEZCUXl4RFFVRkRPMUZCUlRGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzWlVGQlpTeERRVUZETEZGQlFWRXNRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF6dFpRVU4yUkN4TlFVRk5MRTlCUVU4c1IwRkJSeXhSUVVGUkxFTkJRVU1zWlVGQlpTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU14UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRaQ3hYUVVGWExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4aFFVRkxMRU5CUVVNc1ZVRkJWU3hEUVVGRExGZEJRVmNzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1VVRkJVU3hKUVVGSkxHbERRVUZsTEVOQlFVTXNUVUZCVFN4RlFVRkZMR1ZCUVdVc1IwRkJSeXhEUVVGRExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRkRWtzVjBGQlZ5eERRVUZETEU5QlFVOHNTVUZCU1N4UFFVRlBMRU5CUVVNN1dVRkRia01zUTBGQlF6dFJRVU5NTEVOQlFVTTdVVUZGUkN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eDNRMEZCZDBNc1JVRkJSU3hYUVVGWExFTkJRVU1zUTBGQlF6dFJRVU42UlN4TlFVRk5MRU5CUVVNc1YwRkJWeXhEUVVGRE8wbEJRM1pDTEVOQlFVTTdTVUZGUkN4bFFVRmxPMGxCUTFBc1MwRkJTeXhEUVVGRExHOUNRVUZ2UWl4RFFVRkRMRk5CUVc5Q0xFVkJRVVVzWlVGQmQwSTdVVUZETjBVc1RVRkJUU3hyUWtGQmEwSXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXh6UWtGQmMwSXNRMEZCUXl4VFFVRlRMRVZCUVVVc1UwRkJVeXhGUVVGRkxGTkJRVk1zUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0UlFVVjZSeXd5UWtGQk1rSTdVVUZETTBJc1RVRkJUU3huUWtGQlowSXNSMEZCUnl4SlFVRkpMRWRCUVVjc1JVRkJWU3hEUVVGRE8xRkJRek5ETEUxQlFVMHNiVUpCUVcxQ0xFZEJRVWNzU1VGQlNTeEhRVUZITEVWQlFWVXNRMEZCUXp0UlFVVTVReXhyUWtGQmEwSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhYUVVGWExFVkJRVVVzUlVGQlJUdFpRVU4yUXl4NVFrRkJlVUk3V1VGRGVrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1YwRkJWeXhEUVVGRExGbEJRVmtzUTBGQlF5eFJRVUZSTEVWQlFVVXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU0xUXl4blFrRkJaMElzUTBGQlF5eEhRVUZITEVOQlFVTXNNa0pCUVZrc1EwRkJReXhsUVVGbExFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU14Uml4RFFVRkRPMWxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03WjBKQlEwb3NiVUpCUVcxQ0xFTkJRVU1zUjBGQlJ5eERRVUZETEZkQlFWY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTjBSU3hEUVVGRE8xRkJRMHdzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZGU0N4RlFVRkZMRU5CUVVNc1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4SlFVRkpMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU12UWl4TlFVRk5MSGxDUVVGNVFpeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMSE5DUVVGelFpeERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc2JVSkJRVzFDTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eFhRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMR1ZCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkZNMG9zZVVKQlFYbENMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zVjBGQlZ5eEZRVUZGTEVWQlFVVTdaMEpCUXpsRExFVkJRVVVzUTBGQlF5eERRVUZETEZkQlFWY3NRMEZCUXl4WlFVRlpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkROVU1zWjBKQlFXZENMRU5CUVVNc1IwRkJSeXhEUVVGRExESkNRVUZaTEVOQlFVTXNaVUZCWlN4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVVNN1owSkJRekZHTEVOQlFVTTdXVUZEVEN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOUUxFTkJRVU03VVVGRlJDeE5RVUZOTEZsQlFWa3NSMEZCWVN4RlFVRkZMRU5CUVVNN1VVRkRiRU1zVFVGQlRTeFhRVUZYTEVkQlFVY3NTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4RFFVRkRPMUZCUldwRUxHdEVRVUZyUkR0UlFVTnNSQ3hwUkVGQmFVUTdVVUZEYWtRc1NVRkJTU3haUVVGWkxFTkJRVU03VVVGRGFrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5zUWl4WlFVRlpMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1YwRkJWeXhEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRmRCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zWlVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU53U0N4RFFVRkRPMUZCUlVRc2MwUkJRWE5FTzFGQlEzUkVMRzlGUVVGdlJUdFJRVU53UlN4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRmRCUVZjc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXp0WlFVTXhReXhOUVVGTkxFMUJRVTBzUjBGQlZ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1YwRkJTU3hEUVVGRExGVkJRVlVzUTBGQlF5eGxRVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVVm9SeXhOUVVGTkxFTkJRVU1zWTBGQll5eEhRVUZITEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4VFFVRlRMRU5CUVVNN1dVRkRia1VzV1VGQldTeERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVNNVFpeERRVUZETzFGQlJVUXNORUpCUVRSQ08xRkJRelZDTEZsQlFWa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVTdXVUZEZGtJc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRaUVVNelJDeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEcxQ1FVRnRRaXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzFsQlF6TkVMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6bERMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVWdzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXp0SlFVTjRRaXhEUVVGRE8wbEJSVVFzWlVGQlpUdEpRVU5RTEdWQlFXVXNRMEZCUXl4SlFVRlZMRVZCUVVVc1MwRkJZU3hGUVVGRkxGRkJRWGxDTEVWQlFVVXNaVUZCZDBJN1VVRkRiRWNzVFVGQlRTeEhRVUZITEVkQlFVY3NVMEZCUnl4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFVkJRVVVzUzBGQlN5eEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRPMUZCUXpORExFMUJRVTBzVDBGQlR5eEhRVUZITEZOQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRGFrTXNUVUZCVFN4WlFVRlpMRWRCUVVjc1UwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTXhReXhKUVVGSkxHMUNRVUZ0UWl4SFFVRkhMR0ZCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU03VVVGRk9VVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5zUWl4dFFrRkJiVUlzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMR05CUVdNc1EwRkJReXhaUVVGWkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZWtVc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eHBRa0ZCVHl4RFFVRkRMRlZCUVZVc1EwRkJReXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEcxQ1FVRnRRaXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU4wUlN4RFFVRkRPMGxCUlVRc1pVRkJaVHRKUVVOUUxFdEJRVXNzUTBGQlF5eFpRVUZaTEVOQlFVTXNTVUZCVlN4RlFVRkZMRTFCUVdNc1JVRkJSU3hsUVVGblF5eEZRVUZGTEUxQlFXVXNSVUZETjBVc2VVSkJRWEZFTEVWQlFVVXNWVUZCYTBJc1JVRkJSU3hIUVVGUkxFVkJRVVVzVTBGQmEwSTdVVUZGT1Vnc1NVRkJTU3hyUWtGQmEwSXNSMEZCUnl4VlFVRlZMRU5CUVVNN1VVRkRjRU1zUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU03V1VGRGNrTXNUVUZCVFN4VFFVRlRMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRmxCUVZrc1JVRkJSU3hIUVVGSExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlJYUkZMRFJDUVVFMFFqdFpRVU0xUWl4TlFVRk5MRU5CUVVNc1pVRkJaU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVWQlFVVXNSMEZCUnl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8xbEJSV3hITEdkRFFVRm5RenRaUVVOb1F5dzRRMEZCT0VNN1dVRkRPVU1zUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzU1VGQlNTeHJRa0ZCYTBJc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF6RkRMRTFCUVUwc1UwRkJVeXhIUVVGSExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRWRCUVVjc2EwSkJRV3RDTEVOQlFVTTdaMEpCUlhwRUxESkZRVUV5UlR0blFrRkRNMFVzUlVGQlJTeERRVUZETEVOQlFVTXNVMEZCVXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMR1ZCUVdVc1EwRkJReXhKUVVGSkxESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMR1ZCUVdVc1EwRkJReXhuUWtGQlowSXNSVUZCUlN4cFFrRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTTFTQ3g1UWtGQmVVSTdiMEpCUTNwQ0xFMUJRVTBzUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXl4RlFVRkZMR1ZCUVdVc1EwRkJReXhuUWtGQlowSXNSVUZCUlN4VFFVRlRMRVZCUVVVc1IwRkJSeXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzI5Q1FVTjJSaXh2UTBGQmIwTTdiMEpCUTNCRExESkNRVUZaTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hOUVVGTkxFVkJRVVVzWlVGQlpTeEZRVUZGTEhsQ1FVRjVRaXhGUVVGRkxFMUJRVTBzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0blFrRkRla2NzUTBGQlF6dG5Ra0ZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVTBGQlV5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRM1pDTEVsQlFVa3NWVUZCVlN4SFFVRkhMRU5CUVVNc1EwRkJRenR2UWtGRGJrSXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4TlFVRk5MRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTTdkMEpCUTNKRExGVkJRVlVzUjBGQlJ5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN2IwSkJRekZFTEVOQlFVTTdiMEpCUlVRc1ZVRkJWU3hGUVVGRkxFTkJRVU03YjBKQlJXSXNUVUZCVFN4VFFVRlRMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zYjBKQlFXOUNMRU5CUVVNc1NVRkJTU3hGUVVGRkxGVkJRVlVzUlVGQlJTeExRVUZMTEVWQlFVVXNaVUZCWlN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8yOUNRVVZ5Unl4TlFVRk5MRVZCUVVVc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1dVRkJXU3hGUVVGRkxFZEJRVWNzU1VGQlNTeERRVUZETEVOQlFVTTdiMEpCUlM5RUxIbENRVUY1UWp0dlFrRkRla0lzVFVGQlRTeERRVUZETEdWQlFXVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1UwRkJVeXhEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1UwRkJVeXhGUVVGRkxFZEJRVWNzUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0dlFrRkZMMFVzYjBOQlFXOURPMjlDUVVOd1F5d3lRa0ZCV1N4RFFVRkRMRlZCUVZVc1EwRkJReXhKUVVGSkxFVkJRVVVzVFVGQlRTeEZRVUZGTEdWQlFXVXNSVUZCUlN4NVFrRkJlVUlzUlVGQlJTeE5RVUZOTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1owSkJRM3BITEVOQlFVTTdaMEpCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03YjBKQlEwb3NOa1JCUVRaRU8yOUNRVU0zUkN4NVFrRkJlVUk3YjBKQlEzcENMREpDUVVGWkxFTkJRVU1zVlVGQlZTeERRVUZETEVsQlFVa3NSVUZCUlN4TlFVRk5MRVZCUVVVc1pVRkJaU3hGUVVGRkxIbENRVUY1UWl4RlFVRkZMRTFCUVUwc1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF6dG5Ra0ZEZWtjc1EwRkJRenRaUVVOTUxFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0blFrRkRTaXhyUlVGQmEwVTdaMEpCUTJ4RkxIRkNRVUZ4UWp0blFrRkRja0lzYTBKQlFXdENMRWxCUVVrc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXp0WlFVTTFReXhEUVVGRE8xRkJRMHdzUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZGUkN4bFFVRmxPMGxCUTFBc1MwRkJTeXhEUVVGRExHdENRVUZyUWl4RFFVRkRMR2RDUVVGelFpeEZRVUZGTEdsQ1FVRjFRaXhGUVVGRkxGbEJRVEpDTEVWQlFVVXNhMEpCUVRCQ08xRkJRM0pKTEUxQlFVMHNhVUpCUVdsQ0xFZEJRVWNzUlVGQlJTeERRVUZETzFGQlJUZENMRWxCUVVrc2RVSkJRVFpDTEVOQlFVTTdVVUZEYkVNc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhaUVVGWkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNN1dVRkRNME1zYjBOQlFXOURPMWxCUTNCRExESkVRVUV5UkR0WlFVTXpSQ3d3UkVGQk1FUTdXVUZETVVRc05FSkJRVFJDTzFsQlF6VkNMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eHRRa0ZCYlVJc1IwRkJSeXg1UWtGQlZ5eERRVUZETEZWQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExGbEJRVmtzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZETDBZc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETERaQ1FVRTJRaXhIUVVGSExIbENRVUZYTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRekZGTEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXcyUWtGQk5rSXNSMEZCUnl4NVFrRkJWeXhEUVVGRExGVkJRVlVzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4RFFVRkRPMWxCUlRsSExHOUVRVUZ2UkR0WlFVTndSQ3h6UkVGQmMwUTdXVUZEZEVRc2RVUkJRWFZFTzFsQlJYWkVMRVZCUVVVc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMSFZDUVVGMVFpeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOb1JDd3dRMEZCTUVNN1owSkJRekZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RlFVRkZMRXRCUVVzc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZsQlFWa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlEyNUdMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEhkR1FVRjNSaXhEUVVGRExFTkJRVU03WjBKQlEzUklMRU5CUVVNN1owSkJRMFFzV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMR2RDUVVGblFpeEhRVUZITEdkQ1FVRm5RaXhEUVVGRE8yZENRVU53UkN4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zYVVKQlFXbENMRWRCUVVjc2FVSkJRV2xDTEVOQlFVTTdXVUZETVVRc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTktMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eG5Ra0ZCWjBJc1IwRkJSeXgxUWtGQmRVSXNRMEZCUXp0blFrRkRNMFFzV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMR2xDUVVGcFFpeEhRVUZITEdkQ1FVRm5RaXhEUVVGRE8xbEJRM3BFTEVOQlFVTTdXVUZGUkN4TlFVRk5MRk5CUVZNc1IwRkJSeXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNN1dVRkZOME1zVFVGQlRTeGpRVUZqTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFZEJRVWNzUTBGQlF5eG5Ra0ZCWjBJc1JVRkJSU3hwUWtGQmFVSXNSVUZCUlN4RFFVRkZMRk5CUVZNc1EwRkJSU3hGUVVGRkxHdENRVUZyUWl4RFFVRkRMRU5CUVVNN1dVRkZNMGdzV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1IwRkJSeXhUUVVGSExFTkJRVU1zVlVGQlZTeERRVUZETEdOQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zZVVKQlFWY3NRMEZCUXl4TlFVRk5MRWRCUVVjc1UwRkJSeXhEUVVGRExFMUJRVTBzUlVGQlJTeFRRVUZITEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVVelJ5eDNSMEZCZDBjN1dVRkRlRWNzVFVGQlRTeHBRa0ZCYVVJc1IwRkJSeXg1UWtGQlZ5eERRVUZETEZWQlFWVXNRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU53UlN4MVFrRkJkVUlzUjBGQlJ5d3lRa0ZCV1N4RFFVRkRMR1ZCUVdVc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4RFFVRkRPMWxCUlRGRkxHbENRVUZwUWl4RFFVRkRMRWxCUVVrc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4RFFVRkRPMUZCUXpsRExFTkJRVU03VVVGRFJDdzJSRUZCTmtRN1VVRkROMFFzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVONFJDeERRVUZET3p0QlFXeHVRMFFzWlVGQlpUdEJRVU5UTEd0RFFVRm5RaXhIUVVGWExFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1FVRkZia1VzWlVGQlpUdEJRVU5UTEhGRFFVRnRRaXhIUVVGWExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMEZCUldoR0xHVkJRV1U3UVVGRFV5dzBRa0ZCVlN4SFFVRlhMRWRCUVVjc1EwRkJRenRCUVZKeVJDdzRRMEZ2YmtOREluMD1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL3RyYW5zYWN0aW9ucy90cmFuc2FjdGlvbkNsaWVudC50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgbmV0d29ya0NsaWVudEZhY3RvcnlfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9mYWN0b3JpZXMvbmV0d29ya0NsaWVudEZhY3RvcnlcIik7XHJcbmNvbnN0IG5ldHdvcmtDbGllbnRfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsvbmV0d29ya0NsaWVudFwiKTtcclxuLyoqXHJcbiAqIFBsYXRmb3JtIGFic3RyYWN0aW9uIGxheWVyIGZvciBCcm93c2VyLlxyXG4gKi9cclxuY2xhc3MgUEFMIHtcclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybSBhbnkgaW5pdGlhbGl6YXRpb24gZm9yIHRoZSBQQUwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBpbml0aWFsaXplKCkge1xyXG4gICAgICAgIGlmICghUEFMLl9pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIFBBTC5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIG5ldHdvcmtDbGllbnRGYWN0b3J5XzEuTmV0d29ya0NsaWVudEZhY3RvcnkuaW5zdGFuY2UoKS5yZWdpc3RlcihcImRlZmF1bHRcIiwgKG5ldHdvcmtFbmRwb2ludCkgPT4gbmV3IG5ldHdvcmtDbGllbnRfMS5OZXR3b3JrQ2xpZW50KG5ldHdvcmtFbmRwb2ludCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbn1cclxuLyogQGludGVybmFsICovXHJcblBBTC5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG5leHBvcnRzLlBBTCA9IFBBTDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0dGc0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dmMzSmpMM0JoYkM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzT0VaQlFUSkdPMEZCUlROR0xESkVRVUYzUkR0QlFVVjRSRHM3UjBGRlJ6dEJRVU5JTzBsQlNVazdPMDlCUlVjN1NVRkRTU3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEZWQlFWVTdVVUZETVVJc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNZMEZCWXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMFFpeEhRVUZITEVOQlFVTXNZMEZCWXl4SFFVRkhMRWxCUVVrc1EwRkJRenRaUVVNeFFpd3lRMEZCYjBJc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVOQlFVTXNVMEZCVXl4RlFVRkZMRU5CUVVNc1pVRkJhVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNTVUZCU1N3MlFrRkJZU3hEUVVGRExHVkJRV1VzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYmtrc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNN1NVRkROMElzUTBGQlF6czdRVUZpUkN4bFFVRmxPMEZCUTBFc2EwSkJRV01zUjBGQldTeExRVUZMTEVOQlFVTTdRVUZHYmtRc2EwSkJaVU1pZlE9PVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zcmMvcGFsLnRzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW90YS1waWNvLXBhbC1icm93c2VyL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW90YS1waWNvLXBhbC1icm93c2VyL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgYXJyYXlIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyXCIpO1xyXG5jb25zdCBudW1iZXJIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlclwiKTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IHN0cmluZ0hlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvc3RyaW5nSGVscGVyXCIpO1xyXG5jb25zdCBjcnlwdG9FcnJvcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvZXJyb3IvY3J5cHRvRXJyb3JcIik7XHJcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2hhc2hcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJ5dGVzXCIpO1xyXG4vKipcclxuICogUHJvb2ZPZldvcmsgaW1wbGVtZW50YXRpb24gdXNpbmcgUmVtb3RlIFBvd0JveC5cclxuICovXHJcbmNsYXNzIFByb29mT2ZXb3JrQm94IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFByb29mT2ZXb3JrLlxyXG4gICAgICogQHBhcmFtIG5ldHdvcmtDbGllbnQgVGhlIG5ldHdvcmsgY2xpZW50IHRvIGNvbW11bmljYXRlIHRocm91Z2guXHJcbiAgICAgKiBAcGFyYW0gYXBpS2V5IFRoZSBBUEkga2V5IHRvIGFjY2VzcyB0aGUgcG93IGJveC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmV0d29ya0NsaWVudCwgYXBpS2V5LCBwb2xsSW50ZXJ2YWxNcyA9IDEwMDApIHtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkobmV0d29ya0NsaWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgbmV0d29ya0NsaWVudCBtdXN0IGJlIGRlZmluZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNFbXB0eShhcGlLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIGFwaUtleSBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHBvbGxJbnRlcnZhbE1zKSB8fCBwb2xsSW50ZXJ2YWxNcyA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHBvbGxJbnRlcnZhbE1zIG11c3QgYmUgPiAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9uZXR3b3JrQ2xpZW50ID0gbmV0d29ya0NsaWVudDtcclxuICAgICAgICB0aGlzLl9hcGlLZXkgPSBhcGlLZXk7XHJcbiAgICAgICAgdGhpcy5fcG9sbEludGVydmFsTXMgPSBwb2xsSW50ZXJ2YWxNcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb3cgdGhlIHByb29mIG9mIHdvcmsgdG8gcGVyZm9ybSBhbnkgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKiBXaWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgaW1wbGVtZW50YXRpb24gaXMgbm90IHN1cHBvcnRlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIHNpbmdsZSBjb252ZXJzaW9uIHBlciBwb3cgY2FsbC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgcG93IG9ubHkgZG9lcyBvbmUgY29udmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgcGVyZm9ybXNTaW5nbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtIGEgcHJvb2Ygb2Ygd29yayBvbiB0aGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSB0cnVua1RyYW5zYWN0aW9uIFRoZSB0cnVua1RyYW5zYWN0aW9uIHRvIHVzZSBmb3IgdGhlIHBvdy5cclxuICAgICAqIEBwYXJhbSBicmFuY2hUcmFuc2FjdGlvbiBUaGUgYnJhbmNoVHJhbnNhY3Rpb24gdG8gdXNlIGZvciB0aGUgcG93LlxyXG4gICAgICogQHBhcmFtIHRyeXRlcyBUaGUgdHJ5dGVzIHRvIHBlcmZvcm0gdGhlIHBvdyBvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgcHJvZHVjZWQgYnkgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHBvdyh0cnVua1RyYW5zYWN0aW9uLCBicmFuY2hUcmFuc2FjdGlvbiwgdHJ5dGVzLCBtaW5XZWlnaHRNYWduaXR1ZGUpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJ1bmtUcmFuc2FjdGlvbiwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHRydW5rVHJhbnNhY3Rpb24gbXVzdCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoYnJhbmNoVHJhbnNhY3Rpb24sIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBicmFuY2hUcmFuc2FjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyeXRlcywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSB0cnl0ZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIFRyeXRlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG1pbldlaWdodE1hZ25pdHVkZSkgfHwgbWluV2VpZ2h0TWFnbml0dWRlIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgbWluV2VpZ2h0TWFnbml0dWRlIG11c3QgYmUgPiAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhdHRhY2hUb1RhbmdsZVJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIGNvbW1hbmQ6IFwiYXR0YWNoVG9UYW5nbGVcIixcclxuICAgICAgICAgICAgdHJ1bmtUcmFuc2FjdGlvbjogdHJ1bmtUcmFuc2FjdGlvbi50b1RyeXRlcygpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIGJyYW5jaFRyYW5zYWN0aW9uOiBicmFuY2hUcmFuc2FjdGlvbi50b1RyeXRlcygpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIG1pbldlaWdodE1hZ25pdHVkZSxcclxuICAgICAgICAgICAgdHJ5dGVzOiB0cnl0ZXMubWFwKHQgPT4gdC50b1N0cmluZygpKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbEhlYWRlcnMgPSB7IEF1dGhvcml6YXRpb246IHRoaXMuX2FwaUtleSB9O1xyXG4gICAgICAgIGNvbnN0IGF0dGFjaFRvVGFuZ2xlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9uZXR3b3JrQ2xpZW50LnBvc3RKc29uKGF0dGFjaFRvVGFuZ2xlUmVxdWVzdCwgXCJjb21tYW5kc1wiLCBhZGRpdGlvbmFsSGVhZGVycyk7XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KGF0dGFjaFRvVGFuZ2xlUmVzcG9uc2UpIHx8IHN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KGF0dGFjaFRvVGFuZ2xlUmVzcG9uc2Uuam9iSWQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIGF0dGFjaFRvVGFuZ2xlUmVxdWVzdCBkaWQgbm90IHJldHVybiBhIGpvYklkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FpdEZvckpvYkNvbXBsZXRpb24oYXR0YWNoVG9UYW5nbGVSZXNwb25zZS5qb2JJZCwgdHJ5dGVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGFzeW5jIHdhaXRGb3JKb2JDb21wbGV0aW9uKGpvYklkLCBzb3VyY2VUcnl0ZXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBqb2JSZXNwb25zZSA9IGF3YWl0IHRoaXMuX25ldHdvcmtDbGllbnQuZ2V0SnNvbihgam9icy8ke2pvYklkfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqb2JSZXNwb25zZS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3Ioam9iUmVzcG9uc2UuZXJyb3JNZXNzYWdlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpvYlJlc3BvbnNlLnByb2dyZXNzID09PSBcIjEwMFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqb2JSZXNwb25zZSAmJiBqb2JSZXNwb25zZS5yZXNwb25zZSAmJiBqb2JSZXNwb25zZS5yZXNwb25zZS50cnl0ZXMgJiYgam9iUmVzcG9uc2UucmVzcG9uc2UudHJ5dGVzLmxlbmd0aCA9PT0gc291cmNlVHJ5dGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShqb2JSZXNwb25zZS5yZXNwb25zZS50cnl0ZXMubWFwKHQgPT4gdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSByZXNwb25zZSBkaWQgbm90IGNvbnRhaW4gZW5vdWdoIHRyeXRlc1wiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcy5fcG9sbEludGVydmFsTXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUHJvb2ZPZldvcmtCb3ggPSBQcm9vZk9mV29ya0JveDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0hKdmIyWlBabGR2Y210Q2IzZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOXpjbU12Y0hKdmIyWlBabGR2Y210Q2IzZ3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQkxEQkZRVUYxUlR0QlFVTjJSU3cwUlVGQmVVVTdRVUZEZWtVc05FVkJRWGxGTzBGQlEzcEZMRFJGUVVGNVJUdEJRVVY2UlN3d1JVRkJkVVU3UVVGRmRrVXNlVVJCUVhORU8wRkJRM1JFTERaRVFVRXdSRHRCUVVzeFJEczdSMEZGUnp0QlFVTklPMGxCVVVrN096czdUMEZKUnp0SlFVTklMRmxCUVZrc1lVRkJOa0lzUlVGQlJTeE5RVUZqTEVWQlFVVXNhVUpCUVhsQ0xFbEJRVWs3VVVGRGNFWXNSVUZCUlN4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM1JETEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExHMURRVUZ0UXl4RFFVRkRMRU5CUVVNN1VVRkRMMFFzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNdlFpeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXc0UWtGQk9FSXNRMEZCUXl4RFFVRkRPMUZCUXpGRUxFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEdOQlFXTXNRMEZCUXl4SlFVRkpMR05CUVdNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEycEZMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEdkRFFVRm5ReXhEUVVGRExFTkJRVU03VVVGRE5VUXNRMEZCUXp0UlFVTkVMRWxCUVVrc1EwRkJReXhqUVVGakxFZEJRVWNzWVVGQllTeERRVUZETzFGQlEzQkRMRWxCUVVrc1EwRkJReXhQUVVGUExFZEJRVWNzVFVGQlRTeERRVUZETzFGQlEzUkNMRWxCUVVrc1EwRkJReXhsUVVGbExFZEJRVWNzWTBGQll5eERRVUZETzBsQlF6RkRMRU5CUVVNN1NVRkZSRHM3TzA5QlIwYzdTVUZEU1N4TFFVRkxMRU5CUVVNc1ZVRkJWVHRSUVVOdVFpeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRE8wbEJRemRDTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeGpRVUZqTzFGQlEycENMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03U1VGRGFrSXNRMEZCUXp0SlFVVkVPenM3T3pzN08wOUJUMGM3U1VGRFNTeExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRMR2RDUVVGelFpeEZRVUZGTEdsQ1FVRjFRaXhGUVVGRkxFMUJRV2RDTEVWQlFVVXNhMEpCUVRCQ08xRkJRekZITEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNaMEpCUVdkQ0xFVkJRVVVzVjBGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXk5RExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMSEZFUVVGeFJDeERRVUZETEVOQlFVTTdVVUZEYWtZc1EwRkJRenRSUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zYVVKQlFXbENMRVZCUVVVc1YwRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyaEVMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEhORVFVRnpSQ3hEUVVGRExFTkJRVU03VVVGRGJFWXNRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zZVVKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRkxHVkJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjJReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl3MFEwRkJORU1zUTBGQlF5eERRVUZETzFGQlEzaEZMRU5CUVVNN1VVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1UwRkJVeXhEUVVGRExHdENRVUZyUWl4RFFVRkRMRWxCUVVrc2EwSkJRV3RDTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONlJTeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXh2UTBGQmIwTXNRMEZCUXl4RFFVRkRPMUZCUTJoRkxFTkJRVU03VVVGRlJDeE5RVUZOTEhGQ1FVRnhRaXhIUVVFeVFqdFpRVU5zUkN4UFFVRlBMRVZCUVVVc1owSkJRV2RDTzFsQlEzcENMR2RDUVVGblFpeEZRVUZGTEdkQ1FVRm5RaXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlR0WlFVTjRSQ3hwUWtGQmFVSXNSVUZCUlN4cFFrRkJhVUlzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVN1dVRkRNVVFzYTBKQlFXdENPMWxCUTJ4Q0xFMUJRVTBzUlVGQlJTeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMU5CUTNoRExFTkJRVU03VVVGRlJpeE5RVUZOTEdsQ1FVRnBRaXhIUVVGSExFVkJRVVVzWVVGQllTeEZRVUZGTEVsQlFVa3NRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJRenRSUVVVeFJDeE5RVUZOTEhOQ1FVRnpRaXhIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4UlFVRlJMRU5CUVd0RUxIRkNRVUZ4UWl4RlFVRkZMRlZCUVZVc1JVRkJSU3hwUWtGQmFVSXNRMEZCUXl4RFFVRkRPMUZCUlhwTExFVkJRVVVzUTBGQlF5eERRVUZETERKQ1FVRlpMRU5CUVVNc1QwRkJUeXhEUVVGRExITkNRVUZ6UWl4RFFVRkRMRWxCUVVrc01rSkJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNjMEpCUVhOQ0xFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNKSExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMR3RFUVVGclJDeERRVUZETEVOQlFVTTdVVUZET1VVc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEwb3NUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXh2UWtGQmIwSXNRMEZCUXl4elFrRkJjMElzUTBGQlF5eExRVUZMTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRNMFVzUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZGUkN4bFFVRmxPMGxCUTFBc1MwRkJTeXhEUVVGRExHOUNRVUZ2UWl4RFFVRkRMRXRCUVdFc1JVRkJSU3haUVVGelFqdFJRVU53UlN4TlFVRk5MRU5CUVVNc1NVRkJTU3hQUVVGUExFTkJRVmNzUTBGQlF5eFBRVUZQTEVWQlFVVXNUVUZCVFN4RlFVRkZMRVZCUVVVN1dVRkROME1zVFVGQlRTeFZRVUZWTEVkQlFVY3NWMEZCVnl4RFFVRkRMRXRCUVVzc1NVRkJTU3hGUVVGRk8yZENRVU4wUXl4SlFVRkpMRU5CUVVNN2IwSkJRMFFzVFVGQlRTeFhRVUZYTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExFOUJRVThzUTBGQlpTeFJRVUZSTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN2IwSkJRM0pHTEVWQlFVVXNRMEZCUXl4RFFVRkRMRmRCUVZjc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzNkQ1FVTndRaXhoUVVGaExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTTdkMEpCUXpGQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEhsQ1FVRlhMRU5CUVVNc1YwRkJWeXhEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTNSRUxFTkJRVU03YjBKQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExGZEJRVmNzUTBGQlF5eFJRVUZSTEV0QlFVc3NTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenQzUWtGRGVFTXNZVUZCWVN4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRE8zZENRVU14UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhYUVVGWExFbEJRVWtzVjBGQlZ5eERRVUZETEZGQlFWRXNTVUZCU1N4WFFVRlhMRU5CUVVNc1VVRkJVU3hEUVVGRExFMUJRVTBzU1VGQlNTeFhRVUZYTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFdEJRVXNzV1VGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN05FSkJRMjVKTEU5QlFVOHNRMEZCUXl4WFFVRlhMRU5CUVVNc1VVRkJVU3hEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenQzUWtGRGVFVXNRMEZCUXp0M1FrRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6czBRa0ZEU2l4TlFVRk5MRU5CUVVNc1NVRkJTU3g1UWtGQlZ5eERRVUZETERSRFFVRTBReXhEUVVGRExFTkJRVU1zUTBGQlF6dDNRa0ZETVVVc1EwRkJRenR2UWtGRFRDeERRVUZETzJkQ1FVTk1MRU5CUVVNN1owSkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRFdDeGhRVUZoTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNN2IwSkJRekZDTEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRuUWtGRGFFSXNRMEZCUXp0WlFVTk1MRU5CUVVNc1JVRkRPRUlzU1VGQlNTeERRVUZETEdWQlFXVXNRMEZCUXl4RFFVRkRPMUZCUTNwRUxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlExQXNRMEZCUXp0RFFVTktPMEZCT1VkRUxIZERRVGhIUXlKOVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zcmMvcHJvb2ZPZldvcmtCb3gudHMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW90YS1waWNvLXBvdy1ib3gvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pb3RhLXBpY28tcG93LWJveC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lvdGEtcGljby1wb3ctYm94L25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgYXJyYXlIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyXCIpO1xyXG5jb25zdCBudW1iZXJIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlclwiKTtcclxuY29uc3QgY3J5cHRvRXJyb3JfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NyeXB0by9kaXN0L2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlc1wiKTtcclxuY29uc3QgcGVhcmxEaXZlcl8xID0gcmVxdWlyZShcIi4vcGVhcmxEaXZlci9wZWFybERpdmVyXCIpO1xyXG4vKipcclxuICogUHJvb2ZPZldvcmsgaW1wbGVtZW50YXRpb24gdXNpbmcgSmF2YVNjcmlwdC5cclxuICovXHJcbmNsYXNzIFByb29mT2ZXb3JrSnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvdyB0aGUgcHJvb2Ygb2Ygd29yayB0byBwZXJmb3JtIGFueSBpbml0aWFsaXphdGlvbi5cclxuICAgICAqIFdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBpbml0aWFsaXplKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgc2luZ2xlIGNvbnZlcnNpb24gcGVyIHBvdyBjYWxsLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBwb3cgb25seSBkb2VzIG9uZSBjb252ZXJzaW9uLlxyXG4gICAgICovXHJcbiAgICBwZXJmb3Jtc1NpbmdsZSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybSBhIHByb29mIG9mIHdvcmsgb24gdGhlIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0gdHJ1bmtUcmFuc2FjdGlvbiBUaGUgdHJ1bmtUcmFuc2FjdGlvbiB0byB1c2UgZm9yIHRoZSBwb3cuXHJcbiAgICAgKiBAcGFyYW0gYnJhbmNoVHJhbnNhY3Rpb24gVGhlIGJyYW5jaFRyYW5zYWN0aW9uIHRvIHVzZSBmb3IgdGhlIHBvdy5cclxuICAgICAqIEBwYXJhbSB0cnl0ZXMgVGhlIHRyeXRlcyB0byBwZXJmb3JtIHRoZSBwb3cgb24uXHJcbiAgICAgKiBAcGFyYW0gbWluV2VpZ2h0TWFnbml0dWRlIFRoZSBtaW5pbXVtIHdlaWdodCBtYWduaXR1ZGUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJ5dGVzIHByb2R1Y2VkIGJ5IHRoZSBwcm9vZiBvZiB3b3JrLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBwb3codHJ1bmtUcmFuc2FjdGlvbiwgYnJhbmNoVHJhbnNhY3Rpb24sIHRyeXRlcywgbWluV2VpZ2h0TWFnbml0dWRlKSB7XHJcbiAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQodHJ5dGVzLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHRyeXRlcyBtdXN0IGJlIGFuIGFycmF5IG9mIHR5cGUgVHJ5dGVzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobWluV2VpZ2h0TWFnbml0dWRlKSB8fCBtaW5XZWlnaHRNYWduaXR1ZGUgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBtaW5XZWlnaHRNYWduaXR1ZGUgbXVzdCBiZSA+IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5vbmNlID0gbmV3IHBlYXJsRGl2ZXJfMS5QZWFybERpdmVyKCkuc2VhcmNoV2l0aFRyeXRlcyh0cnl0ZXNbMF0sIG1pbldlaWdodE1hZ25pdHVkZSk7XHJcbiAgICAgICAgY29uc3Qgbm9uY2VTdHJpbmcgPSBub25jZS50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IHRyeXRlc1N0cmluZyA9IHRyeXRlcy50b1N0cmluZygpO1xyXG4gICAgICAgIHJldHVybiBbdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodHJ5dGVzU3RyaW5nLnN1YnN0cigwLCB0cnl0ZXNTdHJpbmcubGVuZ3RoIC0gbm9uY2VTdHJpbmcubGVuZ3RoKSArIG5vbmNlU3RyaW5nKV07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Qcm9vZk9mV29ya0pzID0gUHJvb2ZPZldvcmtKcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0hKdmIyWlBabGR2Y210S2N5NXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUwzTnlZeTl3Y205dlprOW1WMjl5YTBwekxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVN3d1JVRkJkVVU3UVVGRGRrVXNORVZCUVhsRk8wRkJRM3BGTERCRlFVRjFSVHRCUVVkMlJTdzJSRUZCTUVRN1FVRkRNVVFzZDBSQlFYRkVPMEZCUlhKRU96dEhRVVZITzBGQlEwZzdTVUZEU1RzN08wOUJSMGM3U1VGRFNTeExRVUZMTEVOQlFVTXNWVUZCVlR0UlFVTnVRaXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRPMGxCUXpkQ0xFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hqUVVGak8xRkJRMnBDTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRhRUlzUTBGQlF6dEpRVVZFT3pzN096czdPMDlCVDBjN1NVRkRTU3hMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEdkQ1FVRnpRaXhGUVVGRkxHbENRVUYxUWl4RlFVRkZMRTFCUVdkQ0xFVkJRVVVzYTBKQlFUQkNPMUZCUXpGSExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeEZRVUZGTEdWQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMlF5eE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXcwUTBGQk5FTXNRMEZCUXl4RFFVRkRPMUZCUTNoRkxFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEd0Q1FVRnJRaXhEUVVGRExFbEJRVWtzYTBKQlFXdENMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU42UlN4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eHZRMEZCYjBNc1EwRkJReXhEUVVGRE8xRkJRMmhGTEVOQlFVTTdVVUZEUkN4TlFVRk5MRXRCUVVzc1IwRkJSeXhKUVVGSkxIVkNRVUZWTEVWQlFVVXNRMEZCUXl4blFrRkJaMElzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc2EwSkJRV3RDTEVOQlFVTXNRMEZCUXp0UlFVTXZSU3hOUVVGTkxGZEJRVmNzUjBGQlZ5eExRVUZMTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNN1VVRkROME1zVFVGQlRTeFpRVUZaTEVkQlFWY3NUVUZCVFN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8xRkJReTlETEUxQlFVMHNRMEZCUXl4RFFVRkZMR1ZCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zV1VGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRVZCUVVVc1dVRkJXU3hEUVVGRExFMUJRVTBzUjBGQlJ5eFhRVUZYTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1YwRkJWeXhEUVVGRExFTkJRVVVzUTBGQlF6dEpRVU5xU0N4RFFVRkRPME5CUTBvN1FVRnlRMFFzYzBOQmNVTkRJbjA9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL3NyYy9wcm9vZk9mV29ya0pzLnRzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lvdGEtcGljby1wb3ctanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pb3RhLXBpY28tcG93LWpzL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW90YS1waWNvLXBvdy1qcy9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IHNwb25nZUZhY3RvcnlfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NyeXB0by9kaXN0L2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5XCIpO1xyXG5jb25zdCB0cml0c18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJpdHNcIik7XHJcbmNvbnN0IGFkZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFkZXJzL2FkZFwiKSk7XHJcbmNvbnN0IGNoZWNrQ29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYWRlcnMvY2hlY2tDb2xcIikpO1xyXG5jb25zdCBjaGVja0RvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYWRlcnMvY2hlY2tEb1wiKSk7XHJcbmNvbnN0IGNoZWNrS18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFkZXJzL2NoZWNrS1wiKSk7XHJcbmNvbnN0IGZpbmFsaXplXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYWRlcnMvZmluYWxpemVcIikpO1xyXG5jb25zdCBoZWFkZXJzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYWRlcnMvaGVhZGVyc1wiKSk7XHJcbmNvbnN0IGluY3JlbWVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFkZXJzL2luY3JlbWVudFwiKSk7XHJcbmNvbnN0IGluaXRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhZGVycy9pbml0XCIpKTtcclxuY29uc3QgdHJhbnNmb3JtXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYWRlcnMvdHJhbnNmb3JtXCIpKTtcclxuY29uc3Qgd2ViR0xXb3JrZXJfMSA9IHJlcXVpcmUoXCIuLi93ZWJHTC93ZWJHTFdvcmtlclwiKTtcclxuY29uc3QgcGVhcmxEaXZlclN0YXRlXzEgPSByZXF1aXJlKFwiLi9wZWFybERpdmVyU3RhdGVcIik7XHJcbi8qKlxyXG4gKiBQZWFybERpdmVyLlxyXG4gKiBDb252ZXJ0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaW90YWxlZGdlci9jdXJsLmxpYi5qcy9ibG9iL21hc3Rlci9zcmMvcGVhcmxkaXZlci5qc1xyXG4gKi9cclxuY2xhc3MgUGVhcmxEaXZlciB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHdlYkdMUGxhdGZvcm0pIHtcclxuICAgICAgICB0aGlzLl93ZWJHTFdvcmtlciA9IG5ldyB3ZWJHTFdvcmtlcl8xLldlYkdMV29ya2VyKCk7XHJcbiAgICAgICAgY29uc3QgY3VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFwiY3VybFwiKTtcclxuICAgICAgICB0aGlzLl9oYXNoTGVuZ3RoID0gY3VybC5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlTGVuZ3RoID0gY3VybC5nZXRDb25zdGFudChcIlNUQVRFX0xFTkdUSFwiKTtcclxuICAgICAgICB0aGlzLl9udW1iZXJSb3VuZHMgPSBjdXJsLmdldENvbnN0YW50KFwiTlVNQkVSX09GX1JPVU5EU1wiKTtcclxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbkxlbmd0aCA9IHRoaXMuX2hhc2hMZW5ndGggKiAzMztcclxuICAgICAgICB0aGlzLl9ub25jZUxlbmd0aCA9IHRoaXMuX2hhc2hMZW5ndGggLyAzO1xyXG4gICAgICAgIHRoaXMuX25vbmNlU3RhcnQgPSB0aGlzLl9oYXNoTGVuZ3RoIC0gdGhpcy5fbm9uY2VMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fd2ViR0xXb3JrZXIuaW5pdGlhbGl6ZSh3ZWJHTFBsYXRmb3JtLCB0aGlzLl9zdGF0ZUxlbmd0aCArIDEsIFBlYXJsRGl2ZXIuVEVYRUxfU0laRSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJ1ZmZlciA9IHRoaXMuX3dlYkdMV29ya2VyLmdldElwdCgpLmRhdGE7XHJcbiAgICAgICAgdGhpcy5fd2ViR0xXb3JrZXIuYWRkUHJvZ3JhbShcImluaXRcIiwgaGVhZGVyc18xLmRlZmF1bHQgKyBhZGRfMS5kZWZhdWx0ICsgaW5pdF8xLmRlZmF1bHQsIFwiZ3Jfb2Zmc2V0XCIpO1xyXG4gICAgICAgIHRoaXMuX3dlYkdMV29ya2VyLmFkZFByb2dyYW0oXCJpbmNyZW1lbnRcIiwgaGVhZGVyc18xLmRlZmF1bHQgKyBhZGRfMS5kZWZhdWx0ICsgaW5jcmVtZW50XzEuZGVmYXVsdCk7XHJcbiAgICAgICAgdGhpcy5fd2ViR0xXb3JrZXIuYWRkUHJvZ3JhbShcInR3aXN0XCIsIGhlYWRlcnNfMS5kZWZhdWx0ICsgdHJhbnNmb3JtXzEuZGVmYXVsdCk7XHJcbiAgICAgICAgdGhpcy5fd2ViR0xXb3JrZXIuYWRkUHJvZ3JhbShcImNoZWNrXCIsIGhlYWRlcnNfMS5kZWZhdWx0ICsgY2hlY2tEb18xLmRlZmF1bHQgKyBjaGVja0tfMS5kZWZhdWx0LCBcIm1pbldlaWdodE1hZ25pdHVkZVwiKTtcclxuICAgICAgICB0aGlzLl93ZWJHTFdvcmtlci5hZGRQcm9ncmFtKFwiY29sX2NoZWNrXCIsIGhlYWRlcnNfMS5kZWZhdWx0ICsgY2hlY2tDb2xfMS5kZWZhdWx0KTtcclxuICAgICAgICB0aGlzLl93ZWJHTFdvcmtlci5hZGRQcm9ncmFtKFwiZmluYWxpemVcIiwgaGVhZGVyc18xLmRlZmF1bHQgKyBjaGVja0RvXzEuZGVmYXVsdCArIGZpbmFsaXplXzEuZGVmYXVsdCk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBwZWFybERpdmVyU3RhdGVfMS5QZWFybERpdmVyU3RhdGUucmVhZHk7XHJcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgUGVhcmxEaXZlciBtYWluIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW5pdGlhbGl6ZSh3ZWJHTFBsYXRmb3JtKSB7XHJcbiAgICAgICAgaWYgKCFQZWFybERpdmVyLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIFBlYXJsRGl2ZXIuaW5zdGFuY2UgPSBuZXcgUGVhcmxEaXZlcih3ZWJHTFBsYXRmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsb3NlZG93biB0aGUgUGVhcmxEaXZlciBtYWluIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2xvc2Vkb3duKCkge1xyXG4gICAgICAgIGlmIChQZWFybERpdmVyLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIFBlYXJsRGl2ZXIuaW5zdGFuY2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtIGEgc2VhcmNoIHVzaW5nIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSB0cnl0ZXMgVGhlIHRyeXRlcyB0byBwZXJmb3JtIHRoZSBzZWFyY2ggb24uXHJcbiAgICAgKiBAcGFyYW0gbWluV2VpZ2h0TWFnbml0dWRlIFRoZSBtaW5pbXVtIHdlaWdodCBtYWduaXR1ZGUuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSB0cnl0ZXMgZnJvbSB0aGUgc2VhcmNoLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzZWFyY2hXaXRoVHJ5dGVzKHRyeXRlcywgbWluV2VpZ2h0TWFnbml0dWRlKSB7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoU3RhdGVzID0gdGhpcy5wcmVwYXJlKHRyeXRlcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoKHNlYXJjaFN0YXRlcywgbWluV2VpZ2h0TWFnbml0dWRlKTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgcHJlcGFyZSh0cmFuc2FjdGlvblRyeXRlcykge1xyXG4gICAgICAgIGNvbnN0IGN1cmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcImN1cmxcIik7XHJcbiAgICAgICAgY3VybC5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25Ucml0cyA9IHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyh0cmFuc2FjdGlvblRyeXRlcykudG9BcnJheSgpO1xyXG4gICAgICAgIGN1cmwuYWJzb3JiKHRyYW5zYWN0aW9uVHJpdHMsIDAsIHRoaXMuX3RyYW5zYWN0aW9uTGVuZ3RoIC0gdGhpcy5faGFzaExlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgY3VybFN0YXRlID0gY3VybC5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uVHJpdHNcclxuICAgICAgICAgICAgLnNsaWNlKHRoaXMuX3RyYW5zYWN0aW9uTGVuZ3RoIC0gdGhpcy5faGFzaExlbmd0aCwgdGhpcy5fdHJhbnNhY3Rpb25MZW5ndGgpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY3VybFN0YXRlW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaFRvUGFpcihjdXJsU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBhc3luYyBzZWFyY2goc3RhdGVzLCBtaW5XZWlnaHQpIHtcclxuICAgICAgICAvLyBwcm9taXNlIHdpbGwgY29tcGxldGUgd2hlbiB0aGUgc2VhcmNoIGhhcyBjb21wbGV0ZWRcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cHJvbWlzZS1tdXN0LWNvbXBsZXRlXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZXM6IHN0YXRlcyxcclxuICAgICAgICAgICAgICAgIG1pbldlaWdodE1hZ25pdHVkZTogbWluV2VpZ2h0LFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IHJlc29sdmVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gcGVhcmxEaXZlclN0YXRlXzEuUGVhcmxEaXZlclN0YXRlLnJlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaERvTmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIHNlYXJjaFRvUGFpcihzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IHtcclxuICAgICAgICAgICAgbG93OiBuZXcgSW50MzJBcnJheSh0aGlzLl9zdGF0ZUxlbmd0aCksXHJcbiAgICAgICAgICAgIGhpZ2g6IG5ldyBJbnQzMkFycmF5KHRoaXMuX3N0YXRlTGVuZ3RoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc3RhdGUuZm9yRWFjaCgodHJpdCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgc3dpdGNoICh0cml0KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVzLmxvd1tpbmRleF0gPSBQZWFybERpdmVyLkhJR0hfQklUUztcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMuaGlnaFtpbmRleF0gPSBQZWFybERpdmVyLkhJR0hfQklUUztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMubG93W2luZGV4XSA9IFBlYXJsRGl2ZXIuTE9XX0JJVFM7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVzLmhpZ2hbaW5kZXhdID0gUGVhcmxEaXZlci5ISUdIX0JJVFM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcy5sb3dbaW5kZXhdID0gUGVhcmxEaXZlci5ISUdIX0JJVFM7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVzLmhpZ2hbaW5kZXhdID0gUGVhcmxEaXZlci5MT1dfQklUUztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2VhcmNoT2Zmc2V0KHN0YXRlcywgdGhpcy5fbm9uY2VTdGFydCk7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlcztcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgc2VhcmNoT2Zmc2V0KHN0YXRlcywgb2Zmc2V0KSB7XHJcbiAgICAgICAgc3RhdGVzLmxvd1tvZmZzZXQgKyAwXSA9IFBlYXJsRGl2ZXIuTE9XXzA7XHJcbiAgICAgICAgc3RhdGVzLmxvd1tvZmZzZXQgKyAxXSA9IFBlYXJsRGl2ZXIuTE9XXzE7XHJcbiAgICAgICAgc3RhdGVzLmxvd1tvZmZzZXQgKyAyXSA9IFBlYXJsRGl2ZXIuTE9XXzI7XHJcbiAgICAgICAgc3RhdGVzLmxvd1tvZmZzZXQgKyAzXSA9IFBlYXJsRGl2ZXIuTE9XXzM7XHJcbiAgICAgICAgc3RhdGVzLmhpZ2hbb2Zmc2V0ICsgMF0gPSBQZWFybERpdmVyLkhJR0hfMDtcclxuICAgICAgICBzdGF0ZXMuaGlnaFtvZmZzZXQgKyAxXSA9IFBlYXJsRGl2ZXIuSElHSF8xO1xyXG4gICAgICAgIHN0YXRlcy5oaWdoW29mZnNldCArIDJdID0gUGVhcmxEaXZlci5ISUdIXzI7XHJcbiAgICAgICAgc3RhdGVzLmhpZ2hbb2Zmc2V0ICsgM10gPSBQZWFybERpdmVyLkhJR0hfMztcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgc2VhcmNoRG9OZXh0KCkge1xyXG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShuZXh0KSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHBlYXJsRGl2ZXJTdGF0ZV8xLlBlYXJsRGl2ZXJTdGF0ZS5yZWFkeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gcGVhcmxEaXZlclN0YXRlXzEuUGVhcmxEaXZlclN0YXRlLnNlYXJjaGluZztcclxuICAgICAgICAgICAgdGhpcy53ZWJHTEZpbmROb25jZShuZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIHdlYkdMRmluZE5vbmNlKHNlYXJjaE9iamVjdCkge1xyXG4gICAgICAgIHRoaXMud2ViR0xXcml0ZUJ1ZmZlcnMoc2VhcmNoT2JqZWN0LnN0YXRlcyk7XHJcbiAgICAgICAgdGhpcy5fd2ViR0xXb3JrZXIud3JpdGVEYXRhKHRoaXMuX2N1cnJlbnRCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuX3dlYkdMV29ya2VyLnJ1blByb2dyYW0oXCJpbml0XCIsIDEsIHsgbmFtZTogXCJncl9vZmZzZXRcIiwgdmFsdWU6IDAgfSk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLndlYkdMU2VhcmNoKHNlYXJjaE9iamVjdCksIDEpO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICB3ZWJHTFdyaXRlQnVmZmVycyhzdGF0ZXMpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3N0YXRlTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudEJ1ZmZlcltpICogUGVhcmxEaXZlci5URVhFTF9TSVpFXSA9IHN0YXRlcy5sb3dbaV07XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRCdWZmZXJbaSAqIFBlYXJsRGl2ZXIuVEVYRUxfU0laRSArIDFdID0gc3RhdGVzLmhpZ2hbaV07XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRCdWZmZXJbaSAqIFBlYXJsRGl2ZXIuVEVYRUxfU0laRSArIDJdID0gc3RhdGVzLmxvd1tpXTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudEJ1ZmZlcltpICogUGVhcmxEaXZlci5URVhFTF9TSVpFICsgM10gPSBzdGF0ZXMuaGlnaFtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIHdlYkdMU2VhcmNoKHNlYXJjaE9iamVjdCkge1xyXG4gICAgICAgIHRoaXMuX3dlYkdMV29ya2VyLnJ1blByb2dyYW0oXCJpbmNyZW1lbnRcIiwgMSk7XHJcbiAgICAgICAgdGhpcy5fd2ViR0xXb3JrZXIucnVuUHJvZ3JhbShcInR3aXN0XCIsIHRoaXMuX251bWJlclJvdW5kcyk7XHJcbiAgICAgICAgdGhpcy5fd2ViR0xXb3JrZXIucnVuUHJvZ3JhbShcImNoZWNrXCIsIDEsIHsgbmFtZTogXCJtaW5XZWlnaHRNYWduaXR1ZGVcIiwgdmFsdWU6IHNlYXJjaE9iamVjdC5taW5XZWlnaHRNYWduaXR1ZGUgfSk7XHJcbiAgICAgICAgdGhpcy5fd2ViR0xXb3JrZXIucnVuUHJvZ3JhbShcImNvbF9jaGVja1wiLCAxKTtcclxuICAgICAgICBpZiAodGhpcy5fd2ViR0xXb3JrZXIucmVhZERhdGEodGhpcy5fc3RhdGVMZW5ndGgsIDAsIDEsIDEpWzJdID09PSAtMSkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMud2ViR0xTZWFyY2goc2VhcmNoT2JqZWN0KSwgMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fd2ViR0xXb3JrZXIucnVuUHJvZ3JhbShcImZpbmFsaXplXCIsIDEpO1xyXG4gICAgICAgICAgICBjb25zdCBub25jZSA9IHRoaXMuX3dlYkdMV29ya2VyLnJlYWREYXRhKDAsIDAsIHRoaXMuX3dlYkdMV29ya2VyLmdldERpbWVuc2lvbnMoKS54LCAxKVxyXG4gICAgICAgICAgICAgICAgLnJlZHVjZSh0aGlzLnBhY2soNCksIFtdKVxyXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIHRoaXMuX2hhc2hMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAubWFwKHggPT4geFszXSk7XHJcbiAgICAgICAgICAgIHNlYXJjaE9iamVjdC5jYWxsYmFjayh0cml0c18xLlRyaXRzLmZyb21OdW1iZXJBcnJheShub25jZSkudG9Ucnl0ZXMoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoRG9OZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBwYWNrKGwpIHtcclxuICAgICAgICByZXR1cm4gKHIsIGN1cnJlbnRWYWx1ZSwgY3VycmVudEluZGV4KSA9PiAoY3VycmVudEluZGV4ICUgbCA9PT0gMCA/IHIucHVzaChbY3VycmVudFZhbHVlXSkgOiByW3IubGVuZ3RoIC0gMV0ucHVzaChjdXJyZW50VmFsdWUpKSAmJiByO1xyXG4gICAgfVxyXG59XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5QZWFybERpdmVyLlRFWEVMX1NJWkUgPSA0O1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuUGVhcmxEaXZlci5MT1dfQklUUyA9IDA7IC8vIDAwMDAwMDAwXHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5QZWFybERpdmVyLkhJR0hfQklUUyA9IC0xOyAvLyAweEZGRkZGRkZGLEZGRkZGRkZGLDQyOTQ5NjcyOTVcclxuLyogQGludGVybmFsICovXHJcblBlYXJsRGl2ZXIuTE9XXzAgPSAweERCNkRCNkRCOyAvLyA2REI2REI2RCxcclxuLyogQGludGVybmFsICovXHJcblBlYXJsRGl2ZXIuTE9XXzEgPSAweEYxRjhGQzdFOyAvLyAzRjFGOEZDNyxcclxuLyogQGludGVybmFsICovXHJcblBlYXJsRGl2ZXIuTE9XXzIgPSAweDdGRkZFMDBGOyAvLyBGRkZDMDFGRixcclxuLyogQGludGVybmFsICovXHJcblBlYXJsRGl2ZXIuTE9XXzMgPSAweEZGQzAwMDAwOyAvLyAwN0ZGRkZGRixcclxuLyogQGludGVybmFsICovXHJcblBlYXJsRGl2ZXIuSElHSF8wID0gMHhCNkRCNkRCNjsgLy8gREI2REI2REIsXHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5QZWFybERpdmVyLkhJR0hfMSA9IDB4OEZDN0UzRjE7IC8vIEY4RkM3RTNGLFxyXG4vKiBAaW50ZXJuYWwgKi9cclxuUGVhcmxEaXZlci5ISUdIXzIgPSAweEZGQzAxRkZGOyAvLyBGODAzRkZGRixcclxuLyogQGludGVybmFsICovXHJcblBlYXJsRGl2ZXIuSElHSF8zID0gMHgwMDNGRkZGRjsgLy9GRkZGRkZGRixcclxuZXhwb3J0cy5QZWFybERpdmVyID0gUGVhcmxEaXZlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0dWaGNteEVhWFpsY2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl3WldGeWJFUnBkbVZ5TDNCbFlYSnNSR2wyWlhJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPenRCUVVGQkxEUkZRVUY1UlR0QlFVTjZSU3hyUmtGQkswVTdRVUZETDBVc01rUkJRWGRFTzBGQlIzaEVMSGxFUVVGcFF6dEJRVU5xUXl4dFJVRkJNa003UVVGRE0wTXNhVVZCUVhsRE8wRkJRM3BETEN0RVFVRjFRenRCUVVOMlF5eHRSVUZCTWtNN1FVRkRNME1zYVVWQlFYbERPMEZCUTNwRExIRkZRVUUyUXp0QlFVTTNReXd5UkVGQmJVTTdRVUZEYmtNc2NVVkJRVFpETzBGQlF6ZERMSE5FUVVGdFJEdEJRVWR1UkN4MVJFRkJiMFE3UVVGRGNFUTdPenRIUVVkSE8wRkJRMGc3U1VGblJFa3NaVUZCWlR0SlFVTm1MRmxCUVc5Q0xHRkJRVFpDTzFGQlF6ZERMRWxCUVVrc1EwRkJReXhaUVVGWkxFZEJRVWNzU1VGQlNTeDVRa0ZCVnl4RlFVRkZMRU5CUVVNN1VVRkRkRU1zVFVGQlRTeEpRVUZKTEVkQlFVY3NOa0pCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRja1FzU1VGQlNTeERRVUZETEZkQlFWY3NSMEZCUnl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExHRkJRV0VzUTBGQlF5eERRVUZETzFGQlEyNUVMRWxCUVVrc1EwRkJReXhaUVVGWkxFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJRenRSUVVOeVJDeEpRVUZKTEVOQlFVTXNZVUZCWVN4SFFVRkhMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1EwRkJRenRSUVVNeFJDeEpRVUZKTEVOQlFVTXNhMEpCUVd0Q0xFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NSMEZCUnl4RlFVRkZMRU5CUVVNN1VVRkRhRVFzU1VGQlNTeERRVUZETEZsQlFWa3NSMEZCUnl4SlFVRkpMRU5CUVVNc1YwRkJWeXhIUVVGSExFTkJRVU1zUTBGQlF6dFJRVU42UXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhIUVVGSExFbEJRVWtzUTBGQlF5eFhRVUZYTEVkQlFVY3NTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJRenRSUVVWNFJDeEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRlZCUVZVc1EwRkJReXhoUVVGaExFVkJRVVVzU1VGQlNTeERRVUZETEZsQlFWa3NSMEZCUnl4RFFVRkRMRVZCUVVVc1ZVRkJWU3hEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETzFGQlF6RkdMRWxCUVVrc1EwRkJReXhqUVVGakxFZEJRVWNzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU03VVVGRGRFUXNTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhWUVVGVkxFTkJRVU1zVFVGQlRTeEZRVUZGTEdsQ1FVRlBMRWRCUVVjc1lVRkJSeXhIUVVGSExHTkJRVWtzUlVGQlJTeFhRVUZYTEVOQlFVTXNRMEZCUXp0UlFVTjRSU3hKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEZWQlFWVXNRMEZCUXl4WFFVRlhMRVZCUVVVc2FVSkJRVThzUjBGQlJ5eGhRVUZITEVkQlFVY3NiVUpCUVZNc1EwRkJReXhEUVVGRE8xRkJRM0pGTEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFOUJRVThzUlVGQlJTeHBRa0ZCVHl4SFFVRkhMRzFDUVVGVExFTkJRVU1zUTBGQlF6dFJRVU16UkN4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExGVkJRVlVzUTBGQlF5eFBRVUZQTEVWQlFVVXNhVUpCUVU4c1IwRkJSeXhwUWtGQlR5eEhRVUZITEdkQ1FVRk5MRVZCUVVVc2IwSkJRVzlDTEVOQlFVTXNRMEZCUXp0UlFVTjRSaXhKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEZWQlFWVXNRMEZCUXl4WFFVRlhMRVZCUVVVc2FVSkJRVThzUjBGQlJ5eHJRa0ZCVVN4RFFVRkRMRU5CUVVNN1VVRkRPVVFzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1ZVRkJWU3hGUVVGRkxHbENRVUZQTEVkQlFVY3NhVUpCUVU4c1IwRkJSeXhyUWtGQlVTeERRVUZETEVOQlFVTTdVVUZEZGtVc1NVRkJTU3hEUVVGRExFMUJRVTBzUjBGQlJ5eHBRMEZCWlN4RFFVRkRMRXRCUVVzc1EwRkJRenRSUVVOd1F5eEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRVZCUVVVc1EwRkJRenRKUVVOeVFpeERRVUZETzBsQlJVUTdPMDlCUlVjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEdGQlFUWkNPMUZCUTJ4RUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRrSXNWVUZCVlN4RFFVRkRMRkZCUVZFc1IwRkJSeXhKUVVGSkxGVkJRVlVzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXp0UlFVTjRSQ3hEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVVZFT3p0UFFVVkhPMGxCUTBrc1RVRkJUU3hEUVVGRExGTkJRVk03VVVGRGJrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZEVJc1ZVRkJWU3hEUVVGRExGRkJRVkVzUjBGQlJ5eFRRVUZUTEVOQlFVTTdVVUZEY0VNc1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRlJEczdPenM3VDBGTFJ6dEpRVU5KTEV0QlFVc3NRMEZCUXl4blFrRkJaMElzUTBGQlF5eE5RVUZqTEVWQlFVVXNhMEpCUVRCQ08xRkJRM0JGTEUxQlFVMHNXVUZCV1N4SFFVRkhMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZETVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RlFVRkZMR3RDUVVGclFpeERRVUZETEVOQlFVTTdTVUZEZWtRc1EwRkJRenRKUVVWRUxHVkJRV1U3U1VGRFVDeFBRVUZQTEVOQlFVTXNhVUpCUVhsQ08xRkJRM0pETEUxQlFVMHNTVUZCU1N4SFFVRkhMRFpDUVVGaExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJRM0pFTEVsQlFVa3NRMEZCUXl4VlFVRlZMRVZCUVVVc1EwRkJRenRSUVVOc1FpeE5RVUZOTEdkQ1FVRm5RaXhIUVVGSExHRkJRVXNzUTBGQlF5eFZRVUZWTEVOQlFVTXNhVUpCUVdsQ0xFTkJRVU1zUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXp0UlFVTjJSU3hKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEdkQ1FVRm5RaXhGUVVGRkxFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNhMEpCUVd0Q0xFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMUZCUXpkRkxFMUJRVTBzVTBGQlV5eEhRVUZITEVsQlFVa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRSUVVOc1F5eG5Ra0ZCWjBJN1lVRkRXQ3hMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEd0Q1FVRnJRaXhIUVVGSExFbEJRVWtzUTBGQlF5eFhRVUZYTEVWQlFVVXNTVUZCU1N4RFFVRkRMR3RDUVVGclFpeERRVUZETzJGQlF6RkZMRTlCUVU4c1EwRkJReXhEUVVGRExFdEJRV0VzUlVGQlJTeExRVUZoTEVWQlFVVXNSVUZCUlR0WlFVTjBReXhUUVVGVExFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NTMEZCU3l4RFFVRkRPMUZCUXpkQ0xFTkJRVU1zUTBGQlF5eERRVUZETzFGQlExQXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTTdTVUZEZUVNc1EwRkJRenRKUVVWRUxHVkJRV1U3U1VGRFVDeExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVRoQ0xFVkJRVVVzVTBGQmFVSTdVVUZEYkVVc2MwUkJRWE5FTzFGQlEzUkVMR2xFUVVGcFJEdFJRVU5xUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hQUVVGUExFTkJRVk1zUTBGQlF5eFBRVUZQTEVWQlFVVXNUVUZCVFN4RlFVRkZMRVZCUVVVN1dVRkRNME1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1owSkJRMklzVFVGQlRTeEZRVUZGTEUxQlFVMDdaMEpCUTJRc2EwSkJRV3RDTEVWQlFVVXNVMEZCVXp0blFrRkROMElzVVVGQlVTeEZRVUZGTEU5QlFVODdZVUZEY0VJc1EwRkJReXhEUVVGRE8xbEJRMGdzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1MwRkJTeXhwUTBGQlpTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM2hETEVsQlFVa3NRMEZCUXl4WlFVRlpMRVZCUVVVc1EwRkJRenRaUVVONFFpeERRVUZETzFGQlEwd3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRVQ3hEUVVGRE8wbEJSVVFzWlVGQlpUdEpRVU5RTEZsQlFWa3NRMEZCUXl4TFFVRm5RanRSUVVOcVF5eE5RVUZOTEUxQlFVMHNSMEZCUnp0WlFVTllMRWRCUVVjc1JVRkJSU3hKUVVGSkxGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRPMWxCUTNSRExFbEJRVWtzUlVGQlJTeEpRVUZKTEZWQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRE8xTkJRekZETEVOQlFVTTdVVUZEUml4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zU1VGQldTeEZRVUZGTEV0QlFXRXNSVUZCUlN4RlFVRkZPMWxCUXpGRExFMUJRVTBzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMWdzUzBGQlN5eERRVUZETzI5Q1FVTkdMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NWVUZCVlN4RFFVRkRMRk5CUVZNc1EwRkJRenR2UWtGRGVrTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eFZRVUZWTEVOQlFVTXNVMEZCVXl4RFFVRkRPMjlDUVVNeFF5eExRVUZMTEVOQlFVTTdaMEpCUTFZc1MwRkJTeXhEUVVGRE8yOUNRVU5HTEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1MwRkJTeXhEUVVGRExFZEJRVWNzVlVGQlZTeERRVUZETEZGQlFWRXNRMEZCUXp0dlFrRkRlRU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhWUVVGVkxFTkJRVU1zVTBGQlV5eERRVUZETzI5Q1FVTXhReXhMUVVGTExFTkJRVU03WjBKQlExWTdiMEpCUTBrc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eExRVUZMTEVOQlFVTXNSMEZCUnl4VlFVRlZMRU5CUVVNc1UwRkJVeXhEUVVGRE8yOUNRVU42UXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eEhRVUZITEZWQlFWVXNRMEZCUXl4UlFVRlJMRU5CUVVNN1dVRkRha1FzUTBGQlF6dFJRVU5NTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTBnc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eE5RVUZOTEVWQlFVVXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8xRkJRelZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNN1NVRkRiRUlzUTBGQlF6dEpRVVZFTEdWQlFXVTdTVUZEVUN4WlFVRlpMRU5CUVVNc1RVRkJPRUlzUlVGQlJTeE5RVUZqTzFGQlF5OUVMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRlZCUVZVc1EwRkJReXhMUVVGTExFTkJRVU03VVVGRE1VTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NWVUZCVlN4RFFVRkRMRXRCUVVzc1EwRkJRenRSUVVNeFF5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eFZRVUZWTEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUXpGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExGVkJRVlVzUTBGQlF5eExRVUZMTEVOQlFVTTdVVUZETVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF6dFJRVU0xUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRE8xRkJRelZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNN1VVRkROVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXp0SlFVTm9SQ3hEUVVGRE8wbEJSVVFzWlVGQlpUdEpRVU5RTEZsQlFWazdVVUZEYUVJc1RVRkJUU3hKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJRenRSUVVOcVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkROMElzU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4cFEwRkJaU3hEUVVGRExFdEJRVXNzUTBGQlF6dFJRVU40UXl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFNpeEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMR2xEUVVGbExFTkJRVU1zVTBGQlV5eERRVUZETzFsQlEzaERMRWxCUVVrc1EwRkJReXhqUVVGakxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZET1VJc1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRlJDeGxRVUZsTzBsQlExQXNZMEZCWXl4RFFVRkRMRmxCUVc5RE8xRkJRM1pFTEVsQlFVa3NRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eFpRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkROVU1zU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETzFGQlEycEVMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hKUVVGSkxFVkJRVVVzVjBGQlZ5eEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRM3BGTEZWQlFWVXNRMEZCUXl4SFFVRkhMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEZsQlFWa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRM2hFTEVOQlFVTTdTVUZGUkN4bFFVRmxPMGxCUTFBc2FVSkJRV2xDTEVOQlFVTXNUVUZCT0VJN1VVRkRjRVFzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU03V1VGRGVrTXNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJReXhEUVVGRExFZEJRVWNzVlVGQlZTeERRVUZETEZWQlFWVXNRMEZCUXl4SFFVRkhMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETDBRc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETEVkQlFVY3NWVUZCVlN4RFFVRkRMRlZCUVZVc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JGTEVsQlFVa3NRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJReXhIUVVGSExGVkJRVlVzUTBGQlF5eFZRVUZWTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnVSU3hKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTXNSMEZCUnl4VlFVRlZMRU5CUVVNc1ZVRkJWU3hIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVFVXNRMEZCUXp0SlFVTk1MRU5CUVVNN1NVRkZSQ3hsUVVGbE8wbEJRMUFzVjBGQlZ5eERRVUZETEZsQlFXOURPMUZCUTNCRUxFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNWVUZCVlN4RFFVRkRMRmRCUVZjc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU0zUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExGVkJRVlVzUTBGQlF5eFBRVUZQTEVWQlFVVXNTVUZCU1N4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRE8xRkJRekZFTEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlN4SlFVRkpMRVZCUVVVc2IwSkJRVzlDTEVWQlFVVXNTMEZCU3l4RlFVRkZMRmxCUVZrc1EwRkJReXhyUWtGQmEwSXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRha2dzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlJUZERMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJReXhaUVVGWkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia1VzVlVGQlZTeERRVUZETEVkQlFVY3NSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVU1zV1VGQldTeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRla1FzUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTBvc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eFZRVUZWTEVOQlFVTXNWVUZCVlN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRelZETEUxQlFVMHNTMEZCU3l4SFFVRkhMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eGhRVUZoTEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8ybENRVU5xUml4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNN2FVSkJRM2hDTEV0QlFVc3NRMEZCUXl4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF6dHBRa0ZETVVJc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRmNFSXNXVUZCV1N4RFFVRkRMRkZCUVZFc1EwRkJReXhoUVVGTExFTkJRVU1zWlVGQlpTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGREwwUXNTVUZCU1N4RFFVRkRMRmxCUVZrc1JVRkJSU3hEUVVGRE8xRkJRM2hDTEVOQlFVTTdTVUZEVEN4RFFVRkRPMGxCUlVRc1pVRkJaVHRKUVVOUUxFbEJRVWtzUTBGQlF5eERRVUZUTzFGQlEyeENMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRV0VzUlVGQlJTeFpRVUZaTEVWQlFVVXNXVUZCV1N4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRExGbEJRVmtzUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRM1JLTEVOQlFVTTdPMEZCTVU1RUxHVkJRV1U3UVVGRFV5eHhRa0ZCVlN4SFFVRlhMRU5CUVVNc1EwRkJRenRCUVVVdlF5eGxRVUZsTzBGQlExTXNiVUpCUVZFc1IwRkJWeXhEUVVGRExFTkJRVU1zUTBGQlF5eFhRVUZYTzBGQlEzcEVMR1ZCUVdVN1FVRkRVeXh2UWtGQlV5eEhRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc2FVTkJRV2xETzBGQlEycEdMR1ZCUVdVN1FVRkRVeXhuUWtGQlN5eEhRVUZYTEZWQlFWVXNRMEZCUXl4RFFVRkRMRmxCUVZrN1FVRkRhRVVzWlVGQlpUdEJRVU5UTEdkQ1FVRkxMRWRCUVZjc1ZVRkJWU3hEUVVGRExFTkJRVU1zV1VGQldUdEJRVU5vUlN4bFFVRmxPMEZCUTFNc1owSkJRVXNzUjBGQlZ5eFZRVUZWTEVOQlFVTXNRMEZCUXl4WlFVRlpPMEZCUTJoRkxHVkJRV1U3UVVGRFV5eG5Ra0ZCU3l4SFFVRlhMRlZCUVZVc1EwRkJReXhEUVVGRExGbEJRVms3UVVGRGFFVXNaVUZCWlR0QlFVTlRMR2xDUVVGTkxFZEJRVmNzVlVGQlZTeERRVUZETEVOQlFVTXNXVUZCV1R0QlFVTnFSU3hsUVVGbE8wRkJRMU1zYVVKQlFVMHNSMEZCVnl4VlFVRlZMRU5CUVVNc1EwRkJReXhaUVVGWk8wRkJRMnBGTEdWQlFXVTdRVUZEVXl4cFFrRkJUU3hIUVVGWExGVkJRVlVzUTBGQlF5eERRVUZETEZsQlFWazdRVUZEYWtVc1pVRkJaVHRCUVVOVExHbENRVUZOTEVkQlFWY3NWVUZCVlN4RFFVRkRMRU5CUVVNc1YwRkJWenRCUVhwQ2NFVXNaME5CT0U1REluMD1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL3BlYXJsRGl2ZXIvcGVhcmxEaXZlci50cyIsInZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cImVtc2NyaXB0ZW5cIiAvPlxyXG5jb25zdCBhcnJheUhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXJcIik7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgY3J5cHRvRXJyb3JfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NyeXB0by9kaXN0L2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlc1wiKTtcclxuLy8gQHRzLWlnbm9yZVxyXG5jb25zdCBpb3RhX3BpY29fcG93X3dhc21fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vd2FzbS9pb3RhLXBpY28tcG93LXdhc21cIikpO1xyXG4vKipcclxuICogUHJvb2ZPZldvcmsgaW1wbGVtZW50YXRpb24gdXNpbmcgV2ViQXNzZW1ibHkuXHJcbiAqL1xyXG5jbGFzcyBQcm9vZk9mV29ya1dhc20ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgUHJvb2ZPZldvcmsuXHJcbiAgICAgKiBAcGFyYW0gd2ViUGxhdGZvcm0gUHJvdmlkZXMgcGxhdGZvcm0gc3BlY2lmaWMgZnVuY3Rpb25zLCBvcHRpb25hbCBtb3N0bHkgdXNlZCBmb3IgdGVzdGluZy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iod2ViUGxhdGZvcm0pIHtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkod2ViUGxhdGZvcm0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlYlBsYXRmb3JtID0ge1xyXG4gICAgICAgICAgICAgICAgd2ViQXNzZW1ibHlUeXBlOiB0eXBlb2YgV2ViQXNzZW1ibHksXHJcbiAgICAgICAgICAgICAgICB3YXNtTW9kdWxlTG9hZGVyOiBpb3RhX3BpY29fcG93X3dhc21fMS5kZWZhdWx0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl93ZWJQbGF0Zm9ybSA9IHdlYlBsYXRmb3JtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb3cgdGhlIHByb29mIG9mIHdvcmsgdG8gcGVyZm9ybSBhbnkgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKiBXaWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgaW1wbGVtZW50YXRpb24gaXMgbm90IHN1cHBvcnRlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkodGhpcy5fd2ViUGxhdGZvcm0ud2ViQXNzZW1ibHlUeXBlKSB8fCB0aGlzLl93ZWJQbGF0Zm9ybS53ZWJBc3NlbWJseVR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIk5vIFdlYkFzc2VtYmx5IHN1cHBvcnQgZGV0ZWN0ZWRcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHt9O1xyXG4gICAgICAgICAgICBtb2R1bGUub25SdW50aW1lSW5pdGlhbGl6ZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jY3VybFBvdyA9IG1vZHVsZS5jd3JhcChcImNjdXJsX3Bvd1wiLCBcInN0cmluZ1wiLCBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIl0pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2ViUGxhdGZvcm0ud2FzbU1vZHVsZUxvYWRlcihtb2R1bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZXJlIHdhcyBhIHByb2JsZW0gaW50aWFsaXppbmcgdGhlIFdlYkFzc2VtYmx5IE1vZHVsZVwiLCB1bmRlZmluZWQsIGVycikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIHNpbmdsZSBjb252ZXJzaW9uIHBlciBwb3cgY2FsbC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgcG93IG9ubHkgZG9lcyBvbmUgY29udmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgcGVyZm9ybXNTaW5nbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm0gYSBwcm9vZiBvZiB3b3JrIG9uIHRoZSBkYXRhLlxyXG4gICAgICogQHBhcmFtIHRydW5rVHJhbnNhY3Rpb24gVGhlIHRydW5rVHJhbnNhY3Rpb24gdG8gdXNlIGZvciB0aGUgcG93LlxyXG4gICAgICogQHBhcmFtIGJyYW5jaFRyYW5zYWN0aW9uIFRoZSBicmFuY2hUcmFuc2FjdGlvbiB0byB1c2UgZm9yIHRoZSBwb3cuXHJcbiAgICAgKiBAcGFyYW0gdHJ5dGVzIFRoZSB0cnl0ZXMgdG8gcGVyZm9ybSB0aGUgcG93IG9uLlxyXG4gICAgICogQHBhcmFtIG1pbldlaWdodE1hZ25pdHVkZSBUaGUgbWluaW11bSB3ZWlnaHQgbWFnbml0dWRlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHRyeXRlcyBwcm9kdWNlZCBieSB0aGUgcHJvb2Ygb2Ygd29yay5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcG93KHRydW5rVHJhbnNhY3Rpb24sIGJyYW5jaFRyYW5zYWN0aW9uLCB0cnl0ZXMsIG1pbldlaWdodE1hZ25pdHVkZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh0aGlzLl9jY3VybFBvdykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiV2ViQXNzZW1ibHkgbm90IGxvYWRlZCwgaGF2ZSB5b3UgY2FsbGVkIGluaXRpYWxpemVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQodHJ5dGVzLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSB0cnl0ZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIFRyeXRlc1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobWluV2VpZ2h0TWFnbml0dWRlKSB8fCBtaW5XZWlnaHRNYWduaXR1ZGUgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgbWluV2VpZ2h0TWFnbml0dWRlIG11c3QgYmUgPiAwXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jY3VybFBvdyh0cnl0ZXNbMF0udG9TdHJpbmcoKSwgbWluV2VpZ2h0TWFnbml0dWRlKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoW3RyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHJlc3VsdCldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUHJvb2ZPZldvcmtXYXNtID0gUHJvb2ZPZldvcmtXYXNtO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljSEp2YjJaUFpsZHZjbXRYWVhOdExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dmMzSmpMM0J5YjI5bVQyWlhiM0pyVjJGemJTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3TzBGQlFVRXNiME5CUVc5RE8wRkJRM0JETERCRlFVRjFSVHRCUVVOMlJTdzBSVUZCZVVVN1FVRkRla1VzTkVWQlFYbEZPMEZCUTNwRkxEQkZRVUYxUlR0QlFVZDJSU3cyUkVGQk1FUTdRVUZETVVRc1lVRkJZVHRCUVVOaUxHOUdRVUY1UkR0QlFVZDZSRHM3UjBGRlJ6dEJRVU5JTzBsQlQwazdPenRQUVVkSE8wbEJRMGdzV1VGQldTeFhRVUV3UWp0UlFVTnNReXhGUVVGRkxFTkJRVU1zUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXhYUVVGWExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY0VNc1NVRkJTU3hEUVVGRExGbEJRVmtzUjBGQlJ6dG5Ra0ZEYUVJc1pVRkJaU3hGUVVGRkxFOUJRVThzVjBGQlZ6dG5Ra0ZEYmtNc1owSkJRV2RDTEVWQlFVVXNORUpCUVdVN1lVRkRjRU1zUTBGQlF6dFJRVU5PTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOS0xFbEJRVWtzUTBGQlF5eFpRVUZaTEVkQlFVY3NWMEZCVnl4RFFVRkRPMUZCUTNCRExFTkJRVU03U1VGRFRDeERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzUzBGQlN5eERRVUZETEZWQlFWVTdVVUZEYmtJc1RVRkJUU3hEUVVGRExFbEJRVWtzVDBGQlR5eERRVUZQTEVOQlFVTXNUMEZCVHl4RlFVRkZMRTFCUVUwc1JVRkJSU3hGUVVGRk8xbEJRM3BETEVWQlFVVXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1pVRkJaU3hEUVVGRExFbEJRVWtzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4bFFVRmxMRXRCUVVzc1YwRkJWeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZETDBjc1RVRkJUU3hEUVVGRExFbEJRVWtzZVVKQlFWY3NRMEZCUXl4cFEwRkJhVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETDBRc1EwRkJRenRaUVVWRUxFMUJRVTBzVFVGQlRTeEhRVUZSTEVWQlFVVXNRMEZCUXp0WlFVVjJRaXhOUVVGTkxFTkJRVU1zYjBKQlFXOUNMRWRCUVVjc1IwRkJSeXhGUVVGRk8yZENRVU12UWl4SlFVRkpMRU5CUVVNc1UwRkJVeXhIUVVGSExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCVnl4RlFVRkZMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNelJTeFBRVUZQTEVWQlFVVXNRMEZCUXp0WlFVTmtMRU5CUVVNc1EwRkJRenRaUVVWR0xFbEJRVWtzUTBGQlF6dG5Ra0ZEUkN4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExHZENRVUZuUWl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xbEJReTlETEVOQlFVTTdXVUZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTllMRTFCUVUwc1EwRkJReXhKUVVGSkxIbENRVUZYTEVOQlFVTXNkMFJCUVhkRUxFVkJRVVVzVTBGQlV5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRkRWNzUTBGQlF6dFJRVU5NTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTFBc1EwRkJRenRKUVVWRU96czdUMEZIUnp0SlFVTkpMR05CUVdNN1VVRkRha0lzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0SlFVTm9RaXhEUVVGRE8wbEJSVVE3T3pzN096czdUMEZQUnp0SlFVTkpMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zWjBKQlFYTkNMRVZCUVVVc2FVSkJRWFZDTEVWQlFVVXNUVUZCWjBJc1JVRkJSU3hyUWtGQk1FSTdVVUZETVVjc1RVRkJUU3hEUVVGRExFbEJRVWtzVDBGQlR5eERRVUZYTEVOQlFVTXNUMEZCVHl4RlFVRkZMRTFCUVUwc1JVRkJSU3hGUVVGRk8xbEJRemRETEVWQlFVVXNRMEZCUXl4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzWkRMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEc5RVFVRnZSQ3hEUVVGRExFTkJRVU03V1VGRGFFWXNRMEZCUXp0WlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zZVVKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRkxHVkJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRka01zVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc05FTkJRVFJETEVOQlFVTXNRMEZCUXp0WlFVTjRSU3hEUVVGRE8xbEJRMFFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eHJRa0ZCYTBJc1EwRkJReXhKUVVGSkxHdENRVUZyUWl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzcEZMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEc5RFFVRnZReXhEUVVGRExFTkJRVU03V1VGRGFFVXNRMEZCUXp0WlFVVkVMRWxCUVVrc1EwRkJRenRuUWtGRFJDeE5RVUZOTEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1JVRkJSU3hyUWtGQmEwSXNRMEZCUXl4RFFVRkRPMmRDUVVWNFJTeFBRVUZQTEVOQlFVTXNRMEZCUlN4bFFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTXpReXhEUVVGRE8xbEJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRFdDeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRhRUlzUTBGQlF6dFJRVU5NTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTFBc1EwRkJRenREUVVOS08wRkJjRVpFTERCRFFXOUdReUo5XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL3NyYy9wcm9vZk9mV29ya1dhc20udHMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW90YS1waWNvLXBvdy13YXNtL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW90YS1waWNvLXBvdy13YXNtL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW90YS1waWNvLXBvdy13YXNtL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNb2R1bGUgPSBmdW5jdGlvbihNb2R1bGUpIHtcclxuICBNb2R1bGUgPSBNb2R1bGUgfHwge307XHJcblxyXG4vLyBUaGUgTW9kdWxlIG9iamVjdDogT3VyIGludGVyZmFjZSB0byB0aGUgb3V0c2lkZSB3b3JsZC4gV2UgaW1wb3J0XHJcbi8vIGFuZCBleHBvcnQgdmFsdWVzIG9uIGl0LiBUaGVyZSBhcmUgdmFyaW91cyB3YXlzIE1vZHVsZSBjYW4gYmUgdXNlZDpcclxuLy8gMS4gTm90IGRlZmluZWQuIFdlIGNyZWF0ZSBpdCBoZXJlXHJcbi8vIDIuIEEgZnVuY3Rpb24gcGFyYW1ldGVyLCBmdW5jdGlvbihNb2R1bGUpIHsgLi5nZW5lcmF0ZWQgY29kZS4uIH1cclxuLy8gMy4gcHJlLXJ1biBhcHBlbmRlZCBpdCwgdmFyIE1vZHVsZSA9IHt9OyAuLmdlbmVyYXRlZCBjb2RlLi5cclxuLy8gNC4gRXh0ZXJuYWwgc2NyaXB0IHRhZyBkZWZpbmVzIHZhciBNb2R1bGUuXHJcbi8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgTW9kdWxlIGFscmVhZHkgZXhpc3RzIChlLmcuIGNhc2UgMyBhYm92ZSkuXHJcbi8vIFN1YnN0aXR1dGlvbiB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYWN0dWFsIGNvZGUgb24gbGF0ZXIgc3RhZ2Ugb2YgdGhlIGJ1aWxkLFxyXG4vLyB0aGlzIHdheSBDbG9zdXJlIENvbXBpbGVyIHdpbGwgbm90IG1hbmdsZSBpdCAoZS5nLiBjYXNlIDQuIGFib3ZlKS5cclxuLy8gTm90ZSB0aGF0IGlmIHlvdSB3YW50IHRvIHJ1biBjbG9zdXJlLCBhbmQgYWxzbyB0byB1c2UgTW9kdWxlXHJcbi8vIGFmdGVyIHRoZSBnZW5lcmF0ZWQgY29kZSwgeW91IHdpbGwgbmVlZCB0byBkZWZpbmUgICB2YXIgTW9kdWxlID0ge307XHJcbi8vIGJlZm9yZSB0aGUgY29kZS4gVGhlbiB0aGF0IG9iamVjdCB3aWxsIGJlIHVzZWQgaW4gdGhlIGNvZGUsIGFuZCB5b3VcclxuLy8gY2FuIGNvbnRpbnVlIHRvIHVzZSBNb2R1bGUgYWZ0ZXJ3YXJkcyBhcyB3ZWxsLlxyXG52YXIgTW9kdWxlID0gdHlwZW9mIE1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBNb2R1bGUgOiB7fTtcclxuXHJcbi8vIC0tcHJlLWpzZXMgYXJlIGVtaXR0ZWQgYWZ0ZXIgdGhlIE1vZHVsZSBpbnRlZ3JhdGlvbiBjb2RlLCBzbyB0aGF0IHRoZXkgY2FuXHJcbi8vIHJlZmVyIHRvIE1vZHVsZSAoaWYgdGhleSBjaG9vc2U7IHRoZXkgY2FuIGFsc28gZGVmaW5lIE1vZHVsZSlcclxuLy8ge3tQUkVfSlNFU319XHJcblxyXG4vLyBTb21ldGltZXMgYW4gZXhpc3RpbmcgTW9kdWxlIG9iamVjdCBleGlzdHMgd2l0aCBwcm9wZXJ0aWVzXHJcbi8vIG1lYW50IHRvIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBtb2R1bGUgZnVuY3Rpb25hbGl0eS4gSGVyZVxyXG4vLyB3ZSBjb2xsZWN0IHRob3NlIHByb3BlcnRpZXMgYW5kIHJlYXBwbHkgX2FmdGVyXyB3ZSBjb25maWd1cmVcclxuLy8gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBkZWZhdWx0cyB0byBhdm9pZCBoYXZpbmcgdG8gYmUgc29cclxuLy8gZGVmZW5zaXZlIGR1cmluZyBpbml0aWFsaXphdGlvbi5cclxudmFyIG1vZHVsZU92ZXJyaWRlcyA9IHt9O1xyXG52YXIga2V5O1xyXG5mb3IgKGtleSBpbiBNb2R1bGUpIHtcclxuICBpZiAoTW9kdWxlLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgIG1vZHVsZU92ZXJyaWRlc1trZXldID0gTW9kdWxlW2tleV07XHJcbiAgfVxyXG59XHJcblxyXG5Nb2R1bGVbJ2FyZ3VtZW50cyddID0gW107XHJcbk1vZHVsZVsndGhpc1Byb2dyYW0nXSA9ICcuL3RoaXMucHJvZ3JhbSc7XHJcbk1vZHVsZVsncXVpdCddID0gZnVuY3Rpb24oc3RhdHVzLCB0b1Rocm93KSB7XHJcbiAgdGhyb3cgdG9UaHJvdztcclxufTtcclxuTW9kdWxlWydwcmVSdW4nXSA9IFtdO1xyXG5Nb2R1bGVbJ3Bvc3RSdW4nXSA9IFtdO1xyXG5cclxuLy8gVGhlIGVudmlyb25tZW50IHNldHVwIGNvZGUgYmVsb3cgaXMgY3VzdG9taXplZCB0byB1c2UgTW9kdWxlLlxyXG4vLyAqKiogRW52aXJvbm1lbnQgc2V0dXAgY29kZSAqKipcclxudmFyIEVOVklST05NRU5UX0lTX1dFQiA9IGZhbHNlO1xyXG52YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gZmFsc2U7XHJcbnZhciBFTlZJUk9OTUVOVF9JU19OT0RFID0gZmFsc2U7XHJcbnZhciBFTlZJUk9OTUVOVF9JU19TSEVMTCA9IGZhbHNlO1xyXG5cclxuLy8gVGhyZWUgY29uZmlndXJhdGlvbnMgd2UgY2FuIGJlIHJ1bm5pbmcgaW46XHJcbi8vIDEpIFdlIGNvdWxkIGJlIHRoZSBhcHBsaWNhdGlvbiBtYWluKCkgdGhyZWFkIHJ1bm5pbmcgaW4gdGhlIG1haW4gSlMgVUkgdGhyZWFkLiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSID09IGZhbHNlIGFuZCBFTlZJUk9OTUVOVF9JU19QVEhSRUFEID09IGZhbHNlKVxyXG4vLyAyKSBXZSBjb3VsZCBiZSB0aGUgYXBwbGljYXRpb24gbWFpbigpIHRocmVhZCBwcm94aWVkIHRvIHdvcmtlci4gKHdpdGggRW1zY3JpcHRlbiAtcyBQUk9YWV9UT19XT1JLRVI9MSkgKEVOVklST05NRU5UX0lTX1dPUktFUiA9PSB0cnVlLCBFTlZJUk9OTUVOVF9JU19QVEhSRUFEID09IGZhbHNlKVxyXG4vLyAzKSBXZSBjb3VsZCBiZSBhbiBhcHBsaWNhdGlvbiBwdGhyZWFkIHJ1bm5pbmcgaW4gYSB3b3JrZXIuIChFTlZJUk9OTUVOVF9JU19XT1JLRVIgPT0gdHJ1ZSBhbmQgRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCA9PSB0cnVlKVxyXG5cclxuaWYgKE1vZHVsZVsnRU5WSVJPTk1FTlQnXSkge1xyXG4gIGlmIChNb2R1bGVbJ0VOVklST05NRU5UJ10gPT09ICdXRUInKSB7XHJcbiAgICBFTlZJUk9OTUVOVF9JU19XRUIgPSB0cnVlO1xyXG4gIH0gZWxzZSBpZiAoTW9kdWxlWydFTlZJUk9OTUVOVCddID09PSAnV09SS0VSJykge1xyXG4gICAgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKE1vZHVsZVsnRU5WSVJPTk1FTlQnXSA9PT0gJ05PREUnKSB7XHJcbiAgICBFTlZJUk9OTUVOVF9JU19OT0RFID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKE1vZHVsZVsnRU5WSVJPTk1FTlQnXSA9PT0gJ1NIRUxMJykge1xyXG4gICAgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSB0cnVlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZVtcXCdFTlZJUk9OTUVOVFxcJ10gdmFsdWUgaXMgbm90IHZhbGlkLiBtdXN0IGJlIG9uZSBvZjogV0VCfFdPUktFUnxOT0RFfFNIRUxMLicpO1xyXG4gIH1cclxufSBlbHNlIHtcclxuICBFTlZJUk9OTUVOVF9JU19XRUIgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JztcclxuICBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJztcclxuICBFTlZJUk9OTUVOVF9JU19OT0RFID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICYmICFFTlZJUk9OTUVOVF9JU19XRUIgJiYgIUVOVklST05NRU5UX0lTX1dPUktFUjtcclxuICBFTlZJUk9OTUVOVF9JU19TSEVMTCA9ICFFTlZJUk9OTUVOVF9JU19XRUIgJiYgIUVOVklST05NRU5UX0lTX05PREUgJiYgIUVOVklST05NRU5UX0lTX1dPUktFUjtcclxufVxyXG5cclxuXHJcbmlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7XHJcbiAgLy8gRXhwb3NlIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHNhbWUgc2ltcGxlIHdheSB0aGF0IHRoZSBzaGVsbHMgd29ya1xyXG4gIC8vIE5vdGUgdGhhdCB3ZSBwb2xsdXRlIHRoZSBnbG9iYWwgbmFtZXNwYWNlIGhlcmUsIG90aGVyd2lzZSB3ZSBicmVhayBpbiBub2RlXHJcbiAgdmFyIG5vZGVGUztcclxuICB2YXIgbm9kZVBhdGg7XHJcblxyXG4gIE1vZHVsZVsncmVhZCddID0gZnVuY3Rpb24gc2hlbGxfcmVhZChmaWxlbmFtZSwgYmluYXJ5KSB7XHJcbiAgICB2YXIgcmV0O1xyXG4gICAgcmV0ID0gdHJ5UGFyc2VBc0RhdGFVUkkoZmlsZW5hbWUpO1xyXG4gICAgaWYgKCFyZXQpIHtcclxuICAgICAgaWYgKCFub2RlRlMpIG5vZGVGUyA9IHJlcXVpcmUoJ2ZzJyk7XHJcbiAgICAgIGlmICghbm9kZVBhdGgpIG5vZGVQYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG4gICAgICBmaWxlbmFtZSA9IG5vZGVQYXRoWydub3JtYWxpemUnXShmaWxlbmFtZSk7XHJcbiAgICAgIHJldCA9IG5vZGVGU1sncmVhZEZpbGVTeW5jJ10oZmlsZW5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJpbmFyeSA/IHJldCA6IHJldC50b1N0cmluZygpO1xyXG4gIH07XHJcblxyXG4gIE1vZHVsZVsncmVhZEJpbmFyeSddID0gZnVuY3Rpb24gcmVhZEJpbmFyeShmaWxlbmFtZSkge1xyXG4gICAgdmFyIHJldCA9IE1vZHVsZVsncmVhZCddKGZpbGVuYW1lLCB0cnVlKTtcclxuICAgIGlmICghcmV0LmJ1ZmZlcikge1xyXG4gICAgICByZXQgPSBuZXcgVWludDhBcnJheShyZXQpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0KHJldC5idWZmZXIpO1xyXG4gICAgcmV0dXJuIHJldDtcclxuICB9O1xyXG5cclxuICBpZiAocHJvY2Vzc1snYXJndiddLmxlbmd0aCA+IDEpIHtcclxuICAgIE1vZHVsZVsndGhpc1Byb2dyYW0nXSA9IHByb2Nlc3NbJ2FyZ3YnXVsxXS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgfVxyXG5cclxuICBNb2R1bGVbJ2FyZ3VtZW50cyddID0gcHJvY2Vzc1snYXJndiddLnNsaWNlKDIpO1xyXG5cclxuICAvLyBNT0RVTEFSSVpFIHdpbGwgZXhwb3J0IHRoZSBtb2R1bGUgaW4gdGhlIHByb3BlciBwbGFjZSBvdXRzaWRlLCB3ZSBkb24ndCBuZWVkIHRvIGV4cG9ydCBoZXJlXHJcblxyXG4gIHByb2Nlc3NbJ29uJ10oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24oZXgpIHtcclxuICAgIC8vIHN1cHByZXNzIEV4aXRTdGF0dXMgZXhjZXB0aW9ucyBmcm9tIHNob3dpbmcgYW4gZXJyb3JcclxuICAgIGlmICghKGV4IGluc3RhbmNlb2YgRXhpdFN0YXR1cykpIHtcclxuICAgICAgdGhyb3cgZXg7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgLy8gQ3VycmVudGx5IG5vZGUgd2lsbCBzd2FsbG93IHVuaGFuZGxlZCByZWplY3Rpb25zLCBidXQgdGhpcyBiZWhhdmlvciBpc1xyXG4gIC8vIGRlcHJlY2F0ZWQsIGFuZCBpbiB0aGUgZnV0dXJlIGl0IHdpbGwgZXhpdCB3aXRoIGVycm9yIHN0YXR1cy5cclxuICBwcm9jZXNzWydvbiddKCd1bmhhbmRsZWRSZWplY3Rpb24nLCBmdW5jdGlvbihyZWFzb24sIHApIHtcclxuICAgIE1vZHVsZVsncHJpbnRFcnInXSgnbm9kZS5qcyBleGl0aW5nIGR1ZSB0byB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nKTtcclxuICAgIHByb2Nlc3NbJ2V4aXQnXSgxKTtcclxuICB9KTtcclxuXHJcbiAgTW9kdWxlWydpbnNwZWN0J10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF0nOyB9O1xyXG59XHJcbmVsc2UgaWYgKEVOVklST05NRU5UX0lTX1NIRUxMKSB7XHJcbiAgaWYgKHR5cGVvZiByZWFkICE9ICd1bmRlZmluZWQnKSB7XHJcbiAgICBNb2R1bGVbJ3JlYWQnXSA9IGZ1bmN0aW9uIHNoZWxsX3JlYWQoZikge1xyXG4gICAgICB2YXIgZGF0YSA9IHRyeVBhcnNlQXNEYXRhVVJJKGYpO1xyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBpbnRBcnJheVRvU3RyaW5nKGRhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZWFkKGYpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIE1vZHVsZVsncmVhZEJpbmFyeSddID0gZnVuY3Rpb24gcmVhZEJpbmFyeShmKSB7XHJcbiAgICB2YXIgZGF0YTtcclxuICAgIGRhdGEgPSB0cnlQYXJzZUFzRGF0YVVSSShmKTtcclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiByZWFkYnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZWFkYnVmZmVyKGYpKTtcclxuICAgIH1cclxuICAgIGRhdGEgPSByZWFkKGYsICdiaW5hcnknKTtcclxuICAgIGFzc2VydCh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfTtcclxuXHJcbiAgaWYgKHR5cGVvZiBzY3JpcHRBcmdzICE9ICd1bmRlZmluZWQnKSB7XHJcbiAgICBNb2R1bGVbJ2FyZ3VtZW50cyddID0gc2NyaXB0QXJncztcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHMgIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIE1vZHVsZVsnYXJndW1lbnRzJ10gPSBhcmd1bWVudHM7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHF1aXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIE1vZHVsZVsncXVpdCddID0gZnVuY3Rpb24oc3RhdHVzLCB0b1Rocm93KSB7XHJcbiAgICAgIHF1aXQoc3RhdHVzKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikge1xyXG4gIE1vZHVsZVsncmVhZCddID0gZnVuY3Rpb24gc2hlbGxfcmVhZCh1cmwpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xyXG4gICAgICB4aHIuc2VuZChudWxsKTtcclxuICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgdmFyIGRhdGEgPSB0cnlQYXJzZUFzRGF0YVVSSSh1cmwpO1xyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBpbnRBcnJheVRvU3RyaW5nKGRhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IGVycjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XHJcbiAgICBNb2R1bGVbJ3JlYWRCaW5hcnknXSA9IGZ1bmN0aW9uIHJlYWRCaW5hcnkodXJsKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcclxuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuICAgICAgICB4aHIuc2VuZChudWxsKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0cnlQYXJzZUFzRGF0YVVSSSh1cmwpO1xyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgTW9kdWxlWydyZWFkQXN5bmMnXSA9IGZ1bmN0aW9uIHJlYWRBc3luYyh1cmwsIG9ubG9hZCwgb25lcnJvcikge1xyXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XHJcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiB4aHJfb25sb2FkKCkge1xyXG4gICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDAgfHwgKHhoci5zdGF0dXMgPT0gMCAmJiB4aHIucmVzcG9uc2UpKSB7IC8vIGZpbGUgVVJMcyBjYW4gcmV0dXJuIDBcclxuICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGRhdGEgPSB0cnlQYXJzZUFzRGF0YVVSSSh1cmwpO1xyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIG9ubG9hZChkYXRhLmJ1ZmZlcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIG9uZXJyb3IoKTtcclxuICAgIH07XHJcbiAgICB4aHIub25lcnJvciA9IG9uZXJyb3I7XHJcbiAgICB4aHIuc2VuZChudWxsKTtcclxuICB9O1xyXG5cclxuICBpZiAodHlwZW9mIGFyZ3VtZW50cyAhPSAndW5kZWZpbmVkJykge1xyXG4gICAgTW9kdWxlWydhcmd1bWVudHMnXSA9IGFyZ3VtZW50cztcclxuICB9XHJcblxyXG4gIE1vZHVsZVsnc2V0V2luZG93VGl0bGUnXSA9IGZ1bmN0aW9uKHRpdGxlKSB7IGRvY3VtZW50LnRpdGxlID0gdGl0bGUgfTtcclxufVxyXG5lbHNlIHtcclxuICAvLyBVbnJlYWNoYWJsZSBiZWNhdXNlIFNIRUxMIGlzIGRlcGVuZGVudCBvbiB0aGUgb3RoZXJzXHJcbiAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHJ1bnRpbWUgZW52aXJvbm1lbnQnKTtcclxufVxyXG5cclxuLy8gY29uc29sZS5sb2cgaXMgY2hlY2tlZCBmaXJzdCwgYXMgJ3ByaW50JyBvbiB0aGUgd2ViIHdpbGwgb3BlbiBhIHByaW50IGRpYWxvZ3VlXHJcbi8vIHByaW50RXJyIGlzIHByZWZlcmFibGUgdG8gY29uc29sZS53YXJuICh3b3JrcyBiZXR0ZXIgaW4gc2hlbGxzKVxyXG5Nb2R1bGVbJ3ByaW50J10gPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgPyBjb25zb2xlLmxvZyA6ICh0eXBlb2YgcHJpbnQgIT09ICd1bmRlZmluZWQnID8gcHJpbnQgOiBudWxsKTtcclxuTW9kdWxlWydwcmludEVyciddID0gdHlwZW9mIHByaW50RXJyICE9PSAndW5kZWZpbmVkJyA/IHByaW50RXJyIDogKCh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB8fCBNb2R1bGVbJ3ByaW50J10pO1xyXG5cclxuLy8gKioqIEVudmlyb25tZW50IHNldHVwIGNvZGUgKioqXHJcblxyXG4vLyBDbG9zdXJlIGhlbHBlcnNcclxuTW9kdWxlLnByaW50ID0gTW9kdWxlWydwcmludCddO1xyXG5Nb2R1bGUucHJpbnRFcnIgPSBNb2R1bGVbJ3ByaW50RXJyJ107XHJcblxyXG4vLyBNZXJnZSBiYWNrIGluIHRoZSBvdmVycmlkZXNcclxuZm9yIChrZXkgaW4gbW9kdWxlT3ZlcnJpZGVzKSB7XHJcbiAgaWYgKG1vZHVsZU92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICBNb2R1bGVba2V5XSA9IG1vZHVsZU92ZXJyaWRlc1trZXldO1xyXG4gIH1cclxufVxyXG4vLyBGcmVlIHRoZSBvYmplY3QgaGllcmFyY2h5IGNvbnRhaW5lZCBpbiB0aGUgb3ZlcnJpZGVzLCB0aGlzIGxldHMgdGhlIEdDXHJcbi8vIHJlY2xhaW0gZGF0YSB1c2VkIGUuZy4gaW4gbWVtb3J5SW5pdGlhbGl6ZXJSZXF1ZXN0LCB3aGljaCBpcyBhIGxhcmdlIHR5cGVkIGFycmF5LlxyXG5tb2R1bGVPdmVycmlkZXMgPSB1bmRlZmluZWQ7XHJcblxyXG5cclxuXHJcbi8vIHt7UFJFQU1CTEVfQURESVRJT05TfX1cclxuXHJcbnZhciBTVEFDS19BTElHTiA9IDE2O1xyXG5cclxuLy8gc3RhY2sgbWFuYWdlbWVudCwgYW5kIG90aGVyIGZ1bmN0aW9uYWxpdHkgdGhhdCBpcyBwcm92aWRlZCBieSB0aGUgY29tcGlsZWQgY29kZSxcclxuLy8gc2hvdWxkIG5vdCBiZSB1c2VkIGJlZm9yZSBpdCBpcyByZWFkeVxyXG5zdGFja1NhdmUgPSBzdGFja1Jlc3RvcmUgPSBzdGFja0FsbG9jID0gc2V0VGVtcFJldDAgPSBnZXRUZW1wUmV0MCA9IGZ1bmN0aW9uKCkge1xyXG4gIGFib3J0KCdjYW5ub3QgdXNlIHRoZSBzdGFjayBiZWZvcmUgY29tcGlsZWQgY29kZSBpcyByZWFkeSB0byBydW4sIGFuZCBoYXMgcHJvdmlkZWQgc3RhY2sgYWNjZXNzJyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzdGF0aWNBbGxvYyhzaXplKSB7XHJcbiAgYXNzZXJ0KCFzdGF0aWNTZWFsZWQpO1xyXG4gIHZhciByZXQgPSBTVEFUSUNUT1A7XHJcbiAgU1RBVElDVE9QID0gKFNUQVRJQ1RPUCArIHNpemUgKyAxNSkgJiAtMTY7XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gZHluYW1pY0FsbG9jKHNpemUpIHtcclxuICBhc3NlcnQoRFlOQU1JQ1RPUF9QVFIpO1xyXG4gIHZhciByZXQgPSBIRUFQMzJbRFlOQU1JQ1RPUF9QVFI+PjJdO1xyXG4gIHZhciBlbmQgPSAocmV0ICsgc2l6ZSArIDE1KSAmIC0xNjtcclxuICBIRUFQMzJbRFlOQU1JQ1RPUF9QVFI+PjJdID0gZW5kO1xyXG4gIGlmIChlbmQgPj0gVE9UQUxfTUVNT1JZKSB7XHJcbiAgICB2YXIgc3VjY2VzcyA9IGVubGFyZ2VNZW1vcnkoKTtcclxuICAgIGlmICghc3VjY2Vzcykge1xyXG4gICAgICBIRUFQMzJbRFlOQU1JQ1RPUF9QVFI+PjJdID0gcmV0O1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWxpZ25NZW1vcnkoc2l6ZSwgZmFjdG9yKSB7XHJcbiAgaWYgKCFmYWN0b3IpIGZhY3RvciA9IFNUQUNLX0FMSUdOOyAvLyBzdGFjayBhbGlnbm1lbnQgKDE2LWJ5dGUpIGJ5IGRlZmF1bHRcclxuICB2YXIgcmV0ID0gc2l6ZSA9IE1hdGguY2VpbChzaXplIC8gZmFjdG9yKSAqIGZhY3RvcjtcclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXROYXRpdmVUeXBlU2l6ZSh0eXBlKSB7XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlICdpMSc6IGNhc2UgJ2k4JzogcmV0dXJuIDE7XHJcbiAgICBjYXNlICdpMTYnOiByZXR1cm4gMjtcclxuICAgIGNhc2UgJ2kzMic6IHJldHVybiA0O1xyXG4gICAgY2FzZSAnaTY0JzogcmV0dXJuIDg7XHJcbiAgICBjYXNlICdmbG9hdCc6IHJldHVybiA0O1xyXG4gICAgY2FzZSAnZG91YmxlJzogcmV0dXJuIDg7XHJcbiAgICBkZWZhdWx0OiB7XHJcbiAgICAgIGlmICh0eXBlW3R5cGUubGVuZ3RoLTFdID09PSAnKicpIHtcclxuICAgICAgICByZXR1cm4gNDsgLy8gQSBwb2ludGVyXHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZVswXSA9PT0gJ2knKSB7XHJcbiAgICAgICAgdmFyIGJpdHMgPSBwYXJzZUludCh0eXBlLnN1YnN0cigxKSk7XHJcbiAgICAgICAgYXNzZXJ0KGJpdHMgJSA4ID09PSAwKTtcclxuICAgICAgICByZXR1cm4gYml0cyAvIDg7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdhcm5PbmNlKHRleHQpIHtcclxuICBpZiAoIXdhcm5PbmNlLnNob3duKSB3YXJuT25jZS5zaG93biA9IHt9O1xyXG4gIGlmICghd2Fybk9uY2Uuc2hvd25bdGV4dF0pIHtcclxuICAgIHdhcm5PbmNlLnNob3duW3RleHRdID0gMTtcclxuICAgIE1vZHVsZS5wcmludEVycih0ZXh0KTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxudmFyIGZ1bmN0aW9uUG9pbnRlcnMgPSBuZXcgQXJyYXkoMCk7XHJcblxyXG5mdW5jdGlvbiBhZGRGdW5jdGlvbihmdW5jKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvblBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoIWZ1bmN0aW9uUG9pbnRlcnNbaV0pIHtcclxuICAgICAgZnVuY3Rpb25Qb2ludGVyc1tpXSA9IGZ1bmM7XHJcbiAgICAgIHJldHVybiAxICsgaTtcclxuICAgIH1cclxuICB9XHJcbiAgdGhyb3cgJ0ZpbmlzaGVkIHVwIGFsbCByZXNlcnZlZCBmdW5jdGlvbiBwb2ludGVycy4gVXNlIGEgaGlnaGVyIHZhbHVlIGZvciBSRVNFUlZFRF9GVU5DVElPTl9QT0lOVEVSUy4nO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVGdW5jdGlvbihpbmRleCkge1xyXG4gIGZ1bmN0aW9uUG9pbnRlcnNbaW5kZXgtMV0gPSBudWxsO1xyXG59XHJcblxyXG52YXIgZnVuY1dyYXBwZXJzID0ge307XHJcblxyXG5mdW5jdGlvbiBnZXRGdW5jV3JhcHBlcihmdW5jLCBzaWcpIHtcclxuICBpZiAoIWZ1bmMpIHJldHVybjsgLy8gb24gbnVsbCBwb2ludGVyLCByZXR1cm4gdW5kZWZpbmVkXHJcbiAgYXNzZXJ0KHNpZyk7XHJcbiAgaWYgKCFmdW5jV3JhcHBlcnNbc2lnXSkge1xyXG4gICAgZnVuY1dyYXBwZXJzW3NpZ10gPSB7fTtcclxuICB9XHJcbiAgdmFyIHNpZ0NhY2hlID0gZnVuY1dyYXBwZXJzW3NpZ107XHJcbiAgaWYgKCFzaWdDYWNoZVtmdW5jXSkge1xyXG4gICAgLy8gb3B0aW1pemUgYXdheSBhcmd1bWVudHMgdXNhZ2UgaW4gY29tbW9uIGNhc2VzXHJcbiAgICBpZiAoc2lnLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICBzaWdDYWNoZVtmdW5jXSA9IGZ1bmN0aW9uIGR5bkNhbGxfd3JhcHBlcigpIHtcclxuICAgICAgICByZXR1cm4gZHluQ2FsbChzaWcsIGZ1bmMpO1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChzaWcubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIHNpZ0NhY2hlW2Z1bmNdID0gZnVuY3Rpb24gZHluQ2FsbF93cmFwcGVyKGFyZykge1xyXG4gICAgICAgIHJldHVybiBkeW5DYWxsKHNpZywgZnVuYywgW2FyZ10pO1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZ2VuZXJhbCBjYXNlXHJcbiAgICAgIHNpZ0NhY2hlW2Z1bmNdID0gZnVuY3Rpb24gZHluQ2FsbF93cmFwcGVyKCkge1xyXG4gICAgICAgIHJldHVybiBkeW5DYWxsKHNpZywgZnVuYywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBzaWdDYWNoZVtmdW5jXTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIG1ha2VCaWdJbnQobG93LCBoaWdoLCB1bnNpZ25lZCkge1xyXG4gIHJldHVybiB1bnNpZ25lZCA/ICgoKygobG93Pj4+MCkpKSsoKCsoKGhpZ2g+Pj4wKSkpKjQyOTQ5NjcyOTYuMCkpIDogKCgrKChsb3c+Pj4wKSkpKygoKygoaGlnaHwwKSkpKjQyOTQ5NjcyOTYuMCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5DYWxsKHNpZywgcHRyLCBhcmdzKSB7XHJcbiAgaWYgKGFyZ3MgJiYgYXJncy5sZW5ndGgpIHtcclxuICAgIGFzc2VydChhcmdzLmxlbmd0aCA9PSBzaWcubGVuZ3RoLTEpO1xyXG4gICAgYXNzZXJ0KCgnZHluQ2FsbF8nICsgc2lnKSBpbiBNb2R1bGUsICdiYWQgZnVuY3Rpb24gcG9pbnRlciB0eXBlIC0gbm8gdGFibGUgZm9yIHNpZyBcXCcnICsgc2lnICsgJ1xcJycpO1xyXG4gICAgcmV0dXJuIE1vZHVsZVsnZHluQ2FsbF8nICsgc2lnXS5hcHBseShudWxsLCBbcHRyXS5jb25jYXQoYXJncykpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBhc3NlcnQoc2lnLmxlbmd0aCA9PSAxKTtcclxuICAgIGFzc2VydCgoJ2R5bkNhbGxfJyArIHNpZykgaW4gTW9kdWxlLCAnYmFkIGZ1bmN0aW9uIHBvaW50ZXIgdHlwZSAtIG5vIHRhYmxlIGZvciBzaWcgXFwnJyArIHNpZyArICdcXCcnKTtcclxuICAgIHJldHVybiBNb2R1bGVbJ2R5bkNhbGxfJyArIHNpZ10uY2FsbChudWxsLCBwdHIpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldENvbXBpbGVyU2V0dGluZyhuYW1lKSB7XHJcbiAgdGhyb3cgJ1lvdSBtdXN0IGJ1aWxkIHdpdGggLXMgUkVUQUlOX0NPTVBJTEVSX1NFVFRJTkdTPTEgZm9yIGdldENvbXBpbGVyU2V0dGluZyBvciBlbXNjcmlwdGVuX2dldF9jb21waWxlcl9zZXR0aW5nIHRvIHdvcmsnO1xyXG59XHJcblxyXG52YXIgUnVudGltZSA9IHtcclxuICAvLyBGSVhNRSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBsYXllciBmb3IgcG9ydHMuIFN1cHBvcnQgc29tZSBSdW50aW1lLipcclxuICAvLyAgICAgICBmb3Igbm93LCBmaXggaXQgdGhlcmUsIHRoZW4gcmVtb3ZlIGl0IGZyb20gaGVyZS4gVGhhdCB3YXkgd2VcclxuICAvLyAgICAgICBjYW4gbWluaW1pemUgYW55IHBlcmlvZCBvZiBicmVha2FnZS5cclxuICBkeW5DYWxsOiBkeW5DYWxsLCAvLyBmb3IgU0RMMiBwb3J0XHJcbiAgLy8gaGVscGZ1bCBlcnJvcnNcclxuICBnZXRUZW1wUmV0MDogZnVuY3Rpb24oKSB7IGFib3J0KCdnZXRUZW1wUmV0MCgpIGlzIG5vdyBhIHRvcC1sZXZlbCBmdW5jdGlvbiwgYWZ0ZXIgcmVtb3ZpbmcgdGhlIFJ1bnRpbWUgb2JqZWN0LiBSZW1vdmUgXCJSdW50aW1lLlwiJykgfSxcclxuICBzdGF0aWNBbGxvYzogZnVuY3Rpb24oKSB7IGFib3J0KCdzdGF0aWNBbGxvYygpIGlzIG5vdyBhIHRvcC1sZXZlbCBmdW5jdGlvbiwgYWZ0ZXIgcmVtb3ZpbmcgdGhlIFJ1bnRpbWUgb2JqZWN0LiBSZW1vdmUgXCJSdW50aW1lLlwiJykgfSxcclxuICBzdGFja0FsbG9jOiBmdW5jdGlvbigpIHsgYWJvcnQoJ3N0YWNrQWxsb2MoKSBpcyBub3cgYSB0b3AtbGV2ZWwgZnVuY3Rpb24sIGFmdGVyIHJlbW92aW5nIHRoZSBSdW50aW1lIG9iamVjdC4gUmVtb3ZlIFwiUnVudGltZS5cIicpIH0sXHJcbn07XHJcblxyXG4vLyBUaGUgYWRkcmVzcyBnbG9iYWxzIGJlZ2luIGF0LiBWZXJ5IGxvdyBpbiBtZW1vcnksIGZvciBjb2RlIHNpemUgYW5kIG9wdGltaXphdGlvbiBvcHBvcnR1bml0aWVzLlxyXG4vLyBBYm92ZSAwIGlzIHN0YXRpYyBtZW1vcnksIHN0YXJ0aW5nIHdpdGggZ2xvYmFscy5cclxuLy8gVGhlbiB0aGUgc3RhY2suXHJcbi8vIFRoZW4gJ2R5bmFtaWMnIG1lbW9yeSBmb3Igc2Jyay5cclxudmFyIEdMT0JBTF9CQVNFID0gMTAyNDtcclxuXHJcblxyXG5cclxuLy8gPT09IFByZWFtYmxlIGxpYnJhcnkgc3R1ZmYgPT09XHJcblxyXG4vLyBEb2N1bWVudGF0aW9uIGZvciB0aGUgcHVibGljIEFQSXMgZGVmaW5lZCBpbiB0aGlzIGZpbGUgbXVzdCBiZSB1cGRhdGVkIGluOlxyXG4vLyAgICBzaXRlL3NvdXJjZS9kb2NzL2FwaV9yZWZlcmVuY2UvcHJlYW1ibGUuanMucnN0XHJcbi8vIEEgcHJlYnVpbHQgbG9jYWwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgYXQ6XHJcbi8vICAgIHNpdGUvYnVpbGQvdGV4dC9kb2NzL2FwaV9yZWZlcmVuY2UvcHJlYW1ibGUuanMudHh0XHJcbi8vIFlvdSBjYW4gYWxzbyBidWlsZCBkb2NzIGxvY2FsbHkgYXMgSFRNTCBvciBvdGhlciBmb3JtYXRzIGluIHNpdGUvXHJcbi8vIEFuIG9ubGluZSBIVE1MIHZlcnNpb24gKHdoaWNoIG1heSBiZSBvZiBhIGRpZmZlcmVudCB2ZXJzaW9uIG9mIEVtc2NyaXB0ZW4pXHJcbi8vICAgIGlzIHVwIGF0IGh0dHA6Ly9rcmlwa2VuLmdpdGh1Yi5pby9lbXNjcmlwdGVuLXNpdGUvZG9jcy9hcGlfcmVmZXJlbmNlL3ByZWFtYmxlLmpzLmh0bWxcclxuXHJcblxyXG5cclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFJ1bnRpbWUgZXNzZW50aWFsc1xyXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbnZhciBBQk9SVCA9IDA7IC8vIHdoZXRoZXIgd2UgYXJlIHF1aXR0aW5nIHRoZSBhcHBsaWNhdGlvbi4gbm8gY29kZSBzaG91bGQgcnVuIGFmdGVyIHRoaXMuIHNldCBpbiBleGl0KCkgYW5kIGFib3J0KClcclxudmFyIEVYSVRTVEFUVVMgPSAwO1xyXG5cclxuLyoqIEB0eXBlIHtmdW5jdGlvbigqLCBzdHJpbmc9KX0gKi9cclxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgdGV4dCkge1xyXG4gIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICBhYm9ydCgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIHRleHQpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGdsb2JhbFNjb3BlID0gdGhpcztcclxuXHJcbi8vIFJldHVybnMgdGhlIEMgZnVuY3Rpb24gd2l0aCBhIHNwZWNpZmllZCBpZGVudGlmaWVyIChmb3IgQysrLCB5b3UgbmVlZCB0byBkbyBtYW51YWwgbmFtZSBtYW5nbGluZylcclxuZnVuY3Rpb24gZ2V0Q0Z1bmMoaWRlbnQpIHtcclxuICB2YXIgZnVuYyA9IE1vZHVsZVsnXycgKyBpZGVudF07IC8vIGNsb3N1cmUgZXhwb3J0ZWQgZnVuY3Rpb25cclxuICBhc3NlcnQoZnVuYywgJ0Nhbm5vdCBjYWxsIHVua25vd24gZnVuY3Rpb24gJyArIGlkZW50ICsgJywgbWFrZSBzdXJlIGl0IGlzIGV4cG9ydGVkJyk7XHJcbiAgcmV0dXJuIGZ1bmM7XHJcbn1cclxuXHJcbnZhciBKU2Z1bmNzID0ge1xyXG4gIC8vIEhlbHBlcnMgZm9yIGN3cmFwIC0tIGl0IGNhbid0IHJlZmVyIHRvIFJ1bnRpbWUgZGlyZWN0bHkgYmVjYXVzZSBpdCBtaWdodFxyXG4gIC8vIGJlIHJlbmFtZWQgYnkgY2xvc3VyZSwgaW5zdGVhZCBpdCBjYWxscyBKU2Z1bmNzWydzdGFja1NhdmUnXS5ib2R5IHRvIGZpbmRcclxuICAvLyBvdXQgd2hhdCB0aGUgbWluaWZpZWQgZnVuY3Rpb24gbmFtZSBpcy5cclxuICAnc3RhY2tTYXZlJzogZnVuY3Rpb24oKSB7XHJcbiAgICBzdGFja1NhdmUoKVxyXG4gIH0sXHJcbiAgJ3N0YWNrUmVzdG9yZSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgc3RhY2tSZXN0b3JlKClcclxuICB9LFxyXG4gIC8vIHR5cGUgY29udmVyc2lvbiBmcm9tIGpzIHRvIGNcclxuICAnYXJyYXlUb0MnIDogZnVuY3Rpb24oYXJyKSB7XHJcbiAgICB2YXIgcmV0ID0gc3RhY2tBbGxvYyhhcnIubGVuZ3RoKTtcclxuICAgIHdyaXRlQXJyYXlUb01lbW9yeShhcnIsIHJldCk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH0sXHJcbiAgJ3N0cmluZ1RvQycgOiBmdW5jdGlvbihzdHIpIHtcclxuICAgIHZhciByZXQgPSAwO1xyXG4gICAgaWYgKHN0ciAhPT0gbnVsbCAmJiBzdHIgIT09IHVuZGVmaW5lZCAmJiBzdHIgIT09IDApIHsgLy8gbnVsbCBzdHJpbmdcclxuICAgICAgLy8gYXQgbW9zdCA0IGJ5dGVzIHBlciBVVEYtOCBjb2RlIHBvaW50LCArMSBmb3IgdGhlIHRyYWlsaW5nICdcXDAnXHJcbiAgICAgIHZhciBsZW4gPSAoc3RyLmxlbmd0aCA8PCAyKSArIDE7XHJcbiAgICAgIHJldCA9IHN0YWNrQWxsb2MobGVuKTtcclxuICAgICAgc3RyaW5nVG9VVEY4KHN0ciwgcmV0LCBsZW4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9XHJcbn07XHJcbi8vIEZvciBmYXN0IGxvb2t1cCBvZiBjb252ZXJzaW9uIGZ1bmN0aW9uc1xyXG52YXIgdG9DID0geydzdHJpbmcnIDogSlNmdW5jc1snc3RyaW5nVG9DJ10sICdhcnJheScgOiBKU2Z1bmNzWydhcnJheVRvQyddfTtcclxuXHJcbi8vIEMgY2FsbGluZyBpbnRlcmZhY2UuXHJcbmZ1bmN0aW9uIGNjYWxsIChpZGVudCwgcmV0dXJuVHlwZSwgYXJnVHlwZXMsIGFyZ3MsIG9wdHMpIHtcclxuICB2YXIgZnVuYyA9IGdldENGdW5jKGlkZW50KTtcclxuICB2YXIgY0FyZ3MgPSBbXTtcclxuICB2YXIgc3RhY2sgPSAwO1xyXG4gIGFzc2VydChyZXR1cm5UeXBlICE9PSAnYXJyYXknLCAnUmV0dXJuIHR5cGUgc2hvdWxkIG5vdCBiZSBcImFycmF5XCIuJyk7XHJcbiAgaWYgKGFyZ3MpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgY29udmVydGVyID0gdG9DW2FyZ1R5cGVzW2ldXTtcclxuICAgICAgaWYgKGNvbnZlcnRlcikge1xyXG4gICAgICAgIGlmIChzdGFjayA9PT0gMCkgc3RhY2sgPSBzdGFja1NhdmUoKTtcclxuICAgICAgICBjQXJnc1tpXSA9IGNvbnZlcnRlcihhcmdzW2ldKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjQXJnc1tpXSA9IGFyZ3NbaV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgdmFyIHJldCA9IGZ1bmMuYXBwbHkobnVsbCwgY0FyZ3MpO1xyXG4gIGlmIChyZXR1cm5UeXBlID09PSAnc3RyaW5nJykgcmV0ID0gUG9pbnRlcl9zdHJpbmdpZnkocmV0KTtcclxuICBpZiAoc3RhY2sgIT09IDApIHtcclxuICAgIHN0YWNrUmVzdG9yZShzdGFjayk7XHJcbiAgfVxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGN3cmFwIChpZGVudCwgcmV0dXJuVHlwZSwgYXJnVHlwZXMpIHtcclxuICBhcmdUeXBlcyA9IGFyZ1R5cGVzIHx8IFtdO1xyXG4gIHZhciBjZnVuYyA9IGdldENGdW5jKGlkZW50KTtcclxuICAvLyBXaGVuIHRoZSBmdW5jdGlvbiB0YWtlcyBudW1iZXJzIGFuZCByZXR1cm5zIGEgbnVtYmVyLCB3ZSBjYW4ganVzdCByZXR1cm5cclxuICAvLyB0aGUgb3JpZ2luYWwgZnVuY3Rpb25cclxuICB2YXIgbnVtZXJpY0FyZ3MgPSBhcmdUeXBlcy5ldmVyeShmdW5jdGlvbih0eXBlKXsgcmV0dXJuIHR5cGUgPT09ICdudW1iZXInfSk7XHJcbiAgdmFyIG51bWVyaWNSZXQgPSByZXR1cm5UeXBlICE9PSAnc3RyaW5nJztcclxuICBpZiAobnVtZXJpY1JldCAmJiBudW1lcmljQXJncykge1xyXG4gICAgcmV0dXJuIGNmdW5jO1xyXG4gIH1cclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gY2NhbGwoaWRlbnQsIHJldHVyblR5cGUsIGFyZ1R5cGVzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsIG51bWJlciwgc3RyaW5nLCBib29sZWFuPSl9ICovXHJcbmZ1bmN0aW9uIHNldFZhbHVlKHB0ciwgdmFsdWUsIHR5cGUsIG5vU2FmZSkge1xyXG4gIHR5cGUgPSB0eXBlIHx8ICdpOCc7XHJcbiAgaWYgKHR5cGUuY2hhckF0KHR5cGUubGVuZ3RoLTEpID09PSAnKicpIHR5cGUgPSAnaTMyJzsgLy8gcG9pbnRlcnMgYXJlIDMyLWJpdFxyXG4gICAgc3dpdGNoKHR5cGUpIHtcclxuICAgICAgY2FzZSAnaTEnOiBIRUFQOFsoKHB0cik+PjApXT12YWx1ZTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2k4JzogSEVBUDhbKChwdHIpPj4wKV09dmFsdWU7IGJyZWFrO1xyXG4gICAgICBjYXNlICdpMTYnOiBIRUFQMTZbKChwdHIpPj4xKV09dmFsdWU7IGJyZWFrO1xyXG4gICAgICBjYXNlICdpMzInOiBIRUFQMzJbKChwdHIpPj4yKV09dmFsdWU7IGJyZWFrO1xyXG4gICAgICBjYXNlICdpNjQnOiAodGVtcEk2NCA9IFt2YWx1ZT4+PjAsKHRlbXBEb3VibGU9dmFsdWUsKCsoTWF0aF9hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aF9taW4oKCsoTWF0aF9mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aF9jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKChwdHIpPj4yKV09dGVtcEk2NFswXSxIRUFQMzJbKCgocHRyKSsoNCkpPj4yKV09dGVtcEk2NFsxXSk7IGJyZWFrO1xyXG4gICAgICBjYXNlICdmbG9hdCc6IEhFQVBGMzJbKChwdHIpPj4yKV09dmFsdWU7IGJyZWFrO1xyXG4gICAgICBjYXNlICdkb3VibGUnOiBIRUFQRjY0WygocHRyKT4+MyldPXZhbHVlOyBicmVhaztcclxuICAgICAgZGVmYXVsdDogYWJvcnQoJ2ludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICcgKyB0eXBlKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsIHN0cmluZywgYm9vbGVhbj0pfSAqL1xyXG5mdW5jdGlvbiBnZXRWYWx1ZShwdHIsIHR5cGUsIG5vU2FmZSkge1xyXG4gIHR5cGUgPSB0eXBlIHx8ICdpOCc7XHJcbiAgaWYgKHR5cGUuY2hhckF0KHR5cGUubGVuZ3RoLTEpID09PSAnKicpIHR5cGUgPSAnaTMyJzsgLy8gcG9pbnRlcnMgYXJlIDMyLWJpdFxyXG4gICAgc3dpdGNoKHR5cGUpIHtcclxuICAgICAgY2FzZSAnaTEnOiByZXR1cm4gSEVBUDhbKChwdHIpPj4wKV07XHJcbiAgICAgIGNhc2UgJ2k4JzogcmV0dXJuIEhFQVA4WygocHRyKT4+MCldO1xyXG4gICAgICBjYXNlICdpMTYnOiByZXR1cm4gSEVBUDE2WygocHRyKT4+MSldO1xyXG4gICAgICBjYXNlICdpMzInOiByZXR1cm4gSEVBUDMyWygocHRyKT4+MildO1xyXG4gICAgICBjYXNlICdpNjQnOiByZXR1cm4gSEVBUDMyWygocHRyKT4+MildO1xyXG4gICAgICBjYXNlICdmbG9hdCc6IHJldHVybiBIRUFQRjMyWygocHRyKT4+MildO1xyXG4gICAgICBjYXNlICdkb3VibGUnOiByZXR1cm4gSEVBUEY2NFsoKHB0cik+PjMpXTtcclxuICAgICAgZGVmYXVsdDogYWJvcnQoJ2ludmFsaWQgdHlwZSBmb3IgZ2V0VmFsdWU6ICcgKyB0eXBlKTtcclxuICAgIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxudmFyIEFMTE9DX05PUk1BTCA9IDA7IC8vIFRyaWVzIHRvIHVzZSBfbWFsbG9jKClcclxudmFyIEFMTE9DX1NUQUNLID0gMTsgLy8gTGl2ZXMgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgY3VycmVudCBmdW5jdGlvbiBjYWxsXHJcbnZhciBBTExPQ19TVEFUSUMgPSAyOyAvLyBDYW5ub3QgYmUgZnJlZWRcclxudmFyIEFMTE9DX0RZTkFNSUMgPSAzOyAvLyBDYW5ub3QgYmUgZnJlZWQgZXhjZXB0IHRocm91Z2ggc2Jya1xyXG52YXIgQUxMT0NfTk9ORSA9IDQ7IC8vIERvIG5vdCBhbGxvY2F0ZVxyXG5cclxuLy8gYWxsb2NhdGUoKTogVGhpcyBpcyBmb3IgaW50ZXJuYWwgdXNlLiBZb3UgY2FuIHVzZSBpdCB5b3Vyc2VsZiBhcyB3ZWxsLCBidXQgdGhlIGludGVyZmFjZVxyXG4vLyAgICAgICAgICAgICBpcyBhIGxpdHRsZSB0cmlja3kgKHNlZSBkb2NzIHJpZ2h0IGJlbG93KS4gVGhlIHJlYXNvbiBpcyB0aGF0IGl0IGlzIG9wdGltaXplZFxyXG4vLyAgICAgICAgICAgICBmb3IgbXVsdGlwbGUgc3ludGF4ZXMgdG8gc2F2ZSBzcGFjZSBpbiBnZW5lcmF0ZWQgY29kZS4gU28geW91IHNob3VsZFxyXG4vLyAgICAgICAgICAgICBub3JtYWxseSBub3QgdXNlIGFsbG9jYXRlKCksIGFuZCBpbnN0ZWFkIGFsbG9jYXRlIG1lbW9yeSB1c2luZyBfbWFsbG9jKCksXHJcbi8vICAgICAgICAgICAgIGluaXRpYWxpemUgaXQgd2l0aCBzZXRWYWx1ZSgpLCBhbmQgc28gZm9ydGguXHJcbi8vIEBzbGFiOiBBbiBhcnJheSBvZiBkYXRhLCBvciBhIG51bWJlci4gSWYgYSBudW1iZXIsIHRoZW4gdGhlIHNpemUgb2YgdGhlIGJsb2NrIHRvIGFsbG9jYXRlLFxyXG4vLyAgICAgICAgaW4gKmJ5dGVzKiAobm90ZSB0aGF0IHRoaXMgaXMgc29tZXRpbWVzIGNvbmZ1c2luZzogdGhlIG5leHQgcGFyYW1ldGVyIGRvZXMgbm90XHJcbi8vICAgICAgICBhZmZlY3QgdGhpcyEpXHJcbi8vIEB0eXBlczogRWl0aGVyIGFuIGFycmF5IG9mIHR5cGVzLCBvbmUgZm9yIGVhY2ggYnl0ZSAob3IgMCBpZiBubyB0eXBlIGF0IHRoYXQgcG9zaXRpb24pLFxyXG4vLyAgICAgICAgIG9yIGEgc2luZ2xlIHR5cGUgd2hpY2ggaXMgdXNlZCBmb3IgdGhlIGVudGlyZSBibG9jay4gVGhpcyBvbmx5IG1hdHRlcnMgaWYgdGhlcmVcclxuLy8gICAgICAgICBpcyBpbml0aWFsIGRhdGEgLSBpZiBAc2xhYiBpcyBhIG51bWJlciwgdGhlbiB0aGlzIGRvZXMgbm90IG1hdHRlciBhdCBhbGwgYW5kIGlzXHJcbi8vICAgICAgICAgaWdub3JlZC5cclxuLy8gQGFsbG9jYXRvcjogSG93IHRvIGFsbG9jYXRlIG1lbW9yeSwgc2VlIEFMTE9DXypcclxuLyoqIEB0eXBlIHtmdW5jdGlvbigoVHlwZWRBcnJheXxBcnJheTxudW1iZXI+fG51bWJlciksIHN0cmluZywgbnVtYmVyLCBudW1iZXI9KX0gKi9cclxuZnVuY3Rpb24gYWxsb2NhdGUoc2xhYiwgdHlwZXMsIGFsbG9jYXRvciwgcHRyKSB7XHJcbiAgdmFyIHplcm9pbml0LCBzaXplO1xyXG4gIGlmICh0eXBlb2Ygc2xhYiA9PT0gJ251bWJlcicpIHtcclxuICAgIHplcm9pbml0ID0gdHJ1ZTtcclxuICAgIHNpemUgPSBzbGFiO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB6ZXJvaW5pdCA9IGZhbHNlO1xyXG4gICAgc2l6ZSA9IHNsYWIubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgdmFyIHNpbmdsZVR5cGUgPSB0eXBlb2YgdHlwZXMgPT09ICdzdHJpbmcnID8gdHlwZXMgOiBudWxsO1xyXG5cclxuICB2YXIgcmV0O1xyXG4gIGlmIChhbGxvY2F0b3IgPT0gQUxMT0NfTk9ORSkge1xyXG4gICAgcmV0ID0gcHRyO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXQgPSBbdHlwZW9mIF9tYWxsb2MgPT09ICdmdW5jdGlvbicgPyBfbWFsbG9jIDogc3RhdGljQWxsb2MsIHN0YWNrQWxsb2MsIHN0YXRpY0FsbG9jLCBkeW5hbWljQWxsb2NdW2FsbG9jYXRvciA9PT0gdW5kZWZpbmVkID8gQUxMT0NfU1RBVElDIDogYWxsb2NhdG9yXShNYXRoLm1heChzaXplLCBzaW5nbGVUeXBlID8gMSA6IHR5cGVzLmxlbmd0aCkpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHplcm9pbml0KSB7XHJcbiAgICB2YXIgc3RvcDtcclxuICAgIHB0ciA9IHJldDtcclxuICAgIGFzc2VydCgocmV0ICYgMykgPT0gMCk7XHJcbiAgICBzdG9wID0gcmV0ICsgKHNpemUgJiB+Myk7XHJcbiAgICBmb3IgKDsgcHRyIDwgc3RvcDsgcHRyICs9IDQpIHtcclxuICAgICAgSEVBUDMyWygocHRyKT4+MildPTA7XHJcbiAgICB9XHJcbiAgICBzdG9wID0gcmV0ICsgc2l6ZTtcclxuICAgIHdoaWxlIChwdHIgPCBzdG9wKSB7XHJcbiAgICAgIEhFQVA4WygocHRyKyspPj4wKV09MDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfVxyXG5cclxuICBpZiAoc2luZ2xlVHlwZSA9PT0gJ2k4Jykge1xyXG4gICAgaWYgKHNsYWIuc3ViYXJyYXkgfHwgc2xhYi5zbGljZSkge1xyXG4gICAgICBIRUFQVTguc2V0KC8qKiBAdHlwZSB7IVVpbnQ4QXJyYXl9ICovIChzbGFiKSwgcmV0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIEhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoc2xhYiksIHJldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH1cclxuXHJcbiAgdmFyIGkgPSAwLCB0eXBlLCB0eXBlU2l6ZSwgcHJldmlvdXNUeXBlO1xyXG4gIHdoaWxlIChpIDwgc2l6ZSkge1xyXG4gICAgdmFyIGN1cnIgPSBzbGFiW2ldO1xyXG5cclxuICAgIHR5cGUgPSBzaW5nbGVUeXBlIHx8IHR5cGVzW2ldO1xyXG4gICAgaWYgKHR5cGUgPT09IDApIHtcclxuICAgICAgaSsrO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGFzc2VydCh0eXBlLCAnTXVzdCBrbm93IHdoYXQgdHlwZSB0byBzdG9yZSBpbiBhbGxvY2F0ZSEnKTtcclxuXHJcbiAgICBpZiAodHlwZSA9PSAnaTY0JykgdHlwZSA9ICdpMzInOyAvLyBzcGVjaWFsIGNhc2U6IHdlIGhhdmUgb25lIGkzMiBoZXJlLCBhbmQgb25lIGkzMiBsYXRlclxyXG5cclxuICAgIHNldFZhbHVlKHJldCtpLCBjdXJyLCB0eXBlKTtcclxuXHJcbiAgICAvLyBubyBuZWVkIHRvIGxvb2sgdXAgc2l6ZSB1bmxlc3MgdHlwZSBjaGFuZ2VzLCBzbyBjYWNoZSBpdFxyXG4gICAgaWYgKHByZXZpb3VzVHlwZSAhPT0gdHlwZSkge1xyXG4gICAgICB0eXBlU2l6ZSA9IGdldE5hdGl2ZVR5cGVTaXplKHR5cGUpO1xyXG4gICAgICBwcmV2aW91c1R5cGUgPSB0eXBlO1xyXG4gICAgfVxyXG4gICAgaSArPSB0eXBlU2l6ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vIEFsbG9jYXRlIG1lbW9yeSBkdXJpbmcgYW55IHN0YWdlIG9mIHN0YXJ0dXAgLSBzdGF0aWMgbWVtb3J5IGVhcmx5IG9uLCBkeW5hbWljIG1lbW9yeSBsYXRlciwgbWFsbG9jIHdoZW4gcmVhZHlcclxuZnVuY3Rpb24gZ2V0TWVtb3J5KHNpemUpIHtcclxuICBpZiAoIXN0YXRpY1NlYWxlZCkgcmV0dXJuIHN0YXRpY0FsbG9jKHNpemUpO1xyXG4gIGlmICghcnVudGltZUluaXRpYWxpemVkKSByZXR1cm4gZHluYW1pY0FsbG9jKHNpemUpO1xyXG4gIHJldHVybiBfbWFsbG9jKHNpemUpO1xyXG59XHJcblxyXG4vKiogQHR5cGUge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyPSl9ICovXHJcbmZ1bmN0aW9uIFBvaW50ZXJfc3RyaW5naWZ5KHB0ciwgbGVuZ3RoKSB7XHJcbiAgaWYgKGxlbmd0aCA9PT0gMCB8fCAhcHRyKSByZXR1cm4gJyc7XHJcbiAgLy8gVE9ETzogdXNlIFRleHREZWNvZGVyXHJcbiAgLy8gRmluZCB0aGUgbGVuZ3RoLCBhbmQgY2hlY2sgZm9yIFVURiB3aGlsZSBkb2luZyBzb1xyXG4gIHZhciBoYXNVdGYgPSAwO1xyXG4gIHZhciB0O1xyXG4gIHZhciBpID0gMDtcclxuICB3aGlsZSAoMSkge1xyXG4gICAgYXNzZXJ0KHB0ciArIGkgPCBUT1RBTF9NRU1PUlkpO1xyXG4gICAgdCA9IEhFQVBVOFsoKChwdHIpKyhpKSk+PjApXTtcclxuICAgIGhhc1V0ZiB8PSB0O1xyXG4gICAgaWYgKHQgPT0gMCAmJiAhbGVuZ3RoKSBicmVhaztcclxuICAgIGkrKztcclxuICAgIGlmIChsZW5ndGggJiYgaSA9PSBsZW5ndGgpIGJyZWFrO1xyXG4gIH1cclxuICBpZiAoIWxlbmd0aCkgbGVuZ3RoID0gaTtcclxuXHJcbiAgdmFyIHJldCA9ICcnO1xyXG5cclxuICBpZiAoaGFzVXRmIDwgMTI4KSB7XHJcbiAgICB2YXIgTUFYX0NIVU5LID0gMTAyNDsgLy8gc3BsaXQgdXAgaW50byBjaHVua3MsIGJlY2F1c2UgLmFwcGx5IG9uIGEgaHVnZSBzdHJpbmcgY2FuIG92ZXJmbG93IHRoZSBzdGFja1xyXG4gICAgdmFyIGN1cnI7XHJcbiAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xyXG4gICAgICBjdXJyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIEhFQVBVOC5zdWJhcnJheShwdHIsIHB0ciArIE1hdGgubWluKGxlbmd0aCwgTUFYX0NIVU5LKSkpO1xyXG4gICAgICByZXQgPSByZXQgPyByZXQgKyBjdXJyIDogY3VycjtcclxuICAgICAgcHRyICs9IE1BWF9DSFVOSztcclxuICAgICAgbGVuZ3RoIC09IE1BWF9DSFVOSztcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfVxyXG4gIHJldHVybiBVVEY4VG9TdHJpbmcocHRyKTtcclxufVxyXG5cclxuLy8gR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIEFTQ0lJLWVuY29kZWQgc3RyaW5nIGluIHRoZSBlbXNjcmlwdGVuIEhFQVAsIHJldHVybnNcclxuLy8gYSBjb3B5IG9mIHRoYXQgc3RyaW5nIGFzIGEgSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0LlxyXG5cclxuZnVuY3Rpb24gQXNjaWlUb1N0cmluZyhwdHIpIHtcclxuICB2YXIgc3RyID0gJyc7XHJcbiAgd2hpbGUgKDEpIHtcclxuICAgIHZhciBjaCA9IEhFQVA4WygocHRyKyspPj4wKV07XHJcbiAgICBpZiAoIWNoKSByZXR1cm4gc3RyO1xyXG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQ29waWVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QgJ3N0cicgdG8gdGhlIGVtc2NyaXB0ZW4gSEVBUCBhdCBhZGRyZXNzICdvdXRQdHInLFxyXG4vLyBudWxsLXRlcm1pbmF0ZWQgYW5kIGVuY29kZWQgaW4gQVNDSUkgZm9ybS4gVGhlIGNvcHkgd2lsbCByZXF1aXJlIGF0IG1vc3Qgc3RyLmxlbmd0aCsxIGJ5dGVzIG9mIHNwYWNlIGluIHRoZSBIRUFQLlxyXG5cclxuZnVuY3Rpb24gc3RyaW5nVG9Bc2NpaShzdHIsIG91dFB0cikge1xyXG4gIHJldHVybiB3cml0ZUFzY2lpVG9NZW1vcnkoc3RyLCBvdXRQdHIsIGZhbHNlKTtcclxufVxyXG5cclxuLy8gR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjgtZW5jb2RlZCBzdHJpbmcgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgY29udGFpbnMgdWludDggdmFsdWVzLCByZXR1cm5zXHJcbi8vIGEgY29weSBvZiB0aGF0IHN0cmluZyBhcyBhIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdC5cclxuXHJcbnZhciBVVEY4RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSA6IHVuZGVmaW5lZDtcclxuZnVuY3Rpb24gVVRGOEFycmF5VG9TdHJpbmcodThBcnJheSwgaWR4KSB7XHJcbiAgdmFyIGVuZFB0ciA9IGlkeDtcclxuICAvLyBUZXh0RGVjb2RlciBuZWVkcyB0byBrbm93IHRoZSBieXRlIGxlbmd0aCBpbiBhZHZhbmNlLCBpdCBkb2Vzbid0IHN0b3Agb24gbnVsbCB0ZXJtaW5hdG9yIGJ5IGl0c2VsZi5cclxuICAvLyBBbHNvLCB1c2UgdGhlIGxlbmd0aCBpbmZvIHRvIGF2b2lkIHJ1bm5pbmcgdGlueSBzdHJpbmdzIHRocm91Z2ggVGV4dERlY29kZXIsIHNpbmNlIC5zdWJhcnJheSgpIGFsbG9jYXRlcyBnYXJiYWdlLlxyXG4gIHdoaWxlICh1OEFycmF5W2VuZFB0cl0pICsrZW5kUHRyO1xyXG5cclxuICBpZiAoZW5kUHRyIC0gaWR4ID4gMTYgJiYgdThBcnJheS5zdWJhcnJheSAmJiBVVEY4RGVjb2Rlcikge1xyXG4gICAgcmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZSh1OEFycmF5LnN1YmFycmF5KGlkeCwgZW5kUHRyKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciB1MCwgdTEsIHUyLCB1MywgdTQsIHU1O1xyXG5cclxuICAgIHZhciBzdHIgPSAnJztcclxuICAgIHdoaWxlICgxKSB7XHJcbiAgICAgIC8vIEZvciBVVEY4IGJ5dGUgc3RydWN0dXJlLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvbiBhbmQgaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIyNzkudHh0IGFuZCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzYyOVxyXG4gICAgICB1MCA9IHU4QXJyYXlbaWR4KytdO1xyXG4gICAgICBpZiAoIXUwKSByZXR1cm4gc3RyO1xyXG4gICAgICBpZiAoISh1MCAmIDB4ODApKSB7IHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTsgY29udGludWU7IH1cclxuICAgICAgdTEgPSB1OEFycmF5W2lkeCsrXSAmIDYzO1xyXG4gICAgICBpZiAoKHUwICYgMHhFMCkgPT0gMHhDMCkgeyBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpOyBjb250aW51ZTsgfVxyXG4gICAgICB1MiA9IHU4QXJyYXlbaWR4KytdICYgNjM7XHJcbiAgICAgIGlmICgodTAgJiAweEYwKSA9PSAweEUwKSB7XHJcbiAgICAgICAgdTAgPSAoKHUwICYgMTUpIDw8IDEyKSB8ICh1MSA8PCA2KSB8IHUyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHUzID0gdThBcnJheVtpZHgrK10gJiA2MztcclxuICAgICAgICBpZiAoKHUwICYgMHhGOCkgPT0gMHhGMCkge1xyXG4gICAgICAgICAgdTAgPSAoKHUwICYgNykgPDwgMTgpIHwgKHUxIDw8IDEyKSB8ICh1MiA8PCA2KSB8IHUzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB1NCA9IHU4QXJyYXlbaWR4KytdICYgNjM7XHJcbiAgICAgICAgICBpZiAoKHUwICYgMHhGQykgPT0gMHhGOCkge1xyXG4gICAgICAgICAgICB1MCA9ICgodTAgJiAzKSA8PCAyNCkgfCAodTEgPDwgMTgpIHwgKHUyIDw8IDEyKSB8ICh1MyA8PCA2KSB8IHU0O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdTUgPSB1OEFycmF5W2lkeCsrXSAmIDYzO1xyXG4gICAgICAgICAgICB1MCA9ICgodTAgJiAxKSA8PCAzMCkgfCAodTEgPDwgMjQpIHwgKHUyIDw8IDE4KSB8ICh1MyA8PCAxMikgfCAodTQgPDwgNikgfCB1NTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHUwIDwgMHgxMDAwMCkge1xyXG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgY2ggPSB1MCAtIDB4MTAwMDA7XHJcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwIHwgKGNoID4+IDEwKSwgMHhEQzAwIHwgKGNoICYgMHgzRkYpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjgtZW5jb2RlZCBzdHJpbmcgaW4gdGhlIGVtc2NyaXB0ZW4gSEVBUCwgcmV0dXJuc1xyXG4vLyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXHJcblxyXG5mdW5jdGlvbiBVVEY4VG9TdHJpbmcocHRyKSB7XHJcbiAgcmV0dXJuIFVURjhBcnJheVRvU3RyaW5nKEhFQVBVOCxwdHIpO1xyXG59XHJcblxyXG4vLyBDb3BpZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdCAnc3RyJyB0byB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSBhdCBhZGRyZXNzICdvdXRJZHgnLFxyXG4vLyBlbmNvZGVkIGluIFVURjggZm9ybSBhbmQgbnVsbC10ZXJtaW5hdGVkLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrMSBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cclxuLy8gVXNlIHRoZSBmdW5jdGlvbiBsZW5ndGhCeXRlc1VURjggdG8gY29tcHV0ZSB0aGUgZXhhY3QgbnVtYmVyIG9mIGJ5dGVzIChleGNsdWRpbmcgbnVsbCB0ZXJtaW5hdG9yKSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCB3cml0ZS5cclxuLy8gUGFyYW1ldGVyczpcclxuLy8gICBzdHI6IHRoZSBKYXZhc2NyaXB0IHN0cmluZyB0byBjb3B5LlxyXG4vLyAgIG91dFU4QXJyYXk6IHRoZSBhcnJheSB0byBjb3B5IHRvLiBFYWNoIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgYXNzdW1lZCB0byBiZSBvbmUgOC1ieXRlIGVsZW1lbnQuXHJcbi8vICAgb3V0SWR4OiBUaGUgc3RhcnRpbmcgb2Zmc2V0IGluIHRoZSBhcnJheSB0byBiZWdpbiB0aGUgY29weWluZy5cclxuLy8gICBtYXhCeXRlc1RvV3JpdGU6IFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0aGlzIGZ1bmN0aW9uIGNhbiB3cml0ZSB0byB0aGUgYXJyYXkuIFRoaXMgY291bnQgc2hvdWxkIGluY2x1ZGUgdGhlIG51bGxcclxuLy8gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0b3IsIGkuZS4gaWYgbWF4Qnl0ZXNUb1dyaXRlPTEsIG9ubHkgdGhlIG51bGwgdGVybWluYXRvciB3aWxsIGJlIHdyaXR0ZW4gYW5kIG5vdGhpbmcgZWxzZS5cclxuLy8gICAgICAgICAgICAgICAgICAgIG1heEJ5dGVzVG9Xcml0ZT0wIGRvZXMgbm90IHdyaXRlIGFueSBieXRlcyB0byB0aGUgb3V0cHV0LCBub3QgZXZlbiB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IuXHJcblxyXG5mdW5jdGlvbiBzdHJpbmdUb1VURjhBcnJheShzdHIsIG91dFU4QXJyYXksIG91dElkeCwgbWF4Qnl0ZXNUb1dyaXRlKSB7XHJcbiAgaWYgKCEobWF4Qnl0ZXNUb1dyaXRlID4gMCkpIC8vIFBhcmFtZXRlciBtYXhCeXRlc1RvV3JpdGUgaXMgbm90IG9wdGlvbmFsLiBOZWdhdGl2ZSB2YWx1ZXMsIDAsIG51bGwsIHVuZGVmaW5lZCBhbmQgZmFsc2UgZWFjaCBkb24ndCB3cml0ZSBvdXQgYW55IGJ5dGVzLlxyXG4gICAgcmV0dXJuIDA7XHJcblxyXG4gIHZhciBzdGFydElkeCA9IG91dElkeDtcclxuICB2YXIgZW5kSWR4ID0gb3V0SWR4ICsgbWF4Qnl0ZXNUb1dyaXRlIC0gMTsgLy8gLTEgZm9yIHN0cmluZyBudWxsIHRlcm1pbmF0b3IuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcclxuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFNvIGRlY29kZSBVVEYxNi0+VVRGMzItPlVURjguXHJcbiAgICAvLyBTZWUgaHR0cDovL3VuaWNvZGUub3JnL2ZhcS91dGZfYm9tLmh0bWwjdXRmMTYtM1xyXG4gICAgLy8gRm9yIFVURjggYnl0ZSBzdHJ1Y3R1cmUsIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uIGFuZCBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjI3OS50eHQgYW5kIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNjI5XHJcbiAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXHJcbiAgICBpZiAodSA+PSAweEQ4MDAgJiYgdSA8PSAweERGRkYpIHUgPSAweDEwMDAwICsgKCh1ICYgMHgzRkYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzRkYpO1xyXG4gICAgaWYgKHUgPD0gMHg3Rikge1xyXG4gICAgICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gdTtcclxuICAgIH0gZWxzZSBpZiAodSA8PSAweDdGRikge1xyXG4gICAgICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xyXG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4QzAgfCAodSA+PiA2KTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XHJcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHhGRkZGKSB7XHJcbiAgICAgIGlmIChvdXRJZHggKyAyID49IGVuZElkeCkgYnJlYWs7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHhFMCB8ICh1ID4+IDEyKTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgNjMpO1xyXG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcclxuICAgIH0gZWxzZSBpZiAodSA8PSAweDFGRkZGRikge1xyXG4gICAgICBpZiAob3V0SWR4ICsgMyA+PSBlbmRJZHgpIGJyZWFrO1xyXG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4RjAgfCAodSA+PiAxOCk7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiA2Myk7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XHJcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHgzRkZGRkZGKSB7XHJcbiAgICAgIGlmIChvdXRJZHggKyA0ID49IGVuZElkeCkgYnJlYWs7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHhGOCB8ICh1ID4+IDI0KTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDE4KSAmIDYzKTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDEyKSAmIDYzKTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgNjMpO1xyXG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChvdXRJZHggKyA1ID49IGVuZElkeCkgYnJlYWs7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHhGQyB8ICh1ID4+IDMwKTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDI0KSAmIDYzKTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDE4KSAmIDYzKTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDEyKSAmIDYzKTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgNjMpO1xyXG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gTnVsbC10ZXJtaW5hdGUgdGhlIHBvaW50ZXIgdG8gdGhlIGJ1ZmZlci5cclxuICBvdXRVOEFycmF5W291dElkeF0gPSAwO1xyXG4gIHJldHVybiBvdXRJZHggLSBzdGFydElkeDtcclxufVxyXG5cclxuLy8gQ29waWVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QgJ3N0cicgdG8gdGhlIGVtc2NyaXB0ZW4gSEVBUCBhdCBhZGRyZXNzICdvdXRQdHInLFxyXG4vLyBudWxsLXRlcm1pbmF0ZWQgYW5kIGVuY29kZWQgaW4gVVRGOCBmb3JtLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrMSBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cclxuLy8gVXNlIHRoZSBmdW5jdGlvbiBsZW5ndGhCeXRlc1VURjggdG8gY29tcHV0ZSB0aGUgZXhhY3QgbnVtYmVyIG9mIGJ5dGVzIChleGNsdWRpbmcgbnVsbCB0ZXJtaW5hdG9yKSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCB3cml0ZS5cclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxyXG5cclxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcclxuICBhc3NlcnQodHlwZW9mIG1heEJ5dGVzVG9Xcml0ZSA9PSAnbnVtYmVyJywgJ3N0cmluZ1RvVVRGOChzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSBpcyBtaXNzaW5nIHRoZSB0aGlyZCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IGJ1ZmZlciEnKTtcclxuICByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xyXG59XHJcblxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgc3RyaW5nIHRha2VzIGlmIGVuY29kZWQgYXMgYSBVVEY4IGJ5dGUgYXJyYXksIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yIGJ5dGUuXHJcblxyXG5mdW5jdGlvbiBsZW5ndGhCeXRlc1VURjgoc3RyKSB7XHJcbiAgdmFyIGxlbiA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcclxuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFNvIGRlY29kZSBVVEYxNi0+VVRGMzItPlVURjguXHJcbiAgICAvLyBTZWUgaHR0cDovL3VuaWNvZGUub3JnL2ZhcS91dGZfYm9tLmh0bWwjdXRmMTYtM1xyXG4gICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZVxyXG4gICAgaWYgKHUgPj0gMHhEODAwICYmIHUgPD0gMHhERkZGKSB1ID0gMHgxMDAwMCArICgodSAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M0ZGKTtcclxuICAgIGlmICh1IDw9IDB4N0YpIHtcclxuICAgICAgKytsZW47XHJcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHg3RkYpIHtcclxuICAgICAgbGVuICs9IDI7XHJcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHhGRkZGKSB7XHJcbiAgICAgIGxlbiArPSAzO1xyXG4gICAgfSBlbHNlIGlmICh1IDw9IDB4MUZGRkZGKSB7XHJcbiAgICAgIGxlbiArPSA0O1xyXG4gICAgfSBlbHNlIGlmICh1IDw9IDB4M0ZGRkZGRikge1xyXG4gICAgICBsZW4gKz0gNTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxlbiArPSA2O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbGVuO1xyXG59XHJcblxyXG4vLyBHaXZlbiBhIHBvaW50ZXIgJ3B0cicgdG8gYSBudWxsLXRlcm1pbmF0ZWQgVVRGMTZMRS1lbmNvZGVkIHN0cmluZyBpbiB0aGUgZW1zY3JpcHRlbiBIRUFQLCByZXR1cm5zXHJcbi8vIGEgY29weSBvZiB0aGF0IHN0cmluZyBhcyBhIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdC5cclxuXHJcbnZhciBVVEYxNkRlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHREZWNvZGVyKCd1dGYtMTZsZScpIDogdW5kZWZpbmVkO1xyXG5mdW5jdGlvbiBVVEYxNlRvU3RyaW5nKHB0cikge1xyXG4gIGFzc2VydChwdHIgJSAyID09IDAsICdQb2ludGVyIHBhc3NlZCB0byBVVEYxNlRvU3RyaW5nIG11c3QgYmUgYWxpZ25lZCB0byB0d28gYnl0ZXMhJyk7XHJcbiAgdmFyIGVuZFB0ciA9IHB0cjtcclxuICAvLyBUZXh0RGVjb2RlciBuZWVkcyB0byBrbm93IHRoZSBieXRlIGxlbmd0aCBpbiBhZHZhbmNlLCBpdCBkb2Vzbid0IHN0b3Agb24gbnVsbCB0ZXJtaW5hdG9yIGJ5IGl0c2VsZi5cclxuICAvLyBBbHNvLCB1c2UgdGhlIGxlbmd0aCBpbmZvIHRvIGF2b2lkIHJ1bm5pbmcgdGlueSBzdHJpbmdzIHRocm91Z2ggVGV4dERlY29kZXIsIHNpbmNlIC5zdWJhcnJheSgpIGFsbG9jYXRlcyBnYXJiYWdlLlxyXG4gIHZhciBpZHggPSBlbmRQdHIgPj4gMTtcclxuICB3aGlsZSAoSEVBUDE2W2lkeF0pICsraWR4O1xyXG4gIGVuZFB0ciA9IGlkeCA8PCAxO1xyXG5cclxuICBpZiAoZW5kUHRyIC0gcHRyID4gMzIgJiYgVVRGMTZEZWNvZGVyKSB7XHJcbiAgICByZXR1cm4gVVRGMTZEZWNvZGVyLmRlY29kZShIRUFQVTguc3ViYXJyYXkocHRyLCBlbmRQdHIpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGkgPSAwO1xyXG5cclxuICAgIHZhciBzdHIgPSAnJztcclxuICAgIHdoaWxlICgxKSB7XHJcbiAgICAgIHZhciBjb2RlVW5pdCA9IEhFQVAxNlsoKChwdHIpKyhpKjIpKT4+MSldO1xyXG4gICAgICBpZiAoY29kZVVuaXQgPT0gMCkgcmV0dXJuIHN0cjtcclxuICAgICAgKytpO1xyXG4gICAgICAvLyBmcm9tQ2hhckNvZGUgY29uc3RydWN0cyBhIGNoYXJhY3RlciBmcm9tIGEgVVRGLTE2IGNvZGUgdW5pdCwgc28gd2UgY2FuIHBhc3MgdGhlIFVURjE2IHN0cmluZyByaWdodCB0aHJvdWdoLlxyXG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlVW5pdCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDb3BpZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdCAnc3RyJyB0byB0aGUgZW1zY3JpcHRlbiBIRUFQIGF0IGFkZHJlc3MgJ291dFB0cicsXHJcbi8vIG51bGwtdGVybWluYXRlZCBhbmQgZW5jb2RlZCBpbiBVVEYxNiBmb3JtLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrMiBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cclxuLy8gVXNlIHRoZSBmdW5jdGlvbiBsZW5ndGhCeXRlc1VURjE2KCkgdG8gY29tcHV0ZSB0aGUgZXhhY3QgbnVtYmVyIG9mIGJ5dGVzIChleGNsdWRpbmcgbnVsbCB0ZXJtaW5hdG9yKSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCB3cml0ZS5cclxuLy8gUGFyYW1ldGVyczpcclxuLy8gICBzdHI6IHRoZSBKYXZhc2NyaXB0IHN0cmluZyB0byBjb3B5LlxyXG4vLyAgIG91dFB0cjogQnl0ZSBhZGRyZXNzIGluIEVtc2NyaXB0ZW4gSEVBUCB3aGVyZSB0byB3cml0ZSB0aGUgc3RyaW5nIHRvLlxyXG4vLyAgIG1heEJ5dGVzVG9Xcml0ZTogVGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRoaXMgZnVuY3Rpb24gY2FuIHdyaXRlIHRvIHRoZSBhcnJheS4gVGhpcyBjb3VudCBzaG91bGQgaW5jbHVkZSB0aGUgbnVsbFxyXG4vLyAgICAgICAgICAgICAgICAgICAgdGVybWluYXRvciwgaS5lLiBpZiBtYXhCeXRlc1RvV3JpdGU9Miwgb25seSB0aGUgbnVsbCB0ZXJtaW5hdG9yIHdpbGwgYmUgd3JpdHRlbiBhbmQgbm90aGluZyBlbHNlLlxyXG4vLyAgICAgICAgICAgICAgICAgICAgbWF4Qnl0ZXNUb1dyaXRlPDIgZG9lcyBub3Qgd3JpdGUgYW55IGJ5dGVzIHRvIHRoZSBvdXRwdXQsIG5vdCBldmVuIHRoZSBudWxsIHRlcm1pbmF0b3IuXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBFWENMVURJTkcgdGhlIG51bGwgdGVybWluYXRvci5cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ1RvVVRGMTYoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkge1xyXG4gIGFzc2VydChvdXRQdHIgJSAyID09IDAsICdQb2ludGVyIHBhc3NlZCB0byBzdHJpbmdUb1VURjE2IG11c3QgYmUgYWxpZ25lZCB0byB0d28gYnl0ZXMhJyk7XHJcbiAgYXNzZXJ0KHR5cGVvZiBtYXhCeXRlc1RvV3JpdGUgPT0gJ251bWJlcicsICdzdHJpbmdUb1VURjE2KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIGlzIG1pc3NpbmcgdGhlIHRoaXJkIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgYnVmZmVyIScpO1xyXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpZiBtYXggYnl0ZXMgaXMgbm90IHNwZWNpZmllZCwgYXNzdW1lIHVuc2FmZSB1bmJvdW5kZWQgd3JpdGUgaXMgYWxsb3dlZC5cclxuICBpZiAobWF4Qnl0ZXNUb1dyaXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgIG1heEJ5dGVzVG9Xcml0ZSA9IDB4N0ZGRkZGRkY7XHJcbiAgfVxyXG4gIGlmIChtYXhCeXRlc1RvV3JpdGUgPCAyKSByZXR1cm4gMDtcclxuICBtYXhCeXRlc1RvV3JpdGUgLT0gMjsgLy8gTnVsbCB0ZXJtaW5hdG9yLlxyXG4gIHZhciBzdGFydFB0ciA9IG91dFB0cjtcclxuICB2YXIgbnVtQ2hhcnNUb1dyaXRlID0gKG1heEJ5dGVzVG9Xcml0ZSA8IHN0ci5sZW5ndGgqMikgPyAobWF4Qnl0ZXNUb1dyaXRlIC8gMikgOiBzdHIubGVuZ3RoO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ2hhcnNUb1dyaXRlOyArK2kpIHtcclxuICAgIC8vIGNoYXJDb2RlQXQgcmV0dXJucyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgc28gaXQgY2FuIGJlIGRpcmVjdGx5IHdyaXR0ZW4gdG8gdGhlIEhFQVAuXHJcbiAgICB2YXIgY29kZVVuaXQgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZVxyXG4gICAgSEVBUDE2Wygob3V0UHRyKT4+MSldPWNvZGVVbml0O1xyXG4gICAgb3V0UHRyICs9IDI7XHJcbiAgfVxyXG4gIC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBIRUFQLlxyXG4gIEhFQVAxNlsoKG91dFB0cik+PjEpXT0wO1xyXG4gIHJldHVybiBvdXRQdHIgLSBzdGFydFB0cjtcclxufVxyXG5cclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IHN0cmluZyB0YWtlcyBpZiBlbmNvZGVkIGFzIGEgVVRGMTYgYnl0ZSBhcnJheSwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IgYnl0ZS5cclxuXHJcbmZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGMTYoc3RyKSB7XHJcbiAgcmV0dXJuIHN0ci5sZW5ndGgqMjtcclxufVxyXG5cclxuZnVuY3Rpb24gVVRGMzJUb1N0cmluZyhwdHIpIHtcclxuICBhc3NlcnQocHRyICUgNCA9PSAwLCAnUG9pbnRlciBwYXNzZWQgdG8gVVRGMzJUb1N0cmluZyBtdXN0IGJlIGFsaWduZWQgdG8gZm91ciBieXRlcyEnKTtcclxuICB2YXIgaSA9IDA7XHJcblxyXG4gIHZhciBzdHIgPSAnJztcclxuICB3aGlsZSAoMSkge1xyXG4gICAgdmFyIHV0ZjMyID0gSEVBUDMyWygoKHB0cikrKGkqNCkpPj4yKV07XHJcbiAgICBpZiAodXRmMzIgPT0gMClcclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgICsraTtcclxuICAgIC8vIEdvdGNoYTogZnJvbUNoYXJDb2RlIGNvbnN0cnVjdHMgYSBjaGFyYWN0ZXIgZnJvbSBhIFVURi0xNiBlbmNvZGVkIGNvZGUgKHBhaXIpLCBub3QgZnJvbSBhIFVuaWNvZGUgY29kZSBwb2ludCEgU28gZW5jb2RlIHRoZSBjb2RlIHBvaW50IHRvIFVURi0xNiBmb3IgY29uc3RydWN0aW5nLlxyXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcclxuICAgIGlmICh1dGYzMiA+PSAweDEwMDAwKSB7XHJcbiAgICAgIHZhciBjaCA9IHV0ZjMyIC0gMHgxMDAwMDtcclxuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwIHwgKGNoID4+IDEwKSwgMHhEQzAwIHwgKGNoICYgMHgzRkYpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHV0ZjMyKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIENvcGllcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0ICdzdHInIHRvIHRoZSBlbXNjcmlwdGVuIEhFQVAgYXQgYWRkcmVzcyAnb3V0UHRyJyxcclxuLy8gbnVsbC10ZXJtaW5hdGVkIGFuZCBlbmNvZGVkIGluIFVURjMyIGZvcm0uIFRoZSBjb3B5IHdpbGwgcmVxdWlyZSBhdCBtb3N0IHN0ci5sZW5ndGgqNCs0IGJ5dGVzIG9mIHNwYWNlIGluIHRoZSBIRUFQLlxyXG4vLyBVc2UgdGhlIGZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGMzIoKSB0byBjb21wdXRlIHRoZSBleGFjdCBudW1iZXIgb2YgYnl0ZXMgKGV4Y2x1ZGluZyBudWxsIHRlcm1pbmF0b3IpIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIHdyaXRlLlxyXG4vLyBQYXJhbWV0ZXJzOlxyXG4vLyAgIHN0cjogdGhlIEphdmFzY3JpcHQgc3RyaW5nIHRvIGNvcHkuXHJcbi8vICAgb3V0UHRyOiBCeXRlIGFkZHJlc3MgaW4gRW1zY3JpcHRlbiBIRUFQIHdoZXJlIHRvIHdyaXRlIHRoZSBzdHJpbmcgdG8uXHJcbi8vICAgbWF4Qnl0ZXNUb1dyaXRlOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdGhpcyBmdW5jdGlvbiBjYW4gd3JpdGUgdG8gdGhlIGFycmF5LiBUaGlzIGNvdW50IHNob3VsZCBpbmNsdWRlIHRoZSBudWxsXHJcbi8vICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdG9yLCBpLmUuIGlmIG1heEJ5dGVzVG9Xcml0ZT00LCBvbmx5IHRoZSBudWxsIHRlcm1pbmF0b3Igd2lsbCBiZSB3cml0dGVuIGFuZCBub3RoaW5nIGVsc2UuXHJcbi8vICAgICAgICAgICAgICAgICAgICBtYXhCeXRlc1RvV3JpdGU8NCBkb2VzIG5vdCB3cml0ZSBhbnkgYnl0ZXMgdG8gdGhlIG91dHB1dCwgbm90IGV2ZW4gdGhlIG51bGwgdGVybWluYXRvci5cclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxyXG5cclxuZnVuY3Rpb24gc3RyaW5nVG9VVEYzMihzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSB7XHJcbiAgYXNzZXJ0KG91dFB0ciAlIDQgPT0gMCwgJ1BvaW50ZXIgcGFzc2VkIHRvIHN0cmluZ1RvVVRGMzIgbXVzdCBiZSBhbGlnbmVkIHRvIGZvdXIgYnl0ZXMhJyk7XHJcbiAgYXNzZXJ0KHR5cGVvZiBtYXhCeXRlc1RvV3JpdGUgPT0gJ251bWJlcicsICdzdHJpbmdUb1VURjMyKHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIGlzIG1pc3NpbmcgdGhlIHRoaXJkIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgYnVmZmVyIScpO1xyXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpZiBtYXggYnl0ZXMgaXMgbm90IHNwZWNpZmllZCwgYXNzdW1lIHVuc2FmZSB1bmJvdW5kZWQgd3JpdGUgaXMgYWxsb3dlZC5cclxuICBpZiAobWF4Qnl0ZXNUb1dyaXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgIG1heEJ5dGVzVG9Xcml0ZSA9IDB4N0ZGRkZGRkY7XHJcbiAgfVxyXG4gIGlmIChtYXhCeXRlc1RvV3JpdGUgPCA0KSByZXR1cm4gMDtcclxuICB2YXIgc3RhcnRQdHIgPSBvdXRQdHI7XHJcbiAgdmFyIGVuZFB0ciA9IHN0YXJ0UHRyICsgbWF4Qnl0ZXNUb1dyaXRlIC0gNDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xyXG4gICAgLy8gR290Y2hhOiBjaGFyQ29kZUF0IHJldHVybnMgYSAxNi1iaXQgd29yZCB0aGF0IGlzIGEgVVRGLTE2IGVuY29kZWQgY29kZSB1bml0LCBub3QgYSBVbmljb2RlIGNvZGUgcG9pbnQgb2YgdGhlIGNoYXJhY3RlciEgV2UgbXVzdCBkZWNvZGUgdGhlIHN0cmluZyB0byBVVEYtMzIgdG8gdGhlIGhlYXAuXHJcbiAgICAvLyBTZWUgaHR0cDovL3VuaWNvZGUub3JnL2ZhcS91dGZfYm9tLmh0bWwjdXRmMTYtM1xyXG4gICAgdmFyIGNvZGVVbml0ID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIHBvc3NpYmx5IGEgbGVhZCBzdXJyb2dhdGVcclxuICAgIGlmIChjb2RlVW5pdCA+PSAweEQ4MDAgJiYgY29kZVVuaXQgPD0gMHhERkZGKSB7XHJcbiAgICAgIHZhciB0cmFpbFN1cnJvZ2F0ZSA9IHN0ci5jaGFyQ29kZUF0KCsraSk7XHJcbiAgICAgIGNvZGVVbml0ID0gMHgxMDAwMCArICgoY29kZVVuaXQgJiAweDNGRikgPDwgMTApIHwgKHRyYWlsU3Vycm9nYXRlICYgMHgzRkYpO1xyXG4gICAgfVxyXG4gICAgSEVBUDMyWygob3V0UHRyKT4+MildPWNvZGVVbml0O1xyXG4gICAgb3V0UHRyICs9IDQ7XHJcbiAgICBpZiAob3V0UHRyICsgNCA+IGVuZFB0cikgYnJlYWs7XHJcbiAgfVxyXG4gIC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBIRUFQLlxyXG4gIEhFQVAzMlsoKG91dFB0cik+PjIpXT0wO1xyXG4gIHJldHVybiBvdXRQdHIgLSBzdGFydFB0cjtcclxufVxyXG5cclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IHN0cmluZyB0YWtlcyBpZiBlbmNvZGVkIGFzIGEgVVRGMTYgYnl0ZSBhcnJheSwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IgYnl0ZS5cclxuXHJcbmZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGMzIoc3RyKSB7XHJcbiAgdmFyIGxlbiA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcclxuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFdlIG11c3QgZGVjb2RlIHRoZSBzdHJpbmcgdG8gVVRGLTMyIHRvIHRoZSBoZWFwLlxyXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcclxuICAgIHZhciBjb2RlVW5pdCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgaWYgKGNvZGVVbml0ID49IDB4RDgwMCAmJiBjb2RlVW5pdCA8PSAweERGRkYpICsraTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZSwgc28gc2tpcCBvdmVyIHRoZSB0YWlsIHN1cnJvZ2F0ZS5cclxuICAgIGxlbiArPSA0O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxlbjtcclxufVxyXG5cclxuLy8gQWxsb2NhdGUgaGVhcCBzcGFjZSBmb3IgYSBKUyBzdHJpbmcsIGFuZCB3cml0ZSBpdCB0aGVyZS5cclxuLy8gSXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsZXIgdG8gZnJlZSgpIHRoYXQgbWVtb3J5LlxyXG5mdW5jdGlvbiBhbGxvY2F0ZVVURjgoc3RyKSB7XHJcbiAgdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XHJcbiAgdmFyIHJldCA9IF9tYWxsb2Moc2l6ZSk7XHJcbiAgaWYgKHJldCkgc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQOCwgcmV0LCBzaXplKTtcclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBBbGxvY2F0ZSBzdGFjayBzcGFjZSBmb3IgYSBKUyBzdHJpbmcsIGFuZCB3cml0ZSBpdCB0aGVyZS5cclxuZnVuY3Rpb24gYWxsb2NhdGVVVEY4T25TdGFjayhzdHIpIHtcclxuICB2YXIgc2l6ZSA9IGxlbmd0aEJ5dGVzVVRGOChzdHIpICsgMTtcclxuICB2YXIgcmV0ID0gc3RhY2tBbGxvYyhzaXplKTtcclxuICBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVA4LCByZXQsIHNpemUpO1xyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlbWFuZ2xlKGZ1bmMpIHtcclxuICB3YXJuT25jZSgnd2FybmluZzogYnVpbGQgd2l0aCAgLXMgREVNQU5HTEVfU1VQUE9SVD0xICB0byBsaW5rIGluIGxpYmN4eGFiaSBkZW1hbmdsaW5nJyk7XHJcbiAgcmV0dXJuIGZ1bmM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlbWFuZ2xlQWxsKHRleHQpIHtcclxuICB2YXIgcmVnZXggPVxyXG4gICAgL19fWltcXHdcXGRfXSsvZztcclxuICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlZ2V4LFxyXG4gICAgZnVuY3Rpb24oeCkge1xyXG4gICAgICB2YXIgeSA9IGRlbWFuZ2xlKHgpO1xyXG4gICAgICByZXR1cm4geCA9PT0geSA/IHggOiAoeCArICcgWycgKyB5ICsgJ10nKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBqc1N0YWNrVHJhY2UoKSB7XHJcbiAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xyXG4gIGlmICghZXJyLnN0YWNrKSB7XHJcbiAgICAvLyBJRTEwKyBzcGVjaWFsIGNhc2VzOiBJdCBkb2VzIGhhdmUgY2FsbHN0YWNrIGluZm8sIGJ1dCBpdCBpcyBvbmx5IHBvcHVsYXRlZCBpZiBhbiBFcnJvciBvYmplY3QgaXMgdGhyb3duLFxyXG4gICAgLy8gc28gdHJ5IHRoYXQgYXMgYSBzcGVjaWFsLWNhc2UuXHJcbiAgICB0cnkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoMCk7XHJcbiAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgZXJyID0gZTtcclxuICAgIH1cclxuICAgIGlmICghZXJyLnN0YWNrKSB7XHJcbiAgICAgIHJldHVybiAnKG5vIHN0YWNrIHRyYWNlIGF2YWlsYWJsZSknO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZXJyLnN0YWNrLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YWNrVHJhY2UoKSB7XHJcbiAgdmFyIGpzID0ganNTdGFja1RyYWNlKCk7XHJcbiAgaWYgKE1vZHVsZVsnZXh0cmFTdGFja1RyYWNlJ10pIGpzICs9ICdcXG4nICsgTW9kdWxlWydleHRyYVN0YWNrVHJhY2UnXSgpO1xyXG4gIHJldHVybiBkZW1hbmdsZUFsbChqcyk7XHJcbn1cclxuXHJcbi8vIE1lbW9yeSBtYW5hZ2VtZW50XHJcblxyXG52YXIgUEFHRV9TSVpFID0gMTYzODQ7XHJcbnZhciBXQVNNX1BBR0VfU0laRSA9IDY1NTM2O1xyXG52YXIgQVNNSlNfUEFHRV9TSVpFID0gMTY3NzcyMTY7XHJcbnZhciBNSU5fVE9UQUxfTUVNT1JZID0gMTY3NzcyMTY7XHJcblxyXG5mdW5jdGlvbiBhbGlnblVwKHgsIG11bHRpcGxlKSB7XHJcbiAgaWYgKHggJSBtdWx0aXBsZSA+IDApIHtcclxuICAgIHggKz0gbXVsdGlwbGUgLSAoeCAlIG11bHRpcGxlKTtcclxuICB9XHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcbnZhciBIRUFQLFxyXG4vKiogQHR5cGUge0FycmF5QnVmZmVyfSAqL1xyXG4gIGJ1ZmZlcixcclxuLyoqIEB0eXBlIHtJbnQ4QXJyYXl9ICovXHJcbiAgSEVBUDgsXHJcbi8qKiBAdHlwZSB7VWludDhBcnJheX0gKi9cclxuICBIRUFQVTgsXHJcbi8qKiBAdHlwZSB7SW50MTZBcnJheX0gKi9cclxuICBIRUFQMTYsXHJcbi8qKiBAdHlwZSB7VWludDE2QXJyYXl9ICovXHJcbiAgSEVBUFUxNixcclxuLyoqIEB0eXBlIHtJbnQzMkFycmF5fSAqL1xyXG4gIEhFQVAzMixcclxuLyoqIEB0eXBlIHtVaW50MzJBcnJheX0gKi9cclxuICBIRUFQVTMyLFxyXG4vKiogQHR5cGUge0Zsb2F0MzJBcnJheX0gKi9cclxuICBIRUFQRjMyLFxyXG4vKiogQHR5cGUge0Zsb2F0NjRBcnJheX0gKi9cclxuICBIRUFQRjY0O1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlR2xvYmFsQnVmZmVyKGJ1Zikge1xyXG4gIE1vZHVsZVsnYnVmZmVyJ10gPSBidWZmZXIgPSBidWY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUdsb2JhbEJ1ZmZlclZpZXdzKCkge1xyXG4gIE1vZHVsZVsnSEVBUDgnXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShidWZmZXIpO1xyXG4gIE1vZHVsZVsnSEVBUDE2J10gPSBIRUFQMTYgPSBuZXcgSW50MTZBcnJheShidWZmZXIpO1xyXG4gIE1vZHVsZVsnSEVBUDMyJ10gPSBIRUFQMzIgPSBuZXcgSW50MzJBcnJheShidWZmZXIpO1xyXG4gIE1vZHVsZVsnSEVBUFU4J10gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gIE1vZHVsZVsnSEVBUFUxNiddID0gSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xyXG4gIE1vZHVsZVsnSEVBUFUzMiddID0gSEVBUFUzMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xyXG4gIE1vZHVsZVsnSEVBUEYzMiddID0gSEVBUEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcclxuICBNb2R1bGVbJ0hFQVBGNjQnXSA9IEhFQVBGNjQgPSBuZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlcik7XHJcbn1cclxuXHJcbnZhciBTVEFUSUNfQkFTRSwgU1RBVElDVE9QLCBzdGF0aWNTZWFsZWQ7IC8vIHN0YXRpYyBhcmVhXHJcbnZhciBTVEFDS19CQVNFLCBTVEFDS1RPUCwgU1RBQ0tfTUFYOyAvLyBzdGFjayBhcmVhXHJcbnZhciBEWU5BTUlDX0JBU0UsIERZTkFNSUNUT1BfUFRSOyAvLyBkeW5hbWljIGFyZWEgaGFuZGxlZCBieSBzYnJrXHJcblxyXG4gIFNUQVRJQ19CQVNFID0gU1RBVElDVE9QID0gU1RBQ0tfQkFTRSA9IFNUQUNLVE9QID0gU1RBQ0tfTUFYID0gRFlOQU1JQ19CQVNFID0gRFlOQU1JQ1RPUF9QVFIgPSAwO1xyXG4gIHN0YXRpY1NlYWxlZCA9IGZhbHNlO1xyXG5cclxuXHJcbi8vIEluaXRpYWxpemVzIHRoZSBzdGFjayBjb29raWUuIENhbGxlZCBhdCB0aGUgc3RhcnR1cCBvZiBtYWluIGFuZCBhdCB0aGUgc3RhcnR1cCBvZiBlYWNoIHRocmVhZCBpbiBwdGhyZWFkcyBtb2RlLlxyXG5mdW5jdGlvbiB3cml0ZVN0YWNrQ29va2llKCkge1xyXG4gIGFzc2VydCgoU1RBQ0tfTUFYICYgMykgPT0gMCk7XHJcbiAgSEVBUFUzMlsoU1RBQ0tfTUFYID4+IDIpLTFdID0gMHgwMjEzNTQ2NztcclxuICBIRUFQVTMyWyhTVEFDS19NQVggPj4gMiktMl0gPSAweDg5QkFDREZFO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja1N0YWNrQ29va2llKCkge1xyXG4gIGlmIChIRUFQVTMyWyhTVEFDS19NQVggPj4gMiktMV0gIT0gMHgwMjEzNTQ2NyB8fCBIRUFQVTMyWyhTVEFDS19NQVggPj4gMiktMl0gIT0gMHg4OUJBQ0RGRSkge1xyXG4gICAgYWJvcnQoJ1N0YWNrIG92ZXJmbG93ISBTdGFjayBjb29raWUgaGFzIGJlZW4gb3ZlcndyaXR0ZW4sIGV4cGVjdGVkIGhleCBkd29yZHMgMHg4OUJBQ0RGRSBhbmQgMHgwMjEzNTQ2NywgYnV0IHJlY2VpdmVkIDB4JyArIEhFQVBVMzJbKFNUQUNLX01BWCA+PiAyKS0yXS50b1N0cmluZygxNikgKyAnICcgKyBIRUFQVTMyWyhTVEFDS19NQVggPj4gMiktMV0udG9TdHJpbmcoMTYpKTtcclxuICB9XHJcbiAgLy8gQWxzbyB0ZXN0IHRoZSBnbG9iYWwgYWRkcmVzcyAwIGZvciBpbnRlZ3JpdHkuIFRoaXMgY2hlY2sgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBTQUZFX1NQTElUX01FTU9SWSB0aG91Z2gsIHNpbmNlIHRoYXQgbW9kZSBhbHJlYWR5IHRlc3RzIGFsbCBhZGRyZXNzIDAgYWNjZXNzZXMgb24gaXRzIG93bi5cclxuICBpZiAoSEVBUDMyWzBdICE9PSAweDYzNzM2ZDY1IC8qICdlbXNjJyAqLykgdGhyb3cgJ1J1bnRpbWUgZXJyb3I6IFRoZSBhcHBsaWNhdGlvbiBoYXMgY29ycnVwdGVkIGl0cyBoZWFwIG1lbW9yeSBhcmVhIChhZGRyZXNzIHplcm8pISc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFib3J0U3RhY2tPdmVyZmxvdyhhbGxvY1NpemUpIHtcclxuICBhYm9ydCgnU3RhY2sgb3ZlcmZsb3chIEF0dGVtcHRlZCB0byBhbGxvY2F0ZSAnICsgYWxsb2NTaXplICsgJyBieXRlcyBvbiB0aGUgc3RhY2ssIGJ1dCBzdGFjayBoYXMgb25seSAnICsgKFNUQUNLX01BWCAtIHN0YWNrU2F2ZSgpICsgYWxsb2NTaXplKSArICcgYnl0ZXMgYXZhaWxhYmxlIScpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeSgpIHtcclxuICBhYm9ydCgnQ2Fubm90IGVubGFyZ2UgbWVtb3J5IGFycmF5cy4gRWl0aGVyICgxKSBjb21waWxlIHdpdGggIC1zIFRPVEFMX01FTU9SWT1YICB3aXRoIFggaGlnaGVyIHRoYW4gdGhlIGN1cnJlbnQgdmFsdWUgJyArIFRPVEFMX01FTU9SWSArICcsICgyKSBjb21waWxlIHdpdGggIC1zIEFMTE9XX01FTU9SWV9HUk9XVEg9MSAgd2hpY2ggYWxsb3dzIGluY3JlYXNpbmcgdGhlIHNpemUgYXQgcnVudGltZSwgb3IgKDMpIGlmIHlvdSB3YW50IG1hbGxvYyB0byByZXR1cm4gTlVMTCAoMCkgaW5zdGVhZCBvZiB0aGlzIGFib3J0LCBjb21waWxlIHdpdGggIC1zIEFCT1JUSU5HX01BTExPQz0wICcpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZW5sYXJnZU1lbW9yeSgpIHtcclxuICBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeSgpO1xyXG59XHJcblxyXG5cclxudmFyIFRPVEFMX1NUQUNLID0gTW9kdWxlWydUT1RBTF9TVEFDSyddIHx8IDUyNDI4ODA7XHJcbnZhciBUT1RBTF9NRU1PUlkgPSBNb2R1bGVbJ1RPVEFMX01FTU9SWSddIHx8IDE2Nzc3MjE2O1xyXG5pZiAoVE9UQUxfTUVNT1JZIDwgVE9UQUxfU1RBQ0spIE1vZHVsZS5wcmludEVycignVE9UQUxfTUVNT1JZIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBUT1RBTF9TVEFDSywgd2FzICcgKyBUT1RBTF9NRU1PUlkgKyAnISAoVE9UQUxfU1RBQ0s9JyArIFRPVEFMX1NUQUNLICsgJyknKTtcclxuXHJcbi8vIEluaXRpYWxpemUgdGhlIHJ1bnRpbWUncyBtZW1vcnlcclxuLy8gY2hlY2sgZm9yIGZ1bGwgZW5naW5lIHN1cHBvcnQgKHVzZSBzdHJpbmcgJ3N1YmFycmF5JyB0byBhdm9pZCBjbG9zdXJlIGNvbXBpbGVyIGNvbmZ1c2lvbilcclxuYXNzZXJ0KHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBJbnQzMkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSAhPT0gdW5kZWZpbmVkICYmIEludDMyQXJyYXkucHJvdG90eXBlLnNldCAhPT0gdW5kZWZpbmVkLFxyXG4gICAgICAgJ0pTIGVuZ2luZSBkb2VzIG5vdCBwcm92aWRlIGZ1bGwgdHlwZWQgYXJyYXkgc3VwcG9ydCcpO1xyXG5cclxuXHJcblxyXG4vLyBVc2UgYSBwcm92aWRlZCBidWZmZXIsIGlmIHRoZXJlIGlzIG9uZSwgb3IgZWxzZSBhbGxvY2F0ZSBhIG5ldyBvbmVcclxuaWYgKE1vZHVsZVsnYnVmZmVyJ10pIHtcclxuICBidWZmZXIgPSBNb2R1bGVbJ2J1ZmZlciddO1xyXG4gIGFzc2VydChidWZmZXIuYnl0ZUxlbmd0aCA9PT0gVE9UQUxfTUVNT1JZLCAncHJvdmlkZWQgYnVmZmVyIHNob3VsZCBiZSAnICsgVE9UQUxfTUVNT1JZICsgJyBieXRlcywgYnV0IGl0IGlzICcgKyBidWZmZXIuYnl0ZUxlbmd0aCk7XHJcbn0gZWxzZSB7XHJcbiAgLy8gVXNlIGEgV2ViQXNzZW1ibHkgbWVtb3J5IHdoZXJlIGF2YWlsYWJsZVxyXG4gIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBXZWJBc3NlbWJseS5NZW1vcnkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGFzc2VydChUT1RBTF9NRU1PUlkgJSBXQVNNX1BBR0VfU0laRSA9PT0gMCk7XHJcbiAgICBNb2R1bGVbJ3dhc21NZW1vcnknXSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoeyAnaW5pdGlhbCc6IFRPVEFMX01FTU9SWSAvIFdBU01fUEFHRV9TSVpFLCAnbWF4aW11bSc6IFRPVEFMX01FTU9SWSAvIFdBU01fUEFHRV9TSVpFIH0pO1xyXG4gICAgYnVmZmVyID0gTW9kdWxlWyd3YXNtTWVtb3J5J10uYnVmZmVyO1xyXG4gIH0gZWxzZVxyXG4gIHtcclxuICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihUT1RBTF9NRU1PUlkpO1xyXG4gIH1cclxuICBhc3NlcnQoYnVmZmVyLmJ5dGVMZW5ndGggPT09IFRPVEFMX01FTU9SWSk7XHJcbiAgTW9kdWxlWydidWZmZXInXSA9IGJ1ZmZlcjtcclxufVxyXG51cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIGdldFRvdGFsTWVtb3J5KCkge1xyXG4gIHJldHVybiBUT1RBTF9NRU1PUlk7XHJcbn1cclxuXHJcbi8vIEVuZGlhbm5lc3MgY2hlY2sgKG5vdGU6IGFzc3VtZXMgY29tcGlsZXIgYXJjaCB3YXMgbGl0dGxlLWVuZGlhbilcclxuICBIRUFQMzJbMF0gPSAweDYzNzM2ZDY1OyAvKiAnZW1zYycgKi9cclxuSEVBUDE2WzFdID0gMHg2MzczO1xyXG5pZiAoSEVBUFU4WzJdICE9PSAweDczIHx8IEhFQVBVOFszXSAhPT0gMHg2MykgdGhyb3cgJ1J1bnRpbWUgZXJyb3I6IGV4cGVjdGVkIHRoZSBzeXN0ZW0gdG8gYmUgbGl0dGxlLWVuZGlhbiEnO1xyXG5cclxuZnVuY3Rpb24gY2FsbFJ1bnRpbWVDYWxsYmFja3MoY2FsbGJhY2tzKSB7XHJcbiAgd2hpbGUoY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcclxuICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrcy5zaGlmdCgpO1xyXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGZ1bmMgPSBjYWxsYmFjay5mdW5jO1xyXG4gICAgaWYgKHR5cGVvZiBmdW5jID09PSAnbnVtYmVyJykge1xyXG4gICAgICBpZiAoY2FsbGJhY2suYXJnID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdiddKGZ1bmMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIE1vZHVsZVsnZHluQ2FsbF92aSddKGZ1bmMsIGNhbGxiYWNrLmFyZyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZ1bmMoY2FsbGJhY2suYXJnID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2suYXJnKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBfX0FUUFJFUlVOX18gID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgYmVmb3JlIHRoZSBydW50aW1lIGlzIGluaXRpYWxpemVkXHJcbnZhciBfX0FUSU5JVF9fICAgID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgZHVyaW5nIHN0YXJ0dXBcclxudmFyIF9fQVRNQUlOX18gICAgPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCB3aGVuIG1haW4oKSBpcyB0byBiZSBydW5cclxudmFyIF9fQVRFWElUX18gICAgPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCBkdXJpbmcgc2h1dGRvd25cclxudmFyIF9fQVRQT1NUUlVOX18gPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCBhZnRlciB0aGUgcnVudGltZSBoYXMgZXhpdGVkXHJcblxyXG52YXIgcnVudGltZUluaXRpYWxpemVkID0gZmFsc2U7XHJcbnZhciBydW50aW1lRXhpdGVkID0gZmFsc2U7XHJcblxyXG5cclxuZnVuY3Rpb24gcHJlUnVuKCkge1xyXG4gIC8vIGNvbXBhdGliaWxpdHkgLSBtZXJnZSBpbiBhbnl0aGluZyBmcm9tIE1vZHVsZVsncHJlUnVuJ10gYXQgdGhpcyB0aW1lXHJcbiAgaWYgKE1vZHVsZVsncHJlUnVuJ10pIHtcclxuICAgIGlmICh0eXBlb2YgTW9kdWxlWydwcmVSdW4nXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZVJ1biddID0gW01vZHVsZVsncHJlUnVuJ11dO1xyXG4gICAgd2hpbGUgKE1vZHVsZVsncHJlUnVuJ10ubGVuZ3RoKSB7XHJcbiAgICAgIGFkZE9uUHJlUnVuKE1vZHVsZVsncHJlUnVuJ10uc2hpZnQoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc3VyZUluaXRSdW50aW1lKCkge1xyXG4gIGNoZWNrU3RhY2tDb29raWUoKTtcclxuICBpZiAocnVudGltZUluaXRpYWxpemVkKSByZXR1cm47XHJcbiAgcnVudGltZUluaXRpYWxpemVkID0gdHJ1ZTtcclxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJlTWFpbigpIHtcclxuICBjaGVja1N0YWNrQ29va2llKCk7XHJcbiAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVE1BSU5fXyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4aXRSdW50aW1lKCkge1xyXG4gIGNoZWNrU3RhY2tDb29raWUoKTtcclxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FURVhJVF9fKTtcclxuICBydW50aW1lRXhpdGVkID0gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gcG9zdFJ1bigpIHtcclxuICBjaGVja1N0YWNrQ29va2llKCk7XHJcbiAgLy8gY29tcGF0aWJpbGl0eSAtIG1lcmdlIGluIGFueXRoaW5nIGZyb20gTW9kdWxlWydwb3N0UnVuJ10gYXQgdGhpcyB0aW1lXHJcbiAgaWYgKE1vZHVsZVsncG9zdFJ1biddKSB7XHJcbiAgICBpZiAodHlwZW9mIE1vZHVsZVsncG9zdFJ1biddID09ICdmdW5jdGlvbicpIE1vZHVsZVsncG9zdFJ1biddID0gW01vZHVsZVsncG9zdFJ1biddXTtcclxuICAgIHdoaWxlIChNb2R1bGVbJ3Bvc3RSdW4nXS5sZW5ndGgpIHtcclxuICAgICAgYWRkT25Qb3N0UnVuKE1vZHVsZVsncG9zdFJ1biddLnNoaWZ0KCkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcclxuICBfX0FUUFJFUlVOX18udW5zaGlmdChjYik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZE9uSW5pdChjYikge1xyXG4gIF9fQVRJTklUX18udW5zaGlmdChjYik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZE9uUHJlTWFpbihjYikge1xyXG4gIF9fQVRNQUlOX18udW5zaGlmdChjYik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZE9uRXhpdChjYikge1xyXG4gIF9fQVRFWElUX18udW5zaGlmdChjYik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYikge1xyXG4gIF9fQVRQT1NUUlVOX18udW5zaGlmdChjYik7XHJcbn1cclxuXHJcbi8vIERlcHJlY2F0ZWQ6IFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVjYXVzZSBpdCBpcyB1bnNhZmUgYW5kIGRvZXMgbm90IHByb3ZpZGVcclxuLy8gYSBtYXhpbXVtIGxlbmd0aCBsaW1pdCBvZiBob3cgbWFueSBieXRlcyBpdCBpcyBhbGxvd2VkIHRvIHdyaXRlLiBQcmVmZXIgY2FsbGluZyB0aGVcclxuLy8gZnVuY3Rpb24gc3RyaW5nVG9VVEY4QXJyYXkoKSBpbnN0ZWFkLCB3aGljaCB0YWtlcyBpbiBhIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIHVzZWRcclxuLy8gdG8gYmUgc2VjdXJlIGZyb20gb3V0IG9mIGJvdW5kcyB3cml0ZXMuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5mdW5jdGlvbiB3cml0ZVN0cmluZ1RvTWVtb3J5KHN0cmluZywgYnVmZmVyLCBkb250QWRkTnVsbCkge1xyXG4gIHdhcm5PbmNlKCd3cml0ZVN0cmluZ1RvTWVtb3J5IGlzIGRlcHJlY2F0ZWQgYW5kIHNob3VsZCBub3QgYmUgY2FsbGVkISBVc2Ugc3RyaW5nVG9VVEY4KCkgaW5zdGVhZCEnKTtcclxuXHJcbiAgdmFyIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBsYXN0Q2hhciwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGVuZDtcclxuICBpZiAoZG9udEFkZE51bGwpIHtcclxuICAgIC8vIHN0cmluZ1RvVVRGOEFycmF5IGFsd2F5cyBhcHBlbmRzIG51bGwuIElmIHdlIGRvbid0IHdhbnQgdG8gZG8gdGhhdCwgcmVtZW1iZXIgdGhlXHJcbiAgICAvLyBjaGFyYWN0ZXIgdGhhdCBleGlzdGVkIGF0IHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgbnVsbCB3aWxsIGJlIHBsYWNlZCwgYW5kIHJlc3RvcmVcclxuICAgIC8vIHRoYXQgYWZ0ZXIgdGhlIHdyaXRlIChiZWxvdykuXHJcbiAgICBlbmQgPSBidWZmZXIgKyBsZW5ndGhCeXRlc1VURjgoc3RyaW5nKTtcclxuICAgIGxhc3RDaGFyID0gSEVBUDhbZW5kXTtcclxuICB9XHJcbiAgc3RyaW5nVG9VVEY4KHN0cmluZywgYnVmZmVyLCBJbmZpbml0eSk7XHJcbiAgaWYgKGRvbnRBZGROdWxsKSBIRUFQOFtlbmRdID0gbGFzdENoYXI7IC8vIFJlc3RvcmUgdGhlIHZhbHVlIHVuZGVyIHRoZSBudWxsIGNoYXJhY3Rlci5cclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVBcnJheVRvTWVtb3J5KGFycmF5LCBidWZmZXIpIHtcclxuICBhc3NlcnQoYXJyYXkubGVuZ3RoID49IDAsICd3cml0ZUFycmF5VG9NZW1vcnkgYXJyYXkgbXVzdCBoYXZlIGEgbGVuZ3RoIChzaG91bGQgYmUgYW4gYXJyYXkgb3IgdHlwZWQgYXJyYXkpJylcclxuICBIRUFQOC5zZXQoYXJyYXksIGJ1ZmZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsIGJ1ZmZlciwgZG9udEFkZE51bGwpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xyXG4gICAgYXNzZXJ0KHN0ci5jaGFyQ29kZUF0KGkpID09PSBzdHIuY2hhckNvZGVBdChpKSYweGZmKTtcclxuICAgIEhFQVA4WygoYnVmZmVyKyspPj4wKV09c3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgfVxyXG4gIC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBIRUFQLlxyXG4gIGlmICghZG9udEFkZE51bGwpIEhFQVA4WygoYnVmZmVyKT4+MCldPTA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVuU2lnbih2YWx1ZSwgYml0cywgaWdub3JlKSB7XHJcbiAgaWYgKHZhbHVlID49IDApIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgcmV0dXJuIGJpdHMgPD0gMzIgPyAyKk1hdGguYWJzKDEgPDwgKGJpdHMtMSkpICsgdmFsdWUgLy8gTmVlZCBzb21lIHRyaWNrZXJ5LCBzaW5jZSBpZiBiaXRzID09IDMyLCB3ZSBhcmUgcmlnaHQgYXQgdGhlIGxpbWl0IG9mIHRoZSBiaXRzIEpTIHVzZXMgaW4gYml0c2hpZnRzXHJcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygyLCBiaXRzKSAgICAgICAgICsgdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gcmVTaWduKHZhbHVlLCBiaXRzLCBpZ25vcmUpIHtcclxuICBpZiAodmFsdWUgPD0gMCkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICB2YXIgaGFsZiA9IGJpdHMgPD0gMzIgPyBNYXRoLmFicygxIDw8IChiaXRzLTEpKSAvLyBhYnMgaXMgbmVlZGVkIGlmIGJpdHMgPT0gMzJcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygyLCBiaXRzLTEpO1xyXG4gIGlmICh2YWx1ZSA+PSBoYWxmICYmIChiaXRzIDw9IDMyIHx8IHZhbHVlID4gaGFsZikpIHsgLy8gZm9yIGh1Z2UgdmFsdWVzLCB3ZSBjYW4gaGl0IHRoZSBwcmVjaXNpb24gbGltaXQgYW5kIGFsd2F5cyBnZXQgdHJ1ZSBoZXJlLiBzbyBkb24ndCBkbyB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQsIGluIGdlbmVyYWwgdGhlcmUgaXMgbm8gcGVyZmVjdCBzb2x1dGlvbiBoZXJlLiBXaXRoIDY0LWJpdCBpbnRzLCB3ZSBnZXQgcm91bmRpbmcgYW5kIGVycm9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogSW4gaTY0IG1vZGUgMSwgcmVzaWduIHRoZSB0d28gcGFydHMgc2VwYXJhdGVseSBhbmQgc2FmZWx5XHJcbiAgICB2YWx1ZSA9IC0yKmhhbGYgKyB2YWx1ZTsgLy8gQ2Fubm90IGJpdHNoaWZ0IGhhbGYsIGFzIGl0IG1heSBiZSBhdCB0aGUgbGltaXQgb2YgdGhlIGJpdHMgSlMgdXNlcyBpbiBiaXRzaGlmdHNcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG5hc3NlcnQoTWF0aFsnaW11bCddICYmIE1hdGhbJ2Zyb3VuZCddICYmIE1hdGhbJ2NsejMyJ10gJiYgTWF0aFsndHJ1bmMnXSwgJ3RoaXMgaXMgYSBsZWdhY3kgYnJvd3NlciwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCcpO1xyXG5cclxudmFyIE1hdGhfYWJzID0gTWF0aC5hYnM7XHJcbnZhciBNYXRoX2NvcyA9IE1hdGguY29zO1xyXG52YXIgTWF0aF9zaW4gPSBNYXRoLnNpbjtcclxudmFyIE1hdGhfdGFuID0gTWF0aC50YW47XHJcbnZhciBNYXRoX2Fjb3MgPSBNYXRoLmFjb3M7XHJcbnZhciBNYXRoX2FzaW4gPSBNYXRoLmFzaW47XHJcbnZhciBNYXRoX2F0YW4gPSBNYXRoLmF0YW47XHJcbnZhciBNYXRoX2F0YW4yID0gTWF0aC5hdGFuMjtcclxudmFyIE1hdGhfZXhwID0gTWF0aC5leHA7XHJcbnZhciBNYXRoX2xvZyA9IE1hdGgubG9nO1xyXG52YXIgTWF0aF9zcXJ0ID0gTWF0aC5zcXJ0O1xyXG52YXIgTWF0aF9jZWlsID0gTWF0aC5jZWlsO1xyXG52YXIgTWF0aF9mbG9vciA9IE1hdGguZmxvb3I7XHJcbnZhciBNYXRoX3BvdyA9IE1hdGgucG93O1xyXG52YXIgTWF0aF9pbXVsID0gTWF0aC5pbXVsO1xyXG52YXIgTWF0aF9mcm91bmQgPSBNYXRoLmZyb3VuZDtcclxudmFyIE1hdGhfcm91bmQgPSBNYXRoLnJvdW5kO1xyXG52YXIgTWF0aF9taW4gPSBNYXRoLm1pbjtcclxudmFyIE1hdGhfbWF4ID0gTWF0aC5tYXg7XHJcbnZhciBNYXRoX2NsejMyID0gTWF0aC5jbHozMjtcclxudmFyIE1hdGhfdHJ1bmMgPSBNYXRoLnRydW5jO1xyXG5cclxuLy8gQSBjb3VudGVyIG9mIGRlcGVuZGVuY2llcyBmb3IgY2FsbGluZyBydW4oKS4gSWYgd2UgbmVlZCB0b1xyXG4vLyBkbyBhc3luY2hyb25vdXMgd29yayBiZWZvcmUgcnVubmluZywgaW5jcmVtZW50IHRoaXMgYW5kXHJcbi8vIGRlY3JlbWVudCBpdC4gSW5jcmVtZW50aW5nIG11c3QgaGFwcGVuIGluIGEgcGxhY2UgbGlrZVxyXG4vLyBQUkVfUlVOX0FERElUSU9OUyAodXNlZCBieSBlbWNjIHRvIGFkZCBmaWxlIHByZWxvYWRpbmcpLlxyXG4vLyBOb3RlIHRoYXQgeW91IGNhbiBhZGQgZGVwZW5kZW5jaWVzIGluIHByZVJ1biwgZXZlbiB0aG91Z2hcclxuLy8gaXQgaGFwcGVucyByaWdodCBiZWZvcmUgcnVuIC0gcnVuIHdpbGwgYmUgcG9zdHBvbmVkIHVudGlsXHJcbi8vIHRoZSBkZXBlbmRlbmNpZXMgYXJlIG1ldC5cclxudmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XHJcbnZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XHJcbnZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsOyAvLyBvdmVycmlkZGVuIHRvIHRha2UgZGlmZmVyZW50IGFjdGlvbnMgd2hlbiBhbGwgcnVuIGRlcGVuZGVuY2llcyBhcmUgZnVsZmlsbGVkXHJcbnZhciBydW5EZXBlbmRlbmN5VHJhY2tpbmcgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koaWQpIHtcclxuICB2YXIgb3JpZyA9IGlkO1xyXG4gIHdoaWxlICgxKSB7XHJcbiAgICBpZiAoIXJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0pIHJldHVybiBpZDtcclxuICAgIGlkID0gb3JpZyArIE1hdGgucmFuZG9tKCk7XHJcbiAgfVxyXG4gIHJldHVybiBpZDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xyXG4gIHJ1bkRlcGVuZGVuY2llcysrO1xyXG4gIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xyXG4gICAgTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10ocnVuRGVwZW5kZW5jaWVzKTtcclxuICB9XHJcbiAgaWYgKGlkKSB7XHJcbiAgICBhc3NlcnQoIXJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0pO1xyXG4gICAgcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSA9IDE7XHJcbiAgICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgPT09IG51bGwgJiYgdHlwZW9mIHNldEludGVydmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAvLyBDaGVjayBmb3IgbWlzc2luZyBkZXBlbmRlbmNpZXMgZXZlcnkgZmV3IHNlY29uZHNcclxuICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoQUJPUlQpIHtcclxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xyXG4gICAgICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2hvd24gPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBkZXAgaW4gcnVuRGVwZW5kZW5jeVRyYWNraW5nKSB7XHJcbiAgICAgICAgICBpZiAoIXNob3duKSB7XHJcbiAgICAgICAgICAgIHNob3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgTW9kdWxlLnByaW50RXJyKCdzdGlsbCB3YWl0aW5nIG9uIHJ1biBkZXBlbmRlbmNpZXM6Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBNb2R1bGUucHJpbnRFcnIoJ2RlcGVuZGVuY3k6ICcgKyBkZXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvd24pIHtcclxuICAgICAgICAgIE1vZHVsZS5wcmludEVycignKGVuZCBvZiBsaXN0KScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgMTAwMDApO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBNb2R1bGUucHJpbnRFcnIoJ3dhcm5pbmc6IHJ1biBkZXBlbmRlbmN5IGFkZGVkIHdpdGhvdXQgSUQnKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpIHtcclxuICBydW5EZXBlbmRlbmNpZXMtLTtcclxuICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcclxuICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7XHJcbiAgfVxyXG4gIGlmIChpZCkge1xyXG4gICAgYXNzZXJ0KHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0pO1xyXG4gICAgZGVsZXRlIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF07XHJcbiAgfSBlbHNlIHtcclxuICAgIE1vZHVsZS5wcmludEVycignd2FybmluZzogcnVuIGRlcGVuZGVuY3kgcmVtb3ZlZCB3aXRob3V0IElEJyk7XHJcbiAgfVxyXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPT0gMCkge1xyXG4gICAgaWYgKHJ1bkRlcGVuZGVuY3lXYXRjaGVyICE9PSBudWxsKSB7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xyXG4gICAgICBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XHJcbiAgICAgIHZhciBjYWxsYmFjayA9IGRlcGVuZGVuY2llc0Z1bGZpbGxlZDtcclxuICAgICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcclxuICAgICAgY2FsbGJhY2soKTsgLy8gY2FuIGFkZCBhbm90aGVyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuTW9kdWxlW1wicHJlbG9hZGVkSW1hZ2VzXCJdID0ge307IC8vIG1hcHMgdXJsIHRvIGltYWdlIGRhdGFcclxuTW9kdWxlW1wicHJlbG9hZGVkQXVkaW9zXCJdID0ge307IC8vIG1hcHMgdXJsIHRvIGF1ZGlvIGRhdGFcclxuXHJcblxyXG5cclxudmFyIG1lbW9yeUluaXRpYWxpemVyID0gbnVsbDtcclxuXHJcblxyXG5cclxudmFyIC8qIHNob3cgZXJyb3JzIG9uIGxpa2VseSBjYWxscyB0byBGUyB3aGVuIGl0IHdhcyBub3QgaW5jbHVkZWQgKi8gRlMgPSB7XHJcbiAgZXJyb3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgYWJvcnQoJ0ZpbGVzeXN0ZW0gc3VwcG9ydCAoRlMpIHdhcyBub3QgaW5jbHVkZWQuIFRoZSBwcm9ibGVtIGlzIHRoYXQgeW91IGFyZSB1c2luZyBmaWxlcyBmcm9tIEpTLCBidXQgZmlsZXMgd2VyZSBub3QgdXNlZCBmcm9tIEMvQysrLCBzbyBmaWxlc3lzdGVtIHN1cHBvcnQgd2FzIG5vdCBhdXRvLWluY2x1ZGVkLiBZb3UgY2FuIGZvcmNlLWluY2x1ZGUgZmlsZXN5c3RlbSBzdXBwb3J0IHdpdGggIC1zIEZPUkNFX0ZJTEVTWVNURU09MScpO1xyXG4gIH0sXHJcbiAgaW5pdDogZnVuY3Rpb24oKSB7IEZTLmVycm9yKCkgfSxcclxuICBjcmVhdGVEYXRhRmlsZTogZnVuY3Rpb24oKSB7IEZTLmVycm9yKCkgfSxcclxuICBjcmVhdGVQcmVsb2FkZWRGaWxlOiBmdW5jdGlvbigpIHsgRlMuZXJyb3IoKSB9LFxyXG4gIGNyZWF0ZUxhenlGaWxlOiBmdW5jdGlvbigpIHsgRlMuZXJyb3IoKSB9LFxyXG4gIG9wZW46IGZ1bmN0aW9uKCkgeyBGUy5lcnJvcigpIH0sXHJcbiAgbWtkZXY6IGZ1bmN0aW9uKCkgeyBGUy5lcnJvcigpIH0sXHJcbiAgcmVnaXN0ZXJEZXZpY2U6IGZ1bmN0aW9uKCkgeyBGUy5lcnJvcigpIH0sXHJcbiAgYW5hbHl6ZVBhdGg6IGZ1bmN0aW9uKCkgeyBGUy5lcnJvcigpIH0sXHJcbiAgbG9hZEZpbGVzRnJvbURCOiBmdW5jdGlvbigpIHsgRlMuZXJyb3IoKSB9LFxyXG5cclxuICBFcnJub0Vycm9yOiBmdW5jdGlvbiBFcnJub0Vycm9yKCkgeyBGUy5lcnJvcigpIH0sXHJcbn07XHJcbk1vZHVsZVsnRlNfY3JlYXRlRGF0YUZpbGUnXSA9IEZTLmNyZWF0ZURhdGFGaWxlO1xyXG5Nb2R1bGVbJ0ZTX2NyZWF0ZVByZWxvYWRlZEZpbGUnXSA9IEZTLmNyZWF0ZVByZWxvYWRlZEZpbGU7XHJcblxyXG5cclxuXHJcbi8vIFByZWZpeCBvZiBkYXRhIFVSSXMgZW1pdHRlZCBieSBTSU5HTEVfRklMRSBhbmQgcmVsYXRlZCBvcHRpb25zLlxyXG52YXIgZGF0YVVSSVByZWZpeCA9ICdkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsJztcclxuXHJcbi8vIEluZGljYXRlcyB3aGV0aGVyIGZpbGVuYW1lIGlzIGEgYmFzZTY0IGRhdGEgVVJJLlxyXG5mdW5jdGlvbiBpc0RhdGFVUkkoZmlsZW5hbWUpIHtcclxuICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID9cclxuICAgICAgZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KSA6XHJcbiAgICAgIGZpbGVuYW1lLmluZGV4T2YoZGF0YVVSSVByZWZpeCkgPT09IDA7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGludGVncmF0ZVdhc21KUygpIHtcclxuICAvLyB3YXNtLmpzIGhhcyBzZXZlcmFsIG1ldGhvZHMgZm9yIGNyZWF0aW5nIHRoZSBjb21waWxlZCBjb2RlIG1vZHVsZSBoZXJlOlxyXG4gIC8vICAqICduYXRpdmUtd2FzbScgOiB1c2UgbmF0aXZlIFdlYkFzc2VtYmx5IHN1cHBvcnQgaW4gdGhlIGJyb3dzZXJcclxuICAvLyAgKiAnaW50ZXJwcmV0LXMtZXhwcic6IGxvYWQgcy1leHByZXNzaW9uIGNvZGUgZnJvbSBhIC53YXN0IGFuZCBpbnRlcnByZXRcclxuICAvLyAgKiAnaW50ZXJwcmV0LWJpbmFyeSc6IGxvYWQgYmluYXJ5IHdhc20gYW5kIGludGVycHJldFxyXG4gIC8vICAqICdpbnRlcnByZXQtYXNtMndhc20nOiBsb2FkIGFzbS5qcyBjb2RlLCB0cmFuc2xhdGUgdG8gd2FzbSwgYW5kIGludGVycHJldFxyXG4gIC8vICAqICdhc21qcyc6IG5vIHdhc20sIGp1c3QgbG9hZCB0aGUgYXNtLmpzIGNvZGUgYW5kIHVzZSB0aGF0IChnb29kIGZvciB0ZXN0aW5nKVxyXG4gIC8vIFRoZSBtZXRob2QgaXMgc2V0IGF0IGNvbXBpbGUgdGltZSAoQklOQVJZRU5fTUVUSE9EKVxyXG4gIC8vIFRoZSBtZXRob2QgY2FuIGJlIGEgY29tbWEtc2VwYXJhdGVkIGxpc3QsIGluIHdoaWNoIGNhc2UsIHdlIHdpbGwgdHJ5IHRoZVxyXG4gIC8vIG9wdGlvbnMgb25lIGJ5IG9uZS4gU29tZSBvZiB0aGVtIGNhbiBmYWlsIGdyYWNlZnVsbHksIGFuZCB0aGVuIHdlIGNhbiB0cnlcclxuICAvLyB0aGUgbmV4dC5cclxuXHJcbiAgLy8gaW5wdXRzXHJcblxyXG4gIHZhciBtZXRob2QgPSAnbmF0aXZlLXdhc20nO1xyXG5cclxuICB2YXIgd2FzbVRleHRGaWxlID0gJyc7XHJcbiAgdmFyIHdhc21CaW5hcnlGaWxlID0gJ2RhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxBR0Z6YlFFQUFBQUJjaEpnQTM5L2Z3Ri9ZQUYvQVg5Z0FBRi9ZQUYvQUdBQ2YzOEJmMkFFZjM5L2Z3Ri9ZQUovZndCZ0EzOS9md0JnQkg5L2YzOEFZQU4vZjM4QmZtQUFBR0FGZjM5L2YzOEJmMkFEZm45L0FYOWdBbjUvQVg5Z0JYOS9mMzkvQUdBR2YzeC9mMzkvQVg5Z0FYd0JmbUFDZkg4QmZBS1hCU0VEWlc1MkJtMWxiVzl5ZVFJQmdBS0FBZ05sYm5ZRmRHRmliR1VCY0FFUUVBTmxibllLYldWdGIzSjVRbUZ6WlFOL0FBTmxibllKZEdGaWJHVkNZWE5sQTM4QUEyVnVkZzVFV1U1QlRVbERWRTlRWDFCVVVnTi9BQU5sYm5ZTmRHVnRjRVJ2ZFdKc1pWQjBjZ04vQUFObGJuWUZRVUpQVWxRRGZ3QURaVzUyQ0ZOVVFVTkxWRTlRQTM4QUEyVnVkZ2xUVkVGRFMxOU5RVmdEZndBRFpXNTJCMk4wZEhwZmFUZ0Rmd0FHWjJ4dlltRnNBMDVoVGdOOEFBWm5iRzlpWVd3SVNXNW1hVzVwZEhrRGZBQURaVzUyRFdWdWJHRnlaMlZOWlcxdmNua0FBZ05sYm5ZT1oyVjBWRzkwWVd4TlpXMXZjbmtBQWdObGJuWVhZV0p2Y25SUGJrTmhibTV2ZEVkeWIzZE5aVzF2Y25rQUFnTmxibllTWVdKdmNuUlRkR0ZqYTA5MlpYSm1iRzkzQUFNRFpXNTJDMjUxYkd4R2RXNWpYMmxwQUFNRFpXNTJEVzUxYkd4R2RXNWpYMmxwYVdrQUF3TmxibllIWDE5ZmJHOWphd0FEQTJWdWRndGZYMTl6WlhSRmNuSk9id0FEQTJWdWRnMWZYMTl6ZVhOallXeHNNVFF3QUFRRFpXNTJEVjlmWDNONWMyTmhiR3d4TkRZQUJBTmxibllNWDE5ZmMzbHpZMkZzYkRVMEFBUURaVzUyQzE5ZlgzTjVjMk5oYkd3MkFBUURaVzUyQ1Y5ZlgzVnViRzlqYXdBREEyVnVkaUZmWlcxelkzSnBjSFJsYmw5b1lYTmZkR2h5WldGa2FXNW5YM04xY0hCdmNuUUFBZ05sYm5ZV1gyVnRjMk55YVhCMFpXNWZiV1Z0WTNCNVgySnBad0FBQTJWdWRoSmZiR3gyYlY5emRHRmphM0psYzNSdmNtVUFBd05sYm5ZUFgyeHNkbTFmYzNSaFkydHpZWFpsQUFJRFpXNTJEMTl3ZEdoeVpXRmtYMk55WldGMFpRQUZBMlZ1ZGcxZmNIUm9jbVZoWkY5cWIybHVBQVFEWlc1MkUxOXdkR2h5WldGa1gyMTFkR1Y0WDJsdWFYUUFCQU5sYm5ZSVgzTjVjMk52Ym1ZQUFRTlNVUUVDQXdZR0F3SUVBd2NEQ0FjQkNBQUlDUVFBQ2dZQkF3RUFBQUVDQVFBRUFBc0JBd2NCQnd3TkRRRUFEZ1FQRUJFUkFBSUNBZ1FFQkFBRUFBRUVBUVFFQWdvQkFRQUtBUUFBQVFFQkJBVUJBQVp5Rkg4Qkl3SUxmd0VqQXd0L0FTTUVDMzhCSXdVTGZ3RWpCZ3QvQVNNSEMzOEJRUUFMZndGQkFBdC9BVUVBQzM4QlFRQUxmQUVqQ0F0OEFTTUpDMzhCUVFBTGZ3RkJBQXQvQVVFQUMzOEJRUUFMZkFGRUFBQUFBQUFBQUFBTGZ3RkJBQXQ5QVVNQUFBQUFDMzBCUXdBQUFBQUxCNmtDRlJGZlgxOWxjbkp1YjE5c2IyTmhkR2x2YmdBeENsOWpZM1Z5YkY5d2IzY0FIQWRmWm1ac2RYTm9BRmdGWDJaeVpXVUFMQTlmYkd4MmJWOWljM2RoY0Y5cE16SUFYQWRmYldGc2JHOWpBQ3NIWDIxbGJXTndlUUJkQjE5dFpXMXpaWFFBWGhOZmNIUm9jbVZoWkY5dGRYUmxlRjlzYjJOckFGOFZYM0IwYUhKbFlXUmZiWFYwWlhoZmRXNXNiMk5yQUdBRlgzTmljbXNBWVFwa2VXNURZV3hzWDJscEFHSU1aSGx1UTJGc2JGOXBhV2xwQUdNVFpYTjBZV0pzYVhOb1UzUmhZMnRUY0dGalpRQVlDMmRsZEZSbGJYQlNaWFF3QUJzTGNuVnVVRzl6ZEZObGRITUFXd3R6WlhSVVpXMXdVbVYwTUFBYUNITmxkRlJvY21WM0FCa0tjM1JoWTJ0QmJHeHZZd0FWREhOMFlXTnJVbVZ6ZEc5eVpRQVhDWE4wWVdOclUyRjJaUUFXQ1JZQkFDTUJDeEJrTFdSa1pDSmtaR1ZsTGk4elpXVmxDc2IwQWxFb0FRRi9JdzBoQVNNTklBQnFKQTBqRFVFUGFrRndjU1FOSXcwakRrNEVRQ0FBRUFNTElBRVBDd1VBSXcwUEN3WUFJQUFrRFFzS0FDQUFKQTBnQVNRT0N4SUFJeEJCQUVZRVFDQUFKQkFnQVNRUkN3c0dBQ0FBSkJzTEJRQWpHdzhMekFFQkdIOGpEU0VaSXcxQm9BWnFKQTBqRFNNT1RnUkFRYUFHRUFNTElCbEJPR29oRlNBWklSWWdBQ0VNSUFFaEVSQXBRUUFoRWlBTUlSY2dGMEh4RkJCU0lRSWdBaUVUSUF3aEF5QVRJUVFnQXlBRUVDY2hCU0FGSVJRZ0ZSQWRJQlFoQmlBVklBWkI0RHdRSGlBVUlRY2dCMEhnUEdvaENDQVZJQWhCOHdFUVhSb2dFU0VKSUJZZ0ZTQUpRWDhRSUNBVUlRb2dDa0hnUEdvaEN5QUxJQlZCOHdFUVhSb2dGQ0VOSUExQkFFSFRQaEFvSVE0Z0RpRVNJQlFoRHlBUEVDd2dFaUVRSUJra0RTQVFEd3N5QVFSL0l3MGhCQ01OUVJCcUpBMGpEU01PVGdSQVFSQVFBd3NnQUNFQklBRWhBaUFDUVFCQjJRVVFYaG9nQkNRTkR3dXNBUUVWZnlNTklSY2pEVUVRYWlRTkl3MGpEazRFUUVFUUVBTUxJQUFoRHlBQklSQWdBaUVSUVFBaEVnTkFBa0FnRHlFVElCQWhGQ0FTSVJVZ0ZDQVZhaUVESUJFaEJDQUVRZk1CU0NFRklCRWhCaUFGQkg4Z0JnVkI4d0VMSVFjZ0J5RUlJQk1nQXlBSUVGMGFJQThoQ1NBSkVCOGdFaUVLSUFwQjh3RnFJUXNnQ3lFU0lCRWhEQ0FNUWZNQmF5RU5JQTBoRVNBTlFRQktJUTRnRGtVRVFBd0JDd3dCQ3dzZ0Z5UU5Ed3ZCQWdFbGZ5TU5JU1VqRFVId0JXb2tEU01OSXc1T0JFQkI4QVVRQXdzZ0pVRU1haUVlSUFBaEFVRUFJUXdEUUFKQUlBd2hIeUFmUWRFQVNDRWdJQ0JGQkVBTUFRc2dBU0VoSUI0Z0lVSFpCUkJkR2tFQUlSY0RRQUpBSUJjaElpQWlRZGtGU0NFaklDTkZCRUFNQVFzZ0Z5RUNRWUFJSUFKQkFuUnFJUU1nQXlnQ0FDRUVJQjRnQkdvaEJTQUZMQUFBSVFZZ0JrRVlkRUVZZFNFSElCY2hDQ0FJUVFGcUlRbEJnQWdnQ1VFQ2RHb2hDaUFLS0FJQUlRc2dIaUFMYWlFTklBMHNBQUFoRGlBT1FSaDBRUmgxSVE4Z0QwRUNkQ0VRSUFjZ0VHb2hFU0FSUVFWcUlSSkI2QjRnRWtFQ2RHb2hFeUFUS0FJQUlSUWdGRUgvQVhFaEZTQUJJUllnRnlFWUlCWWdHR29oR1NBWklCVTZBQUFnRnlFYUlCcEJBV29oR3lBYklSY01BUXNMSUF3aEhDQWNRUUZxSVIwZ0hTRU1EQUVMQ3lBbEpBMFBDOXNHQVZWL0l3MGhXQ01OUWZDMkFXb2tEU01OSXc1T0JFQkI4TFlCRUFNTElGaEJvTFlCYWlGV0lGZ2hCeUJZUWJpMkFXb2hDU0JZUWFTMkFXb2hDaUFBSVNVZ0FTRXdJQUloT3lBRElVWWdPeUVMSUF0QkFFZ2hEQ0E3SVEwZ0RVSHpBVW9oRGlBTUlBNXlJVlVnSlNFUElGVUVRQ0FQUVFVMkFnQkJsQjhvQWdBaEVDQTdJUkVnVmlBUk5nSUFJQkJCaUNNZ1ZoQmFHaUJZSkEwUEN5QVBRUUUyQWdBZ01DRVNJQWNnRWtHaUFSQWhFQTBoRXlBbElSUWdGRUVFYWlFVklCVWdFellDQUNBbElSWWdGa0VFYWlFWElCY29BZ0FoR0NBWVFRQkhJUmtnR1VVRVFDQUtJQWMyQWdBZ01DRkxJQXBCQkdvaFRDQk1JRXMyQWdBZ095Rk5JQXBCQ0dvaFRpQk9JRTAyQWdBZ1ZDRlBJQXBCREdvaFVDQlFJRTgyQWdBZ0pTRlNJQXBCRUdvaFV5QlRJRkkyQWdBZ0NoQWlHaUJZSkEwUEN5QkdJUm9nR2tFQVRDRWJJQnNFUUVIVUFCQVVJUndnSEVFQmF5RWRJQjBoUmlCR0lSNGdIa0VCU0NFZklCOEVmMEVCQlNBZEN5RUVJQVFoUmdzZ0pTRWdJQ0JCQ0dvaElTQWhRUUFRRXhvZ1JpRWlFQkFoSXlBaklRZ2dJa0VDZENFRkl3MGhKQ01OUVFFZ0JXeEJEMnBCY0hGcUpBMGpEU01PVGdSQVFRRWdCV3hCRDJwQmNIRVFBd3NnUmlFbUlDWkJGR3doQmlNTklTY2pEVUVCSUFac1FROXFRWEJ4YWlRTkl3MGpEazRFUUVFQklBWnNRUTlxUVhCeEVBTUxRUUFoVkFOQUFrQWdWQ0VvSUVZaEtTQW9JQ2xJSVNvZ0trVUVRQXdCQ3lCVUlTc2dKeUFyUVJSc2FpRXNJQWtnQnpZQ0FDQUpRUVJxSVMwZ01DRXVJQzBnTGpZQ0FDQUpRUWhxSVM4Z095RXhJQzhnTVRZQ0FDQUpRUXhxSVRJZ1ZDRXpJRElnTXpZQ0FDQUpRUkJxSVRRZ0pTRTFJRFFnTlRZQ0FDQXNJQWtwQWdBM0FnQWdMRUVJYWlBSlFRaHFLUUlBTndJQUlDeEJFR29nQ1VFUWFpZ0NBRFlDQUNCVUlUWWdKQ0EyUVFKMGFpRTNJRlFoT0NBbklEaEJGR3hxSVRrZ04wRUFRUVVnT1JBUkdpQlVJVG9nT2tFQmFpRThJRHdoVkF3QkN3dEJBQ0ZSQTBBQ1FDQlJJVDBnVkNFK0lEMGdQa2doUHlBL1JRUkFEQUVMSUZFaFFDQWtJRUJCQW5ScUlVRWdRU2dDQUNGQ0lFSkJBRWNoUXlCREJFQWdVU0ZFSUNRZ1JFRUNkR29oUlNCRktBSUFJVWNnUjBFQUVCSWFDeUJSSVVnZ1NFRUJhaUZKSUVraFVRd0JDd3NnQ0NGS0lFb1FEeUJZSkEwUEM2NEZBa2QvQVg0akRTRkpJdzFCRUdva0RTTU5JdzVPQkVCQkVCQURDeUFBSVJnZ0FTRWpJQUloTGtFQUlUa0RRQUpBSURraFJDQkVRZGtGU0NGR0lFWkZCRUFNQVFzZ0l5RkhJRGtoQkNCSElBUnFJUVVnQlN3QUFDRUdJQVpCR0hSQkdIVWhCd0pBQWtBQ1FBSkFJQWRCQUdzT0FnQUJBZ3NDUUNBWUlRZ2dPU0VKSUFnZ0NVRURkR29oQ2lBS1FuODNBd0FnR0NFTElBdEJ5QzFxSVF3Z09TRU5JQXdnRFVFRGRHb2hEa0ovSVVvZ0RpRUREQU1BQ3dBTEFrQWdHQ0VQSURraEVDQVBJQkJCQTNScUlSRWdFVUlBTndNQUlCZ2hFaUFTUWNndGFpRVRJRGtoRkNBVElCUkJBM1JxSVJWQ2Z5RktJQlVoQXd3Q0FBc0FDd0pBSUJnaEZpQTVJUmNnRmlBWFFRTjBhaUVaSUJsQ2Z6Y0RBQ0FZSVJvZ0drSElMV29oR3lBNUlSd2dHeUFjUVFOMGFpRWRRZ0FoU2lBZElRTUxDeUFESUVvM0F3QWdPU0VlSUI1QkFXb2hIeUFmSVRrTUFRc0xJQmdoSUNBdUlTRWdJQ0FoUVFOMGFpRWlJQ0pDN2JiYjdiYmI3YlpiTndNQUlCZ2hKQ0FrUWNndGFpRWxJQzRoSmlBbElDWkJBM1JxSVNjZ0owTGI3YmJiN2JiYjdiWi9Od01BSUJnaEtDQXVJU2tnS1VFQmFpRXFJQ2dnS2tFRGRHb2hLeUFyUXNlZi92ampqNy84Y1RjREFDQVlJU3dnTEVISUxXb2hMU0F1SVM4Z0wwRUJhaUV3SUMwZ01FRURkR29oTVNBeFFyLzg4Y2VmL3ZqamozODNBd0FnR0NFeUlDNGhNeUF6UVFKcUlUUWdNaUEwUVFOMGFpRTFJRFZDLzRQdy8vK0IrUC8vQURjREFDQVlJVFlnTmtISUxXb2hOeUF1SVRnZ09FRUNhaUU2SURjZ09rRURkR29oT3lBN1F2Ly9qOEQvLzRkZ053TUFJQmdoUENBdUlUMGdQVUVEYWlFK0lEd2dQa0VEZEdvaFB5QS9Rdi8vLzcrQWdJQmdOd01BSUJnaFFDQkFRY2d0YWlGQklDNGhRaUJDUVFOcUlVTWdRU0JEUVFOMGFpRkZJRVZDLy8vLy8vLy8veDgzQXdBZ1NTUU5Ed3ZyQmdKU2Z3eCtJdzBoVWlNTlFlQ1JBbW9rRFNNTkl3NU9CRUJCNEpFQ0VBTUxJRkpCK09NQmFpRW9JRkpCc0xZQmFpRXpJRkpCMklnQmFpRURJRkpCa05zQWFpRUVJRkpCeUMxcUlRVWdVaUVHSUFBaEN5QUxJUWdnQ0NFV0lCWWhDU0FKUVJCcUlRb2dDaWdDQUNFTUlBd2hJU0FXSVEwZ0RVRUVhaUVPSUE0b0FnQWhEeUFQSVFJZ0tFRUFRY2d0RUY0YUlETkJBRUhJTFJCZUdpQVdJUkFnRUNnQ0FDRVJJQ2dnRVVISUxSQmRHaUFXSVJJZ0VpZ0NBQ0VUSUJOQnlDMXFJUlFnTXlBVVFjZ3RFRjBhSUJZaEZTQVZRUXhxSVJjZ0Z5Z0NBQ0VZSUJnaE93TkFBa0FnT3lFWklCbEJmMm9oR2lBYUlUc2dHVUVBU2lFYklCdEZCRUFNQVFzZ0tDQXpRYVlCUWNFQkVDTU1BUXNMSUFWQkFFSElMUkJlR2lBR1FRQkJ5QzBRWGhvZ0EwRUFRY2d0RUY0YUlBUkJBRUhJTFJCZUdrRUFJUWNEUUFKQUlCWWhIQ0FoSVIwZ0hDQWRRUUVRSkNFZUlCNUJHSFJCR0hWQkFFY2hIeUFmUlFSQVFSSWhVUXdCQ3lBb0lETkJ3UUZCOHdFUUl5QUZJQ2hCeUMwUVhSb2dCaUF6UWNndEVGMGFJQVVnQmlBRElBUVFKU0FXSVNBZ0lFRUlhaUVpSUNJb0FnQWhJeUFGSUFZZ0l4QW1JVlFnVkNGZUlGUkNBRkVoSkNBa1JRUkFEQUVMREFFTEN5QlJRUkpHQkVCQkFDRUJJQUVoVUNCU0pBMGdVQThMSUY0aFZTQlZlaUZXSUZhbklTVWdKU0ZESUVNaEprRUJJQ1owSVNjZ0o2d2hWeUJYSVZNZ0lTRXBJQ2xCQkdvaEtpQXFLQUlBSVNzZ0swRUFSeUVzSUN3RVFDQVdJUzBnTFVFUWFpRXVJQzRvQWdBaEx5QXZRUWhxSVRBZ01CQmZHZ3NnSVNFeElERW9BZ0FoTWlBeVFRTkhJVFFDUUNBMEJFQWdJU0UxSURWQkF6WUNBRUVBSVRzRFFDQTdJVFlnTmtIekFVZ2hOeUEzUlFSQURBTUxJRHNoT0NBb0lEaEJBM1JxSVRrZ09Ta0RBQ0ZZSUZNaFdTQllJRm1ESVZvZ1drSUFVU0U2SURvRVFFRUJJVUVGSURzaFBDQXpJRHhCQTNScUlUMGdQU2tEQUNGYklGTWhYQ0JiSUZ5RElWMGdYVUlBVVNFK0lENEVmMEYvQlVFQUN5RS9JRDhoUVFzZ1FVSC9BWEVoUUNBQ0lVSWdPeUZFSUVJZ1JHb2hSU0JGSUVBNkFBQWdPeUZHSUVaQkFXb2hSeUJISVRzTUFBc0FDd3NnSVNGSUlFaEJCR29oU1NCSktBSUFJVW9nU2tFQVJ5RkxJRXNFUUNBV0lVd2dURUVRYWlGTklFMG9BZ0FoVGlCT1FRaHFJVThnVHhCZ0dndEJBQ0VCSUFFaFVDQlNKQTBnVUE4TG5BSUNHMzhPZmlNTklSNGpEVUV3YWlRTkl3MGpEazRFUUVFd0VBTUxJQUFoRmlBQklSa2dBaUVhSUFNaEcwSUJJU3dnR2lFRUlBUWhIQU5BQWtBZ0hDRUZJQnNoQmlBRklBWkpJUWNnTENFaElDRkNBRkloQ0NBSEJIOGdDQVZCQUFzaENTQUpSUVJBREFFTElCWWhDaUFjSVFzZ0NpQUxRUU4wYWlFTUlBd3BBd0FoSWlBaUlSOGdHU0VOSUJ3aERpQU5JQTVCQTNScUlROGdEeWtEQUNFaklDTWhJQ0FnSVNRZ0h5RWxJQ1FnSllVaEppQVdJUkFnSENFUklCQWdFVUVEZEdvaEVpQVNJQ1kzQXdBZ0h5RW5JQmtoRXlBY0lSUWdFeUFVUVFOMGFpRVZJQlVnSnpjREFDQWdJU2dnSHlFcElDbENmNFVoS2lBb0lDcURJU3NnS3lFc0lCd2hGeUFYUVFGcUlSZ2dHQ0VjREFFTEN5QWVKQTBQQy9ZQkFTRi9JdzBoSXlNTlFSQnFKQTBqRFNNT1RnUkFRUkFRQXdzZ0FDRWNJQUVoSFNBQ0lSNGdIU0VnSUNCQkJHb2hJU0FoS0FJQUlRTWdBMEVBUnlFRUlBUUVRQ0FjSVFVZ0JVRVFhaUVHSUFZb0FnQWhCeUFIUVFocUlRZ2dDQkJmR2lBZElRa2dDU2dDQUNFS0lCNGhDeUFLSUF0R0lRd2dERUVCY1NFTklBMUIvd0Z4SVE0Z0RpRWZJQndoRHlBUFFSQnFJUkFnRUNnQ0FDRVJJQkZCQ0dvaEVpQVNFR0FhSUI4aEV5QVRJUmNnRnlFYklDTWtEU0FiRHdVZ0hTRVVJQlFvQWdBaEZTQWVJUllnRlNBV1JpRVlJQmhCQVhFaEdTQVpRZjhCY1NFYUlCb2hGeUFYSVJzZ0l5UU5JQnNQQ3dCQkFBOEx6QU1DS244V2ZpTU5JUzBqRFVIQUFHb2tEU01OSXc1T0JFQkJ3QUFRQXdzZ0FDRWJJQUVoSHlBQ0lTTWdBeUVwUVFBaEtrSFJBQ0VyQTBBQ1FDQXJJUVVnQlVGL2FpRUdJQVloS3lBRlFRQktJUWNnQjBVRVFBd0JDeUFqSVFnZ0d5RUpJQWdnQ1VISUxSQmRHaUFwSVFvZ0h5RUxJQW9nQzBISUxSQmRHa0VBSVFRRFFDQUVJUXdnREVIWkJVZ2hEU0FOUlFSQURBTUxJQ01oRGlBcUlROGdEaUFQUVFOMGFpRVFJQkFwQXdBaE1pQXlJUzRnS1NFUklDb2hFaUFSSUJKQkEzUnFJUk1nRXlrREFDRXpJRE1oTHlBcElSUWdLaUVWSUJWQjdRSklJUllnRmdSL1Fld0NCVUdUZlFzaEZ5QXFJUmdnR0NBWGFpRVpJQmtoS2lBVUlCbEJBM1JxSVJvZ0dpa0RBQ0UwSURRaE1DQXVJVFVnTUNFMklEWkNmNFVoTnlBMUlEZUVJVGdnSXlFY0lDb2hIU0FjSUIxQkEzUnFJUjRnSGlrREFDRTVJQzhoT2lBNUlEcUZJVHNnT0NBN2d5RThJRHdoTVNBeElUMGdQVUovaFNFK0lCc2hJQ0FFSVNFZ0lDQWhRUU4wYWlFaUlDSWdQamNEQUNBdUlUOGdNQ0ZBSUQ4Z1FJVWhRU0F4SVVJZ1FTQkNoQ0ZESUI4aEpDQUVJU1VnSkNBbFFRTjBhaUVtSUNZZ1F6Y0RBQ0FFSVNjZ0owRUJhaUVvSUNnaEJBd0FDd0FNQVFzTElDMGtEUThMaWdJQ0UzOExmaU1OSVJVakRVRWdhaVFOSXcwakRrNEVRRUVnRUFNTElBQWhEeUFCSVJBZ0FpRVJRbjhoSUNBUklSTWdFeUVTQTBBQ1FDQVNJUU1nQTBGL2FpRUVJQVFoRWlBRFFRQktJUVVnQlVVRVFFRUZJUlFNQVFzZ0R5RUdJQkloQjBIeUFTQUhheUVJSUFZZ0NFRURkR29oQ1NBSktRTUFJUllnRUNFS0lCSWhDMEh5QVNBTGF5RU1JQW9nREVFRGRHb2hEU0FOS1FNQUlSY2dGaUFYaFNFWUlCaENmNFVoR1NBZ0lSb2dHaUFaZ3lFYklCc2hJQ0FnSVJ3Z0hFSUFVU0VPSUE0RVFFRUVJUlFNQVFzTUFRc0xJQlJCQkVZRVFFSUFJUjRnSGlFZklCVWtEU0FmRHdVZ0ZFRUZSZ1JBSUNBaEhTQWRJUjRnSGlFZklCVWtEU0FmRHdzTFFnQVBDK29CQVIxL0l3MGhIaU1OUVJCcUpBMGpEU01PVGdSQVFSQVFBd3NnQUNFTUlBRWhGaUFXSVJrZ0dVRURiQ0VhSUJvaEd5QWJFQ3NoSENBY0lSaEJBQ0VYQTBBQ1FDQVhJUUlnRmlFRElBSWdBMGdoQkNBWUlRVWdCRVVFUUF3QkN5QVhJUVlnQmtFRGJDRUhJQVVnQjJvaENDQU1JUWtnRnlFS0lBa2dDbW9oQ3lBTExBQUFJUTBnRFVFWWRFRVlkU0VPUWFZaklBNFFWQ0VQSUE4aEVFR21JeUVSSUJBZ0VXc2hFa0c3eEFBZ0VrRURiR29oRXlBSUlCTXVBQUE3QUFBZ0NFRUNhaUFUUVFKcUxBQUFPZ0FBSUJjaEZDQVVRUUZxSVJVZ0ZTRVhEQUVMQ3lBZUpBMGdCUThMN1FNQlIzOGpEU0ZKSXcxQklHb2tEU01OSXc1T0JFQkJJQkFEQ3lBQUlSY2dBU0VpSUFJaExTQXRJUU1nQTBFRGFpRUVJQVJCQVdzaEJTQUZRUU50UVg5eElRWWdCaUZESUVNaEJ5QUhRUUZxSVFnZ0NDRUpJQWtRS3lFS0lBb2hSaUJHSVFzZ1F5RU1JQXNnREdvaERTQU5RUUE2QUFCQkFDRTRBMEFDUUNBNElRNGdReUVQSUE0Z0QwZ2hFQ0FRUlFSQURBRUxJQmNoRVNBaUlSSWdPQ0VUSUJOQkEyd2hGQ0FTSUJScUlSVWdFU0FWYWlFV0lCWXNBQUFoR0NBWVFSaDBRUmgxSVJrZ0Z5RWFJQ0loR3lBNElSd2dIRUVEYkNFZElCc2dIV29oSGlBZVFRRnFJUjhnR2lBZmFpRWdJQ0FzQUFBaElTQWhRUmgwUVJoMUlTTWdJMEVEYkNFa0lCa2dKR29oSlNBWElTWWdJaUVuSURnaEtDQW9RUU5zSVNrZ0p5QXBhaUVxSUNwQkFtb2hLeUFtSUN0cUlTd2dMQ3dBQUNFdUlDNUJHSFJCR0hVaEx5QXZRUWxzSVRBZ0pTQXdhaUV4SURGQi93RnhJVElnTWlGSElFY2hNeUF6UVJoMFFSaDFJVFFnTkVFQVNDRTFJRFVFUUNCSElUWWdOa0VZZEVFWWRTRTNJRGRCRzJvaE9TQTVRZjhCY1NFNklEb2hSd3NnUnlFN0lEdEJHSFJCR0hVaFBFR21JeUE4YWlFOUlEMHNBQUFoUGlCR0lUOGdPQ0ZBSUQ4Z1FHb2hRU0JCSUQ0NkFBQWdPQ0ZDSUVKQkFXb2hSQ0JFSVRnTUFRc0xJRVloUlNCSkpBMGdSUThMOUFFQkVIOGpEU0VQSXcxQkVHb2tEU01OSXc1T0JFQkJFQkFEQ3lBUFFRUnFJUUVnQVVFQU5nQUFJQUZCQkdwQkFEb0FBRUVBSVFBRFFBSkFJQUFoQmlBR1FmTUJTQ0VISUFkRkJFQU1BUXNnQUNFSVFmdzZJQWhCQld4cUlRa2dDU0FCS0FBQU5nQUFJQWxCQkdvZ0FVRUVhaXdBQURvQUFDQUJRUVVRS2lBQUlRb2dDa0VCYWlFTElBc2hBQXdCQ3d0QkFDRUFBMEFDUUNBQUlRd2dERUViU0NFTklBMUZCRUFNQVFzZ0FDRUNRYnZFQUNBQ1FRTnNhaUVESUFNZ0FTNEFBRHNBQUNBRFFRSnFJQUZCQW1vc0FBQTZBQUFnQVVFREVDb2dBQ0VFSUFSQkFXb2hCU0FGSVFBTUFRc0xJQThrRFE4THd3RUJGSDhqRFNFVkl3MUJFR29rRFNNTkl3NU9CRUJCRUJBREN5QUFJUXdnQVNFTlFRQWhEZ05BQWtBZ0RpRVBJQTBoRUNBUElCQklJUkVnRVVVRVFFRUZJUlFNQVFzZ0RDRVNJQTRoRXlBU0lCTnFJUUlnQWl3QUFDRURJQU5CQVdwQkdIUkJHSFVoQkNBQ0lBUTZBQUFnQkVFWWRFRVlkU0VGSUFWQkFVb2hCaUFHUlFSQVFRVWhGQXdCQ3lBTUlRY2dEaUVJSUFjZ0NHb2hDU0FKUVg4NkFBQWdEaUVLSUFwQkFXb2hDeUFMSVE0TUFRc0xJQlJCQlVZRVFDQVZKQTBQQ3d1dGJnR3pDSDhqRFNHekNDTU5RUkJxSkEwakRTTU9UZ1JBUVJBUUF3c2dzd2doVlNBQVFmVUJTU0hFQVFKQUlNUUJCRUFnQUVFTFNTR3pBaUFBUVF0cUlhSURJS0lEUVhoeElaRUVJTE1DQkg5QkVBVWdrUVFMSVlBRklJQUZRUU4ySWU4RlFidzJLQUlBSWQ0R0lONEdJTzhGZGlITkJ5RE5CMEVEY1NGV0lGWkJBRVloWVNCaFJRUkFJTTBIUVFGeElXd2diRUVCY3lGM0lIY2c3d1ZxSVlJQklJSUJRUUYwSVkwQlFlUTJJSTBCUVFKMGFpR1lBU0NZQVVFSWFpR2pBU0NqQVNnQ0FDR3VBU0N1QVVFSWFpRzVBU0M1QVNnQ0FDSEZBU0RGQVNDWUFVWWgwQUVnMEFFRVFFRUJJSUlCZENIYkFTRGJBVUYvY3lIbUFTRGVCaURtQVhFaDhRRkJ2RFlnOFFFMkFnQUZJTVVCUVF4cUlmd0JJUHdCSUpnQk5nSUFJS01CSU1VQk5nSUFDeUNDQVVFRGRDR0hBaUNIQWtFRGNpR1NBaUN1QVVFRWFpR2RBaUNkQWlDU0FqWUNBQ0N1QVNDSEFtb2hxQUlncUFKQkJHb2h0QUlndEFJb0FnQWh2d0lndndKQkFYSWh5Z0lndEFJZ3lnSTJBZ0FndVFFaEJpQ3pDQ1FOSUFZUEMwSEVOaWdDQUNIVkFpQ0FCU0RWQWtzaDRBSWc0QUlFUUNETkIwRUFSaUhyQWlEckFrVUVRQ0ROQnlEdkJYUWg5Z0pCQWlEdkJYUWhnUU5CQUNDQkEyc2hqQU1nZ1FNZ2pBTnlJWmNESVBZQ0lKY0RjU0dqQTBFQUlLTURheUd1QXlDakF5Q3VBM0VodVFNZ3VRTkJmMm9oeEFNZ3hBTkJESFloendNZ3p3TkJFSEVoMmdNZ3hBTWcyZ04ySWVVRElPVURRUVYySWZBRElQQURRUWh4SWZzRElQc0RJTm9EY2lHR0JDRGxBeUQ3QTNZaGtnUWdrZ1JCQW5ZaG5RUWduUVJCQkhFaHFBUWdoZ1FncUFSeUliTUVJSklFSUtnRWRpRytCQ0MrQkVFQmRpSEpCQ0RKQkVFQ2NTSFVCQ0N6QkNEVUJISWgzd1FndmdRZzFBUjJJZW9FSU9vRVFRRjJJZlVFSVBVRVFRRnhJWUVGSU44RUlJRUZjaUdNQlNEcUJDQ0JCWFlobHdVZ2pBVWdsd1ZxSWFJRklLSUZRUUYwSWEwRlFlUTJJSzBGUVFKMGFpRzRCU0M0QlVFSWFpSERCU0REQlNnQ0FDSE9CU0RPQlVFSWFpSFpCU0RaQlNnQ0FDSGtCU0RrQlNDNEJVWWg4QVVnOEFVRVFFRUJJS0lGZENIN0JTRDdCVUYvY3lHR0JpRGVCaUNHQm5FaGtRWkJ2RFlna1FZMkFnQWdrUVloemdjRklPUUZRUXhxSVp3R0lKd0dJTGdGTmdJQUlNTUZJT1FGTmdJQUlONEdJYzRIQ3lDaUJVRURkQ0duQmlDbkJpQ0FCV3Noc2dZZ2dBVkJBM0lodlFZZ3pnVkJCR29oeUFZZ3lBWWd2UVkyQWdBZ3pnVWdnQVZxSWRNR0lMSUdRUUZ5SWQ4R0lOTUdRUVJxSWVvR0lPb0dJTjhHTmdJQUlNNEZJS2NHYWlIMUJpRDFCaUN5QmpZQ0FDRFZBa0VBUmlHQUJ5Q0FCMFVFUUVIUU5pZ0NBQ0dMQnlEVkFrRURkaUdXQnlDV0IwRUJkQ0doQjBIa05pQ2hCMEVDZEdvaHJBZEJBU0NXQjNRaHR3Y2d6Z2NndHdkeEljSUhJTUlIUVFCR0lka0hJTmtIQkVBZ3pnY2d0d2R5SWVRSFFidzJJT1FITmdJQUlLd0hRUWhxSVVRZ3JBY2hFQ0JFSVU0RklLd0hRUWhxSWU4SElPOEhLQUlBSWZvSElQb0hJUkFnN3djaFRnc2dUaUNMQnpZQ0FDQVFRUXhxSVlVSUlJVUlJSXNITmdJQUlJc0hRUWhxSVpBSUlKQUlJQkEyQWdBZ2l3ZEJER29obXdnZ213Z2dyQWMyQWdBTFFjUTJJTElHTmdJQVFkQTJJTk1HTmdJQUlOa0ZJUVlnc3dna0RTQUdEd3RCd0RZb0FnQWhuZ2dnbmdoQkFFWWhud2dnbndnRVFDQ0FCU0VQQlVFQUlKNElheUZYSUo0SUlGZHhJVmdnV0VGL2FpRlpJRmxCREhZaFdpQmFRUkJ4SVZzZ1dTQmJkaUZjSUZ4QkJYWWhYU0JkUVFoeElWNGdYaUJiY2lGZklGd2dYblloWUNCZ1FRSjJJV0lnWWtFRWNTRmpJRjhnWTNJaFpDQmdJR04ySVdVZ1pVRUJkaUZtSUdaQkFuRWhaeUJrSUdkeUlXZ2daU0JuZGlGcElHbEJBWFloYWlCcVFRRnhJV3NnYUNCcmNpRnRJR2tnYTNZaGJpQnRJRzVxSVc5QjdEZ2diMEVDZEdvaGNDQndLQUlBSVhFZ2NVRUVhaUZ5SUhJb0FnQWhjeUJ6UVhoeElYUWdkQ0NBQldzaGRTQnhRUkJxSVhZZ2RpZ0NBQ0Y0SUhoQkFFWWhlU0I1UVFGeElWRWdjVUVRYWlCUlFRSjBhaUY2SUhvb0FnQWhleUI3UVFCR0lYd2dmQVJBSUhFaEN5QjFJUTBGSUhFaERDQjFJUTRnZXlGK0EwQUNRQ0IrUVFScUlYMGdmU2dDQUNGL0lIOUJlSEVoZ0FFZ2dBRWdnQVZySVlFQklJRUJJQTVKSVlNQklJTUJCSDhnZ1FFRklBNExJUUlnZ3dFRWZ5QitCU0FNQ3lFQklINUJFR29oaEFFZ2hBRW9BZ0FoaFFFZ2hRRkJBRVloaGdFZ2hnRkJBWEVoVHlCK1FSQnFJRTlCQW5ScUlZY0JJSWNCS0FJQUlZZ0JJSWdCUVFCR0lZa0JJSWtCQkVBZ0FTRUxJQUloRFF3QkJTQUJJUXdnQWlFT0lJZ0JJWDRMREFFTEN3c2dDeUNBQldvaGlnRWdpZ0VnQzBzaGl3RWdpd0VFUUNBTFFSaHFJWXdCSUl3QktBSUFJWTRCSUF0QkRHb2hqd0VnandFb0FnQWhrQUVna0FFZ0MwWWhrUUVDUUNDUkFRUkFJQXRCRkdvaGxnRWdsZ0VvQWdBaGx3RWdsd0ZCQUVZaG1RRWdtUUVFUUNBTFFSQnFJWm9CSUpvQktBSUFJWnNCSUpzQlFRQkdJWndCSUp3QkJFQkJBQ0UwREFNRklKc0JJU1lnbWdFaEp3c0ZJSmNCSVNZZ2xnRWhKd3NEUUFKQUlDWkJGR29oblFFZ25RRW9BZ0FobmdFZ25nRkJBRVlobndFZ253RkZCRUFnbmdFaEppQ2RBU0VuREFJTElDWkJFR29ob0FFZ29BRW9BZ0Fob1FFZ29RRkJBRVlob2dFZ29nRUVRQXdCQlNDaEFTRW1JS0FCSVNjTERBRUxDeUFuUVFBMkFnQWdKaUUwQlNBTFFRaHFJWklCSUpJQktBSUFJWk1CSUpNQlFReHFJWlFCSUpRQklKQUJOZ0lBSUpBQlFRaHFJWlVCSUpVQklKTUJOZ0lBSUpBQklUUUxDeUNPQVVFQVJpR2tBUUpBSUtRQlJRUkFJQXRCSEdvaHBRRWdwUUVvQWdBaHBnRkI3RGdncGdGQkFuUnFJYWNCSUtjQktBSUFJYWdCSUFzZ3FBRkdJYWtCSUtrQkJFQWdwd0VnTkRZQ0FDQTBRUUJHSWFBSUlLQUlCRUJCQVNDbUFYUWhxZ0VncWdGQmYzTWhxd0VnbmdnZ3F3RnhJYXdCUWNBMklLd0JOZ0lBREFNTEJTQ09BVUVRYWlHdEFTQ3RBU2dDQUNHdkFTQ3ZBU0FMUnlHd0FTQ3dBVUVCY1NGU0lJNEJRUkJxSUZKQkFuUnFJYkVCSUxFQklEUTJBZ0FnTkVFQVJpR3lBU0N5QVFSQURBTUxDeUEwUVJocUliTUJJTE1CSUk0Qk5nSUFJQXRCRUdvaHRBRWd0QUVvQWdBaHRRRWd0UUZCQUVZaHRnRWd0Z0ZGQkVBZ05FRVFhaUczQVNDM0FTQzFBVFlDQUNDMUFVRVlhaUc0QVNDNEFTQTBOZ0lBQ3lBTFFSUnFJYm9CSUxvQktBSUFJYnNCSUxzQlFRQkdJYndCSUx3QlJRUkFJRFJCRkdvaHZRRWd2UUVndXdFMkFnQWd1d0ZCR0dvaHZnRWd2Z0VnTkRZQ0FBc0xDeUFOUVJCSkliOEJJTDhCQkVBZ0RTQ0FCV29od0FFZ3dBRkJBM0lod1FFZ0MwRUVhaUhDQVNEQ0FTREJBVFlDQUNBTElNQUJhaUhEQVNEREFVRUVhaUhHQVNER0FTZ0NBQ0hIQVNESEFVRUJjaUhJQVNER0FTRElBVFlDQUFVZ2dBVkJBM0loeVFFZ0MwRUVhaUhLQVNES0FTREpBVFlDQUNBTlFRRnlJY3NCSUlvQlFRUnFJY3dCSU13QklNc0JOZ0lBSUlvQklBMXFJYzBCSU0wQklBMDJBZ0FnMVFKQkFFWWh6Z0VnemdGRkJFQkIwRFlvQWdBaHp3RWcxUUpCQTNZaDBRRWcwUUZCQVhRaDBnRkI1RFlnMGdGQkFuUnFJZE1CUVFFZzBRRjBJZFFCSU40R0lOUUJjU0hWQVNEVkFVRUFSaUhXQVNEV0FRUkFJTjRHSU5RQmNpSFhBVUc4TmlEWEFUWUNBQ0RUQVVFSWFpRkZJTk1CSVFjZ1JTRk5CU0RUQVVFSWFpSFlBU0RZQVNnQ0FDSFpBU0RaQVNFSElOZ0JJVTBMSUUwZ3p3RTJBZ0FnQjBFTWFpSGFBU0RhQVNEUEFUWUNBQ0RQQVVFSWFpSGNBU0RjQVNBSE5nSUFJTThCUVF4cUlkMEJJTjBCSU5NQk5nSUFDMEhFTmlBTk5nSUFRZEEySUlvQk5nSUFDeUFMUVFocUlkNEJJTjRCSVFZZ3N3Z2tEU0FHRHdVZ2dBVWhEd3NMQlNDQUJTRVBDd1VnQUVHL2Ywc2gzd0VnM3dFRVFFRi9JUThGSUFCQkMyb2g0QUVnNEFGQmVIRWg0UUZCd0RZb0FnQWg0Z0VnNGdGQkFFWWg0d0VnNHdFRVFDRGhBU0VQQlVFQUlPRUJheUhrQVNEZ0FVRUlkaUhsQVNEbEFVRUFSaUhuQVNEbkFRUkFRUUFoSUFVZzRRRkIvLy8vQjBzaDZBRWc2QUVFUUVFZklTQUZJT1VCUVlEK1Ayb2g2UUVnNlFGQkVIWWg2Z0VnNmdGQkNIRWg2d0VnNVFFZzZ3RjBJZXdCSU93QlFZRGdIMm9oN1FFZzdRRkJFSFloN2dFZzdnRkJCSEVoN3dFZzd3RWc2d0Z5SWZBQklPd0JJTzhCZENIeUFTRHlBVUdBZ0E5cUlmTUJJUE1CUVJCMklmUUJJUFFCUVFKeElmVUJJUEFCSVBVQmNpSDJBVUVPSVBZQmF5SDNBU0R5QVNEMUFYUWgrQUVnK0FGQkQzWWgrUUVnOXdFZytRRnFJZm9CSVBvQlFRRjBJZnNCSVBvQlFRZHFJZjBCSU9FQklQMEJkaUgrQVNEK0FVRUJjU0gvQVNEL0FTRDdBWEloZ0FJZ2dBSWhJQXNMUWV3NElDQkJBblJxSVlFQ0lJRUNLQUlBSVlJQ0lJSUNRUUJHSVlNQ0FrQWdnd0lFUUVFQUlUTkJBQ0UySU9RQklUZEJPU0d5Q0FVZ0lFRWZSaUdFQWlBZ1FRRjJJWVVDUVJrZ2hRSnJJWVlDSUlRQ0JIOUJBQVVnaGdJTElZZ0NJT0VCSUlnQ2RDR0pBa0VBSVJzZzVBRWhIaUNDQWlFZklJa0NJU0pCQUNFa0EwQUNRQ0FmUVFScUlZb0NJSW9DS0FJQUlZc0NJSXNDUVhoeElZd0NJSXdDSU9FQmF5R05BaUNOQWlBZVNTR09BaUNPQWdSQUlJMENRUUJHSVk4Q0lJOENCRUJCQUNFOUlCOGhRQ0FmSVVGQlBTR3lDQXdGQlNBZklTc2dqUUloTEFzRklCc2hLeUFlSVN3TElCOUJGR29oa0FJZ2tBSW9BZ0Foa1FJZ0lrRWZkaUdUQWlBZlFSQnFJSk1DUVFKMGFpR1VBaUNVQWlnQ0FDR1ZBaUNSQWtFQVJpR1dBaUNSQWlDVkFrWWhsd0lnbGdJZ2x3SnlJYWdJSUtnSUJIOGdKQVVna1FJTElTMGdsUUpCQUVZaG1BSWdtQUpCQVhNaHBBZ2dwQWhCQVhFaG1RSWdJaUNaQW5RaElTQ1lBZ1JBSUMwaE15QXJJVFlnTENFM1FUa2hzZ2dNQVFVZ0t5RWJJQ3doSGlDVkFpRWZJQ0VoSWlBdElTUUxEQUVMQ3dzTElMSUlRVGxHQkVBZ00wRUFSaUdhQWlBMlFRQkdJWnNDSUpvQ0lKc0NjU0dtQ0NDbUNBUkFRUUlnSUhRaG5BSkJBQ0NjQW1zaG5nSWduQUlnbmdKeUlaOENJT0lCSUo4Q2NTR2dBaUNnQWtFQVJpR2hBaUNoQWdSQUlPRUJJUThNQmd0QkFDQ2dBbXNob2dJZ29BSWdvZ0p4SWFNQ0lLTUNRWDlxSWFRQ0lLUUNRUXgySWFVQ0lLVUNRUkJ4SWFZQ0lLUUNJS1lDZGlHbkFpQ25Ba0VGZGlHcEFpQ3BBa0VJY1NHcUFpQ3FBaUNtQW5JaHF3SWdwd0lncWdKMklhd0NJS3dDUVFKMklhMENJSzBDUVFSeElhNENJS3NDSUs0Q2NpR3ZBaUNzQWlDdUFuWWhzQUlnc0FKQkFYWWhzUUlnc1FKQkFuRWhzZ0lncndJZ3NnSnlJYlVDSUxBQ0lMSUNkaUcyQWlDMkFrRUJkaUczQWlDM0FrRUJjU0c0QWlDMUFpQzRBbklodVFJZ3RnSWd1QUoySWJvQ0lMa0NJTG9DYWlHN0FrSHNPQ0M3QWtFQ2RHb2h2QUlndkFJb0FnQWh2UUpCQUNFNklMMENJVDhGSURZaE9pQXpJVDhMSUQ5QkFFWWh2Z0lndmdJRVFDQTZJVGtnTnlFOEJTQTNJVDBnUHlGQUlEb2hRVUU5SWJJSUN3c2dzZ2hCUFVZRVFBTkFBa0JCQUNHeUNDQkFRUVJxSWNBQ0lNQUNLQUlBSWNFQ0lNRUNRWGh4SWNJQ0lNSUNJT0VCYXlIREFpRERBaUE5U1NIRUFpREVBZ1IvSU1NQ0JTQTlDeUVFSU1RQ0JIOGdRQVVnUVFzaFBpQkFRUkJxSWNVQ0lNVUNLQUlBSWNZQ0lNWUNRUUJHSWNjQ0lNY0NRUUZ4SVZNZ1FFRVFhaUJUUVFKMGFpSElBaURJQWlnQ0FDSEpBaURKQWtFQVJpSExBaURMQWdSQUlENGhPU0FFSVR3TUFRVWdCQ0U5SU1rQ0lVQWdQaUZCUVQwaHNnZ0xEQUVMQ3dzZ09VRUFSaUhNQWlETUFnUkFJT0VCSVE4RlFjUTJLQUlBSWMwQ0lNMENJT0VCYXlIT0FpQThJTTRDU1NIUEFpRFBBZ1JBSURrZzRRRnFJZEFDSU5BQ0lEbExJZEVDSU5FQ1JRUkFRUUFoQmlDekNDUU5JQVlQQ3lBNVFSaHFJZElDSU5JQ0tBSUFJZE1DSURsQkRHb2gxQUlnMUFJb0FnQWgxZ0lnMWdJZ09VWWgxd0lDUUNEWEFnUkFJRGxCRkdvaDNBSWczQUlvQWdBaDNRSWczUUpCQUVZaDNnSWczZ0lFUUNBNVFSQnFJZDhDSU44Q0tBSUFJZUVDSU9FQ1FRQkdJZUlDSU9JQ0JFQkJBQ0U0REFNRklPRUNJUzRnM3dJaEx3c0ZJTjBDSVM0ZzNBSWhMd3NEUUFKQUlDNUJGR29oNHdJZzR3SW9BZ0FoNUFJZzVBSkJBRVloNVFJZzVRSkZCRUFnNUFJaExpRGpBaUV2REFJTElDNUJFR29oNWdJZzVnSW9BZ0FoNXdJZzV3SkJBRVloNkFJZzZBSUVRQXdCQlNEbkFpRXVJT1lDSVM4TERBRUxDeUF2UVFBMkFnQWdMaUU0QlNBNVFRaHFJZGdDSU5nQ0tBSUFJZGtDSU5rQ1FReHFJZG9DSU5vQ0lOWUNOZ0lBSU5ZQ1FRaHFJZHNDSU5zQ0lOa0NOZ0lBSU5ZQ0lUZ0xDeURUQWtFQVJpSHBBZ0pBSU9rQ0JFQWc0Z0VoeGdNRklEbEJIR29oNmdJZzZnSW9BZ0FoN0FKQjdEZ2c3QUpCQW5ScUllMENJTzBDS0FJQUllNENJRGtnN2dKR0llOENJTzhDQkVBZzdRSWdPRFlDQUNBNFFRQkdJYUlJSUtJSUJFQkJBU0RzQW5RaDhBSWc4QUpCZjNNaDhRSWc0Z0VnOFFKeElmSUNRY0EySVBJQ05nSUFJUElDSWNZRERBTUxCU0RUQWtFUWFpSHpBaUR6QWlnQ0FDSDBBaUQwQWlBNVJ5SDFBaUQxQWtFQmNTRlVJTk1DUVJCcUlGUkJBblJxSWZjQ0lQY0NJRGcyQWdBZ09FRUFSaUg0QWlENEFnUkFJT0lCSWNZRERBTUxDeUE0UVJocUlma0NJUGtDSU5NQ05nSUFJRGxCRUdvaCtnSWcrZ0lvQWdBaCt3SWcrd0pCQUVZaC9BSWcvQUpGQkVBZ09FRVFhaUg5QWlEOUFpRDdBallDQUNEN0FrRVlhaUgrQWlEK0FpQTROZ0lBQ3lBNVFSUnFJZjhDSVA4Q0tBSUFJWUFESUlBRFFRQkdJWUlESUlJREJFQWc0Z0VoeGdNRklEaEJGR29oZ3dNZ2d3TWdnQU0yQWdBZ2dBTkJHR29oaEFNZ2hBTWdPRFlDQUNEaUFTSEdBd3NMQ3lBOFFSQkpJWVVEQWtBZ2hRTUVRQ0E4SU9FQmFpR0dBeUNHQTBFRGNpR0hBeUE1UVFScUlZZ0RJSWdESUljRE5nSUFJRGtnaGdOcUlZa0RJSWtEUVFScUlZb0RJSW9ES0FJQUlZc0RJSXNEUVFGeUlZMERJSW9ESUkwRE5nSUFCU0RoQVVFRGNpR09BeUE1UVFScUlZOERJSThESUk0RE5nSUFJRHhCQVhJaGtBTWcwQUpCQkdvaGtRTWdrUU1na0FNMkFnQWcwQUlnUEdvaGtnTWdrZ01nUERZQ0FDQThRUU4ySVpNRElEeEJnQUpKSVpRRElKUURCRUFna3dOQkFYUWhsUU5CNURZZ2xRTkJBblJxSVpZRFFidzJLQUlBSVpnRFFRRWdrd04wSVprRElKZ0RJSmtEY1NHYUF5Q2FBMEVBUmlHYkF5Q2JBd1JBSUpnRElKa0RjaUdjQTBHOE5pQ2NBellDQUNDV0EwRUlhaUZKSUpZRElTVWdTU0ZNQlNDV0EwRUlhaUdkQXlDZEF5Z0NBQ0dlQXlDZUF5RWxJSjBESVV3TElFd2cwQUkyQWdBZ0pVRU1haUdmQXlDZkF5RFFBallDQUNEUUFrRUlhaUdnQXlDZ0F5QWxOZ0lBSU5BQ1FReHFJYUVESUtFRElKWUROZ0lBREFJTElEeEJDSFlocEFNZ3BBTkJBRVlocFFNZ3BRTUVRRUVBSVNNRklEeEIvLy8vQjBzaHBnTWdwZ01FUUVFZklTTUZJS1FEUVlEK1Ayb2hwd01ncHdOQkVIWWhxQU1ncUFOQkNIRWhxUU1ncEFNZ3FRTjBJYW9ESUtvRFFZRGdIMm9ocXdNZ3F3TkJFSFlockFNZ3JBTkJCSEVoclFNZ3JRTWdxUU55SWE4RElLb0RJSzBEZENHd0F5Q3dBMEdBZ0E5cUliRURJTEVEUVJCMkliSURJTElEUVFKeEliTURJSzhESUxNRGNpRzBBMEVPSUxRRGF5RzFBeUN3QXlDekEzUWh0Z01ndGdOQkQzWWh0d01ndFFNZ3R3TnFJYmdESUxnRFFRRjBJYm9ESUxnRFFRZHFJYnNESUR3Z3V3TjJJYndESUx3RFFRRnhJYjBESUwwRElMb0RjaUcrQXlDK0F5RWpDd3RCN0RnZ0kwRUNkR29odndNZzBBSkJIR29od0FNZ3dBTWdJellDQUNEUUFrRVFhaUhCQXlEQkEwRUVhaUhDQXlEQ0EwRUFOZ0lBSU1FRFFRQTJBZ0JCQVNBamRDSERBeURHQXlEREEzRWh4UU1neFFOQkFFWWh4d01neHdNRVFDREdBeUREQTNJaHlBTkJ3RFlneUFNMkFnQWd2d01nMEFJMkFnQWcwQUpCR0dvaHlRTWd5UU1ndndNMkFnQWcwQUpCREdvaHlnTWd5Z01nMEFJMkFnQWcwQUpCQ0dvaHl3TWd5d01nMEFJMkFnQU1BZ3NndndNb0FnQWh6QU1nSTBFZlJpSE5BeUFqUVFGMkljNERRUmtnemdOcklkQURJTTBEQkg5QkFBVWcwQU1MSWRFRElEd2cwUU4wSWRJRElOSURJUndnekFNaEhRTkFBa0FnSFVFRWFpSFRBeURUQXlnQ0FDSFVBeURVQTBGNGNTSFZBeURWQXlBOFJpSFdBeURXQXdSQVFlRUFJYklJREFFTElCeEJIM1loMXdNZ0hVRVFhaURYQTBFQ2RHb2gyQU1nSEVFQmRDSFpBeURZQXlnQ0FDSGJBeURiQTBFQVJpSGNBeURjQXdSQVFlQUFJYklJREFFRklOa0RJUndnMndNaEhRc01BUXNMSUxJSVFlQUFSZ1JBSU5nRElOQUNOZ0lBSU5BQ1FSaHFJZDBESU4wRElCMDJBZ0FnMEFKQkRHb2gzZ01nM2dNZzBBSTJBZ0FnMEFKQkNHb2gzd01nM3dNZzBBSTJBZ0FNQWdVZ3NnaEI0UUJHQkVBZ0hVRUlhaUhnQXlEZ0F5Z0NBQ0hoQXlEaEEwRU1haUhpQXlEaUF5RFFBallDQUNEZ0F5RFFBallDQUNEUUFrRUlhaUhqQXlEakF5RGhBellDQUNEUUFrRU1haUhrQXlEa0F5QWROZ0lBSU5BQ1FSaHFJZVlESU9ZRFFRQTJBZ0FNQXdzTEN3c2dPVUVJYWlIbkF5RG5BeUVHSUxNSUpBMGdCZzhGSU9FQklROExDd3NMQ3d0QnhEWW9BZ0FoNkFNZzZBTWdEMGtoNlFNZzZRTkZCRUFnNkFNZ0Qyc2g2Z05CMERZb0FnQWg2d01nNmdOQkQwc2g3QU1nN0FNRVFDRHJBeUFQYWlIdEEwSFFOaUR0QXpZQ0FFSEVOaURxQXpZQ0FDRHFBMEVCY2lIdUF5RHRBMEVFYWlIdkF5RHZBeUR1QXpZQ0FDRHJBeURvQTJvaDhRTWc4UU1nNmdNMkFnQWdEMEVEY2lIeUF5RHJBMEVFYWlIekF5RHpBeUR5QXpZQ0FBVkJ4RFpCQURZQ0FFSFFOa0VBTmdJQUlPZ0RRUU55SWZRRElPc0RRUVJxSWZVRElQVURJUFFETmdJQUlPc0RJT2dEYWlIMkF5RDJBMEVFYWlIM0F5RDNBeWdDQUNINEF5RDRBMEVCY2lINUF5RDNBeUQ1QXpZQ0FBc2c2d05CQ0dvaCtnTWcrZ01oQmlDekNDUU5JQVlQQzBISU5pZ0NBQ0g4QXlEOEF5QVBTeUg5QXlEOUF3UkFJUHdESUE5cklmNERRY2cySVA0RE5nSUFRZFEyS0FJQUlmOERJUDhESUE5cUlZQUVRZFEySUlBRU5nSUFJUDREUVFGeUlZRUVJSUFFUVFScUlZSUVJSUlFSUlFRU5nSUFJQTlCQTNJaGd3UWcvd05CQkdvaGhBUWdoQVFnZ3dRMkFnQWcvd05CQ0dvaGhRUWdoUVFoQmlDekNDUU5JQVlQQzBHVU9pZ0NBQ0dIQkNDSEJFRUFSaUdJQkNDSUJBUkFRWnc2UVlBZ05nSUFRWmc2UVlBZ05nSUFRYUE2UVg4MkFnQkJwRHBCZnpZQ0FFR29Pa0VBTmdJQVFmZzVRUUEyQWdBZ1ZTR0pCQ0NKQkVGd2NTR0tCQ0NLQkVIWXF0V3FCWE1oaXdSQmxEb2dpd1EyQWdCQmdDQWhqd1FGUVp3NktBSUFJVWdnU0NHUEJBc2dEMEV3YWlHTUJDQVBRUzlxSVkwRUlJOEVJSTBFYWlHT0JFRUFJSThFYXlHUUJDQ09CQ0NRQkhFaGt3UWdrd1FnRDBzaGxBUWdsQVJGQkVCQkFDRUdJTE1JSkEwZ0JnOExRZlE1S0FJQUlaVUVJSlVFUVFCR0laWUVJSllFUlFSQVFldzVLQUlBSVpjRUlKY0VJSk1FYWlHWUJDQ1lCQ0NYQkUwaG1RUWdtQVFnbFFSTElab0VJSmtFSUpvRWNpR25DQ0NuQ0FSQVFRQWhCaUN6Q0NRTklBWVBDd3RCK0Rrb0FnQWhtd1FnbXdSQkJIRWhuQVFnbkFSQkFFWWhuZ1FDUUNDZUJBUkFRZFEyS0FJQUlaOEVJSjhFUVFCR0lhQUVBa0Fnb0FRRVFFSDJBQ0d5Q0FWQi9Ea2hDZ05BQWtBZ0NpZ0NBQ0doQkNDaEJDQ2ZCRXNob2dRZ29nUkZCRUFnQ2tFRWFpR2pCQ0NqQkNnQ0FDR2tCQ0NoQkNDa0JHb2hwUVFncFFRZ253UkxJYVlFSUtZRUJFQU1BZ3NMSUFwQkNHb2hwd1FncHdRb0FnQWhxUVFncVFSQkFFWWhxZ1FncWdRRVFFSDJBQ0d5Q0F3RUJTQ3BCQ0VLQ3d3QkN3c2dqZ1FnL0FOckljTUVJTU1FSUpBRWNTSEVCQ0RFQkVILy8vLy9CMGtoeFFRZ3hRUUVRQ0RFQkJCaEljWUVJQW9vQWdBaHh3UWdvd1FvQWdBaHlBUWd4d1FneUFScUljb0VJTVlFSU1vRVJpSExCQ0RMQkFSQUlNWUVRWDlHSWN3RUlNd0VCRUFneEFRaE1BVWd4QVFoUWlER0JDRkRRWWNCSWJJSURBWUxCU0RHQkNFeElNUUVJVEpCL2dBaHNnZ0xCVUVBSVRBTEN3c0NRQ0N5Q0VIMkFFWUVRRUVBRUdFaHF3UWdxd1JCZjBZaHJBUWdyQVFFUUVFQUlUQUZJS3NFSWEwRVFaZzZLQUlBSWE0RUlLNEVRWDlxSWE4RUlLOEVJSzBFY1NHd0JDQ3dCRUVBUmlHeEJDQ3ZCQ0N0QkdvaHNnUkJBQ0N1QkdzaHRBUWdzZ1FndEFSeEliVUVJTFVFSUswRWF5RzJCQ0N4QkFSL1FRQUZJTFlFQ3lHM0JDQzNCQ0NUQkdvaEJVSHNPU2dDQUNHNEJDQUZJTGdFYWlHNUJDQUZJQTlMSWJvRUlBVkIvLy8vL3dkSklic0VJTG9FSUxzRWNTR2xDQ0NsQ0FSQVFmUTVLQUlBSWJ3RUlMd0VRUUJHSWIwRUlMMEVSUVJBSUxrRUlMZ0VUU0cvQkNDNUJDQzhCRXNod0FRZ3Z3UWd3QVJ5SWEwSUlLMElCRUJCQUNFd0RBVUxDeUFGRUdFaHdRUWd3UVFncXdSR0ljSUVJTUlFQkVBZ0JTRkNJS3NFSVVOQmh3RWhzZ2dNQmdVZ3dRUWhNU0FGSVRKQi9nQWhzZ2dMQlVFQUlUQUxDd3NMQWtBZ3NnaEIvZ0JHQkVCQkFDQXlheUhOQkNBeFFYOUhJYzRFSURKQi8vLy8vd2RKSWM4RUlNOEVJTTRFY1NHeENDQ01CQ0F5U3lIUUJDRFFCQ0N4Q0hFaHFRZ2dxUWhGQkVBZ01VRi9SaUhiQkNEYkJBUkFRUUFoTUF3REJTQXlJVUlnTVNGRFFZY0JJYklJREFVTEFBdEJuRG9vQWdBaDBRUWdqUVFnTW1zaDBnUWcwZ1FnMFFScUlkTUVRUUFnMFFScklkVUVJTk1FSU5VRWNTSFdCQ0RXQkVILy8vLy9CMGtoMXdRZzF3UkZCRUFnTWlGQ0lERWhRMEdIQVNHeUNBd0VDeURXQkJCaElkZ0VJTmdFUVg5R0lka0VJTmtFQkVBZ3pRUVFZUnBCQUNFd0RBSUZJTllFSURKcUlkb0VJTm9FSVVJZ01TRkRRWWNCSWJJSURBUUxBQXNMUWZnNUtBSUFJZHdFSU53RVFRUnlJZDBFUWZnNUlOMEVOZ0lBSURBaE8wR0ZBU0d5Q0FWQkFDRTdRWVVCSWJJSUN3c2dzZ2hCaFFGR0JFQWdrd1JCLy8vLy93ZEpJZDRFSU40RUJFQWdrd1FRWVNIZ0JFRUFFR0VoNFFRZzRBUkJmMGNoNGdRZzRRUkJmMGNoNHdRZzRnUWc0d1J4SWE4SUlPQUVJT0VFU1NIa0JDRGtCQ0N2Q0hFaHFnZ2c0UVFoNVFRZzRBUWg1Z1FnNVFRZzVnUnJJZWNFSUE5QktHb2g2QVFnNXdRZzZBUkxJZWtFSU9rRUJIOGc1d1FGSURzTElRTWdxZ2hCQVhNaHF3Z2c0QVJCZjBZaDZ3UWc2UVJCQVhNaG93Z2c2d1Fnb3doeUlld0VJT3dFSUtzSWNpR3VDQ0N1Q0VVRVFDQURJVUlnNEFRaFEwR0hBU0d5Q0FzTEN5Q3lDRUdIQVVZRVFFSHNPU2dDQUNIdEJDRHRCQ0JDYWlIdUJFSHNPU0R1QkRZQ0FFSHdPU2dDQUNIdkJDRHVCQ0R2QkVzaDhBUWc4QVFFUUVId09TRHVCRFlDQUF0QjFEWW9BZ0FoOFFRZzhRUkJBRVloOGdRQ1FDRHlCQVJBUWN3MktBSUFJZk1FSVBNRVFRQkdJZlFFSUVNZzh3UkpJZllFSVBRRUlQWUVjaUdzQ0NDc0NBUkFRY3cySUVNMkFnQUxRZnc1SUVNMkFnQkJnRG9nUWpZQ0FFR0lPa0VBTmdJQVFaUTZLQUlBSWZjRVFlQTJJUGNFTmdJQVFkdzJRWDgyQWdCQjhEWkI1RFkyQWdCQjdEWkI1RFkyQWdCQitEWkI3RFkyQWdCQjlEWkI3RFkyQWdCQmdEZEI5RFkyQWdCQi9EWkI5RFkyQWdCQmlEZEIvRFkyQWdCQmhEZEIvRFkyQWdCQmtEZEJoRGMyQWdCQmpEZEJoRGMyQWdCQm1EZEJqRGMyQWdCQmxEZEJqRGMyQWdCQm9EZEJsRGMyQWdCQm5EZEJsRGMyQWdCQnFEZEJuRGMyQWdCQnBEZEJuRGMyQWdCQnNEZEJwRGMyQWdCQnJEZEJwRGMyQWdCQnVEZEJyRGMyQWdCQnREZEJyRGMyQWdCQndEZEJ0RGMyQWdCQnZEZEJ0RGMyQWdCQnlEZEJ2RGMyQWdCQnhEZEJ2RGMyQWdCQjBEZEJ4RGMyQWdCQnpEZEJ4RGMyQWdCQjJEZEJ6RGMyQWdCQjFEZEJ6RGMyQWdCQjREZEIxRGMyQWdCQjNEZEIxRGMyQWdCQjZEZEIzRGMyQWdCQjVEZEIzRGMyQWdCQjhEZEI1RGMyQWdCQjdEZEI1RGMyQWdCQitEZEI3RGMyQWdCQjlEZEI3RGMyQWdCQmdEaEI5RGMyQWdCQi9EZEI5RGMyQWdCQmlEaEIvRGMyQWdCQmhEaEIvRGMyQWdCQmtEaEJoRGcyQWdCQmpEaEJoRGcyQWdCQm1EaEJqRGcyQWdCQmxEaEJqRGcyQWdCQm9EaEJsRGcyQWdCQm5EaEJsRGcyQWdCQnFEaEJuRGcyQWdCQnBEaEJuRGcyQWdCQnNEaEJwRGcyQWdCQnJEaEJwRGcyQWdCQnVEaEJyRGcyQWdCQnREaEJyRGcyQWdCQndEaEJ0RGcyQWdCQnZEaEJ0RGcyQWdCQnlEaEJ2RGcyQWdCQnhEaEJ2RGcyQWdCQjBEaEJ4RGcyQWdCQnpEaEJ4RGcyQWdCQjJEaEJ6RGcyQWdCQjFEaEJ6RGcyQWdCQjREaEIxRGcyQWdCQjNEaEIxRGcyQWdCQjZEaEIzRGcyQWdCQjVEaEIzRGcyQWdBZ1FrRllhaUg0QkNCRFFRaHFJZmtFSVBrRUlmb0VJUG9FUVFkeElmc0VJUHNFUVFCR0lmd0VRUUFnK2dScklmMEVJUDBFUVFkeElmNEVJUHdFQkg5QkFBVWcvZ1FMSWY4RUlFTWcvd1JxSVlJRklQZ0VJUDhFYXlHREJVSFVOaUNDQlRZQ0FFSElOaUNEQlRZQ0FDQ0RCVUVCY2lHRUJTQ0NCVUVFYWlHRkJTQ0ZCU0NFQlRZQ0FDQkRJUGdFYWlHR0JTQ0dCVUVFYWlHSEJTQ0hCVUVvTmdJQVFhUTZLQUlBSVlnRlFkZzJJSWdGTmdJQUJVSDhPU0VWQTBBQ1FDQVZLQUlBSVlrRklCVkJCR29oaWdVZ2lnVW9BZ0FoaXdVZ2lRVWdpd1ZxSVkwRklFTWdqUVZHSVk0RklJNEZCRUJCandFaHNnZ01BUXNnRlVFSWFpR1BCU0NQQlNnQ0FDR1FCU0NRQlVFQVJpR1JCU0NSQlFSQURBRUZJSkFGSVJVTERBRUxDeUN5Q0VHUEFVWUVRQ0FWUVF4cUlaSUZJSklGS0FJQUlaTUZJSk1GUVFoeElaUUZJSlFGUVFCR0laVUZJSlVGQkVBZ2lRVWc4UVJOSVpZRklFTWc4UVJMSVpnRklKZ0ZJSllGY1NHd0NDQ3dDQVJBSUlzRklFSnFJWmtGSUlvRklKa0ZOZ0lBUWNnMktBSUFJWm9GSUpvRklFSnFJWnNGSVBFRVFRaHFJWndGSUp3RklaMEZJSjBGUVFkeElaNEZJSjRGUVFCR0laOEZRUUFnblFWcklhQUZJS0FGUVFkeElhRUZJSjhGQkg5QkFBVWdvUVVMSWFNRklQRUVJS01GYWlHa0JTQ2JCU0NqQldzaHBRVkIxRFlncEFVMkFnQkJ5RFlncFFVMkFnQWdwUVZCQVhJaHBnVWdwQVZCQkdvaHB3VWdwd1VncGdVMkFnQWc4UVFnbXdWcUlhZ0ZJS2dGUVFScUlha0ZJS2tGUVNnMkFnQkJwRG9vQWdBaHFnVkIyRFlncWdVMkFnQU1CQXNMQzBITU5pZ0NBQ0dyQlNCRElLc0ZTU0dzQlNDc0JRUkFRY3cySUVNMkFnQUxJRU1nUW1vaHJnVkIvRGtoS0FOQUFrQWdLQ2dDQUNHdkJTQ3ZCU0N1QlVZaHNBVWdzQVVFUUVHWEFTR3lDQXdCQ3lBb1FRaHFJYkVGSUxFRktBSUFJYklGSUxJRlFRQkdJYk1GSUxNRkJFQkIvRGtoQ1F3QkJTQ3lCU0VvQ3d3QkN3c2dzZ2hCbHdGR0JFQWdLRUVNYWlHMEJTQzBCU2dDQUNHMUJTQzFCVUVJY1NHMkJTQzJCVUVBUmlHM0JTQzNCUVJBSUNnZ1F6WUNBQ0FvUVFScUlia0ZJTGtGS0FJQUlib0ZJTG9GSUVKcUlic0ZJTGtGSUxzRk5nSUFJRU5CQ0dvaHZBVWd2QVVodlFVZ3ZRVkJCM0VodmdVZ3ZnVkJBRVlodndWQkFDQzlCV3Nod0FVZ3dBVkJCM0Vod1FVZ3Z3VUVmMEVBQlNEQkJRc2h3Z1VnUXlEQ0JXb2h4QVVncmdWQkNHb2h4UVVneFFVaHhnVWd4Z1ZCQjNFaHh3VWd4d1ZCQUVZaHlBVkJBQ0RHQldzaHlRVWd5UVZCQjNFaHlnVWd5QVVFZjBFQUJTREtCUXNoeXdVZ3JnVWd5d1ZxSWN3RklNd0ZJYzBGSU1RRkljOEZJTTBGSU04RmF5SFFCU0RFQlNBUGFpSFJCU0RRQlNBUGF5SFNCU0FQUVFOeUlkTUZJTVFGUVFScUlkUUZJTlFGSU5NRk5nSUFJUEVFSU13RlJpSFZCUUpBSU5VRkJFQkJ5RFlvQWdBaDFnVWcxZ1VnMGdWcUlkY0ZRY2cySU5jRk5nSUFRZFEySU5FRk5nSUFJTmNGUVFGeUlkZ0ZJTkVGUVFScUlkb0ZJTm9GSU5nRk5nSUFCVUhRTmlnQ0FDSGJCU0RiQlNETUJVWWgzQVVnM0FVRVFFSEVOaWdDQUNIZEJTRGRCU0RTQldvaDNnVkJ4RFlnM2dVMkFnQkIwRFlnMFFVMkFnQWczZ1ZCQVhJaDN3VWcwUVZCQkdvaDRBVWc0QVVnM3dVMkFnQWcwUVVnM2dWcUllRUZJT0VGSU40Rk5nSUFEQUlMSU13RlFRUnFJZUlGSU9JRktBSUFJZU1GSU9NRlFRTnhJZVVGSU9VRlFRRkdJZVlGSU9ZRkJFQWc0d1ZCZUhFaDV3VWc0d1ZCQTNZaDZBVWc0d1ZCZ0FKSklla0ZBa0FnNlFVRVFDRE1CVUVJYWlIcUJTRHFCU2dDQUNIckJTRE1CVUVNYWlIc0JTRHNCU2dDQUNIdEJTRHRCU0RyQlVZaDdnVWc3Z1VFUUVFQklPZ0ZkQ0h4QlNEeEJVRi9jeUh5QlVHOE5pZ0NBQ0h6QlNEekJTRHlCWEVoOUFWQnZEWWc5QVUyQWdBTUFnVWc2d1ZCREdvaDlRVWc5UVVnN1FVMkFnQWc3UVZCQ0dvaDlnVWc5Z1VnNndVMkFnQU1BZ3NBQlNETUJVRVlhaUgzQlNEM0JTZ0NBQ0g0QlNETUJVRU1haUg1QlNENUJTZ0NBQ0g2QlNENkJTRE1CVVloL0FVQ1FDRDhCUVJBSU13RlFSQnFJWUVHSUlFR1FRUnFJWUlHSUlJR0tBSUFJWU1HSUlNR1FRQkdJWVFHSUlRR0JFQWdnUVlvQWdBaGhRWWdoUVpCQUVZaGh3WWdod1lFUUVFQUlUVU1Bd1VnaFFZaEtTQ0JCaUVxQ3dVZ2d3WWhLU0NDQmlFcUN3TkFBa0FnS1VFVWFpR0lCaUNJQmlnQ0FDR0pCaUNKQmtFQVJpR0tCaUNLQmtVRVFDQ0pCaUVwSUlnR0lTb01BZ3NnS1VFUWFpR0xCaUNMQmlnQ0FDR01CaUNNQmtFQVJpR05CaUNOQmdSQURBRUZJSXdHSVNrZ2l3WWhLZ3NNQVFzTElDcEJBRFlDQUNBcElUVUZJTXdGUVFocUlmMEZJUDBGS0FJQUlmNEZJUDRGUVF4cUlmOEZJUDhGSVBvRk5nSUFJUG9GUVFocUlZQUdJSUFHSVA0Rk5nSUFJUG9GSVRVTEN5RDRCVUVBUmlHT0JpQ09CZ1JBREFJTElNd0ZRUnhxSVk4R0lJOEdLQUlBSVpBR1FldzRJSkFHUVFKMGFpR1NCaUNTQmlnQ0FDR1RCaUNUQmlETUJVWWhsQVlDUUNDVUJnUkFJSklHSURVMkFnQWdOVUVBUmlHaENDQ2hDRVVFUUF3Q0MwRUJJSkFHZENHVkJpQ1ZCa0YvY3lHV0JrSEFOaWdDQUNHWEJpQ1hCaUNXQm5FaG1BWkJ3RFlnbUFZMkFnQU1Bd1VnK0FWQkVHb2htUVlnbVFZb0FnQWhtZ1lnbWdZZ3pBVkhJWnNHSUpzR1FRRnhJVkFnK0FWQkVHb2dVRUVDZEdvaG5RWWduUVlnTlRZQ0FDQTFRUUJHSVo0R0lKNEdCRUFNQkFzTEN5QTFRUmhxSVo4R0lKOEdJUGdGTmdJQUlNd0ZRUkJxSWFBR0lLQUdLQUlBSWFFR0lLRUdRUUJHSWFJR0lLSUdSUVJBSURWQkVHb2hvd1lnb3dZZ29RWTJBZ0Fnb1FaQkdHb2hwQVlncEFZZ05UWUNBQXNnb0FaQkJHb2hwUVlncFFZb0FnQWhwZ1lncGdaQkFFWWhxQVlncUFZRVFBd0NDeUExUVJScUlha0dJS2tHSUtZR05nSUFJS1lHUVJocUlhb0dJS29HSURVMkFnQUxDeURNQlNEbkJXb2hxd1lnNXdVZzBnVnFJYXdHSUtzR0lRZ2dyQVloRmdVZ3pBVWhDQ0RTQlNFV0N5QUlRUVJxSWEwR0lLMEdLQUlBSWE0R0lLNEdRWDV4SWE4R0lLMEdJSzhHTmdJQUlCWkJBWEloc0FZZzBRVkJCR29oc1FZZ3NRWWdzQVkyQWdBZzBRVWdGbW9oc3dZZ3N3WWdGallDQUNBV1FRTjJJYlFHSUJaQmdBSkpJYlVHSUxVR0JFQWd0QVpCQVhRaHRnWkI1RFlndGdaQkFuUnFJYmNHUWJ3MktBSUFJYmdHUVFFZ3RBWjBJYmtHSUxnR0lMa0djU0c2QmlDNkJrRUFSaUc3QmlDN0JnUkFJTGdHSUxrR2NpRzhCa0c4TmlDOEJqWUNBQ0MzQmtFSWFpRkhJTGNHSVJrZ1J5RkxCU0MzQmtFSWFpRytCaUMrQmlnQ0FDRy9CaUMvQmlFWklMNEdJVXNMSUVzZzBRVTJBZ0FnR1VFTWFpSEFCaURBQmlEUkJUWUNBQ0RSQlVFSWFpSEJCaURCQmlBWk5nSUFJTkVGUVF4cUljSUdJTUlHSUxjR05nSUFEQUlMSUJaQkNIWWh3d1lnd3daQkFFWWh4QVlDUUNERUJnUkFRUUFoR2dVZ0ZrSC8vLzhIU3lIRkJpREZCZ1JBUVI4aEdnd0NDeUREQmtHQS9qOXFJY1lHSU1ZR1FSQjJJY2NHSU1jR1FRaHhJY2tHSU1NR0lNa0dkQ0hLQmlES0JrR0E0QjlxSWNzR0lNc0dRUkIySWN3R0lNd0dRUVJ4SWMwR0lNMEdJTWtHY2lIT0JpREtCaUROQm5RaHp3WWd6d1pCZ0lBUGFpSFFCaURRQmtFUWRpSFJCaURSQmtFQ2NTSFNCaURPQmlEU0JuSWgxQVpCRGlEVUJtc2gxUVlnendZZzBnWjBJZFlHSU5ZR1FROTJJZGNHSU5VR0lOY0dhaUhZQmlEWUJrRUJkQ0haQmlEWUJrRUhhaUhhQmlBV0lOb0dkaUhiQmlEYkJrRUJjU0hjQmlEY0JpRFpCbkloM1FZZzNRWWhHZ3NMUWV3NElCcEJBblJxSWVBR0lORUZRUnhxSWVFR0lPRUdJQm8yQWdBZzBRVkJFR29oNGdZZzRnWkJCR29oNHdZZzR3WkJBRFlDQUNEaUJrRUFOZ0lBUWNBMktBSUFJZVFHUVFFZ0duUWg1UVlnNUFZZzVRWnhJZVlHSU9ZR1FRQkdJZWNHSU9jR0JFQWc1QVlnNVFaeUllZ0dRY0EySU9nR05nSUFJT0FHSU5FRk5nSUFJTkVGUVJocUlla0dJT2tHSU9BR05nSUFJTkVGUVF4cUllc0dJT3NHSU5FRk5nSUFJTkVGUVFocUlld0dJT3dHSU5FRk5nSUFEQUlMSU9BR0tBSUFJZTBHSUJwQkgwWWg3Z1lnR2tFQmRpSHZCa0VaSU84R2F5SHdCaUR1QmdSL1FRQUZJUEFHQ3lIeEJpQVdJUEVHZENIeUJpRHlCaUVYSU8wR0lSZ0RRQUpBSUJoQkJHb2g4d1lnOHdZb0FnQWg5QVlnOUFaQmVIRWg5Z1lnOWdZZ0ZrWWg5d1lnOXdZRVFFSEFBU0d5Q0F3QkN5QVhRUjkySWZnR0lCaEJFR29nK0FaQkFuUnFJZmtHSUJkQkFYUWgrZ1lnK1FZb0FnQWgrd1lnK3daQkFFWWgvQVlnL0FZRVFFRy9BU0d5Q0F3QkJTRDZCaUVYSVBzR0lSZ0xEQUVMQ3lDeUNFRy9BVVlFUUNENUJpRFJCVFlDQUNEUkJVRVlhaUg5QmlEOUJpQVlOZ0lBSU5FRlFReHFJZjRHSVA0R0lORUZOZ0lBSU5FRlFRaHFJZjhHSVA4R0lORUZOZ0lBREFJRklMSUlRY0FCUmdSQUlCaEJDR29oZ1FjZ2dRY29BZ0FoZ2djZ2dnZEJER29oZ3djZ2d3Y2cwUVUyQWdBZ2dRY2cwUVUyQWdBZzBRVkJDR29oaEFjZ2hBY2dnZ2MyQWdBZzBRVkJER29oaFFjZ2hRY2dHRFlDQUNEUkJVRVlhaUdHQnlDR0IwRUFOZ0lBREFNTEN3c0xJTVFGUVFocUlaRUlJSkVJSVFZZ3N3Z2tEU0FHRHdWQi9Ea2hDUXNMQTBBQ1FDQUpLQUlBSVljSElJY0hJUEVFU3lHSUJ5Q0lCMFVFUUNBSlFRUnFJWWtISUlrSEtBSUFJWW9ISUljSElJb0hhaUdNQnlDTUJ5RHhCRXNoalFjZ2pRY0VRQXdDQ3dzZ0NVRUlhaUdPQnlDT0J5Z0NBQ0dQQnlDUEJ5RUpEQUVMQ3lDTUIwRlJhaUdRQnlDUUIwRUlhaUdSQnlDUkJ5R1NCeUNTQjBFSGNTR1RCeUNUQjBFQVJpR1VCMEVBSUpJSGF5R1ZCeUNWQjBFSGNTR1hCeUNVQndSL1FRQUZJSmNIQ3lHWUJ5Q1FCeUNZQjJvaG1RY2c4UVJCRUdvaG1nY2dtUWNnbWdkSklac0hJSnNIQkg4ZzhRUUZJSmtIQ3lHY0J5Q2NCMEVJYWlHZEJ5Q2NCMEVZYWlHZUJ5QkNRVmhxSVo4SElFTkJDR29ob0FjZ29BY2hvZ2Nnb2dkQkIzRWhvd2Nnb3dkQkFFWWhwQWRCQUNDaUIyc2hwUWNncFFkQkIzRWhwZ2NncEFjRWYwRUFCU0NtQndzaHB3Y2dReUNuQjJvaHFBY2dud2NncHdkcklha0hRZFEySUtnSE5nSUFRY2cySUtrSE5nSUFJS2tIUVFGeUlhb0hJS2dIUVFScUlhc0hJS3NISUtvSE5nSUFJRU1nbndkcUlhMEhJSzBIUVFScUlhNEhJSzRIUVNnMkFnQkJwRG9vQWdBaHJ3ZEIyRFlncndjMkFnQWduQWRCQkdvaHNBY2dzQWRCR3pZQ0FDQ2RCMEg4T1NrQ0FEY0NBQ0NkQjBFSWFrSDhPVUVJYWlrQ0FEY0NBRUg4T1NCRE5nSUFRWUE2SUVJMkFnQkJpRHBCQURZQ0FFR0VPaUNkQnpZQ0FDQ2VCeUd5QndOQUFrQWdzZ2RCQkdvaHNRY2dzUWRCQnpZQ0FDQ3lCMEVJYWlHekJ5Q3pCeUNNQjBraHRBY2d0QWNFUUNDeEJ5R3lCd1VNQVFzTUFRc0xJSndISVBFRVJpRzFCeUMxQjBVRVFDQ2NCeUcyQnlEeEJDRzRCeUMyQnlDNEIyc2h1UWNnc0Fjb0FnQWh1Z2NndWdkQmZuRWh1d2Nnc0FjZ3V3YzJBZ0FndVFkQkFYSWh2QWNnOFFSQkJHb2h2UWNndlFjZ3ZBYzJBZ0FnbkFjZ3VRYzJBZ0FndVFkQkEzWWh2Z2NndVFkQmdBSkpJYjhISUw4SEJFQWd2Z2RCQVhRaHdBZEI1RFlnd0FkQkFuUnFJY0VIUWJ3MktBSUFJY01IUVFFZ3ZnZDBJY1FISU1NSElNUUhjU0hGQnlERkIwRUFSaUhHQnlER0J3UkFJTU1ISU1RSGNpSEhCMEc4TmlESEJ6WUNBQ0RCQjBFSWFpRkdJTUVISVJNZ1JpRktCU0RCQjBFSWFpSElCeURJQnlnQ0FDSEpCeURKQnlFVElNZ0hJVW9MSUVvZzhRUTJBZ0FnRTBFTWFpSEtCeURLQnlEeEJEWUNBQ0R4QkVFSWFpSExCeURMQnlBVE5nSUFJUEVFUVF4cUljd0hJTXdISU1FSE5nSUFEQU1MSUxrSFFRaDJJYzhISU04SFFRQkdJZEFISU5BSEJFQkJBQ0VVQlNDNUIwSC8vLzhIU3lIUkJ5RFJCd1JBUVI4aEZBVWd6d2RCZ1A0L2FpSFNCeURTQjBFUWRpSFRCeURUQjBFSWNTSFVCeURQQnlEVUIzUWgxUWNnMVFkQmdPQWZhaUhXQnlEV0IwRVFkaUhYQnlEWEIwRUVjU0hZQnlEWUJ5RFVCM0loMmdjZzFRY2cyQWQwSWRzSElOc0hRWUNBRDJvaDNBY2czQWRCRUhZaDNRY2czUWRCQW5FaDNnY2cyZ2NnM2dkeUlkOEhRUTRnM3dkckllQUhJTnNISU40SGRDSGhCeURoQjBFUGRpSGlCeURnQnlEaUIyb2g0d2NnNHdkQkFYUWg1UWNnNHdkQkIyb2g1Z2NndVFjZzVnZDJJZWNISU9jSFFRRnhJZWdISU9nSElPVUhjaUhwQnlEcEJ5RVVDd3RCN0RnZ0ZFRUNkR29oNmdjZzhRUkJIR29oNndjZzZ3Y2dGRFlDQUNEeEJFRVVhaUhzQnlEc0IwRUFOZ0lBSUpvSFFRQTJBZ0JCd0RZb0FnQWg3UWRCQVNBVWRDSHVCeUR0QnlEdUIzRWg4QWNnOEFkQkFFWWg4UWNnOFFjRVFDRHRCeUR1QjNJaDhnZEJ3RFlnOGdjMkFnQWc2Z2NnOFFRMkFnQWc4UVJCR0dvaDh3Y2c4d2NnNmdjMkFnQWc4UVJCREdvaDlBY2c5QWNnOFFRMkFnQWc4UVJCQ0dvaDlRY2c5UWNnOFFRMkFnQU1Bd3NnNmdjb0FnQWg5Z2NnRkVFZlJpSDNCeUFVUVFGMklmZ0hRUmtnK0Fkcklma0hJUGNIQkg5QkFBVWcrUWNMSWZzSElMa0hJUHNIZENIOEJ5RDhCeUVSSVBZSElSSURRQUpBSUJKQkJHb2gvUWNnL1Fjb0FnQWgvZ2NnL2dkQmVIRWgvd2NnL3djZ3VRZEdJWUFJSUlBSUJFQkIxUUVoc2dnTUFRc2dFVUVmZGlHQkNDQVNRUkJxSUlFSVFRSjBhaUdDQ0NBUlFRRjBJWU1JSUlJSUtBSUFJWVFJSUlRSVFRQkdJWVlJSUlZSUJFQkIxQUVoc2dnTUFRVWdnd2doRVNDRUNDRVNDd3dCQ3dzZ3NnaEIxQUZHQkVBZ2dnZ2c4UVEyQWdBZzhRUkJHR29oaHdnZ2h3Z2dFallDQUNEeEJFRU1haUdJQ0NDSUNDRHhCRFlDQUNEeEJFRUlhaUdKQ0NDSkNDRHhCRFlDQUF3REJTQ3lDRUhWQVVZRVFDQVNRUWhxSVlvSUlJb0lLQUlBSVlzSUlJc0lRUXhxSVl3SUlJd0lJUEVFTmdJQUlJb0lJUEVFTmdJQUlQRUVRUWhxSVkwSUlJMElJSXNJTmdJQUlQRUVRUXhxSVk0SUlJNElJQkkyQWdBZzhRUkJHR29oandnZ2p3aEJBRFlDQUF3RUN3c0xDd3RCeURZb0FnQWhrZ2dna2dnZ0Qwc2hrd2dna3dnRVFDQ1NDQ0FQYXlHVUNFSElOaUNVQ0RZQ0FFSFVOaWdDQUNHVkNDQ1ZDQ0FQYWlHV0NFSFVOaUNXQ0RZQ0FDQ1VDRUVCY2lHWENDQ1dDRUVFYWlHWUNDQ1lDQ0NYQ0RZQ0FDQVBRUU55SVprSUlKVUlRUVJxSVpvSUlKb0lJSmtJTmdJQUlKVUlRUWhxSVp3SUlKd0lJUVlnc3dna0RTQUdEd3NMRURFaG5RZ2duUWhCRERZQ0FFRUFJUVlnc3dna0RTQUdEd3V3R3dHYkFuOGpEU0diQWlBQVFRQkdJUlFnRkFSQUR3c2dBRUY0YWlHREFVSE1OaWdDQUNITEFTQUFRWHhxSWRZQklOWUJLQUlBSWVFQklPRUJRWGh4SWV3QklJTUJJT3dCYWlIM0FTRGhBVUVCY1NHQ0FpQ0NBa0VBUmlHTkFnSkFJSTBDQkVBZ2d3RW9BZ0FoRlNEaEFVRURjU0VnSUNCQkFFWWhLeUFyQkVBUEMwRUFJQlZySVRZZ2d3RWdObW9oUVNBVklPd0JhaUZNSUVFZ3l3RkpJVmNnVndSQUR3dEIwRFlvQWdBaFlpQmlJRUZHSVcwZ2JRUkFJUGNCUVFScUlZRUNJSUVDS0FJQUlZTUNJSU1DUVFOeElZUUNJSVFDUVFOR0lZVUNJSVVDUlFSQUlFRWhCeUJNSVFnZ1FTR0xBZ3dEQzBIRU5pQk1OZ0lBSUlNQ1FYNXhJWVlDSUlFQ0lJWUNOZ0lBSUV4QkFYSWhod0lnUVVFRWFpR0lBaUNJQWlDSEFqWUNBQ0JCSUV4cUlZa0NJSWtDSUV3MkFnQVBDeUFWUVFOMklYZ2dGVUdBQWtraGhBRWdoQUVFUUNCQlFRaHFJWThCSUk4QktBSUFJWm9CSUVGQkRHb2hwUUVncFFFb0FnQWhzQUVnc0FFZ21nRkdJYnNCSUxzQkJFQkJBU0I0ZENIR0FTREdBVUYvY3lISUFVRzhOaWdDQUNISkFTREpBU0RJQVhFaHlnRkJ2RFlneWdFMkFnQWdRU0VISUV3aENDQkJJWXNDREFNRklKb0JRUXhxSWN3QklNd0JJTEFCTmdJQUlMQUJRUWhxSWMwQklNMEJJSm9CTmdJQUlFRWhCeUJNSVFnZ1FTR0xBZ3dEQ3dBTElFRkJHR29oemdFZ3pnRW9BZ0FoendFZ1FVRU1haUhRQVNEUUFTZ0NBQ0hSQVNEUkFTQkJSaUhTQVFKQUlOSUJCRUFnUVVFUWFpSFlBU0RZQVVFRWFpSFpBU0RaQVNnQ0FDSGFBU0RhQVVFQVJpSGJBU0RiQVFSQUlOZ0JLQUlBSWR3QklOd0JRUUJHSWQwQklOMEJCRUJCQUNFT0RBTUZJTndCSVFrZzJBRWhDZ3NGSU5vQklRa2cyUUVoQ2dzRFFBSkFJQWxCRkdvaDNnRWczZ0VvQWdBaDN3RWczd0ZCQUVZaDRBRWc0QUZGQkVBZzN3RWhDU0RlQVNFS0RBSUxJQWxCRUdvaDRnRWc0Z0VvQWdBaDR3RWc0d0ZCQUVZaDVBRWc1QUVFUUF3QkJTRGpBU0VKSU9JQklRb0xEQUVMQ3lBS1FRQTJBZ0FnQ1NFT0JTQkJRUWhxSWRNQklOTUJLQUlBSWRRQklOUUJRUXhxSWRVQklOVUJJTkVCTmdJQUlORUJRUWhxSWRjQklOY0JJTlFCTmdJQUlORUJJUTRMQ3lEUEFVRUFSaUhsQVNEbEFRUkFJRUVoQnlCTUlRZ2dRU0dMQWdVZ1FVRWNhaUhtQVNEbUFTZ0NBQ0huQVVIc09DRG5BVUVDZEdvaDZBRWc2QUVvQWdBaDZRRWc2UUVnUVVZaDZnRWc2Z0VFUUNEb0FTQU9OZ0lBSUE1QkFFWWhtQUlnbUFJRVFFRUJJT2NCZENIckFTRHJBVUYvY3lIdEFVSEFOaWdDQUNIdUFTRHVBU0R0QVhFaDd3RkJ3RFlnN3dFMkFnQWdRU0VISUV3aENDQkJJWXNDREFRTEJTRFBBVUVRYWlId0FTRHdBU2dDQUNIeEFTRHhBU0JCUnlIeUFTRHlBVUVCY1NFU0lNOEJRUkJxSUJKQkFuUnFJZk1CSVBNQklBNDJBZ0FnRGtFQVJpSDBBU0QwQVFSQUlFRWhCeUJNSVFnZ1FTR0xBZ3dFQ3dzZ0RrRVlhaUgxQVNEMUFTRFBBVFlDQUNCQlFSQnFJZllCSVBZQktBSUFJZmdCSVBnQlFRQkdJZmtCSVBrQlJRUkFJQTVCRUdvaCtnRWcrZ0VnK0FFMkFnQWcrQUZCR0dvaCt3RWcrd0VnRGpZQ0FBc2c5Z0ZCQkdvaC9BRWcvQUVvQWdBaC9RRWcvUUZCQUVZaC9nRWcvZ0VFUUNCQklRY2dUQ0VJSUVFaGl3SUZJQTVCRkdvaC93RWcvd0VnL1FFMkFnQWcvUUZCR0dvaGdBSWdnQUlnRGpZQ0FDQkJJUWNnVENFSUlFRWhpd0lMQ3dVZ2d3RWhCeURzQVNFSUlJTUJJWXNDQ3dzZ2l3SWc5d0ZKSVlvQ0lJb0NSUVJBRHdzZzl3RkJCR29oakFJZ2pBSW9BZ0FoamdJZ2pnSkJBWEVoandJZ2p3SkJBRVloa0FJZ2tBSUVRQThMSUk0Q1FRSnhJWkVDSUpFQ1FRQkdJWklDSUpJQ0JFQkIxRFlvQWdBaGt3SWdrd0lnOXdGR0laUUNJSlFDQkVCQnlEWW9BZ0FobFFJZ2xRSWdDR29obGdKQnlEWWdsZ0kyQWdCQjFEWWdCellDQUNDV0FrRUJjaUdYQWlBSFFRUnFJUllnRmlDWEFqWUNBRUhRTmlnQ0FDRVhJQWNnRjBZaEdDQVlSUVJBRHd0QjBEWkJBRFlDQUVIRU5rRUFOZ0lBRHd0QjBEWW9BZ0FoR1NBWklQY0JSaUVhSUJvRVFFSEVOaWdDQUNFYklCc2dDR29oSEVIRU5pQWNOZ0lBUWRBMklJc0NOZ0lBSUJ4QkFYSWhIU0FIUVFScUlSNGdIaUFkTmdJQUlJc0NJQnhxSVI4Z0h5QWNOZ0lBRHdzZ2pnSkJlSEVoSVNBaElBaHFJU0lnamdKQkEzWWhJeUNPQWtHQUFra2hKQUpBSUNRRVFDRDNBVUVJYWlFbElDVW9BZ0FoSmlEM0FVRU1haUVuSUNjb0FnQWhLQ0FvSUNaR0lTa2dLUVJBUVFFZ0kzUWhLaUFxUVg5eklTeEJ2RFlvQWdBaExTQXRJQ3h4SVM1QnZEWWdMallDQUF3Q0JTQW1RUXhxSVM4Z0x5QW9OZ0lBSUNoQkNHb2hNQ0F3SUNZMkFnQU1BZ3NBQlNEM0FVRVlhaUV4SURFb0FnQWhNaUQzQVVFTWFpRXpJRE1vQWdBaE5DQTBJUGNCUmlFMUFrQWdOUVJBSVBjQlFSQnFJVHNnTzBFRWFpRThJRHdvQWdBaFBTQTlRUUJHSVQ0Z1BnUkFJRHNvQWdBaFB5QS9RUUJHSVVBZ1FBUkFRUUFoRHd3REJTQS9JUXNnT3lFTUN3VWdQU0VMSUR3aERBc0RRQUpBSUF0QkZHb2hRaUJDS0FJQUlVTWdRMEVBUmlGRUlFUkZCRUFnUXlFTElFSWhEQXdDQ3lBTFFSQnFJVVVnUlNnQ0FDRkdJRVpCQUVZaFJ5QkhCRUFNQVFVZ1JpRUxJRVVoREFzTUFRc0xJQXhCQURZQ0FDQUxJUThGSVBjQlFRaHFJVGNnTnlnQ0FDRTRJRGhCREdvaE9TQTVJRFEyQWdBZ05FRUlhaUU2SURvZ09EWUNBQ0EwSVE4TEN5QXlRUUJHSVVnZ1NFVUVRQ0QzQVVFY2FpRkpJRWtvQWdBaFNrSHNPQ0JLUVFKMGFpRkxJRXNvQWdBaFRTQk5JUGNCUmlGT0lFNEVRQ0JMSUE4MkFnQWdEMEVBUmlHWkFpQ1pBZ1JBUVFFZ1NuUWhUeUJQUVg5eklWQkJ3RFlvQWdBaFVTQlJJRkJ4SVZKQndEWWdVallDQUF3RUN3VWdNa0VRYWlGVElGTW9BZ0FoVkNCVUlQY0JSeUZWSUZWQkFYRWhFeUF5UVJCcUlCTkJBblJxSVZZZ1ZpQVBOZ0lBSUE5QkFFWWhXQ0JZQkVBTUJBc0xJQTlCR0dvaFdTQlpJREkyQWdBZzl3RkJFR29oV2lCYUtBSUFJVnNnVzBFQVJpRmNJRnhGQkVBZ0QwRVFhaUZkSUYwZ1d6WUNBQ0JiUVJocUlWNGdYaUFQTmdJQUN5QmFRUVJxSVY4Z1h5Z0NBQ0ZnSUdCQkFFWWhZU0JoUlFSQUlBOUJGR29oWXlCaklHQTJBZ0FnWUVFWWFpRmtJR1FnRHpZQ0FBc0xDd3NnSWtFQmNpRmxJQWRCQkdvaFppQm1JR1UyQWdBZ2l3SWdJbW9oWnlCbklDSTJBZ0JCMERZb0FnQWhhQ0FISUdoR0lXa2dhUVJBUWNRMklDSTJBZ0FQQlNBaUlRMExCU0NPQWtGK2NTRnFJSXdDSUdvMkFnQWdDRUVCY2lGcklBZEJCR29oYkNCc0lHczJBZ0FnaXdJZ0NHb2hiaUJ1SUFnMkFnQWdDQ0VOQ3lBTlFRTjJJVzhnRFVHQUFra2hjQ0J3QkVBZ2IwRUJkQ0Z4UWVRMklIRkJBblJxSVhKQnZEWW9BZ0FoYzBFQklHOTBJWFFnY3lCMGNTRjFJSFZCQUVZaGRpQjJCRUFnY3lCMGNpRjNRYncySUhjMkFnQWdja0VJYWlFUUlISWhCaUFRSVJFRklISkJDR29oZVNCNUtBSUFJWG9nZWlFR0lIa2hFUXNnRVNBSE5nSUFJQVpCREdvaGV5QjdJQWMyQWdBZ0IwRUlhaUY4SUh3Z0JqWUNBQ0FIUVF4cUlYMGdmU0J5TmdJQUR3c2dEVUVJZGlGK0lINUJBRVloZnlCL0JFQkJBQ0VGQlNBTlFmLy8vd2RMSVlBQklJQUJCRUJCSHlFRkJTQitRWUQrUDJvaGdRRWdnUUZCRUhZaGdnRWdnZ0ZCQ0hFaGhRRWdmaUNGQVhRaGhnRWdoZ0ZCZ09BZmFpR0hBU0NIQVVFUWRpR0lBU0NJQVVFRWNTR0pBU0NKQVNDRkFYSWhpZ0VnaGdFZ2lRRjBJWXNCSUlzQlFZQ0FEMm9oakFFZ2pBRkJFSFloalFFZ2pRRkJBbkVoamdFZ2lnRWdqZ0Z5SVpBQlFRNGdrQUZySVpFQklJc0JJSTRCZENHU0FTQ1NBVUVQZGlHVEFTQ1JBU0NUQVdvaGxBRWdsQUZCQVhRaGxRRWdsQUZCQjJvaGxnRWdEU0NXQVhZaGx3RWdsd0ZCQVhFaG1BRWdtQUVnbFFGeUlaa0JJSmtCSVFVTEMwSHNPQ0FGUVFKMGFpR2JBU0FIUVJ4cUlad0JJSndCSUFVMkFnQWdCMEVRYWlHZEFTQUhRUlJxSVo0QklKNEJRUUEyQWdBZ25RRkJBRFlDQUVIQU5pZ0NBQ0dmQVVFQklBVjBJYUFCSUo4QklLQUJjU0doQVNDaEFVRUFSaUdpQVFKQUlLSUJCRUFnbndFZ29BRnlJYU1CUWNBMklLTUJOZ0lBSUpzQklBYzJBZ0FnQjBFWWFpR2tBU0NrQVNDYkFUWUNBQ0FIUVF4cUlhWUJJS1lCSUFjMkFnQWdCMEVJYWlHbkFTQ25BU0FITmdJQUJTQ2JBU2dDQUNHb0FTQUZRUjlHSWFrQklBVkJBWFlocWdGQkdTQ3FBV3NocXdFZ3FRRUVmMEVBQlNDckFRc2hyQUVnRFNDc0FYUWhyUUVnclFFaEF5Q29BU0VFQTBBQ1FDQUVRUVJxSWE0QklLNEJLQUlBSWE4QklLOEJRWGh4SWJFQklMRUJJQTFHSWJJQklMSUJCRUJCeVFBaG1nSU1BUXNnQTBFZmRpR3pBU0FFUVJCcUlMTUJRUUowYWlHMEFTQURRUUYwSWJVQklMUUJLQUlBSWJZQklMWUJRUUJHSWJjQklMY0JCRUJCeUFBaG1nSU1BUVVndFFFaEF5QzJBU0VFQ3d3QkN3c2dtZ0pCeUFCR0JFQWd0QUVnQnpZQ0FDQUhRUmhxSWJnQklMZ0JJQVEyQWdBZ0IwRU1haUc1QVNDNUFTQUhOZ0lBSUFkQkNHb2h1Z0VndWdFZ0J6WUNBQXdDQlNDYUFrSEpBRVlFUUNBRVFRaHFJYndCSUx3QktBSUFJYjBCSUwwQlFReHFJYjRCSUw0QklBYzJBZ0FndkFFZ0J6WUNBQ0FIUVFocUliOEJJTDhCSUwwQk5nSUFJQWRCREdvaHdBRWd3QUVnQkRZQ0FDQUhRUmhxSWNFQklNRUJRUUEyQWdBTUF3c0xDd3RCM0RZb0FnQWh3Z0Vnd2dGQmYyb2h3d0ZCM0RZZ3d3RTJBZ0Fnd3dGQkFFWWh4QUVneEFFRVFFR0VPaUVDQlE4TEEwQUNRQ0FDS0FJQUlRRWdBVUVBUmlIRkFTQUJRUWhxSWNjQklNVUJCRUFNQVFVZ3h3RWhBZ3NNQVFzTFFkdzJRWDgyQWdBUEMwOEJDSDhqRFNFSUl3MUJFR29rRFNNTkl3NU9CRUJCRUJBREN5QUlJUVlnQUVFOGFpRUJJQUVvQWdBaEFpQUNFREloQXlBR0lBTTJBZ0JCQmlBR0VBc2hCQ0FFRURBaEJTQUlKQTBnQlE4TG13VUJRSDhqRFNGQ0l3MUJNR29rRFNNTkl3NU9CRUJCTUJBREN5QkNRUkJxSVR3Z1FpRTdJRUpCSUdvaEhpQUFRUnhxSVNrZ0tTZ0NBQ0UwSUI0Z05EWUNBQ0FlUVFScUlUY2dBRUVVYWlFNElEZ29BZ0FoT1NBNUlEUnJJVG9nTnlBNk5nSUFJQjVCQ0dvaENpQUtJQUUyQWdBZ0hrRU1haUVMSUFzZ0FqWUNBQ0E2SUFKcUlRd2dBRUU4YWlFTklBMG9BZ0FoRGlBZUlROGdPeUFPTmdJQUlEdEJCR29oUFNBOUlBODJBZ0FnTzBFSWFpRStJRDVCQWpZQ0FFR1NBU0E3RUFraEVDQVFFREFoRVNBTUlCRkdJUklDUUNBU0JFQkJBeUZCQlVFQ0lRUWdEQ0VGSUI0aEJpQVJJUnNEUUFKQUlCdEJBRWdoR2lBYUJFQU1BUXNnQlNBYmF5RWtJQVpCQkdvaEpTQWxLQUlBSVNZZ0d5QW1TeUVuSUFaQkNHb2hLQ0FuQkg4Z0tBVWdCZ3NoQ1NBblFSOTBRUjkxSVNvZ0JDQXFhaUVJSUNjRWZ5QW1CVUVBQ3lFcklCc2dLMnNoQXlBSktBSUFJU3dnTENBRGFpRXRJQWtnTFRZQ0FDQUpRUVJxSVM0Z0xpZ0NBQ0V2SUM4Z0Eyc2hNQ0F1SURBMkFnQWdEU2dDQUNFeElBa2hNaUE4SURFMkFnQWdQRUVFYWlFL0lEOGdNallDQUNBOFFRaHFJVUFnUUNBSU5nSUFRWklCSUR3UUNTRXpJRE1RTUNFMUlDUWdOVVloTmlBMkJFQkJBeUZCREFRRklBZ2hCQ0FrSVFVZ0NTRUdJRFVoR3dzTUFRc0xJQUJCRUdvaEhDQWNRUUEyQWdBZ0tVRUFOZ0lBSURoQkFEWUNBQ0FBS0FJQUlSMGdIVUVnY2lFZklBQWdIellDQUNBRVFRSkdJU0FnSUFSQVFRQWhCd1VnQmtFRWFpRWhJQ0VvQWdBaElpQUNJQ0pySVNNZ0l5RUhDd3NMSUVGQkEwWUVRQ0FBUVN4cUlSTWdFeWdDQUNFVUlBQkJNR29oRlNBVktBSUFJUllnRkNBV2FpRVhJQUJCRUdvaEdDQVlJQmMyQWdBZ0ZDRVpJQ2tnR1RZQ0FDQTRJQmsyQWdBZ0FpRUhDeUJDSkEwZ0J3OExzQUVCRUg4akRTRVNJdzFCSUdva0RTTU5JdzVPQkVCQklCQURDeUFTSVF3Z0VrRVVhaUVGSUFCQlBHb2hCaUFHS0FJQUlRY2dCU0VJSUF3Z0J6WUNBQ0FNUVFScUlRMGdEVUVBTmdJQUlBeEJDR29oRGlBT0lBRTJBZ0FnREVFTWFpRVBJQThnQ0RZQ0FDQU1RUkJxSVJBZ0VDQUNOZ0lBUVl3QklBd1FDQ0VKSUFrUU1DRUtJQXBCQUVnaEN5QUxCRUFnQlVGL05nSUFRWDhoQkFVZ0JTZ0NBQ0VESUFNaEJBc2dFaVFOSUFRUEN6TUJCbjhqRFNFR0lBQkJnR0JMSVFJZ0FnUkFRUUFnQUdzaEF4QXhJUVFnQkNBRE5nSUFRWDhoQVFVZ0FDRUJDeUFCRHdzTUFRSi9JdzBoQVVIc09nOExDd0VDZnlNTklRSWdBQThMdXdFQkVYOGpEU0VUSXcxQklHb2tEU01OSXc1T0JFQkJJQkFEQ3lBVElROGdFMEVRYWlFSUlBQkJKR29oQ1NBSlFRSTJBZ0FnQUNnQ0FDRUtJQXBCd0FCeElRc2dDMEVBUmlFTUlBd0VRQ0FBUVR4cUlRMGdEU2dDQUNFT0lBZ2hBeUFQSUE0MkFnQWdEMEVFYWlFUUlCQkJrNmdCTmdJQUlBOUJDR29oRVNBUklBTTJBZ0JCTmlBUEVBb2hCQ0FFUVFCR0lRVWdCVVVFUUNBQVFjc0FhaUVHSUFaQmZ6b0FBQXNMSUFBZ0FTQUNFQzRoQnlBVEpBMGdCdzhMMEFFQkZYOGpEU0VXSUFBc0FBQWhDeUFCTEFBQUlRd2dDMEVZZEVFWWRTQU1RUmgwUVJoMVJ5RU5JQXRCR0hSQkdIVkJBRVloRGlBT0lBMXlJUlFnRkFSQUlBd2hCQ0FMSVFVRklBRWhBaUFBSVFNRFFBSkFJQU5CQVdvaER5QUNRUUZxSVJBZ0R5d0FBQ0VSSUJBc0FBQWhFaUFSUVJoMFFSaDFJQkpCR0hSQkdIVkhJUVlnRVVFWWRFRVlkVUVBUmlFSElBY2dCbkloRXlBVEJFQWdFaUVFSUJFaEJRd0JCU0FRSVFJZ0R5RURDd3dCQ3dzTElBVkIvd0Z4SVFnZ0JFSC9BWEVoQ1NBSUlBbHJJUW9nQ2c4THd3UUJMWDhqRFNFdkl3MUI0QUZxSkEwakRTTU9UZ1JBUWVBQkVBTUxJQzlCK0FCcUlSc2dMMEhRQUdvaEppQXZJU2dnTDBHSUFXb2hLU0FtUWdBM0FnQWdKa0VJYWtJQU53SUFJQ1pCRUdwQ0FEY0NBQ0FtUVJocVFnQTNBZ0FnSmtFZ2FrSUFOd0lBSUFJb0FnQWhMU0FiSUMwMkFnQkJBQ0FCSUJzZ0tDQW1FRFloS2lBcVFRQklJU3NnS3dSQVFYOGhCQVVnQUVITUFHb2hMQ0FzS0FJQUlRY2dCMEYvU2lFSUlBZ0VRQ0FBRURjaENTQUpJU2NGUVFBaEp3c2dBQ2dDQUNFS0lBcEJJSEVoQ3lBQVFjb0FhaUVNSUF3c0FBQWhEU0FOUVJoMFFSaDFRUUZJSVE0Z0RnUkFJQXBCWDNFaER5QUFJQTgyQWdBTElBQkJNR29oRUNBUUtBSUFJUkVnRVVFQVJpRVNJQklFUUNBQVFTeHFJUlFnRkNnQ0FDRVZJQlFnS1RZQ0FDQUFRUnhxSVJZZ0ZpQXBOZ0lBSUFCQkZHb2hGeUFYSUNrMkFnQWdFRUhRQURZQ0FDQXBRZEFBYWlFWUlBQkJFR29oR1NBWklCZzJBZ0FnQUNBQklCc2dLQ0FtRURZaEdpQVZRUUJHSVJ3Z0hBUkFJQm9oQlFVZ0FFRWthaUVkSUIwb0FnQWhIaUFBUVFCQkFDQWVRUWR4UVFocUVRQUFHaUFYS0FJQUlSOGdIMEVBUmlFZ0lDQUVmMEYvQlNBYUN5RURJQlFnRlRZQ0FDQVFRUUEyQWdBZ0dVRUFOZ0lBSUJaQkFEWUNBQ0FYUVFBMkFnQWdBeUVGQ3dVZ0FDQUJJQnNnS0NBbUVEWWhFeUFUSVFVTElBQW9BZ0FoSVNBaFFTQnhJU0lnSWtFQVJpRWpJQ01FZnlBRkJVRi9DeUVHSUNFZ0MzSWhKQ0FBSUNRMkFnQWdKMEVBUmlFbElDVkZCRUFnQUJBNEN5QUdJUVFMSUM4a0RTQUVEd3ZvS2dQbkFuOE9mZ0Y4SXcwaDZ3SWpEVUhBQUdva0RTTU5JdzVPQkVCQndBQVFBd3NnNndKQkVHb2hrZ0lnNndJaG5RSWc2d0pCR0dvaHFBSWc2d0pCQ0dvaHN3SWc2d0pCRkdvaHZRSWdrZ0lnQVRZQ0FDQUFRUUJISVU4Z3FBSkJLR29oV2lCYUlXUWdxQUpCSjJvaGJ5Q3pBa0VFYWlGNlFRQWhGa0VBSVJkQkFDRWhJQUVodlFFRFFBSkFJQmRCZjBvaGhBRUNRQ0NFQVFSQVFmLy8vLzhISUJkcklZNEJJQllnamdGS0laY0JJSmNCQkVBUU1TR2hBU0NoQVVITEFEWUNBRUYvSVNvTUFnVWdGaUFYYWlHcUFTQ3FBU0VxREFJTEFBVWdGeUVxQ3dzZ3ZRRXNBQUFoc3dFZ3N3RkJHSFJCR0hWQkFFWWh4d0VneHdFRVFFSFdBQ0hxQWd3QkJTQ3pBU0hTQVNDOUFTSG5BUXNEUUFKQUFrQUNRQUpBQWtBZzBnRkJHSFJCR0hWQkFHc09KZ0VDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQWdzQ1FDRG5BU0VaSU9jQklmc0JRUWtoNmdJTUJBd0RBQXNBQ3dKQUlPY0JJUmdnNXdFaGh3SU1Bd3dDQUFzQUN3RUxJT2NCUVFGcUlkMEJJSklDSU4wQk5nSUFJTjBCTEFBQUlVb2dTaUhTQVNEZEFTSG5BUXdCQ3dzQ1FDRHFBa0VKUmdSQUEwQUNRRUVBSWVvQ0lQc0JRUUZxSWZJQklQSUJMQUFBSWZ3QklQd0JRUmgwUVJoMVFTVkdJZjBCSVAwQlJRUkFJQmtoR0NEN0FTR0hBZ3dFQ3lBWlFRRnFJZjRCSVBzQlFRSnFJZjhCSUpJQ0lQOEJOZ0lBSVA4QkxBQUFJWUFDSUlBQ1FSaDBRUmgxUVNWR0lZRUNJSUVDQkVBZy9nRWhHU0QvQVNIN0FVRUpJZW9DQlNEK0FTRVlJUDhCSVljQ0RBRUxEQUVMQ3dzTElCZ2hnZ0lndlFFaGd3SWdnZ0lnZ3dKcklZUUNJRThFUUNBQUlMMEJJSVFDRURrTElJUUNRUUJHSVlVQ0lJVUNSUVJBSUNFaElpQ0VBaUVXSUNvaEZ5Q0hBaUc5QVNBaUlTRU1BZ3NnaHdKQkFXb2hoZ0lnaGdJc0FBQWhpQUlnaUFKQkdIUkJHSFVoaVFJZ2lRSkJVR29oM3dJZzN3SkJDa2toM0FJZzNBSUVRQ0NIQWtFQ2FpR0tBaUNLQWl3QUFDR0xBaUNMQWtFWWRFRVlkVUVrUmlHTUFpQ0hBa0VEYWlHTkFpQ01BZ1IvSUkwQ0JTQ0dBZ3NoUkNDTUFnUi9RUUVGSUNFTElRa2dqQUlFZnlEZkFnVkJmd3NoNEFJZzRBSWhHeUFKSVRBZ1JDSG5BZ1ZCZnlFYklDRWhNQ0NHQWlIbkFnc2drZ0lnNXdJMkFnQWc1d0lzQUFBaGpnSWdqZ0pCR0hSQkdIVWhqd0lnandKQllHb2hrQUlna0FKQkgwc2hrUUpCQVNDUUFuUWhrd0lna3dKQmlkRUVjU0dVQWlDVUFrRUFSaUdWQWlDUkFpQ1ZBbkloelFJZ3pRSUVRRUVBSVI4Z2pnSWhTU0RuQWlHbkFnVkJBQ0VnSUk0Q0laY0NJT2NDSVp3Q0EwQUNRQ0NYQWtFWWRFRVlkU0dXQWlDV0FrRmdhaUdZQWtFQklKZ0NkQ0daQWlDWkFpQWdjaUdhQWlDY0FrRUJhaUdiQWlDU0FpQ2JBallDQUNDYkFpd0FBQ0dlQWlDZUFrRVlkRUVZZFNHZkFpQ2ZBa0ZnYWlHZ0FpQ2dBa0VmU3lHaEFrRUJJS0FDZENHaUFpQ2lBa0dKMFFSeElhTUNJS01DUVFCR0lhUUNJS0VDSUtRQ2NpSE1BaURNQWdSQUlKb0NJUjhnbmdJaFNTQ2JBaUduQWd3QkJTQ2FBaUVnSUo0Q0laY0NJSnNDSVp3Q0N3d0JDd3NMSUVsQkdIUkJHSFZCS2tZaHBRSWdwUUlFUUNDbkFrRUJhaUdtQWlDbUFpd0FBQ0dwQWlDcEFrRVlkRUVZZFNHcUFpQ3FBa0ZRYWlIaUFpRGlBa0VLU1NIZUFpRGVBZ1JBSUtjQ1FRSnFJYXNDSUtzQ0xBQUFJYXdDSUt3Q1FSaDBRUmgxUVNSR0lhMENJSzBDQkVBZ0JDRGlBa0VDZEdvaHJnSWdyZ0pCQ2pZQ0FDQ21BaXdBQUNHdkFpQ3ZBa0VZZEVFWWRTR3dBaUN3QWtGUWFpR3hBaUFESUxFQ1FRTjBhaUd5QWlDeUFpa0RBQ0g1QWlENUFxY2h0QUlncHdKQkEyb2h0UUlndEFJaEhrRUJJVHdndFFJaDZBSUZRUlloNmdJTEJVRVdJZW9DQ3lEcUFrRVdSZ1JBUVFBaDZnSWdNRUVBUmlHMkFpQzJBa1VFUUVGL0lRd01Bd3NnVHdSQUlBSW9BZ0FoeUFJZ3lBSWh0d0pCQUVFRWFpSFhBaURYQWlIV0FpRFdBa0VCYXlIT0FpQzNBaURPQW1vaHVBSkJBRUVFYWlIYkFpRGJBaUhhQWlEYUFrRUJheUhaQWlEWkFrRi9jeUhZQWlDNEFpRFlBbkVodVFJZ3VRSWh1Z0lndWdJb0FnQWh1d0lndWdKQkJHb2h5Z0lnQWlES0FqWUNBQ0M3QWlFZVFRQWhQQ0NtQWlIb0FnVkJBQ0VlUVFBaFBDQ21BaUhvQWdzTElKSUNJT2dDTmdJQUlCNUJBRWdodkFJZ0gwR0F3QUJ5SWI0Q1FRQWdIbXNodndJZ3ZBSUVmeUMrQWdVZ0h3c2hDQ0M4QWdSL0lMOENCU0FlQ3lFSElBY2hMU0FJSVM0Z1BDRkNJT2dDSWNNQ0JTQ1NBaEE2SWNBQ0lNQUNRUUJJSWNFQ0lNRUNCRUJCZnlFTURBSUxJSklDS0FJQUlVc2d3QUloTFNBZklTNGdNQ0ZDSUVzaHd3SUxJTU1DTEFBQUljSUNJTUlDUVJoMFFSaDFRUzVHSWNRQ0FrQWd4QUlFUUNEREFrRUJhaUhGQWlERkFpd0FBQ0hHQWlER0FrRVlkRUVZZFVFcVJpSEhBaURIQWtVRVFDRERBa0VCYWlGbElKSUNJR1UyQWdBZ2tnSVFPaUZtSUpJQ0tBSUFJVTBnWmlFY0lFMGhUQXdDQ3lEREFrRUNhaUZRSUZBc0FBQWhVU0JSUVJoMFFSaDFJVklnVWtGUWFpSGhBaURoQWtFS1NTSGRBaURkQWdSQUlNTUNRUU5xSVZNZ1V5d0FBQ0ZVSUZSQkdIUkJHSFZCSkVZaFZTQlZCRUFnQkNEaEFrRUNkR29oVmlCV1FRbzJBZ0FnVUN3QUFDRlhJRmRCR0hSQkdIVWhXQ0JZUVZCcUlWa2dBeUJaUVFOMGFpRmJJRnNwQXdBaDdRSWc3UUtuSVZ3Z3d3SkJCR29oWFNDU0FpQmROZ0lBSUZ3aEhDQmRJVXdNQXdzTElFSkJBRVloWGlCZVJRUkFRWDhoREF3REN5QlBCRUFnQWlnQ0FDSEpBaURKQWlGZlFRQkJCR29oMFFJZzBRSWgwQUlnMEFKQkFXc2h6d0lnWHlEUEFtb2hZRUVBUVFScUlkVUNJTlVDSWRRQ0lOUUNRUUZySWRNQ0lOTUNRWDl6SWRJQ0lHQWcwZ0p4SVdFZ1lTRmlJR0lvQWdBaFl5QmlRUVJxSWNzQ0lBSWd5d0kyQWdBZ1l5SDVBUVZCQUNINUFRc2drZ0lnVURZQ0FDRDVBU0VjSUZBaFRBVkJmeUVjSU1NQ0lVd0xDMEVBSVJvZ1RDRm9BMEFDUUNCb0xBQUFJV2NnWjBFWWRFRVlkU0ZwSUdsQnYzOXFJV29nYWtFNVN5RnJJR3NFUUVGL0lRd01Bd3NnYUVFQmFpRnNJSklDSUd3MkFnQWdhQ3dBQUNGdElHMUJHSFJCR0hVaGJpQnVRYjkvYWlGd1FjSWpJQnBCT214cUlIQnFJWEVnY1N3QUFDRnlJSEpCL3dGeElYTWdjMEYvYWlGMElIUkJDRWtoZFNCMUJFQWdjeUVhSUd3aGFBVU1BUXNNQVFzTElISkJHSFJCR0hWQkFFWWhkaUIyQkVCQmZ5RU1EQUVMSUhKQkdIUkJHSFZCRTBZaGR5QWJRWDlLSVhnQ1FDQjNCRUFnZUFSQVFYOGhEQXdEQlVFd0llb0NDd1VnZUFSQUlBUWdHMEVDZEdvaGVTQjVJSE0yQWdBZ0F5QWJRUU4wYWlGN0lIc3BBd0FoN2dJZ25RSWc3Z0kzQXdCQk1DSHFBZ3dDQ3lCUFJRUkFRUUFoREF3REN5Q2RBaUJ6SUFJUU93c0xJT29DUVRCR0JFQkJBQ0hxQWlCUFJRUkFRUUFoRmlBcUlSY2dRaUVoSUd3aHZRRU1Bd3NMSUdnc0FBQWhmQ0I4UVJoMFFSaDFJWDBnR2tFQVJ5RitJSDFCRDNFaGZ5Qi9RUU5HSVlBQklINGdnQUZ4SWVRQ0lIMUJYM0VoZ1FFZzVBSUVmeUNCQVFVZ2ZRc2hFU0F1UVlEQUFIRWhnZ0VnZ2dGQkFFWWhnd0VnTGtILy8zdHhJWVVCSUlNQkJIOGdMZ1VnaFFFTElTOENRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnRVVIQkFHc09PQTBWQ3hVUUR3NFZGUlVWRlJVVkZSVVZGUXdWRlJVVkFoVVZGUlVWRlJVVkVSVUlCaFFURWhVRkZSVVZDUUFFQVJVVkNoVUhGUlVERlFzQ1FDQWFRZjhCY1NIcEFnSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDRHBBa0VZZEVFWWRVRUFhdzRJQUFFQ0F3UUhCUVlIQ3dKQUlKMENLQUlBSVlZQklJWUJJQ28yQWdCQkFDRVdJQ29oRnlCQ0lTRWdiQ0c5QVF3aURBZ0FDd0FMQWtBZ25RSW9BZ0FoaHdFZ2h3RWdLallDQUVFQUlSWWdLaUVYSUVJaElTQnNJYjBCRENFTUJ3QUxBQXNDUUNBcXJDSHZBaUNkQWlnQ0FDR0lBU0NJQVNEdkFqY0RBRUVBSVJZZ0tpRVhJRUloSVNCc0liMEJEQ0FNQmdBTEFBc0NRQ0FxUWYvL0EzRWhpUUVnblFJb0FnQWhpZ0VnaWdFZ2lRRTdBUUJCQUNFV0lDb2hGeUJDSVNFZ2JDRzlBUXdmREFVQUN3QUxBa0FnS2tIL0FYRWhpd0VnblFJb0FnQWhqQUVnakFFZ2l3RTZBQUJCQUNFV0lDb2hGeUJDSVNFZ2JDRzlBUXdlREFRQUN3QUxBa0FnblFJb0FnQWhqUUVnalFFZ0tqWUNBRUVBSVJZZ0tpRVhJRUloSVNCc0liMEJEQjBNQXdBTEFBc0NRQ0FxckNId0FpQ2RBaWdDQUNHUEFTQ1BBU0R3QWpjREFFRUFJUllnS2lFWElFSWhJU0JzSWIwQkRCd01BZ0FMQUFzQ1FFRUFJUllnS2lFWElFSWhJU0JzSWIwQkRCc0FDd0FMREJZQUN3QUxBa0FnSEVFSVN5R1FBU0NRQVFSL0lCd0ZRUWdMSVpFQklDOUJDSEloa2dGQitBQWhKaUNSQVNFc0lKSUJJVUZCUENIcUFnd1ZBQXNBQ3dFTEFrQWdFU0VtSUJ3aExDQXZJVUZCUENIcUFnd1RBQXNBQ3dKQUlKMENLUU1BSWZJQ0lQSUNJRm9RUFNHYkFTQXZRUWh4SVp3QklKd0JRUUJHSVowQklKc0JJWjRCSUdRZ25nRnJJWjhCSUJ3Z253RktJYUFCSUo4QlFRRnFJYUlCSUowQklLQUJjaUdqQVNDakFRUi9JQndGSUtJQkN5RWRJSnNCSVExQkFDRWxRWkluSVNjZ0hTRTRJQzhoUmlEeUFpSDJBa0hDQUNIcUFnd1NBQXNBQ3dFTEFrQWduUUlwQXdBaDh3SWc4d0pDQUZNaHBBRWdwQUVFUUVJQUlQTUNmU0gwQWlDZEFpRDBBamNEQUVFQklSQkJraWNoRWlEMEFpSDFBa0hCQUNIcUFnd1NCU0F2UVlBUWNTR2xBU0NsQVVFQVJpR21BU0F2UVFGeElhY0JJS2NCUVFCR0lhZ0JJS2dCQkg5QmtpY0ZRWlFuQ3lFRklLWUJCSDhnQlFWQmt5Y0xJUVlnTDBHQkVIRWhxUUVncVFGQkFFY2hxd0VncXdGQkFYRWhQU0E5SVJBZ0JpRVNJUE1DSWZVQ1FjRUFJZW9DREJJTEFBd1FBQXNBQ3dKQUlKMENLUU1BSWV3Q1FRQWhFRUdTSnlFU0lPd0NJZlVDUWNFQUllb0NEQThBQ3dBTEFrQWduUUlwQXdBaDl3SWc5d0tuUWY4QmNTRzRBU0J2SUxnQk9nQUFJRzhoTVVFQUlUSkJraWNoTXlCYUlUZEJBU0ZISUlVQklVZ01EZ0FMQUFzQ1FCQXhJYmtCSUxrQktBSUFJYm9CSUxvQkVEOGh1d0VndXdFaEkwSEdBQ0hxQWd3TkFBc0FDd0pBSUowQ0tBSUFJYndCSUx3QlFRQkhJYjRCSUw0QkJIOGd2QUVGUVp3bkN5Ry9BU0MvQVNFalFjWUFJZW9DREF3QUN3QUxBa0FnblFJcEF3QWgrQUlnK0FLbkljWUJJTE1DSU1ZQk5nSUFJSHBCQURZQ0FDQ2RBaUN6QWpZQ0FFRi9JVVVnc3dJaCtnRkJ5Z0FoNmdJTUN3QUxBQXNDUUNDZEFpZ0NBQ0ZPSUJ4QkFFWWh5QUVneUFFRVFDQUFRU0FnTFVFQUlDOFFRVUVBSVJSQjB3QWg2Z0lGSUJ3aFJTQk9JZm9CUWNvQUllb0NDd3dLQUFzQUN3RUxBUXNCQ3dFTEFRc0JDd0VMQWtBZ25RSXJBd0FoK2dJZ0FDRDZBaUF0SUJ3Z0x5QVJFRU1oNEFFZzRBRWhGaUFxSVJjZ1FpRWhJR3dodlFFTUJRd0NBQXNBQ3dKQUlMMEJJVEZCQUNFeVFaSW5JVE1nV2lFM0lCd2hSeUF2SVVnTEN3c0NRQ0RxQWtFOFJnUkFRUUFoNmdJZ25RSXBBd0FoOFFJZ0prRWdjU0dUQVNEeEFpQmFJSk1CRUR3aGxBRWc4UUpDQUZFaGxRRWdRVUVJY1NHV0FTQ1dBVUVBUmlHWUFTQ1lBU0NWQVhJaDVRSWdKa0VFZFNHWkFVR1NKeUNaQVdvaG1nRWc1UUlFZjBHU0p3VWdtZ0VMSVQ0ZzVRSUVmMEVBQlVFQ0N5RS9JSlFCSVEwZ1B5RWxJRDRoSnlBc0lUZ2dRU0ZHSVBFQ0lmWUNRY0lBSWVvQ0JTRHFBa0hCQUVZRVFFRUFJZW9DSVBVQ0lGb1FQaUdzQVNDc0FTRU5JQkFoSlNBU0lTY2dIQ0U0SUM4aFJpRDFBaUgyQWtIQ0FDSHFBZ1VnNmdKQnhnQkdCRUJCQUNIcUFpQWpRUUFnSEJCQUljQUJJTUFCUVFCR0ljRUJJTUFCSWNJQklDTWh3d0Vnd2dFZ3d3RnJJY1FCSUNNZ0hHb2h4UUVnd1FFRWZ5QWNCU0RFQVFzaFFDREJBUVIvSU1VQkJTREFBUXNoS3lBaklURkJBQ0V5UVpJbklUTWdLeUUzSUVBaFJ5Q0ZBU0ZJQlNEcUFrSEtBRVlFUUVFQUllb0NJUG9CSVE5QkFDRVZRUUFoS1FOQUFrQWdEeWdDQUNISkFTREpBVUVBUmlIS0FTREtBUVJBSUJVaEV5QXBJVFlNQVFzZ3ZRSWd5UUVRUWlITEFTRExBVUVBU0NITUFTQkZJQlZySWMwQklNc0JJTTBCU3lIT0FTRE1BU0RPQVhJaDVnSWc1Z0lFUUNBVklSTWd5d0VoTmd3QkN5QVBRUVJxSWM4QklNc0JJQlZxSWRBQklFVWcwQUZMSWRFQklORUJCRUFnendFaER5RFFBU0VWSU1zQklTa0ZJTkFCSVJNZ3l3RWhOZ3dCQ3d3QkN3c2dOa0VBU0NIVEFTRFRBUVJBUVg4aERBd0dDeUFBUVNBZ0xTQVRJQzhRUVNBVFFRQkdJZFFCSU5RQkJFQkJBQ0VVUWRNQUllb0NCU0Q2QVNFa1FRQWhLQU5BQWtBZ0pDZ0NBQ0hWQVNEVkFVRUFSaUhXQVNEV0FRUkFJQk1oRkVIVEFDSHFBZ3dJQ3lDOUFpRFZBUkJDSWRjQklOY0JJQ2hxSWRnQklOZ0JJQk5LSWRrQklOa0JCRUFnRXlFVVFkTUFJZW9DREFnTElDUkJCR29oMmdFZ0FDQzlBaURYQVJBNUlOZ0JJQk5KSWRzQklOc0JCRUFnMmdFaEpDRFlBU0VvQlNBVElSUkIwd0FoNmdJTUFRc01BUXNMQ3dzTEN3c0xJT29DUWNJQVJnUkFRUUFoNmdJZ09FRi9TaUd0QVNCR1FmLy9lM0VocmdFZ3JRRUVmeUN1QVFVZ1Jnc2hDaUQyQWtJQVVpR3ZBU0E0UVFCSEliQUJJTEFCSUs4QmNpSGpBaUFOSWJFQklHUWdzUUZySWJJQklLOEJRUUZ6SWJRQklMUUJRUUZ4SWJVQklMSUJJTFVCYWlHMkFTQTRJTFlCU2lHM0FTQzNBUVIvSURnRklMWUJDeUU1SU9NQ0JIOGdPUVVnT0FzaE9pRGpBZ1IvSUEwRklGb0xJUTRnRGlFeElDVWhNaUFuSVRNZ1dpRTNJRG9oUnlBS0lVZ0ZJT29DUWRNQVJnUkFRUUFoNmdJZ0wwR0F3QUJ6SWR3QklBQkJJQ0F0SUJRZzNBRVFRU0F0SUJSS0lkNEJJTjRCQkg4Z0xRVWdGQXNoM3dFZzN3RWhGaUFxSVJjZ1FpRWhJR3dodlFFTUF3c0xJRGNoNFFFZ01TSGlBU0RoQVNEaUFXc2g0d0VnUnlEakFVZ2g1QUVnNUFFRWZ5RGpBUVVnUndzaEN5QUxJREpxSWVVQklDMGc1UUZJSWVZQklPWUJCSDhnNVFFRklDMExJVHNnQUVFZ0lEc2c1UUVnU0JCQklBQWdNeUF5RURrZ1NFR0FnQVJ6SWVnQklBQkJNQ0E3SU9VQklPZ0JFRUVnQUVFd0lBc2c0d0ZCQUJCQklBQWdNU0RqQVJBNUlFaEJnTUFBY3lIcEFTQUFRU0FnT3lEbEFTRHBBUkJCSURzaEZpQXFJUmNnUWlFaElHd2h2UUVNQVFzTEFrQWc2Z0pCMWdCR0JFQWdBRUVBUmlIcUFTRHFBUVJBSUNGQkFFWWg2d0VnNndFRVFFRUFJUXdGUVFFaE5RTkFBa0FnQkNBMVFRSjBhaUhzQVNEc0FTZ0NBQ0h0QVNEdEFVRUFSaUh1QVNEdUFRUkFJRFVoTkF3QkN5QURJRFZCQTNScUlmQUJJUEFCSU8wQklBSVFPeUExUVFGcUlmRUJJRFZCQ1VnaDh3RWc4d0VFUUNEeEFTRTFCU0R4QVNFMERBRUxEQUVMQ3lBMFFRcElJZThCSU84QkJFQWdOQ0ZEQTBBQ1FDQUVJRU5CQW5ScUlmWUJJUFlCS0FJQUlmY0JJUGNCUVFCR0lmZ0JJUGdCUlFSQVFYOGhEQXdIQ3lCRFFRRnFJZlFCSUVOQkNVZ2g5UUVnOVFFRVFDRDBBU0ZEQlVFQklRd01BUXNNQVFzTEJVRUJJUXdMQ3dVZ0tpRU1Dd3NMSU9zQ0pBMGdEQThMQ3dFQ2Z5TU5JUUpCQUE4TENRRUNmeU1OSVFJUEN5d0JCWDhqRFNFSElBQW9BZ0FoQXlBRFFTQnhJUVFnQkVFQVJpRUZJQVVFUUNBQklBSWdBQkJRR2dzUEM2SUJBUkovSXcwaEVpQUFLQUlBSVFNZ0F5d0FBQ0VFSUFSQkdIUkJHSFVoQlNBRlFWQnFJUThnRDBFS1NTRU5JQTBFUUVFQUlRSWdBeUVKSUE4aEVBTkFBa0FnQWtFS2JDRUdJQkFnQm1vaEJ5QUpRUUZxSVFnZ0FDQUlOZ0lBSUFnc0FBQWhDaUFLUVJoMFFSaDFJUXNnQzBGUWFpRU9JQTVCQ2traERDQU1CRUFnQnlFQ0lBZ2hDU0FPSVJBRklBY2hBUXdCQ3d3QkN3c0ZRUUFoQVFzZ0FROExtUW9Ea0FGL0IzNENmQ01OSVpJQklBRkJGRXNoRmdKQUlCWkZCRUFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBVUVKYXc0S0FBRUNBd1FGQmdjSUNRb0xBa0FnQWlnQ0FDRTNJRGNoSDBFQVFRUnFJVTBnVFNGTUlFeEJBV3NoU3lBZklFdHFJU2xCQUVFRWFpRlJJRkVoVUNCUVFRRnJJVThnVDBGL2N5Rk9JQ2tnVG5FaE1pQXlJVFFnTkNnQ0FDRTFJRFJCQkdvaFFTQUNJRUUyQWdBZ0FDQTFOZ0lBREEwTUN3QUxBQXNDUUNBQ0tBSUFJVHNnT3lFMlFRQkJCR29oVkNCVUlWTWdVMEVCYXlGU0lEWWdVbW9oQlVFQVFRUnFJVmdnV0NGWElGZEJBV3NoVmlCV1FYOXpJVlVnQlNCVmNTRUdJQVloQnlBSEtBSUFJUWdnQjBFRWFpRklJQUlnU0RZQ0FDQUlyQ0dUQVNBQUlKTUJOd01BREF3TUNnQUxBQXNDUUNBQ0tBSUFJVDhnUHlFSlFRQkJCR29oV3lCYklWb2dXa0VCYXlGWklBa2dXV29oQ2tFQVFRUnFJVjhnWHlGZUlGNUJBV3NoWFNCZFFYOXpJVndnQ2lCY2NTRUxJQXNoRENBTUtBSUFJUTBnREVFRWFpRkpJQUlnU1RZQ0FDQU5yU0dVQVNBQUlKUUJOd01BREFzTUNRQUxBQXNDUUNBQ0tBSUFJVUFnUUNFT1FRQkJDR29oWWlCaUlXRWdZVUVCYXlGZ0lBNGdZR29oRDBFQVFRaHFJV1lnWmlGbElHVkJBV3NoWkNCa1FYOXpJV01nRHlCamNTRVFJQkFoRVNBUktRTUFJWlVCSUJGQkNHb2hTaUFDSUVvMkFnQWdBQ0NWQVRjREFBd0tEQWdBQ3dBTEFrQWdBaWdDQUNFNElEZ2hFa0VBUVFScUlXa2dhU0ZvSUdoQkFXc2haeUFTSUdkcUlSTkJBRUVFYWlGdElHMGhiQ0JzUVFGcklXc2dhMEYvY3lGcUlCTWdhbkVoRkNBVUlSVWdGU2dDQUNFWElCVkJCR29oUWlBQ0lFSTJBZ0FnRjBILy93TnhJUmdnR0VFUWRFRVFkYXdobGdFZ0FDQ1dBVGNEQUF3SkRBY0FDd0FMQWtBZ0FpZ0NBQ0U1SURraEdVRUFRUVJxSVhBZ2NDRnZJRzlCQVdzaGJpQVpJRzVxSVJwQkFFRUVhaUYwSUhRaGN5QnpRUUZySVhJZ2NrRi9jeUZ4SUJvZ2NYRWhHeUFiSVJ3Z0hDZ0NBQ0VkSUJ4QkJHb2hReUFDSUVNMkFnQWdIVUgvL3dOeElRUWdCSzBobHdFZ0FDQ1hBVGNEQUF3SURBWUFDd0FMQWtBZ0FpZ0NBQ0U2SURvaEhrRUFRUVJxSVhjZ2R5RjJJSFpCQVdzaGRTQWVJSFZxSVNCQkFFRUVhaUY3SUhzaGVpQjZRUUZySVhrZ2VVRi9jeUY0SUNBZ2VIRWhJU0FoSVNJZ0lpZ0NBQ0VqSUNKQkJHb2hSQ0FDSUVRMkFnQWdJMEgvQVhFaEpDQWtRUmgwUVJoMXJDR1lBU0FBSUpnQk53TUFEQWNNQlFBTEFBc0NRQ0FDS0FJQUlUd2dQQ0VsUVFCQkJHb2hmaUIrSVgwZ2ZVRUJheUY4SUNVZ2ZHb2hKa0VBUVFScUlZSUJJSUlCSVlFQklJRUJRUUZySVlBQklJQUJRWDl6SVg4Z0ppQi9jU0VuSUNjaEtDQW9LQUlBSVNvZ0tFRUVhaUZGSUFJZ1JUWUNBQ0FxUWY4QmNTRURJQU90SVprQklBQWdtUUUzQXdBTUJnd0VBQXNBQ3dKQUlBSW9BZ0FoUFNBOUlTdEJBRUVJYWlHRkFTQ0ZBU0dFQVNDRUFVRUJheUdEQVNBcklJTUJhaUVzUVFCQkNHb2hpUUVnaVFFaGlBRWdpQUZCQVdzaGh3RWdod0ZCZjNNaGhnRWdMQ0NHQVhFaExTQXRJUzRnTGlzREFDR2FBU0F1UVFocUlVWWdBaUJHTmdJQUlBQWdtZ0U1QXdBTUJRd0RBQXNBQ3dKQUlBSW9BZ0FoUGlBK0lTOUJBRUVJYWlHTUFTQ01BU0dMQVNDTEFVRUJheUdLQVNBdklJb0JhaUV3UVFCQkNHb2hrQUVna0FFaGp3RWdqd0ZCQVdzaGpnRWdqZ0ZCZjNNaGpRRWdNQ0NOQVhFaE1TQXhJVE1nTXlzREFDR2JBU0F6UVFocUlVY2dBaUJITmdJQUlBQWdtd0U1QXdBTUJBd0NBQXNBQ3d3Q0N3c0xEd3VRQVFJT2Z3SitJdzBoRUNBQVFnQlJJUWdnQ0FSQUlBRWhBd1VnQVNFRUlBQWhFUU5BQWtBZ0VhY2hDU0FKUVE5eElRcEJ4aWNnQ21vaEN5QUxMQUFBSVF3Z0RFSC9BWEVoRFNBTklBSnlJUTRnRGtIL0FYRWhCU0FFUVg5cUlRWWdCaUFGT2dBQUlCRkNCSWdoRWlBU1FnQlJJUWNnQndSQUlBWWhBd3dCQlNBR0lRUWdFaUVSQ3d3QkN3c0xJQU1QQzNVQ0NuOENmaU1OSVFzZ0FFSUFVU0VFSUFRRVFDQUJJUUlGSUFBaERDQUJJUU1EUUFKQUlBeW5RZjhCY1NFRklBVkJCM0VoQmlBR1FUQnlJUWNnQTBGL2FpRUlJQWdnQnpvQUFDQU1RZ09JSVEwZ0RVSUFVU0VKSUFrRVFDQUlJUUlNQVFVZ0RTRU1JQWdoQXdzTUFRc0xDeUFDRHd2OUFRSVdmd04rSXcwaEZ5QUFRdi8vLy84UFZpRU9JQUNuSVJRZ0RnUkFJQUFoR0NBQklRVURRQUpBSUJoQ0NvSWhHU0FacDBIL0FYRWhEeUFQUVRCeUlSQWdCVUYvYWlFUklCRWdFRG9BQUNBWVFncUFJUm9nR0VMLy8vLy9ud0ZXSVJJZ0VnUkFJQm9oR0NBUklRVUZEQUVMREFFTEN5QWFweUVWSUJVaEFpQVJJUVFGSUJRaEFpQUJJUVFMSUFKQkFFWWhFeUFUQkVBZ0JDRUdCU0FDSVFNZ0JDRUhBMEFDUUNBRFFRcHdRWDl4SVFnZ0NFRXdjaUVKSUFsQi93RnhJUW9nQjBGL2FpRUxJQXNnQ2pvQUFDQURRUXB1UVg5eElRd2dBMEVLU1NFTklBMEVRQ0FMSVFZTUFRVWdEQ0VESUFzaEJ3c01BUXNMQ3lBR0R3c21BUVovSXcwaEJoQktJUUVnQVVHOEFXb2hBaUFDS0FJQUlRTWdBQ0FERUVzaEJDQUVEd3VIQlFFNGZ5TU5JVG9nQVVIL0FYRWhKaUFBSVRFZ01VRURjU0V5SURKQkFFY2hNeUFDUVFCSElUUWdOQ0F6Y1NFNEFrQWdPQVJBSUFGQi93RnhJVFVnQUNFR0lBSWhDUU5BQWtBZ0Jpd0FBQ0UySURaQkdIUkJHSFVnTlVFWWRFRVlkVVloRWlBU0JFQWdCaUVGSUFraENFRUdJVGtNQkFzZ0JrRUJhaUVUSUFsQmYyb2hGQ0FUSVJVZ0ZVRURjU0VXSUJaQkFFY2hGeUFVUVFCSElSZ2dHQ0FYY1NFM0lEY0VRQ0FUSVFZZ0ZDRUpCU0FUSVFRZ0ZDRUhJQmdoRVVFRklUa01BUXNNQVFzTEJTQUFJUVFnQWlFSElEUWhFVUVGSVRrTEN5QTVRUVZHQkVBZ0VRUkFJQVFoQlNBSElRaEJCaUU1QlNBRUlRNUJBQ0VRQ3dzQ1FDQTVRUVpHQkVBZ0JTd0FBQ0VaSUFGQi93RnhJUm9nR1VFWWRFRVlkU0FhUVJoMFFSaDFSaUViSUJzRVFDQUZJUTRnQ0NFUUJTQW1RWUdDaEFoc0lSd2dDRUVEU3lFZEFrQWdIUVJBSUFVaENpQUlJUXdEUUFKQUlBb29BZ0FoSGlBZUlCeHpJUjhnSDBILy9mdDNhaUVnSUI5QmdJR0NoSGh4SVNFZ0lVR0FnWUtFZUhNaElpQWlJQ0J4SVNNZ0kwRUFSaUVrSUNSRkJFQU1BUXNnQ2tFRWFpRWxJQXhCZkdvaEp5QW5RUU5MSVNnZ0tBUkFJQ1VoQ2lBbklRd0ZJQ1VoQXlBbklRdEJDeUU1REFRTERBRUxDeUFLSVEwZ0RDRVBCU0FGSVFNZ0NDRUxRUXNoT1FzTElEbEJDMFlFUUNBTFFRQkdJU2tnS1FSQUlBTWhEa0VBSVJBTUJBVWdBeUVOSUFzaER3c0xBMEFDUUNBTkxBQUFJU29nS2tFWWRFRVlkU0FhUVJoMFFSaDFSaUVySUNzRVFDQU5JUTRnRHlFUURBVUxJQTFCQVdvaExDQVBRWDlxSVMwZ0xVRUFSaUV1SUM0RVFDQXNJUTVCQUNFUURBRUZJQ3doRFNBdElROExEQUVMQ3dzTEN5QVFRUUJISVM4Z0x3Ui9JQTRGUVFBTElUQWdNQThMekFFQkVYOGpEU0VWSXcxQmdBSnFKQTBqRFNNT1RnUkFRWUFDRUFNTElCVWhEaUFFUVlEQUJIRWhEeUFQUVFCR0lSQWdBaUFEU2lFUklCRWdFSEVoRXlBVEJFQWdBaUFEYXlFU0lCSkJnQUpKSVFjZ0J3Ui9JQklGUVlBQ0N5RUlJQTRnQVNBSUVGNGFJQkpCL3dGTElRa2dDUVJBSUFJZ0Eyc2hDaUFTSVFZRFFBSkFJQUFnRGtHQUFoQTVJQVpCZ0g1cUlRc2dDMEgvQVVzaERDQU1CRUFnQ3lFR0JRd0JDd3dCQ3dzZ0NrSC9BWEVoRFNBTklRVUZJQkloQlFzZ0FDQU9JQVVRT1FzZ0ZTUU5Ed3NxQVFWL0l3MGhCaUFBUVFCR0lRTWdBd1JBUVFBaEFnVWdBQ0FCUVFBUVJ5RUVJQVFoQWdzZ0FnOEwzREFEMGdOL0QzNGhmQ01OSWRjREl3MUJzQVJxSkEwakRTTU9UZ1JBUWJBRUVBTUxJTmNEUVFocUlhVURJTmNESWE4RElOY0RRWXdFYWlHNkF5QzZBeUhDQXlEWEEwR0FCR29oYmlDdkEwRUFOZ0lBSUc1QkRHb2hlQ0FCRUVRaDJBTWcyQU5DQUZNaGhRRWdoUUVFUUNBQm1pSDRBeUQ0QXlIcUEwRUJJUnhCb3ljaEhRVWdCRUdBRUhFaG1BRWdtQUZCQUVZaG93RWdCRUVCY1NHdUFTQ3VBVUVBUmlHNUFTQzVBUVIvUWFRbkJVR3BKd3NoQmlDakFRUi9JQVlGUWFZbkN5RUhJQVJCZ1JCeEljUUJJTVFCUVFCSEljOEJJTThCUVFGeElVb2dBU0hxQXlCS0lSd2dCeUVkQ3lEcUF4QkVJZUFESU9BRFFvQ0FnSUNBZ0lENC93Q0RJZUVESU9FRFFvQ0FnSUNBZ0lENC93QlJJZTBCQWtBZzdRRUVRQ0FGUVNCeElmWUJJUFlCUVFCSElZRUNJSUVDQkg5QnRpY0ZRYm9uQ3lHTUFpRHFBeURxQTJKRUFBQUFBQUFBQUFCRUFBQUFBQUFBQUFCaWNpR1hBaUNCQWdSL1FiNG5CVUhDSndzaG9nSWdsd0lFZnlDaUFnVWdqQUlMSVJrZ0hFRURhaUd0QWlBRVFmLy9lM0VodHdJZ0FFRWdJQUlnclFJZ3R3SVFRU0FBSUIwZ0hCQTVJQUFnR1VFREVEa2dCRUdBd0FCekljSUNJQUJCSUNBQ0lLMENJTUlDRUVFZ3JRSWhiUVVnNmdNZ3J3TVFSU0g4QXlEOEEwUUFBQUFBQUFBQVFLSWgvUU1nL1FORUFBQUFBQUFBQUFCaUllQUNJT0FDQkVBZ3J3TW9BZ0FoNmdJZzZnSkJmMm9oOVFJZ3J3TWc5UUkyQWdBTElBVkJJSEloL3dJZy93SkI0UUJHSVlvRElJb0RCRUFnQlVFZ2NTR1ZBeUNWQTBFQVJpR1lBeUFkUVFscUlaa0RJSmdEQkg4Z0hRVWdtUU1MSVI0Z0hFRUNjaUdhQXlBRFFRdExJWnNEUVF3Z0Eyc2huQU1nbkFOQkFFWWhuUU1nbXdNZ25RTnlJWjREQWtBZ25nTUVRQ0Q5QXlIdUF3VkVBQUFBQUFBQUlFQWg2d01nbkFNaEtnTkFBa0FnS2tGL2FpR2ZBeURyQTBRQUFBQUFBQUF3UUtJaC9nTWdud05CQUVZaG9BTWdvQU1FUUF3QkJTRCtBeUhyQXlDZkF5RXFDd3dCQ3dzZ0hpd0FBQ0doQXlDaEEwRVlkRUVZZFVFdFJpR2lBeUNpQXdSQUlQMERtaUgvQXlEL0F5RCtBNkVoZ0FRZy9nTWdnQVNnSVlFRUlJRUVtaUdDQkNDQ0JDSHVBd3dDQlNEOUF5RCtBNkFoZ3dRZ2d3UWcvZ09oSVlRRUlJUUVJZTREREFJTEFBc0xJSzhES0FJQUlhTURJS01EUVFCSUlhUURRUUFnb3dOcklhWURJS1FEQkg4Z3BnTUZJS01EQ3lHbkF5Q25BNndoNWdNZzVnTWdlQkErSWFnRElLZ0RJSGhHSWFrRElLa0RCRUFnYmtFTGFpR3FBeUNxQTBFd09nQUFJS29ESVJvRklLZ0RJUm9MSUtNRFFSOTFJYXNESUtzRFFRSnhJYXdESUt3RFFTdHFJYTBESUswRFFmOEJjU0d1QXlBYVFYOXFJYkFESUxBRElLNERPZ0FBSUFWQkQyb2hzUU1nc1FOQi93RnhJYklESUJwQmZtb2hzd01nc3dNZ3NnTTZBQUFnQTBFQlNDRzBBeUFFUVFoeEliVURJTFVEUVFCR0liWURJTG9ESVI4ZzdnTWg3d01EUUFKQUlPOERxaUczQTBIR0p5QzNBMm9odUFNZ3VBTXNBQUFodVFNZ3VRTkIvd0Z4SWJzRElKVURJTHNEY2lHOEF5QzhBMEgvQVhFaHZRTWdIMEVCYWlHK0F5QWZJTDBET2dBQUlMY0R0eUdGQkNEdkF5Q0ZCS0VoaGdRZ2hnUkVBQUFBQUFBQU1FQ2lJWWNFSUw0REliOERJTDhESU1JRGF5SEFBeURBQTBFQlJpSEJBeURCQXdSQUlJY0VSQUFBQUFBQUFBQUFZU0hEQXlDMEF5RERBM0VoendNZ3RnTWd6d054SWM0RElNNERCRUFndmdNaExnVWdIMEVDYWlIRUF5QytBMEV1T2dBQUlNUURJUzRMQlNDK0F5RXVDeUNIQkVRQUFBQUFBQUFBQUdJaHhRTWd4UU1FUUNBdUlSOGdod1FoN3dNRkRBRUxEQUVMQ3lBRFFRQkdJY1lESUM0aGFDREdBd1JBUVJnaDFnTUZRWDRnd2dOckljY0RJTWNESUdocUljZ0RJTWdESUFOSUlja0RJTWtEQkVBZ0EwRUNhaUhLQXlCb0lNSURheUZuSUdjaFpTREtBeUZxQlVFWUlkWURDd3NnMWdOQkdFWUVRQ0JvSU1JRGF5SExBeURMQXlGbElNc0RJV29MSUhnaHpBTWdzd01oYnlETUF5QnZheUZ3SUhBZ21nTnFJWEVnY1NCcWFpRnlJQUJCSUNBQ0lISWdCQkJCSUFBZ0hpQ2FBeEE1SUFSQmdJQUVjeUZ6SUFCQk1DQUNJSElnY3hCQklBQWd1Z01nWlJBNUlHb2daV3NoZENBQVFUQWdkRUVBUVFBUVFTQUFJTE1ESUhBUU9TQUVRWURBQUhNaGRTQUFRU0FnQWlCeUlIVVFRU0J5SVcwTUFnc2dBMEVBU0NGMklIWUVmMEVHQlNBREN5RkxJT0FDQkVBZy9RTkVBQUFBQUFBQXNFR2lJZlFESUs4REtBSUFJWGNnZDBGa2FpRjVJSzhESUhrMkFnQWc5QU1oOEFNZ2VTRmlCU0N2QXlnQ0FDRmtJUDBESWZBRElHUWhZZ3NnWWtFQVNDRjZJS1VEUWFBQ2FpRjdJSG9FZnlDbEF3VWdld3NoVlNCVklSZ2c4QU1oOFFNRFFBSkFJUEVEcXlGOElCZ2dmRFlDQUNBWVFRUnFJWDBnZkxnaDlRTWc4UU1nOVFPaElmWURJUFlEUkFBQUFBQmx6YzFCb2lIM0F5RDNBMFFBQUFBQUFBQUFBR0loZmlCK0JFQWdmU0VZSVBjRElmRURCUXdCQ3d3QkN3c2dZa0VBU2lGL0lIOEVRQ0JWSVNZZ2ZTRXBJR0loZ1FFRFFBSkFJSUVCUVIxSUlZQUJJSUFCQkg4Z2dRRUZRUjBMSVlJQklDbEJmR29oRkNBVUlDWkpJWU1CSUlNQkJFQWdKaUU0QlNDQ0FhMGgyUU1nRkNFVlFRQWhGd05BQWtBZ0ZTZ0NBQ0dFQVNDRUFhMGgyZ01nMmdNZzJRT0dJZHNESUJldElkd0RJTnNESU53RGZDSGRBeURkQTBLQWxPdmNBNEloM2dNZzNnT25JWVlCSUJVZ2hnRTJBZ0FnM1FOQ2dKVHIzQU9BSWQ4RElOOERweUdIQVNBVlFYeHFJUk1nRXlBbVNTR0lBU0NJQVFSQURBRUZJQk1oRlNDSEFTRVhDd3dCQ3dzZ2h3RkJBRVloaVFFZ2lRRUVRQ0FtSVRnRklDWkJmR29oaWdFZ2lnRWdod0UyQWdBZ2lnRWhPQXNMSUNraE9RTkFBa0FnT1NBNFN5R0xBU0NMQVVVRVFBd0JDeUE1UVh4cUlZd0JJSXdCS0FJQUlZMEJJSTBCUVFCR0lZNEJJSTRCQkVBZ2pBRWhPUVVNQVFzTUFRc0xJSzhES0FJQUlZOEJJSThCSUlJQmF5R1FBU0N2QXlDUUFUWUNBQ0NRQVVFQVNpR1JBU0NSQVFSQUlEZ2hKaUE1SVNrZ2tBRWhnUUVGSURnaEpTQTVJU2dna0FFaFl3d0JDd3dCQ3dzRklGVWhKU0I5SVNnZ1lpRmpDeUJqUVFCSUlaSUJJSklCQkVBZ1MwRVphaUdUQVNDVEFVRUpiVUYvY1NHVUFTQ1VBVUVCYWlHVkFTRC9Ba0htQUVZaGxnRWdKU0ZBSUNnaFFpQmpJWmtCQTBBQ1FFRUFJSmtCYXlHWEFTQ1hBVUVKU0NHYUFTQ2FBUVIvSUpjQkJVRUpDeUdiQVNCQUlFSkpJWndCSUp3QkJFQkJBU0NiQVhRaG9BRWdvQUZCZjJvaG9RRkJnSlRyM0FNZ213RjJJYUlCUVFBaEVpQkFJU2NEUUFKQUlDY29BZ0FocEFFZ3BBRWdvUUZ4SWFVQklLUUJJSnNCZGlHbUFTQ21BU0FTYWlHbkFTQW5JS2NCTmdJQUlLVUJJS0lCYkNHb0FTQW5RUVJxSWFrQklLa0JJRUpKSWFvQklLb0JCRUFncUFFaEVpQ3BBU0VuQlF3QkN3d0JDd3NnUUNnQ0FDR3JBU0NyQVVFQVJpR3NBU0JBUVFScUlhMEJJS3dCQkg4Z3JRRUZJRUFMSVFnZ3FBRkJBRVlocndFZ3J3RUVRQ0FJSVFvZ1FpRkhCU0JDUVFScUliQUJJRUlncUFFMkFnQWdDQ0VLSUxBQklVY0xCU0JBS0FJQUlaMEJJSjBCUVFCR0laNEJJRUJCQkdvaG53RWduZ0VFZnlDZkFRVWdRQXNoQ1NBSklRb2dRaUZIQ3lDV0FRUi9JRlVGSUFvTEliRUJJRWNoc2dFZ3NRRWhzd0Vnc2dFZ3N3RnJJYlFCSUxRQlFRSjFJYlVCSUxVQklKVUJTaUcyQVNDeEFTQ1ZBVUVDZEdvaHR3RWd0Z0VFZnlDM0FRVWdSd3NoRENDdkF5Z0NBQ0c0QVNDNEFTQ2JBV29odWdFZ3J3TWd1Z0UyQWdBZ3VnRkJBRWdodXdFZ3V3RUVRQ0FLSVVBZ0RDRkNJTG9CSVprQkJTQUtJVDhnRENGQkRBRUxEQUVMQ3dVZ0pTRS9JQ2doUVFzZ1B5QkJTU0c4QVNCVkliMEJJTHdCQkVBZ1B5RytBU0M5QVNDK0FXc2h2d0VndndGQkFuVWh3QUVnd0FGQkNXd2h3UUVnUHlnQ0FDSENBU0RDQVVFS1NTSERBU0REQVFSQUlNRUJJUzBGSU1FQklSdEJDaUVpQTBBQ1FDQWlRUXBzSWNVQklCdEJBV29oeGdFZ3dnRWd4UUZKSWNjQklNY0JCRUFneGdFaExRd0JCU0RHQVNFYklNVUJJU0lMREFFTEN3c0ZRUUFoTFFzZy93SkI1Z0JISWNnQklNZ0JCSDhnTFFWQkFBc2h5UUVnU3lESkFXc2h5Z0VnL3dKQjV3QkdJY3NCSUV0QkFFY2h6QUVnekFFZ3l3RnhJYzBCSU0wQlFSOTBRUjkxSVY4Z3lnRWdYMm9oemdFZ1FTSFFBU0RRQVNDOUFXc2gwUUVnMFFGQkFuVWgwZ0VnMGdGQkNXd2gwd0VnMHdGQmQyb2gxQUVnemdFZzFBRklJZFVCSU5VQkJFQWdWVUVFYWlIV0FTRE9BVUdBeUFCcUlkY0JJTmNCUVFsdFFYOXhJZGdCSU5nQlFZQjRhaUhaQVNEV0FTRFpBVUVDZEdvaDJnRWcxd0ZCQ1c5QmYzRWgyd0VnMndGQkNFZ2gzQUVnM0FFRVFDRGJBU0VoUVFvaE1nTkFBa0FnSVVFQmFpRWdJREpCQ213aDNRRWdJVUVIU0NIZUFTRGVBUVJBSUNBaElTRGRBU0V5QlNEZEFTRXhEQUVMREFFTEN3VkJDaUV4Q3lEYUFTZ0NBQ0hmQVNEZkFTQXhjRUYvY1NIZ0FTRGdBVUVBUmlIaEFTRGFBVUVFYWlIaUFTRGlBU0JCUmlIakFTRGpBU0RoQVhFaDBBTWcwQU1FUUNEYUFTRkdJQzBoU0NBL0lWd0ZJTjhCSURGdVFYOXhJZVFCSU9RQlFRRnhJZVVCSU9VQlFRQkdJZVlCSU9ZQkJIeEVBQUFBQUFBQVFFTUZSQUVBQUFBQUFFQkRDeUh5QXlBeFFRSnRRWDl4SWVjQklPQUJJT2NCU1NIb0FTRGdBU0RuQVVZaDZRRWc0d0VnNlFGeElkRURJTkVEQkh4RUFBQUFBQUFBOEQ4RlJBQUFBQUFBQVBnL0N5SHpBeURvQVFSOFJBQUFBQUFBQU9BL0JTRHpBd3NoNlFNZ0hFRUFSaUhxQVNEcUFRUkFJT2tESWV3RElQSURJZTBEQlNBZExBQUFJZXNCSU9zQlFSaDBRUmgxUVMxR0lld0JJUElEbWlINUF5RHBBNW9oK2dNZzdBRUVmQ0Q1QXdVZzhnTUxJZWdESU93QkJId2crZ01GSU9rREN5SG5BeURuQXlIc0F5RG9BeUh0QXdzZzN3RWc0QUZySWU0QklOb0JJTzRCTmdJQUlPMERJT3dEb0NIN0F5RDdBeUR0QTJJaDd3RWc3d0VFUUNEdUFTQXhhaUh3QVNEYUFTRHdBVFlDQUNEd0FVSC9rK3ZjQTBzaDhRRWc4UUVFUUNBL0lVOGcyZ0VoYkFOQUFrQWdiRUY4YWlIeUFTQnNRUUEyQWdBZzhnRWdUMGtoOHdFZzh3RUVRQ0JQUVh4cUlmUUJJUFFCUVFBMkFnQWc5QUVoVmdVZ1R5RldDeUR5QVNnQ0FDSDFBU0QxQVVFQmFpSDNBU0R5QVNEM0FUWUNBQ0QzQVVIL2srdmNBMHNoK0FFZytBRUVRQ0JXSVU4ZzhnRWhiQVVnVmlGT0lQSUJJV3NNQVFzTUFRc0xCU0EvSVU0ZzJnRWhhd3NnVGlINUFTQzlBU0Q1QVdzaCtnRWcrZ0ZCQW5VaCt3RWcrd0ZCQ1d3aC9BRWdUaWdDQUNIOUFTRDlBVUVLU1NIK0FTRCtBUVJBSUdzaFJpRDhBU0ZJSUU0aFhBVWcvQUVoTzBFS0lUMERRQUpBSUQxQkNtd2gvd0VnTzBFQmFpR0FBaUQ5QVNEL0FVa2hnZ0lnZ2dJRVFDQnJJVVlnZ0FJaFNDQk9JVndNQVFVZ2dBSWhPeUQvQVNFOUN3d0JDd3NMQlNEYUFTRkdJQzBoU0NBL0lWd0xDeUJHUVFScUlZTUNJRUVnZ3dKTElZUUNJSVFDQkg4Z2d3SUZJRUVMSVFzZ1NDRlNJQXNoV3lCY0lWMEZJQzBoVWlCQklWc2dQeUZkQ3lCYklWa0RRQUpBSUZrZ1hVc2hoUUlnaFFKRkJFQkJBQ0ZlREFFTElGbEJmR29oaGdJZ2hnSW9BZ0FoaHdJZ2h3SkJBRVloaUFJZ2lBSUVRQ0NHQWlGWkJVRUJJVjRNQVFzTUFRc0xRUUFnVW1zaGlRSUNRQ0RMQVFSQUlNd0JRUUZ6SWMwRElNMERRUUZ4SVlvQ0lFc2dpZ0pxSVV3Z1RDQlNTaUdMQWlCU1FYdEtJWTBDSUlzQ0lJMENjU0hUQXlEVEF3UkFJQVZCZjJvaGpnSWdURUYvYWlGZ0lHQWdVbXNoandJZ2pnSWhFU0NQQWlFMUJTQUZRWDVxSVpBQ0lFeEJmMm9oa1FJZ2tBSWhFU0NSQWlFMUN5QUVRUWh4SVpJQ0lKSUNRUUJHSVpNQ0lKTUNCRUFnWGdSQUlGbEJmR29obEFJZ2xBSW9BZ0FobFFJZ2xRSkJBRVlobGdJZ2xnSUVRRUVKSVR3RklKVUNRUXB3UVg5eElaZ0NJSmdDUVFCR0laa0NJSmtDQkVCQkFDRXdRUW9oUXdOQUFrQWdRMEVLYkNHYUFpQXdRUUZxSVpzQ0lKVUNJSm9DY0VGL2NTR2NBaUNjQWtFQVJpR2RBaUNkQWdSQUlKc0NJVEFnbWdJaFF3VWdtd0loUEF3QkN3d0JDd3NGUVFBaFBBc0xCVUVKSVR3TElCRkJJSElobmdJZ25nSkI1Z0JHSVo4Q0lGa2hvQUlnb0FJZ3ZRRnJJYUVDSUtFQ1FRSjFJYU1DSUtNQ1FRbHNJYVFDSUtRQ1FYZHFJYVVDSUo4Q0JFQWdwUUlnUEdzaHBnSWdwZ0pCQUVvaHB3SWdwd0lFZnlDbUFnVkJBQXNoVFNBMUlFMUlJYWdDSUtnQ0JIOGdOUVVnVFFzaE5pQVJJU1FnTmlFK1FRQWhaZ3dEQlNDbEFpQlNhaUdwQWlDcEFpQThheUdxQWlDcUFrRUFTaUdyQWlDckFnUi9JS29DQlVFQUN5RlJJRFVnVVVnaHJBSWdyQUlFZnlBMUJTQlJDeUUzSUJFaEpDQTNJVDVCQUNGbURBTUxBQVVnRVNFa0lEVWhQaUNTQWlGbUN3VWdCRUVJY1NGcElBVWhKQ0JMSVQ0Z2FTRm1Dd3NnUGlCbWNpR3VBaUN1QWtFQVJ5R3ZBaUN2QWtFQmNTR3dBaUFrUVNCeUliRUNJTEVDUWVZQVJpR3lBaUN5QWdSQUlGSkJBRW9oc3dJZ3N3SUVmeUJTQlVFQUN5RzBBa0VBSVRvZ3RBSWhZUVVnVWtFQVNDRzFBaUMxQWdSL0lJa0NCU0JTQ3lHMkFpQzJBcXdoNGdNZzRnTWdlQkErSWJnQ0lIZ2h1UUlndUFJaHVnSWd1UUlndWdKcklic0NJTHNDUVFKSUlid0NJTHdDQkVBZ3VBSWhMQU5BQWtBZ0xFRi9haUc5QWlDOUFrRXdPZ0FBSUwwQ0liNENJTGtDSUw0Q2F5Ry9BaUMvQWtFQ1NDSEFBaURBQWdSQUlMMENJU3dGSUwwQ0lTc01BUXNNQVFzTEJTQzRBaUVyQ3lCU1FSOTFJY0VDSU1FQ1FRSnhJY01DSU1NQ1FTdHFJY1FDSU1RQ1FmOEJjU0hGQWlBclFYOXFJY1lDSU1ZQ0lNVUNPZ0FBSUNSQi93RnhJY2NDSUN0QmZtb2h5QUlneUFJZ3h3STZBQUFneUFJaHlRSWd1UUlneVFKckljb0NJTWdDSVRvZ3lnSWhZUXNnSEVFQmFpSExBaURMQWlBK2FpSE1BaURNQWlDd0Ftb2hMeUF2SUdGcUljMENJQUJCSUNBQ0lNMENJQVFRUVNBQUlCMGdIQkE1SUFSQmdJQUVjeUhPQWlBQVFUQWdBaUROQWlET0FoQkJJTElDQkVBZ1hTQlZTeUhQQWlEUEFnUi9JRlVGSUYwTElSWWd1Z05CQ1dvaDBBSWcwQUloMFFJZ3VnTkJDR29oMGdJZ0ZpRlFBMEFDUUNCUUtBSUFJZE1DSU5NQ3JTSGpBeURqQXlEUUFoQStJZFFDSUZBZ0ZrWWgxUUlnMVFJRVFDRFVBaURRQWtZaDJ3SWcyd0lFUUNEU0FrRXdPZ0FBSU5JQ0lTTUZJTlFDSVNNTEJTRFVBaUM2QTBzaDFnSWcxZ0lFUUNEVUFpSFhBaURYQWlEQ0Eyc2gyQUlndWdOQk1DRFlBaEJlR2lEVUFpRVFBMEFDUUNBUVFYOXFJZGtDSU5rQ0lMb0RTeUhhQWlEYUFnUkFJTmtDSVJBRklOa0NJU01NQVFzTUFRc0xCU0RVQWlFakN3c2dJeUhjQWlEUkFpRGNBbXNoM1FJZ0FDQWpJTjBDRURrZ1VFRUVhaUhlQWlEZUFpQlZTeUhmQWlEZkFnUkFEQUVGSU40Q0lWQUxEQUVMQ3lDdUFrRUFSaUhoQWlEaEFrVUVRQ0FBUWRZblFRRVFPUXNnM2dJZ1dVa2g0Z0lnUGtFQVNpSGpBaURpQWlEakFuRWg1QUlnNUFJRVFDQStJVVVnM2dJaFZ3TkFBa0FnVnlnQ0FDSGxBaURsQXEwaDVBTWc1QU1nMEFJUVBpSG1BaURtQWlDNkEwc2g1d0lnNXdJRVFDRG1BaUhvQWlEb0FpRENBMnNoNlFJZ3VnTkJNQ0RwQWhCZUdpRG1BaUVQQTBBQ1FDQVBRWDlxSWVzQ0lPc0NJTG9EU3lIc0FpRHNBZ1JBSU9zQ0lROEZJT3NDSVE0TUFRc01BUXNMQlNEbUFpRU9DeUJGUVFsSUllMENJTzBDQkg4Z1JRVkJDUXNoN2dJZ0FDQU9JTzRDRURrZ1YwRUVhaUh2QWlCRlFYZHFJZkFDSU84Q0lGbEpJZkVDSUVWQkNVb2g4Z0lnOFFJZzhnSnhJZk1DSVBNQ0JFQWc4QUloUlNEdkFpRlhCU0R3QWlGRURBRUxEQUVMQ3dVZ1BpRkVDeUJFUVFscUlmUUNJQUJCTUNEMEFrRUpRUUFRUVFVZ1hVRUVhaUgyQWlCZUJIOGdXUVVnOWdJTElWb2dQa0YvU2lIM0FpRDNBZ1JBSUxvRFFRbHFJZmdDSUdaQkFFWWgrUUlnK0FJaCtnSkJBQ0RDQTJzaCt3SWd1Z05CQ0dvaC9BSWdQaUZVSUYwaFdBTkFBa0FnV0NnQ0FDSDlBaUQ5QXEwaDVRTWc1UU1nK0FJUVBpSCtBaUQrQWlENEFrWWhnQU1nZ0FNRVFDRDhBa0V3T2dBQUlQd0NJUTBGSVA0Q0lRMExJRmdnWFVZaGdRTUNRQ0NCQXdSQUlBMUJBV29oaFFNZ0FDQU5RUUVRT1NCVVFRRklJWVlESVBrQ0lJWURjU0hTQXlEU0F3UkFJSVVESVRRTUFnc2dBRUhXSjBFQkVEa2doUU1oTkFVZ0RTQzZBMHNoZ2dNZ2dnTkZCRUFnRFNFMERBSUxJQTBnK3dKcUlkUURJTlFESWRVRElMb0RRVEFnMVFNUVhob2dEU0V6QTBBQ1FDQXpRWDlxSVlNRElJTURJTG9EU3lHRUF5Q0VBd1JBSUlNRElUTUZJSU1ESVRRTUFRc01BUXNMQ3dzZ05DR0hBeUQ2QWlDSEEyc2hpQU1nVkNDSUEwb2hpUU1naVFNRWZ5Q0lBd1VnVkFzaGl3TWdBQ0EwSUlzREVEa2dWQ0NJQTJzaGpBTWdXRUVFYWlHTkF5Q05BeUJhU1NHT0F5Q01BMEYvU2lHUEF5Q09BeUNQQTNFaGtBTWdrQU1FUUNDTUF5RlVJSTBESVZnRklJd0RJVWtNQVFzTUFRc0xCU0ErSVVrTElFbEJFbW9oa1FNZ0FFRXdJSkVEUVJKQkFCQkJJSGdoa2dNZ09pR1RBeUNTQXlDVEEyc2hsQU1nQUNBNklKUURFRGtMSUFSQmdNQUFjeUdXQXlBQVFTQWdBaUROQWlDV0F4QkJJTTBDSVcwTEN5QnRJQUpJSVpjRElKY0RCSDhnQWdVZ2JRc2hVeURYQXlRTklGTVBDeElDQW44QmZpTU5JUUlnQUwwaEF5QUREd3NWQWdKL0FYd2pEU0VESUFBZ0FSQkdJUVFnQkE4TDlCRURDMzhFZmdWOEl3MGhEQ0FBdlNFUElBOUNOSWdoRUNBUXAwSC8vd054SVFrZ0NVSC9EM0VoQ2dKQUFrQUNRQUpBSUFwQkVIUkJFSFZCQUdzT2dCQUFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQVFJTEFrQWdBRVFBQUFBQUFBQUFBR0loQkNBRUJFQWdBRVFBQUFBQUFBRHdRNkloRkNBVUlBRVFSaUVWSUFFb0FnQWhCU0FGUVVCcUlRWWdGU0VTSUFZaENBVWdBQ0VTUVFBaENBc2dBU0FJTmdJQUlCSWhFUXdEQUFzQUN3SkFJQUFoRVF3Q0FBc0FDd0pBSUJDbklRY2dCMEgvRDNFaEFpQUNRWUo0YWlFRElBRWdBellDQUNBUFF2Ly8vLy8vLy8rSGdIK0RJUTBnRFVLQWdJQ0FnSUNBOEQrRUlRNGdEcjhoRXlBVElSRUxDeUFSRHd2a0JBRTdmeU1OSVQwZ0FFRUFSaUVZQWtBZ0dBUkFRUUVoQXdVZ0FVR0FBVWtoSXlBakJFQWdBVUgvQVhFaExpQUFJQzQ2QUFCQkFTRUREQUlMRUVnaE55QTNRYndCYWlFNElEZ29BZ0FoT1NBNUtBSUFJVG9nT2tFQVJpRUVJQVFFUUNBQlFZQi9jU0VGSUFWQmdMOERSaUVHSUFZRVFDQUJRZjhCY1NFSUlBQWdDRG9BQUVFQklRTU1Bd1VRTVNFSElBZEIxQUEyQWdCQmZ5RUREQU1MQUFzZ0FVR0FFRWtoQ1NBSkJFQWdBVUVHZGlFS0lBcEJ3QUZ5SVFzZ0MwSC9BWEVoRENBQVFRRnFJUTBnQUNBTU9nQUFJQUZCUDNFaERpQU9RWUFCY2lFUElBOUIvd0Z4SVJBZ0RTQVFPZ0FBUVFJaEF3d0NDeUFCUVlDd0Ewa2hFU0FCUVlCQWNTRVNJQkpCZ01BRFJpRVRJQkVnRTNJaE95QTdCRUFnQVVFTWRpRVVJQlJCNEFGeUlSVWdGVUgvQVhFaEZpQUFRUUZxSVJjZ0FDQVdPZ0FBSUFGQkJuWWhHU0FaUVQ5eElSb2dHa0dBQVhJaEd5QWJRZjhCY1NFY0lBQkJBbW9oSFNBWElCdzZBQUFnQVVFL2NTRWVJQjVCZ0FGeUlSOGdIMEgvQVhFaElDQWRJQ0E2QUFCQkF5RUREQUlMSUFGQmdJQjhhaUVoSUNGQmdJREFBRWtoSWlBaUJFQWdBVUVTZGlFa0lDUkI4QUZ5SVNVZ0pVSC9BWEVoSmlBQVFRRnFJU2NnQUNBbU9nQUFJQUZCREhZaEtDQW9RVDl4SVNrZ0tVR0FBWEloS2lBcVFmOEJjU0VySUFCQkFtb2hMQ0FuSUNzNkFBQWdBVUVHZGlFdElDMUJQM0VoTHlBdlFZQUJjaUV3SURCQi93RnhJVEVnQUVFRGFpRXlJQ3dnTVRvQUFDQUJRVDl4SVRNZ00wR0FBWEloTkNBMFFmOEJjU0UxSURJZ05Ub0FBRUVFSVFNTUFnVVFNU0UySURaQjFBQTJBZ0JCZnlFRERBSUxBQXNMSUFNUEN3OEJBMzhqRFNFQ0VFa2hBQ0FBRHdzTUFRSi9JdzBoQVVHVUlROExEd0VEZnlNTklRSVFTU0VBSUFBUEM1TUNBUlovSXcwaEYwRUFJUVFEUUFKQVFkZ25JQVJxSVE4Z0R5d0FBQ0VRSUJCQi93RnhJUkVnRVNBQVJpRVNJQklFUUVFQ0lSWU1BUXNnQkVFQmFpRVRJQk5CMXdCR0lSUWdGQVJBUWJBb0lRTkIxd0FoQmtFRklSWU1BUVVnRXlFRUN3d0JDd3NnRmtFQ1JnUkFJQVJCQUVZaERpQU9CRUJCc0NnaEFnVkJzQ2doQXlBRUlRWkJCU0VXQ3dzZ0ZrRUZSZ1JBQTBBQ1FFRUFJUllnQXlFRkEwQUNRQ0FGTEFBQUlSVWdGVUVZZEVFWWRVRUFSaUVISUFWQkFXb2hDQ0FIQkVBTUFRVWdDQ0VGQ3d3QkN3c2dCa0YvYWlFSklBbEJBRVloQ2lBS0JFQWdDQ0VDREFFRklBZ2hBeUFKSVFaQkJTRVdDd3dCQ3dzTElBRkJGR29oQ3lBTEtBSUFJUXdnQWlBTUVFd2hEU0FORHdzVEFRTi9JdzBoQkNBQUlBRVFUU0VDSUFJUEMxSUJDbjhqRFNFTElBRkJBRVloQXlBREJFQkJBQ0VDQlNBQktBSUFJUVFnQVVFRWFpRUZJQVVvQWdBaEJpQUVJQVlnQUJCT0lRY2dCeUVDQ3lBQ1FRQkhJUWdnQ0FSL0lBSUZJQUFMSVFrZ0NROExqQVVCU1g4akRTRkxJQUFvQWdBaEhTQWRRYUxhNzljR2FpRW9JQUJCQ0dvaE15QXpLQUlBSVQ0Z1BpQW9FRThoUkNBQVFReHFJVVVnUlNnQ0FDRkdJRVlnS0JCUElRa2dBRUVRYWlFS0lBb29BZ0FoQ3lBTElDZ1FUeUVNSUFGQkFuWWhEU0JFSUExSklRNENRQ0FPQkVBZ1JFRUNkQ0VQSUFFZ0Qyc2hFQ0FKSUJCSklSRWdEQ0FRU1NFU0lCRWdFbkVoUnlCSEJFQWdEQ0FKY2lFVElCTkJBM0VoRkNBVVFRQkdJUlVnRlFSQUlBbEJBblloRmlBTVFRSjJJUmRCQUNFRUlFUWhCUU5BQWtBZ0JVRUJkaUVZSUFRZ0dHb2hHU0FaUVFGMElSb2dHaUFXYWlFYklBQWdHMEVDZEdvaEhDQWNLQUlBSVI0Z0hpQW9FRThoSHlBYlFRRnFJU0FnQUNBZ1FRSjBhaUVoSUNFb0FnQWhJaUFpSUNnUVR5RWpJQ01nQVVraEpDQUJJQ05ySVNVZ0h5QWxTU0VtSUNRZ0puRWhTQ0JJUlFSQVFRQWhDQXdHQ3lBaklCOXFJU2NnQUNBbmFpRXBJQ2tzQUFBaEtpQXFRUmgwUVJoMVFRQkdJU3NnSzBVRVFFRUFJUWdNQmdzZ0FDQWphaUVzSUFJZ0xCQTBJUzBnTFVFQVJpRXVJQzRFUUF3QkN5QUZRUUZHSVVFZ0xVRUFTQ0ZDSUFVZ0dHc2hReUJDQkg4Z0dBVWdRd3NoQnlCQ0JIOGdCQVVnR1FzaEJpQkJCRUJCQUNFSURBWUZJQVloQkNBSElRVUxEQUVMQ3lBYUlCZHFJUzhnQUNBdlFRSjBhaUV3SURBb0FnQWhNU0F4SUNnUVR5RXlJQzlCQVdvaE5DQUFJRFJCQW5ScUlUVWdOU2dDQUNFMklEWWdLQkJQSVRjZ055QUJTU0U0SUFFZ04yc2hPU0F5SURsSklUb2dPQ0E2Y1NGSklFa0VRQ0FBSURkcUlUc2dOeUF5YWlFOElBQWdQR29oUFNBOUxBQUFJVDhnUDBFWWRFRVlkVUVBUmlGQUlFQUVmeUE3QlVFQUN5RURJQU1oQ0FWQkFDRUlDd1ZCQUNFSUN3VkJBQ0VJQ3dWQkFDRUlDd3NnQ0E4TEpBRUZmeU1OSVFZZ0FVRUFSaUVESUFBUVhDRUVJQU1FZnlBQUJTQUVDeUVDSUFJUEM3MERBU3AvSXcwaExDQUNRUkJxSVI4Z0h5Z0NBQ0VsSUNWQkFFWWhKaUFtQkVBZ0FoQlJJU2dnS0VFQVJpRXBJQ2tFUUNBZktBSUFJUWtnQ1NFTlFRVWhLd1ZCQUNFRkN3VWdKU0VuSUNjaERVRUZJU3NMQWtBZ0swRUZSZ1JBSUFKQkZHb2hLaUFxS0FJQUlRc2dEU0FMYXlFTUlBd2dBVWtoRGlBTElROGdEZ1JBSUFKQkpHb2hFQ0FRS0FJQUlSRWdBaUFBSUFFZ0VVRUhjVUVJYWhFQUFDRVNJQkloQlF3Q0N5QUNRY3NBYWlFVElCTXNBQUFoRkNBVVFSaDBRUmgxUVg5S0lSVUNRQ0FWQkVBZ0FTRURBMEFDUUNBRFFRQkdJUllnRmdSQVFRQWhCaUFBSVFjZ0FTRUlJQThoSVF3RUN5QURRWDlxSVJjZ0FDQVhhaUVZSUJnc0FBQWhHU0FaUVJoMFFSaDFRUXBHSVJvZ0dnUkFEQUVGSUJjaEF3c01BUXNMSUFKQkpHb2hHeUFiS0FJQUlSd2dBaUFBSUFNZ0hFRUhjVUVJYWhFQUFDRWRJQjBnQTBraEhpQWVCRUFnSFNFRkRBUUxJQUFnQTJvaElDQUJJQU5ySVFRZ0tpZ0NBQ0VLSUFNaEJpQWdJUWNnQkNFSUlBb2hJUVZCQUNFR0lBQWhCeUFCSVFnZ0R5RWhDd3NnSVNBSElBZ1FYUm9nS2lnQ0FDRWlJQ0lnQ0dvaEl5QXFJQ00yQWdBZ0JpQUlhaUVrSUNRaEJRc0xJQVVQQytBQkFSaC9JdzBoR0NBQVFjb0FhaUVDSUFJc0FBQWhEU0FOUVJoMFFSaDFJUkFnRUVIL0FXb2hFU0FSSUJCeUlSSWdFa0gvQVhFaEV5QUNJQk02QUFBZ0FDZ0NBQ0VVSUJSQkNIRWhGU0FWUVFCR0lSWWdGZ1JBSUFCQkNHb2hCQ0FFUVFBMkFnQWdBRUVFYWlFRklBVkJBRFlDQUNBQVFTeHFJUVlnQmlnQ0FDRUhJQUJCSEdvaENDQUlJQWMyQWdBZ0FFRVVhaUVKSUFrZ0J6WUNBQ0FISVFvZ0FFRXdhaUVMSUFzb0FnQWhEQ0FLSUF4cUlRNGdBRUVRYWlFUElBOGdEallDQUVFQUlRRUZJQlJCSUhJaEF5QUFJQU0yQWdCQmZ5RUJDeUFCRHdzM0FRaC9JdzBoQ1NBQVFRQWdBUkJBSVFJZ0FrRUFSaUVESUFJaEJDQUFJUVVnQkNBRmF5RUdJQU1FZnlBQkJTQUdDeUVISUFjUEM4OENBU0IvSXcwaElDQUFJUWdnQ0VFRGNTRVRJQk5CQUVZaEdBSkFJQmdFUUNBQUlRSkJCQ0VmQlNBQUlRTWdDQ0VYQTBBQ1FDQURMQUFBSVJrZ0dVRVlkRUVZZFVFQVJpRWFJQm9FUUNBWElRY01CQXNnQTBFQmFpRWJJQnNoSENBY1FRTnhJUjBnSFVFQVJpRWVJQjRFUUNBYklRSkJCQ0VmREFFRklCc2hBeUFjSVJjTERBRUxDd3NMSUI5QkJFWUVRQ0FDSVFFRFFBSkFJQUVvQWdBaENTQUpRZi85KzNkcUlRb2dDVUdBZ1lLRWVIRWhDeUFMUVlDQmdvUjRjeUVNSUF3Z0NuRWhEU0FOUVFCR0lRNGdBVUVFYWlFUElBNEVRQ0FQSVFFRkRBRUxEQUVMQ3lBSlFmOEJjU0VRSUJCQkdIUkJHSFZCQUVZaEVTQVJCRUFnQVNFRUJTQUJJUVVEUUFKQUlBVkJBV29oRWlBU0xBQUFJUVlnQmtFWWRFRVlkVUVBUmlFVUlCUUVRQ0FTSVFRTUFRVWdFaUVGQ3d3QkN3c0xJQVFoRlNBVklRY0xJQWNnQ0dzaEZpQVdEd3RCQVFkL0l3MGhDQ0FBSUFFUVZTRUNJQUlzQUFBaEF5QUJRZjhCY1NFRUlBTkJHSFJCR0hVZ0JFRVlkRUVZZFVZaEJTQUZCSDhnQWdWQkFBc2hCaUFHRHd1TUJBRXpmeU1OSVRRZ0FVSC9BWEVoRWlBU1FRQkdJUjBDUUNBZEJFQWdBQkJUSVM4Z0FDQXZhaUV3SURBaEFnVWdBQ0VvSUNoQkEzRWhMQ0FzUVFCR0lTMGdMUVJBSUFBaEJRVWdBVUgvQVhFaExpQUFJUVlEUUFKQUlBWXNBQUFoQ0NBSVFSaDBRUmgxUVFCR0lRa2dDRUVZZEVFWWRTQXVRUmgwUVJoMVJpRUtJQWtnQ25JaE1TQXhCRUFnQmlFQ0RBVUxJQVpCQVdvaEN5QUxJUXdnREVFRGNTRU5JQTFCQUVZaERpQU9CRUFnQ3lFRkRBRUZJQXNoQmdzTUFRc0xDeUFTUVlHQ2hBaHNJUThnQlNnQ0FDRVFJQkJCLy8zN2Qyb2hFU0FRUVlDQmdvUjRjU0VUSUJOQmdJR0NoSGh6SVJRZ0ZDQVJjU0VWSUJWQkFFWWhGZ0pBSUJZRVFDQUZJUVFnRUNFWUEwQUNRQ0FZSUE5eklSY2dGMEgvL2Z0M2FpRVpJQmRCZ0lHQ2hIaHhJUm9nR2tHQWdZS0VlSE1oR3lBYklCbHhJUndnSEVFQVJpRWVJQjVGQkVBZ0JDRUREQVFMSUFSQkJHb2hIeUFmS0FJQUlTQWdJRUgvL2Z0M2FpRWhJQ0JCZ0lHQ2hIaHhJU0lnSWtHQWdZS0VlSE1oSXlBaklDRnhJU1FnSkVFQVJpRWxJQ1VFUUNBZklRUWdJQ0VZQlNBZklRTU1BUXNNQVFzTEJTQUZJUU1MQ3lBQlFmOEJjU0VtSUFNaEJ3TkFBa0FnQnl3QUFDRW5JQ2RCR0hSQkdIVkJBRVloS1NBblFSaDBRUmgxSUNaQkdIUkJHSFZHSVNvZ0tTQXFjaUV5SUFkQkFXb2hLeUF5QkVBZ0J5RUNEQUVGSUNzaEJ3c01BUXNMQ3dzZ0FnOExFUUVDZnlNTklRRkI4RG9RQmtINE9nOExEZ0VDZnlNTklRRkI4RG9RREE4TDV3SUJKMzhqRFNFbklBQkJBRVloQ0FKQUlBZ0VRRUdRSVNnQ0FDRWpJQ05CQUVZaEpDQWtCRUJCQUNFZEJVR1FJU2dDQUNFSklBa1FXQ0VLSUFvaEhRc1FWaUVMSUFzb0FnQWhBeUFEUVFCR0lRd2dEQVJBSUIwaEJRVWdBeUVFSUIwaEJnTkFBa0FnQkVITUFHb2hEU0FOS0FJQUlRNGdEa0YvU2lFUElBOEVRQ0FFRURjaEVDQVFJUm9GUVFBaEdnc2dCRUVVYWlFUklCRW9BZ0FoRWlBRVFSeHFJUlFnRkNnQ0FDRVZJQklnRlVzaEZpQVdCRUFnQkJCWklSY2dGeUFHY2lFWUlCZ2hCd1VnQmlFSEN5QWFRUUJHSVJrZ0dVVUVRQ0FFRURnTElBUkJPR29oR3lBYktBSUFJUUlnQWtFQVJpRWNJQndFUUNBSElRVU1BUVVnQWlFRUlBY2hCZ3NNQVFzTEN4QlhJQVVoQVFVZ0FFSE1BR29oRXlBVEtBSUFJUjRnSGtGL1NpRWZJQjlGQkVBZ0FCQlpJU0FnSUNFQkRBSUxJQUFRTnlFaElDRkJBRVloSlNBQUVGa2hJaUFsQkVBZ0lpRUJCU0FBRURnZ0lpRUJDd3NMSUFFUEM0RUNBUmQvSXcwaEZ5QUFRUlJxSVFJZ0FpZ0NBQ0VOSUFCQkhHb2hEeUFQS0FJQUlSQWdEU0FRU3lFUklCRUVRQ0FBUVNScUlSSWdFaWdDQUNFVElBQkJBRUVBSUJOQkIzRkJDR29SQUFBYUlBSW9BZ0FoRkNBVVFRQkdJUlVnRlFSQVFYOGhBUVZCQXlFV0N3VkJBeUVXQ3lBV1FRTkdCRUFnQUVFRWFpRURJQU1vQWdBaEJDQUFRUWhxSVFVZ0JTZ0NBQ0VHSUFRZ0Jra2hCeUFIQkVBZ0JDRUlJQVloQ1NBSUlBbHJJUW9nQUVFb2FpRUxJQXNvQWdBaERDQUFJQXBCQVNBTVFRZHhRUWhxRVFBQUdnc2dBRUVRYWlFT0lBNUJBRFlDQUNBUFFRQTJBZ0FnQWtFQU5nSUFJQVZCQURZQ0FDQURRUUEyQWdCQkFDRUJDeUFCRHdzM0FRUi9JdzBoQmlNTlFSQnFKQTBqRFNNT1RnUkFRUkFRQXdzZ0JpRURJQU1nQWpZQ0FDQUFJQUVnQXhBMUlRUWdCaVFOSUFRUEN3TUFBUXNzQUNBQVFmOEJjVUVZZENBQVFRaDFRZjhCY1VFUWRISWdBRUVRZFVIL0FYRkJDSFJ5SUFCQkdIWnlEd3ZrQkFFRWZ5QUNRWURBQUU0RVFDQUFJQUVnQWhBT0R3c2dBQ0VESUFBZ0Ftb2hCaUFBUVFOeElBRkJBM0ZHQkVBRFFBSkFJQUJCQTNGRkJFQU1BUXNDUUNBQ1FRQkdCRUFnQXc4TElBQWdBU3dBQURvQUFDQUFRUUZxSVFBZ0FVRUJhaUVCSUFKQkFXc2hBZ3NNQVFzTElBWkJmSEVoQkNBRVFjQUFheUVGQTBBQ1FDQUFJQVZNUlFSQURBRUxBa0FnQUNBQktBSUFOZ0lBSUFCQkJHb2dBVUVFYWlnQ0FEWUNBQ0FBUVFocUlBRkJDR29vQWdBMkFnQWdBRUVNYWlBQlFReHFLQUlBTmdJQUlBQkJFR29nQVVFUWFpZ0NBRFlDQUNBQVFSUnFJQUZCRkdvb0FnQTJBZ0FnQUVFWWFpQUJRUmhxS0FJQU5nSUFJQUJCSEdvZ0FVRWNhaWdDQURZQ0FDQUFRU0JxSUFGQklHb29BZ0EyQWdBZ0FFRWthaUFCUVNScUtBSUFOZ0lBSUFCQktHb2dBVUVvYWlnQ0FEWUNBQ0FBUVN4cUlBRkJMR29vQWdBMkFnQWdBRUV3YWlBQlFUQnFLQUlBTmdJQUlBQkJOR29nQVVFMGFpZ0NBRFlDQUNBQVFUaHFJQUZCT0dvb0FnQTJBZ0FnQUVFOGFpQUJRVHhxS0FJQU5nSUFJQUJCd0FCcUlRQWdBVUhBQUdvaEFRc01BUXNMQTBBQ1FDQUFJQVJJUlFSQURBRUxBa0FnQUNBQktBSUFOZ0lBSUFCQkJHb2hBQ0FCUVFScUlRRUxEQUVMQ3dVZ0JrRUVheUVFQTBBQ1FDQUFJQVJJUlFSQURBRUxBa0FnQUNBQkxBQUFPZ0FBSUFCQkFXb2dBVUVCYWl3QUFEb0FBQ0FBUVFKcUlBRkJBbW9zQUFBNkFBQWdBRUVEYWlBQlFRTnFMQUFBT2dBQUlBQkJCR29oQUNBQlFRUnFJUUVMREFFTEN3c0RRQUpBSUFBZ0JraEZCRUFNQVFzQ1FDQUFJQUVzQUFBNkFBQWdBRUVCYWlFQUlBRkJBV29oQVFzTUFRc0xJQU1QQy9FQ0FRUi9JQUFnQW1vaEF5QUJRZjhCY1NFQklBSkJ3d0JPQkVBRFFBSkFJQUJCQTNGQkFFZEZCRUFNQVFzQ1FDQUFJQUU2QUFBZ0FFRUJhaUVBQ3d3QkN3c2dBMEY4Y1NFRUlBUkJ3QUJySVFVZ0FTQUJRUWgwY2lBQlFSQjBjaUFCUVJoMGNpRUdBMEFDUUNBQUlBVk1SUVJBREFFTEFrQWdBQ0FHTmdJQUlBQkJCR29nQmpZQ0FDQUFRUWhxSUFZMkFnQWdBRUVNYWlBR05nSUFJQUJCRUdvZ0JqWUNBQ0FBUVJScUlBWTJBZ0FnQUVFWWFpQUdOZ0lBSUFCQkhHb2dCallDQUNBQVFTQnFJQVkyQWdBZ0FFRWthaUFHTmdJQUlBQkJLR29nQmpZQ0FDQUFRU3hxSUFZMkFnQWdBRUV3YWlBR05nSUFJQUJCTkdvZ0JqWUNBQ0FBUVRocUlBWTJBZ0FnQUVFOGFpQUdOZ0lBSUFCQndBQnFJUUFMREFFTEN3TkFBa0FnQUNBRVNFVUVRQXdCQ3dKQUlBQWdCallDQUNBQVFRUnFJUUFMREFFTEN3c0RRQUpBSUFBZ0EwaEZCRUFNQVFzQ1FDQUFJQUU2QUFBZ0FFRUJhaUVBQ3d3QkN3c2dBeUFDYXc4TEJRQkJBQThMQlFCQkFBOExaZ0VFZnlBQVFROXFRWEJ4SVFBakNpZ0NBQ0VCSUFFZ0FHb2hBeUFBUVFCS0lBTWdBVWh4SUFOQkFFaHlCRUFRQWhwQkRCQUhRWDhQQ3lNS0lBTTJBZ0FRQVNFRUlBTWdCRW9FUUJBQVFRQkdCRUFqQ2lBQk5nSUFRUXdRQjBGL0R3c0xJQUVQQ3hBQUlBRWdBRUVIY1VFQWFoRUJBQThMRkFBZ0FTQUNJQU1nQUVFSGNVRUlhaEVBQUE4TENRQkJBQkFFUVFBUEN3a0FRUUVRQlVFQUR3c0x3aTRCQUVHQUNBdTZMZ0FBQUFCc0FRQUEyQUlBQUdzQkFBRFhBZ0FBYWdFQUFOWUNBQUJwQVFBQTFRSUFBR2dCQUFEVUFnQUFad0VBQU5NQ0FBQm1BUUFBMGdJQUFHVUJBQURSQWdBQVpBRUFBTkFDQUFCakFRQUF6d0lBQUdJQkFBRE9BZ0FBWVFFQUFNMENBQUJnQVFBQXpBSUFBRjhCQUFETEFnQUFYZ0VBQU1vQ0FBQmRBUUFBeVFJQUFGd0JBQURJQWdBQVd3RUFBTWNDQUFCYUFRQUF4Z0lBQUZrQkFBREZBZ0FBV0FFQUFNUUNBQUJYQVFBQXd3SUFBRllCQUFEQ0FnQUFWUUVBQU1FQ0FBQlVBUUFBd0FJQUFGTUJBQUMvQWdBQVVnRUFBTDRDQUFCUkFRQUF2UUlBQUZBQkFBQzhBZ0FBVHdFQUFMc0NBQUJPQVFBQXVnSUFBRTBCQUFDNUFnQUFUQUVBQUxnQ0FBQkxBUUFBdHdJQUFFb0JBQUMyQWdBQVNRRUFBTFVDQUFCSUFRQUF0QUlBQUVjQkFBQ3pBZ0FBUmdFQUFMSUNBQUJGQVFBQXNRSUFBRVFCQUFDd0FnQUFRd0VBQUs4Q0FBQkNBUUFBcmdJQUFFRUJBQUN0QWdBQVFBRUFBS3dDQUFBL0FRQUFxd0lBQUQ0QkFBQ3FBZ0FBUFFFQUFLa0NBQUE4QVFBQXFBSUFBRHNCQUFDbkFnQUFPZ0VBQUtZQ0FBQTVBUUFBcFFJQUFEZ0JBQUNrQWdBQU53RUFBS01DQUFBMkFRQUFvZ0lBQURVQkFBQ2hBZ0FBTkFFQUFLQUNBQUF6QVFBQW53SUFBRElCQUFDZUFnQUFNUUVBQUowQ0FBQXdBUUFBbkFJQUFDOEJBQUNiQWdBQUxnRUFBSm9DQUFBdEFRQUFtUUlBQUN3QkFBQ1lBZ0FBS3dFQUFKY0NBQUFxQVFBQWxnSUFBQ2tCQUFDVkFnQUFLQUVBQUpRQ0FBQW5BUUFBa3dJQUFDWUJBQUNTQWdBQUpRRUFBSkVDQUFBa0FRQUFrQUlBQUNNQkFBQ1BBZ0FBSWdFQUFJNENBQUFoQVFBQWpRSUFBQ0FCQUFDTUFnQUFId0VBQUlzQ0FBQWVBUUFBaWdJQUFCMEJBQUNKQWdBQUhBRUFBSWdDQUFBYkFRQUFod0lBQUJvQkFBQ0dBZ0FBR1FFQUFJVUNBQUFZQVFBQWhBSUFBQmNCQUFDREFnQUFGZ0VBQUlJQ0FBQVZBUUFBZ1FJQUFCUUJBQUNBQWdBQUV3RUFBSDhDQUFBU0FRQUFmZ0lBQUJFQkFBQjlBZ0FBRUFFQUFId0NBQUFQQVFBQWV3SUFBQTRCQUFCNkFnQUFEUUVBQUhrQ0FBQU1BUUFBZUFJQUFBc0JBQUIzQWdBQUNnRUFBSFlDQUFBSkFRQUFkUUlBQUFnQkFBQjBBZ0FBQndFQUFITUNBQUFHQVFBQWNnSUFBQVVCQUFCeEFnQUFCQUVBQUhBQ0FBQURBUUFBYndJQUFBSUJBQUJ1QWdBQUFRRUFBRzBDQUFBQUFRQUFiQUlBQVA4QUFBQnJBZ0FBL2dBQUFHb0NBQUQ5QUFBQWFRSUFBUHdBQUFCb0FnQUErd0FBQUdjQ0FBRDZBQUFBWmdJQUFQa0FBQUJsQWdBQStBQUFBR1FDQUFEM0FBQUFZd0lBQVBZQUFBQmlBZ0FBOVFBQUFHRUNBQUQwQUFBQVlBSUFBUE1BQUFCZkFnQUE4Z0FBQUY0Q0FBRHhBQUFBWFFJQUFQQUFBQUJjQWdBQTd3QUFBRnNDQUFEdUFBQUFXZ0lBQU8wQUFBQlpBZ0FBN0FBQUFGZ0NBQURyQUFBQVZ3SUFBT29BQUFCV0FnQUE2UUFBQUZVQ0FBRG9BQUFBVkFJQUFPY0FBQUJUQWdBQTVnQUFBRklDQUFEbEFBQUFVUUlBQU9RQUFBQlFBZ0FBNHdBQUFFOENBQURpQUFBQVRnSUFBT0VBQUFCTkFnQUE0QUFBQUV3Q0FBRGZBQUFBU3dJQUFONEFBQUJLQWdBQTNRQUFBRWtDQUFEY0FBQUFTQUlBQU5zQUFBQkhBZ0FBMmdBQUFFWUNBQURaQUFBQVJRSUFBTmdBQUFCRUFnQUExd0FBQUVNQ0FBRFdBQUFBUWdJQUFOVUFBQUJCQWdBQTFBQUFBRUFDQUFEVEFBQUFQd0lBQU5JQUFBQStBZ0FBMFFBQUFEMENBQURRQUFBQVBBSUFBTThBQUFBN0FnQUF6Z0FBQURvQ0FBRE5BQUFBT1FJQUFNd0FBQUE0QWdBQXl3QUFBRGNDQUFES0FBQUFOZ0lBQU1rQUFBQTFBZ0FBeUFBQUFEUUNBQURIQUFBQU13SUFBTVlBQUFBeUFnQUF4UUFBQURFQ0FBREVBQUFBTUFJQUFNTUFBQUF2QWdBQXdnQUFBQzRDQUFEQkFBQUFMUUlBQU1BQUFBQXNBZ0FBdndBQUFDc0NBQUMrQUFBQUtnSUFBTDBBQUFBcEFnQUF2QUFBQUNnQ0FBQzdBQUFBSndJQUFMb0FBQUFtQWdBQXVRQUFBQ1VDQUFDNEFBQUFKQUlBQUxjQUFBQWpBZ0FBdGdBQUFDSUNBQUMxQUFBQUlRSUFBTFFBQUFBZ0FnQUFzd0FBQUI4Q0FBQ3lBQUFBSGdJQUFMRUFBQUFkQWdBQXNBQUFBQndDQUFDdkFBQUFHd0lBQUs0QUFBQWFBZ0FBclFBQUFCa0NBQUNzQUFBQUdBSUFBS3NBQUFBWEFnQUFxZ0FBQUJZQ0FBQ3BBQUFBRlFJQUFLZ0FBQUFVQWdBQXB3QUFBQk1DQUFDbUFBQUFFZ0lBQUtVQUFBQVJBZ0FBcEFBQUFCQUNBQUNqQUFBQUR3SUFBS0lBQUFBT0FnQUFvUUFBQUEwQ0FBQ2dBQUFBREFJQUFKOEFBQUFMQWdBQW5nQUFBQW9DQUFDZEFBQUFDUUlBQUp3QUFBQUlBZ0FBbXdBQUFBY0NBQUNhQUFBQUJnSUFBSmtBQUFBRkFnQUFtQUFBQUFRQ0FBQ1hBQUFBQXdJQUFKWUFBQUFDQWdBQWxRQUFBQUVDQUFDVUFBQUFBQUlBQUpNQUFBRC9BUUFBa2dBQUFQNEJBQUNSQUFBQS9RRUFBSkFBQUFEOEFRQUFqd0FBQVBzQkFBQ09BQUFBK2dFQUFJMEFBQUQ1QVFBQWpBQUFBUGdCQUFDTEFBQUE5d0VBQUlvQUFBRDJBUUFBaVFBQUFQVUJBQUNJQUFBQTlBRUFBSWNBQUFEekFRQUFoZ0FBQVBJQkFBQ0ZBQUFBOFFFQUFJUUFBQUR3QVFBQWd3QUFBTzhCQUFDQ0FBQUE3Z0VBQUlFQUFBRHRBUUFBZ0FBQUFPd0JBQUIvQUFBQTZ3RUFBSDRBQUFEcUFRQUFmUUFBQU9rQkFBQjhBQUFBNkFFQUFIc0FBQURuQVFBQWVnQUFBT1lCQUFCNUFBQUE1UUVBQUhnQUFBRGtBUUFBZHdBQUFPTUJBQUIyQUFBQTRnRUFBSFVBQUFEaEFRQUFkQUFBQU9BQkFBQnpBQUFBM3dFQUFISUFBQURlQVFBQWNRQUFBTjBCQUFCd0FBQUEzQUVBQUc4QUFBRGJBUUFBYmdBQUFOb0JBQUJ0QUFBQTJRRUFBR3dBQUFEWUFRQUFhd0FBQU5jQkFBQnFBQUFBMWdFQUFHa0FBQURWQVFBQWFBQUFBTlFCQUFCbkFBQUEwd0VBQUdZQUFBRFNBUUFBWlFBQUFORUJBQUJrQUFBQTBBRUFBR01BQUFEUEFRQUFZZ0FBQU00QkFBQmhBQUFBelFFQUFHQUFBQURNQVFBQVh3QUFBTXNCQUFCZUFBQUF5Z0VBQUYwQUFBREpBUUFBWEFBQUFNZ0JBQUJiQUFBQXh3RUFBRm9BQUFER0FRQUFXUUFBQU1VQkFBQllBQUFBeEFFQUFGY0FBQUREQVFBQVZnQUFBTUlCQUFCVkFBQUF3UUVBQUZRQUFBREFBUUFBVXdBQUFMOEJBQUJTQUFBQXZnRUFBRkVBQUFDOUFRQUFVQUFBQUx3QkFBQlBBQUFBdXdFQUFFNEFBQUM2QVFBQVRRQUFBTGtCQUFCTUFBQUF1QUVBQUVzQUFBQzNBUUFBU2dBQUFMWUJBQUJKQUFBQXRRRUFBRWdBQUFDMEFRQUFSd0FBQUxNQkFBQkdBQUFBc2dFQUFFVUFBQUN4QVFBQVJBQUFBTEFCQUFCREFBQUFyd0VBQUVJQUFBQ3VBUUFBUVFBQUFLMEJBQUJBQUFBQXJBRUFBRDhBQUFDckFRQUFQZ0FBQUtvQkFBQTlBQUFBcVFFQUFEd0FBQUNvQVFBQU93QUFBS2NCQUFBNkFBQUFwZ0VBQURrQUFBQ2xBUUFBT0FBQUFLUUJBQUEzQUFBQW93RUFBRFlBQUFDaUFRQUFOUUFBQUtFQkFBQTBBQUFBb0FFQUFETUFBQUNmQVFBQU1nQUFBSjRCQUFBeEFBQUFuUUVBQURBQUFBQ2NBUUFBTHdBQUFKc0JBQUF1QUFBQW1nRUFBQzBBQUFDWkFRQUFMQUFBQUpnQkFBQXJBQUFBbHdFQUFDb0FBQUNXQVFBQUtRQUFBSlVCQUFBb0FBQUFsQUVBQUNjQUFBQ1RBUUFBSmdBQUFKSUJBQUFsQUFBQWtRRUFBQ1FBQUFDUUFRQUFJd0FBQUk4QkFBQWlBQUFBamdFQUFDRUFBQUNOQVFBQUlBQUFBSXdCQUFBZkFBQUFpd0VBQUI0QUFBQ0tBUUFBSFFBQUFJa0JBQUFjQUFBQWlBRUFBQnNBQUFDSEFRQUFHZ0FBQUlZQkFBQVpBQUFBaFFFQUFCZ0FBQUNFQVFBQUZ3QUFBSU1CQUFBV0FBQUFnZ0VBQUJVQUFBQ0JBUUFBRkFBQUFJQUJBQUFUQUFBQWZ3RUFBQklBQUFCK0FRQUFFUUFBQUgwQkFBQVFBQUFBZkFFQUFBOEFBQUI3QVFBQURnQUFBSG9CQUFBTkFBQUFlUUVBQUF3QUFBQjRBUUFBQ3dBQUFIY0JBQUFLQUFBQWRnRUFBQWtBQUFCMUFRQUFDQUFBQUhRQkFBQUhBQUFBY3dFQUFBWUFBQUJ5QVFBQUJRQUFBSEVCQUFBRUFBQUFjQUVBQUFNQUFBQnZBUUFBQWdBQUFHNEJBQUFCQUFBQWJRRUFBQUFBQUFBQkFBQUFBQUFBQVAvLy8vOENBQUFBQVFBQUFQLy8vLzhBQUFBQUFnQUFBUC8vLy84QkFBQUFBQUFBQUpnUEFBQUZBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNBQUFBQXdBQUFKUWlBQUFBQUFBQUFBQUFBQUFBQUFBQ0FBQUFBQUFBQUFBQUFBQUFBQUQvLy8vLy93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQU1BQUFDY0lnQUFBQVFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFDdi8vLy84QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGUWRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFTVzUyWVd4cFpDQnRhVzVYWldsbmFIUk5ZV2R1YVhSMVpHVWdKV1FBT1VGQ1EwUkZSa2RJU1VwTFRFMU9UMUJSVWxOVVZWWlhXRmxhQUJFQUNnQVJFUkVBQUFBQUJRQUFBQUFBQUFrQUFBQUFDd0FBQUFBQUFBQUFFUUFQQ2hFUkVRTUtCd0FCRXdrTEN3QUFDUVlMQUFBTEFBWVJBQUFBRVJFUkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFzQUFBQUFBQUFBQUJFQUNnb1JFUkVBQ2dBQUFnQUpDd0FBQUFrQUN3QUFDd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1BQUFBQUFBQUFBQUFBQUFNQUFBQUFBd0FBQUFBQ1F3QUFBQUFBQXdBQUF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGdBQUFBQUFBQUFBQUFBQURRQUFBQVFOQUFBQUFBa09BQUFBQUFBT0FBQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQThBQUFBQUR3QUFBQUFKRUFBQUFBQUFFQUFBRUFBQUVnQUFBQklTRWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFTQUFBQUVoSVNBQUFBQUFBQUNRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUN3QUFBQUFBQUFBQUFBQUFDZ0FBQUFBS0FBQUFBQWtMQUFBQUFBQUxBQUFMQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdBQUFBQUFBQUFBQUFBQUF3QUFBQUFEQUFBQUFBSkRBQUFBQUFBREFBQURBQUFMU3NnSUNBd1dEQjRBQ2h1ZFd4c0tRQXRNRmdyTUZnZ01GZ3RNSGdyTUhnZ01IZ0FhVzVtQUVsT1JnQnVZVzRBVGtGT0FEQXhNak0wTlRZM09EbEJRa05FUlVZdUFGUWhJaGtOQVFJREVVc2NEQkFFQ3gwU0hpZG9ibTl3Y1dJZ0JRWVBFeFFWR2dnV0J5Z2tGeGdKQ2c0Ykh5VWpnNEo5SmlvclBEMCtQME5IU2sxWVdWcGJYRjFlWDJCaFkyUmxabWRwYW10c2NuTjBlWHA3ZkFCSmJHeGxaMkZzSUdKNWRHVWdjMlZ4ZFdWdVkyVUFSRzl0WVdsdUlHVnljbTl5QUZKbGMzVnNkQ0J1YjNRZ2NtVndjbVZ6Wlc1MFlXSnNaUUJPYjNRZ1lTQjBkSGtBVUdWeWJXbHpjMmx2YmlCa1pXNXBaV1FBVDNCbGNtRjBhVzl1SUc1dmRDQndaWEp0YVhSMFpXUUFUbThnYzNWamFDQm1hV3hsSUc5eUlHUnBjbVZqZEc5eWVRQk9ieUJ6ZFdOb0lIQnliMk5sYzNNQVJtbHNaU0JsZUdsemRITUFWbUZzZFdVZ2RHOXZJR3hoY21kbElHWnZjaUJrWVhSaElIUjVjR1VBVG04Z2MzQmhZMlVnYkdWbWRDQnZiaUJrWlhacFkyVUFUM1YwSUc5bUlHMWxiVzl5ZVFCU1pYTnZkWEpqWlNCaWRYTjVBRWx1ZEdWeWNuVndkR1ZrSUhONWMzUmxiU0JqWVd4c0FGSmxjMjkxY21ObElIUmxiWEJ2Y21GeWFXeDVJSFZ1WVhaaGFXeGhZbXhsQUVsdWRtRnNhV1FnYzJWbGF3QkRjbTl6Y3kxa1pYWnBZMlVnYkdsdWF3QlNaV0ZrTFc5dWJIa2dabWxzWlNCemVYTjBaVzBBUkdseVpXTjBiM0o1SUc1dmRDQmxiWEIwZVFCRGIyNXVaV04wYVc5dUlISmxjMlYwSUdKNUlIQmxaWElBVDNCbGNtRjBhVzl1SUhScGJXVmtJRzkxZEFCRGIyNXVaV04wYVc5dUlISmxablZ6WldRQVNHOXpkQ0JwY3lCa2IzZHVBRWh2YzNRZ2FYTWdkVzV5WldGamFHRmliR1VBUVdSa2NtVnpjeUJwYmlCMWMyVUFRbkp2YTJWdUlIQnBjR1VBU1M5UElHVnljbTl5QUU1dklITjFZMmdnWkdWMmFXTmxJRzl5SUdGa1pISmxjM01BUW14dlkyc2daR1YyYVdObElISmxjWFZwY21Wa0FFNXZJSE4xWTJnZ1pHVjJhV05sQUU1dmRDQmhJR1JwY21WamRHOXllUUJKY3lCaElHUnBjbVZqZEc5eWVRQlVaWGgwSUdacGJHVWdZblZ6ZVFCRmVHVmpJR1p2Y20xaGRDQmxjbkp2Y2dCSmJuWmhiR2xrSUdGeVozVnRaVzUwQUVGeVozVnRaVzUwSUd4cGMzUWdkRzl2SUd4dmJtY0FVM2x0WW05c2FXTWdiR2x1YXlCc2IyOXdBRVpwYkdWdVlXMWxJSFJ2YnlCc2IyNW5BRlJ2YnlCdFlXNTVJRzl3Wlc0Z1ptbHNaWE1nYVc0Z2MzbHpkR1Z0QUU1dklHWnBiR1VnWkdWelkzSnBjSFJ2Y25NZ1lYWmhhV3hoWW14bEFFSmhaQ0JtYVd4bElHUmxjMk55YVhCMGIzSUFUbThnWTJocGJHUWdjSEp2WTJWemN3QkNZV1FnWVdSa2NtVnpjd0JHYVd4bElIUnZieUJzWVhKblpRQlViMjhnYldGdWVTQnNhVzVyY3dCT2J5QnNiMk5yY3lCaGRtRnBiR0ZpYkdVQVVtVnpiM1Z5WTJVZ1pHVmhaR3h2WTJzZ2QyOTFiR1FnYjJOamRYSUFVM1JoZEdVZ2JtOTBJSEpsWTI5MlpYSmhZbXhsQUZCeVpYWnBiM1Z6SUc5M2JtVnlJR1JwWldRQVQzQmxjbUYwYVc5dUlHTmhibU5sYkdWa0FFWjFibU4wYVc5dUlHNXZkQ0JwYlhCc1pXMWxiblJsWkFCT2J5QnRaWE56WVdkbElHOW1JR1JsYzJseVpXUWdkSGx3WlFCSlpHVnVkR2xtYVdWeUlISmxiVzkyWldRQVJHVjJhV05sSUc1dmRDQmhJSE4wY21WaGJRQk9ieUJrWVhSaElHRjJZV2xzWVdKc1pRQkVaWFpwWTJVZ2RHbHRaVzkxZEFCUGRYUWdiMllnYzNSeVpXRnRjeUJ5WlhOdmRYSmpaWE1BVEdsdWF5Qm9ZWE1nWW1WbGJpQnpaWFpsY21Wa0FGQnliM1J2WTI5c0lHVnljbTl5QUVKaFpDQnRaWE56WVdkbEFFWnBiR1VnWkdWelkzSnBjSFJ2Y2lCcGJpQmlZV1FnYzNSaGRHVUFUbTkwSUdFZ2MyOWphMlYwQUVSbGMzUnBibUYwYVc5dUlHRmtaSEpsYzNNZ2NtVnhkV2x5WldRQVRXVnpjMkZuWlNCMGIyOGdiR0Z5WjJVQVVISnZkRzlqYjJ3Z2QzSnZibWNnZEhsd1pTQm1iM0lnYzI5amEyVjBBRkJ5YjNSdlkyOXNJRzV2ZENCaGRtRnBiR0ZpYkdVQVVISnZkRzlqYjJ3Z2JtOTBJSE4xY0hCdmNuUmxaQUJUYjJOclpYUWdkSGx3WlNCdWIzUWdjM1Z3Y0c5eWRHVmtBRTV2ZENCemRYQndiM0owWldRQVVISnZkRzlqYjJ3Z1ptRnRhV3g1SUc1dmRDQnpkWEJ3YjNKMFpXUUFRV1JrY21WemN5Qm1ZVzFwYkhrZ2JtOTBJSE4xY0hCdmNuUmxaQ0JpZVNCd2NtOTBiMk52YkFCQlpHUnlaWE56SUc1dmRDQmhkbUZwYkdGaWJHVUFUbVYwZDI5eWF5QnBjeUJrYjNkdUFFNWxkSGR2Y21zZ2RXNXlaV0ZqYUdGaWJHVUFRMjl1Ym1WamRHbHZiaUJ5WlhObGRDQmllU0J1WlhSM2IzSnJBRU52Ym01bFkzUnBiMjRnWVdKdmNuUmxaQUJPYnlCaWRXWm1aWElnYzNCaFkyVWdZWFpoYVd4aFlteGxBRk52WTJ0bGRDQnBjeUJqYjI1dVpXTjBaV1FBVTI5amEyVjBJRzV2ZENCamIyNXVaV04wWldRQVEyRnVibTkwSUhObGJtUWdZV1owWlhJZ2MyOWphMlYwSUhOb2RYUmtiM2R1QUU5d1pYSmhkR2x2YmlCaGJISmxZV1I1SUdsdUlIQnliMmR5WlhOekFFOXdaWEpoZEdsdmJpQnBiaUJ3Y205bmNtVnpjd0JUZEdGc1pTQm1hV3hsSUdoaGJtUnNaUUJTWlcxdmRHVWdTUzlQSUdWeWNtOXlBRkYxYjNSaElHVjRZMlZsWkdWa0FFNXZJRzFsWkdsMWJTQm1iM1Z1WkFCWGNtOXVaeUJ0WldScGRXMGdkSGx3WlFCT2J5Qmxjbkp2Y2lCcGJtWnZjbTFoZEdsdmJnPT0nO1xyXG4gIHZhciBhc21qc0NvZGVGaWxlID0gJyc7XHJcblxyXG4gIGlmICh0eXBlb2YgTW9kdWxlWydsb2NhdGVGaWxlJ10gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGlmICghaXNEYXRhVVJJKHdhc21UZXh0RmlsZSkpIHtcclxuICAgICAgd2FzbVRleHRGaWxlID0gTW9kdWxlWydsb2NhdGVGaWxlJ10od2FzbVRleHRGaWxlKTtcclxuICAgIH1cclxuICAgIGlmICghaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSkge1xyXG4gICAgICB3YXNtQmluYXJ5RmlsZSA9IE1vZHVsZVsnbG9jYXRlRmlsZSddKHdhc21CaW5hcnlGaWxlKTtcclxuICAgIH1cclxuICAgIGlmICghaXNEYXRhVVJJKGFzbWpzQ29kZUZpbGUpKSB7XHJcbiAgICAgIGFzbWpzQ29kZUZpbGUgPSBNb2R1bGVbJ2xvY2F0ZUZpbGUnXShhc21qc0NvZGVGaWxlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHV0aWxpdGllc1xyXG5cclxuICB2YXIgd2FzbVBhZ2VTaXplID0gNjQqMTAyNDtcclxuXHJcbiAgdmFyIGluZm8gPSB7XHJcbiAgICAnZ2xvYmFsJzogbnVsbCxcclxuICAgICdlbnYnOiBudWxsLFxyXG4gICAgJ2FzbTJ3YXNtJzogeyAvLyBzcGVjaWFsIGFzbTJ3YXNtIGltcG9ydHNcclxuICAgICAgXCJmNjQtcmVtXCI6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICByZXR1cm4geCAlIHk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFwiZGVidWdnZXJcIjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAncGFyZW50JzogTW9kdWxlIC8vIE1vZHVsZSBpbnNpZGUgd2FzbS1qcy5jcHAgcmVmZXJzIHRvIHdhc20tanMuY3BwOyB0aGlzIGFsbG93cyBhY2Nlc3MgdG8gdGhlIG91dHNpZGUgcHJvZ3JhbS5cclxuICB9O1xyXG5cclxuICB2YXIgZXhwb3J0cyA9IG51bGw7XHJcblxyXG5cclxuICBmdW5jdGlvbiBtZXJnZU1lbW9yeShuZXdCdWZmZXIpIHtcclxuICAgIC8vIFRoZSB3YXNtIGluc3RhbmNlIGNyZWF0ZXMgaXRzIG1lbW9yeS4gQnV0IHN0YXRpYyBpbml0IGNvZGUgbWlnaHQgaGF2ZSB3cml0dGVuIHRvXHJcbiAgICAvLyBidWZmZXIgYWxyZWFkeSwgaW5jbHVkaW5nIHRoZSBtZW0gaW5pdCBmaWxlLCBhbmQgd2UgbXVzdCBjb3B5IGl0IG92ZXIgaW4gYSBwcm9wZXIgbWVyZ2UuXHJcbiAgICAvLyBUT0RPOiBhdm9pZCB0aGlzIGNvcHksIGJ5IGF2b2lkaW5nIHN1Y2ggc3RhdGljIGluaXQgd3JpdGVzXHJcbiAgICAvLyBUT0RPOiBpbiBzaG9ydGVyIHRlcm0sIGp1c3QgY29weSB1cCB0byB0aGUgbGFzdCBzdGF0aWMgaW5pdCB3cml0ZVxyXG4gICAgdmFyIG9sZEJ1ZmZlciA9IE1vZHVsZVsnYnVmZmVyJ107XHJcbiAgICBpZiAobmV3QnVmZmVyLmJ5dGVMZW5ndGggPCBvbGRCdWZmZXIuYnl0ZUxlbmd0aCkge1xyXG4gICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ3RoZSBuZXcgYnVmZmVyIGluIG1lcmdlTWVtb3J5IGlzIHNtYWxsZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lLiBpbiBuYXRpdmUgd2FzbSwgd2Ugc2hvdWxkIGdyb3cgbWVtb3J5IGhlcmUnKTtcclxuICAgIH1cclxuICAgIHZhciBvbGRWaWV3ID0gbmV3IEludDhBcnJheShvbGRCdWZmZXIpO1xyXG4gICAgdmFyIG5ld1ZpZXcgPSBuZXcgSW50OEFycmF5KG5ld0J1ZmZlcik7XHJcblxyXG5cclxuICAgIG5ld1ZpZXcuc2V0KG9sZFZpZXcpO1xyXG4gICAgdXBkYXRlR2xvYmFsQnVmZmVyKG5ld0J1ZmZlcik7XHJcbiAgICB1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZml4SW1wb3J0cyhpbXBvcnRzKSB7XHJcbiAgICByZXR1cm4gaW1wb3J0cztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEJpbmFyeSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChNb2R1bGVbJ3dhc21CaW5hcnknXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShNb2R1bGVbJ3dhc21CaW5hcnknXSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGJpbmFyeSA9IHRyeVBhcnNlQXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKTtcclxuICAgICAgaWYgKGJpbmFyeSkge1xyXG4gICAgICAgIHJldHVybiBiaW5hcnk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKE1vZHVsZVsncmVhZEJpbmFyeSddKSB7XHJcbiAgICAgICAgcmV0dXJuIE1vZHVsZVsncmVhZEJpbmFyeSddKHdhc21CaW5hcnlGaWxlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBcIm9uIHRoZSB3ZWIsIHdlIG5lZWQgdGhlIHdhc20gYmluYXJ5IHRvIGJlIHByZWxvYWRlZCBhbmQgc2V0IG9uIE1vZHVsZVsnd2FzbUJpbmFyeSddLiBlbWNjLnB5IHdpbGwgZG8gdGhhdCBmb3IgeW91IHdoZW4gZ2VuZXJhdGluZyBIVE1MIChidXQgbm90IEpTKVwiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGFib3J0KGVycik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKCkge1xyXG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSB0aGUgYmluYXJ5IHlldCwgYW5kIGhhdmUgdGhlIEZldGNoIGFwaSwgdXNlIHRoYXRcclxuICAgIC8vIGluIHNvbWUgZW52aXJvbm1lbnRzLCBsaWtlIEVsZWN0cm9uJ3MgcmVuZGVyIHByb2Nlc3MsIEZldGNoIGFwaSBtYXkgYmUgcHJlc2VudCwgYnV0IGhhdmUgYSBkaWZmZXJlbnQgY29udGV4dCB0aGFuIGV4cGVjdGVkLCBsZXQncyBvbmx5IHVzZSBpdCBvbiB0aGUgV2ViXHJcbiAgICBpZiAoIU1vZHVsZVsnd2FzbUJpbmFyeSddICYmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSAmJiB0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICBpZiAoIXJlc3BvbnNlWydvayddKSB7XHJcbiAgICAgICAgICB0aHJvdyBcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiICsgd2FzbUJpbmFyeUZpbGUgKyBcIidcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydhcnJheUJ1ZmZlciddKCk7XHJcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZ2V0QmluYXJ5KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gT3RoZXJ3aXNlLCBnZXRCaW5hcnkgc2hvdWxkIGJlIGFibGUgdG8gZ2V0IGl0IHN5bmNocm9ub3VzbHlcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgcmVzb2x2ZShnZXRCaW5hcnkoKSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIGRvLW1ldGhvZCBmdW5jdGlvbnNcclxuXHJcblxyXG4gIGZ1bmN0aW9uIGRvTmF0aXZlV2FzbShnbG9iYWwsIGVudiwgcHJvdmlkZWRCdWZmZXIpIHtcclxuICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgnbm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCcpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBwcmVwYXJlIG1lbW9yeSBpbXBvcnRcclxuICAgIGlmICghKE1vZHVsZVsnd2FzbU1lbW9yeSddIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTWVtb3J5KSkge1xyXG4gICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ25vIG5hdGl2ZSB3YXNtIE1lbW9yeSBpbiB1c2UnKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZW52WydtZW1vcnknXSA9IE1vZHVsZVsnd2FzbU1lbW9yeSddO1xyXG4gICAgLy8gTG9hZCB0aGUgd2FzbSBtb2R1bGUgYW5kIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB1c2luZyBuYXRpdmUgc3VwcG9ydCBpbiB0aGUgSlMgZW5naW5lLlxyXG4gICAgaW5mb1snZ2xvYmFsJ10gPSB7XHJcbiAgICAgICdOYU4nOiBOYU4sXHJcbiAgICAgICdJbmZpbml0eSc6IEluZmluaXR5XHJcbiAgICB9O1xyXG4gICAgaW5mb1snZ2xvYmFsLk1hdGgnXSA9IE1hdGg7XHJcbiAgICBpbmZvWydlbnYnXSA9IGVudjtcclxuICAgIC8vIGhhbmRsZSBhIGdlbmVyYXRlZCB3YXNtIGluc3RhbmNlLCByZWNlaXZpbmcgaXRzIGV4cG9ydHMgYW5kXHJcbiAgICAvLyBwZXJmb3JtaW5nIG90aGVyIG5lY2Vzc2FyeSBzZXR1cFxyXG4gICAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLCBtb2R1bGUpIHtcclxuICAgICAgZXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XHJcbiAgICAgIGlmIChleHBvcnRzLm1lbW9yeSkgbWVyZ2VNZW1vcnkoZXhwb3J0cy5tZW1vcnkpO1xyXG4gICAgICBNb2R1bGVbJ2FzbSddID0gZXhwb3J0cztcclxuICAgICAgTW9kdWxlW1widXNpbmdXYXNtXCJdID0gdHJ1ZTtcclxuICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeSgnd2FzbS1pbnN0YW50aWF0ZScpO1xyXG4gICAgfVxyXG4gICAgYWRkUnVuRGVwZW5kZW5jeSgnd2FzbS1pbnN0YW50aWF0ZScpO1xyXG5cclxuICAgIC8vIFVzZXIgc2hlbGwgcGFnZXMgY2FuIHdyaXRlIHRoZWlyIG93biBNb2R1bGUuaW5zdGFudGlhdGVXYXNtID0gZnVuY3Rpb24oaW1wb3J0cywgc3VjY2Vzc0NhbGxiYWNrKSBjYWxsYmFja1xyXG4gICAgLy8gdG8gbWFudWFsbHkgaW5zdGFudGlhdGUgdGhlIFdhc20gbW9kdWxlIHRoZW1zZWx2ZXMuIFRoaXMgYWxsb3dzIHBhZ2VzIHRvIHJ1biB0aGUgaW5zdGFudGlhdGlvbiBwYXJhbGxlbFxyXG4gICAgLy8gdG8gYW55IG90aGVyIGFzeW5jIHN0YXJ0dXAgYWN0aW9ucyB0aGV5IGFyZSBwZXJmb3JtaW5nLlxyXG4gICAgaWYgKE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10pIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXShpbmZvLCByZWNlaXZlSW5zdGFuY2UpO1xyXG4gICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ01vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6ICcgKyBlKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBc3luYyBjb21waWxhdGlvbiBjYW4gYmUgY29uZnVzaW5nIHdoZW4gYW4gZXJyb3Igb24gdGhlIHBhZ2Ugb3ZlcndyaXRlcyBNb2R1bGVcclxuICAgIC8vIChmb3IgZXhhbXBsZSwgaWYgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGlzIHdyb25nLCBhbmQgdGhlIG9uZSBkZWZpbmluZyBNb2R1bGUgaXNcclxuICAgIC8vIGxhdGVyKSwgc28gd2Ugc2F2ZSBNb2R1bGUgYW5kIGNoZWNrIGl0IGxhdGVyLlxyXG4gICAgdmFyIHRydWVNb2R1bGUgPSBNb2R1bGU7XHJcbiAgICBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGVkU291cmNlKG91dHB1dCkge1xyXG4gICAgICAvLyAnb3V0cHV0JyBpcyBhIFdlYkFzc2VtYmx5SW5zdGFudGlhdGVkU291cmNlIG9iamVjdCB3aGljaCBoYXMgYm90aCB0aGUgbW9kdWxlIGFuZCBpbnN0YW5jZS5cclxuICAgICAgLy8gcmVjZWl2ZUluc3RhbmNlKCkgd2lsbCBzd2FwIGluIHRoZSBleHBvcnRzICh0byBNb2R1bGUuYXNtKSBzbyB0aGV5IGNhbiBiZSBjYWxsZWRcclxuICAgICAgYXNzZXJ0KE1vZHVsZSA9PT0gdHJ1ZU1vZHVsZSwgJ3RoZSBNb2R1bGUgb2JqZWN0IHNob3VsZCBub3QgYmUgcmVwbGFjZWQgZHVyaW5nIGFzeW5jIGNvbXBpbGF0aW9uIC0gcGVyaGFwcyB0aGUgb3JkZXIgb2YgSFRNTCBlbGVtZW50cyBpcyB3cm9uZz8nKTtcclxuICAgICAgdHJ1ZU1vZHVsZSA9IG51bGw7XHJcbiAgICAgIHJlY2VpdmVJbnN0YW5jZShvdXRwdXRbJ2luc3RhbmNlJ10sIG91dHB1dFsnbW9kdWxlJ10pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlcikge1xyXG4gICAgICBnZXRCaW5hcnlQcm9taXNlKCkudGhlbihmdW5jdGlvbihiaW5hcnkpIHtcclxuICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbmZvKTtcclxuICAgICAgfSkudGhlbihyZWNlaXZlcikuY2F0Y2goZnVuY3Rpb24ocmVhc29uKSB7XHJcbiAgICAgICAgTW9kdWxlWydwcmludEVyciddKCdmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAnICsgcmVhc29uKTtcclxuICAgICAgICBhYm9ydChyZWFzb24pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIFByZWZlciBzdHJlYW1pbmcgaW5zdGFudGlhdGlvbiBpZiBhdmFpbGFibGUuXHJcbiAgICBpZiAoIU1vZHVsZVsnd2FzbUJpbmFyeSddICYmXHJcbiAgICAgICAgdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICAgIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkgJiZcclxuICAgICAgICB0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZmV0Y2god2FzbUJpbmFyeUZpbGUsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSksIGluZm8pXHJcbiAgICAgICAgLnRoZW4ocmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24ocmVhc29uKSB7XHJcbiAgICAgICAgICAvLyBXZSBleHBlY3QgdGhlIG1vc3QgY29tbW9uIGZhaWx1cmUgY2F1c2UgdG8gYmUgYSBiYWQgTUlNRSB0eXBlIGZvciB0aGUgYmluYXJ5LFxyXG4gICAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSBmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvbiBzaG91bGQgd29yay5cclxuICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgnd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICcgKyByZWFzb24pO1xyXG4gICAgICAgICAgTW9kdWxlWydwcmludEVyciddKCdmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvbicpO1xyXG4gICAgICAgICAgaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGVkU291cmNlKTtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge307IC8vIG5vIGV4cG9ydHMgeWV0OyB3ZSdsbCBmaWxsIHRoZW0gaW4gbGF0ZXJcclxuICB9XHJcblxyXG5cclxuICAvLyBXZSBtYXkgaGF2ZSBhIHByZWxvYWRlZCB2YWx1ZSBpbiBNb2R1bGUuYXNtLCBzYXZlIGl0XHJcbiAgTW9kdWxlWydhc21QcmVsb2FkJ10gPSBNb2R1bGVbJ2FzbSddO1xyXG5cclxuICAvLyBNZW1vcnkgZ3Jvd3RoIGludGVncmF0aW9uIGNvZGVcclxuXHJcbiAgdmFyIGFzbWpzUmVhbGxvY0J1ZmZlciA9IE1vZHVsZVsncmVhbGxvY0J1ZmZlciddO1xyXG5cclxuICB2YXIgd2FzbVJlYWxsb2NCdWZmZXIgPSBmdW5jdGlvbihzaXplKSB7XHJcbiAgICB2YXIgUEFHRV9NVUxUSVBMRSA9IE1vZHVsZVtcInVzaW5nV2FzbVwiXSA/IFdBU01fUEFHRV9TSVpFIDogQVNNSlNfUEFHRV9TSVpFOyAvLyBJbiB3YXNtLCBoZWFwIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0S0IuIEluIGFzbS5qcywgdGhleSBuZWVkIHRvIGJlIG11bHRpcGxlcyBvZiAxNk1CLlxyXG4gICAgc2l6ZSA9IGFsaWduVXAoc2l6ZSwgUEFHRV9NVUxUSVBMRSk7IC8vIHJvdW5kIHVwIHRvIHdhc20gcGFnZSBzaXplXHJcbiAgICB2YXIgb2xkID0gTW9kdWxlWydidWZmZXInXTtcclxuICAgIHZhciBvbGRTaXplID0gb2xkLmJ5dGVMZW5ndGg7XHJcbiAgICBpZiAoTW9kdWxlW1widXNpbmdXYXNtXCJdKSB7XHJcbiAgICAgIC8vIG5hdGl2ZSB3YXNtIHN1cHBvcnRcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gTW9kdWxlWyd3YXNtTWVtb3J5J10uZ3Jvdygoc2l6ZSAtIG9sZFNpemUpIC8gd2FzbVBhZ2VTaXplKTsgLy8gLmdyb3coKSB0YWtlcyBhIGRlbHRhIGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyBzaXplXHJcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gKC0xIHwgMCkpIHtcclxuICAgICAgICAgIC8vIHN1Y2Nlc3MgaW4gbmF0aXZlIHdhc20gbWVtb3J5IGdyb3d0aCwgZ2V0IHRoZSBidWZmZXIgZnJvbSB0aGUgbWVtb3J5XHJcbiAgICAgICAgICByZXR1cm4gTW9kdWxlWydidWZmZXInXSA9IE1vZHVsZVsnd2FzbU1lbW9yeSddLmJ1ZmZlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdNb2R1bGUucmVhbGxvY0J1ZmZlcjogQXR0ZW1wdGVkIHRvIGdyb3cgZnJvbSAnICsgb2xkU2l6ZSAgKyAnIGJ5dGVzIHRvICcgKyBzaXplICsgJyBieXRlcywgYnV0IGdvdCBlcnJvcjogJyArIGUpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgTW9kdWxlWydyZWFsbG9jQnVmZmVyJ10gPSBmdW5jdGlvbihzaXplKSB7XHJcbiAgICBpZiAoZmluYWxNZXRob2QgPT09ICdhc21qcycpIHtcclxuICAgICAgcmV0dXJuIGFzbWpzUmVhbGxvY0J1ZmZlcihzaXplKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB3YXNtUmVhbGxvY0J1ZmZlcihzaXplKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyB3ZSBtYXkgdHJ5IG1vcmUgdGhhbiBvbmU7IHRoaXMgaXMgdGhlIGZpbmFsIG9uZSwgdGhhdCB3b3JrZWQgYW5kIHdlIGFyZSB1c2luZ1xyXG4gIHZhciBmaW5hbE1ldGhvZCA9ICcnO1xyXG5cclxuICAvLyBQcm92aWRlIGFuIFwiYXNtLmpzIGZ1bmN0aW9uXCIgZm9yIHRoZSBhcHBsaWNhdGlvbiwgY2FsbGVkIHRvIFwibGlua1wiIHRoZSBhc20uanMgbW9kdWxlLiBXZSBpbnN0YW50aWF0ZVxyXG4gIC8vIHRoZSB3YXNtIG1vZHVsZSBhdCB0aGF0IHRpbWUsIGFuZCBpdCByZWNlaXZlcyBpbXBvcnRzIGFuZCBwcm92aWRlcyBleHBvcnRzIGFuZCBzbyBmb3J0aCwgdGhlIGFwcFxyXG4gIC8vIGRvZXNuJ3QgbmVlZCB0byBjYXJlIHRoYXQgaXQgaXMgd2FzbSBvciBvbHlmaWxsZWQgd2FzbSBvciBhc20uanMuXHJcblxyXG4gIE1vZHVsZVsnYXNtJ10gPSBmdW5jdGlvbihnbG9iYWwsIGVudiwgcHJvdmlkZWRCdWZmZXIpIHtcclxuICAgIGVudiA9IGZpeEltcG9ydHMoZW52KTtcclxuXHJcbiAgICAvLyBpbXBvcnQgdGFibGVcclxuICAgIGlmICghZW52Wyd0YWJsZSddKSB7XHJcbiAgICAgIHZhciBUQUJMRV9TSVpFID0gTW9kdWxlWyd3YXNtVGFibGVTaXplJ107XHJcbiAgICAgIGlmIChUQUJMRV9TSVpFID09PSB1bmRlZmluZWQpIFRBQkxFX1NJWkUgPSAxMDI0OyAvLyB3b3JrcyBpbiBiaW5hcnllbiBpbnRlcnByZXRlciBhdCBsZWFzdFxyXG4gICAgICB2YXIgTUFYX1RBQkxFX1NJWkUgPSBNb2R1bGVbJ3dhc21NYXhUYWJsZVNpemUnXTtcclxuICAgICAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIFdlYkFzc2VtYmx5LlRhYmxlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgaWYgKE1BWF9UQUJMRV9TSVpFICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGVudlsndGFibGUnXSA9IG5ldyBXZWJBc3NlbWJseS5UYWJsZSh7ICdpbml0aWFsJzogVEFCTEVfU0laRSwgJ21heGltdW0nOiBNQVhfVEFCTEVfU0laRSwgJ2VsZW1lbnQnOiAnYW55ZnVuYycgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVudlsndGFibGUnXSA9IG5ldyBXZWJBc3NlbWJseS5UYWJsZSh7ICdpbml0aWFsJzogVEFCTEVfU0laRSwgZWxlbWVudDogJ2FueWZ1bmMnIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbnZbJ3RhYmxlJ10gPSBuZXcgQXJyYXkoVEFCTEVfU0laRSk7IC8vIHdvcmtzIGluIGJpbmFyeWVuIGludGVycHJldGVyIGF0IGxlYXN0XHJcbiAgICAgIH1cclxuICAgICAgTW9kdWxlWyd3YXNtVGFibGUnXSA9IGVudlsndGFibGUnXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWVudlsnbWVtb3J5QmFzZSddKSB7XHJcbiAgICAgIGVudlsnbWVtb3J5QmFzZSddID0gTW9kdWxlWydTVEFUSUNfQkFTRSddOyAvLyB0ZWxsIHRoZSBtZW1vcnkgc2VnbWVudHMgd2hlcmUgdG8gcGxhY2UgdGhlbXNlbHZlc1xyXG4gICAgfVxyXG4gICAgaWYgKCFlbnZbJ3RhYmxlQmFzZSddKSB7XHJcbiAgICAgIGVudlsndGFibGVCYXNlJ10gPSAwOyAvLyB0YWJsZSBzdGFydHMgYXQgMCBieSBkZWZhdWx0LCBpbiBkeW5hbWljIGxpbmtpbmcgdGhpcyB3aWxsIGNoYW5nZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHRyeSB0aGUgbWV0aG9kcy4gZWFjaCBzaG91bGQgcmV0dXJuIHRoZSBleHBvcnRzIGlmIGl0IHN1Y2NlZWRlZFxyXG5cclxuICAgIHZhciBleHBvcnRzO1xyXG4gICAgZXhwb3J0cyA9IGRvTmF0aXZlV2FzbShnbG9iYWwsIGVudiwgcHJvdmlkZWRCdWZmZXIpO1xyXG5cclxuICAgIGlmICghZXhwb3J0cykgYWJvcnQoJ25vIGJpbmFyeWVuIG1ldGhvZCBzdWNjZWVkZWQuIGNvbnNpZGVyIGVuYWJsaW5nIG1vcmUgb3B0aW9ucywgbGlrZSBpbnRlcnByZXRpbmcsIGlmIHlvdSB3YW50IHRoYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlwa2VuL2Vtc2NyaXB0ZW4vd2lraS9XZWJBc3NlbWJseSNiaW5hcnllbi1tZXRob2RzJyk7XHJcblxyXG5cclxuICAgIHJldHVybiBleHBvcnRzO1xyXG4gIH07XHJcblxyXG4gIHZhciBtZXRob2RIYW5kbGVyID0gTW9kdWxlWydhc20nXTsgLy8gbm90ZSBvdXIgbWV0aG9kIGhhbmRsZXIsIGFzIHdlIG1heSBtb2RpZnkgTW9kdWxlWydhc20nXSBsYXRlclxyXG59XHJcblxyXG5pbnRlZ3JhdGVXYXNtSlMoKTtcclxuXHJcbi8vID09PSBCb2R5ID09PVxyXG5cclxudmFyIEFTTV9DT05TVFMgPSBbXTtcclxuXHJcblxyXG5cclxuXHJcblNUQVRJQ19CQVNFID0gR0xPQkFMX0JBU0U7XHJcblxyXG5TVEFUSUNUT1AgPSBTVEFUSUNfQkFTRSArIDk4ODg7XHJcbi8qIGdsb2JhbCBpbml0aWFsaXplcnMgKi8gIF9fQVRJTklUX18ucHVzaCgpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIFNUQVRJQ19CVU1QID0gOTg4ODtcclxuTW9kdWxlW1wiU1RBVElDX0JBU0VcIl0gPSBTVEFUSUNfQkFTRTtcclxuTW9kdWxlW1wiU1RBVElDX0JVTVBcIl0gPSBTVEFUSUNfQlVNUDtcclxuXHJcbi8qIG5vIG1lbW9yeSBpbml0aWFsaXplciAqL1xyXG52YXIgdGVtcERvdWJsZVB0ciA9IFNUQVRJQ1RPUDsgU1RBVElDVE9QICs9IDE2O1xyXG5cclxuYXNzZXJ0KHRlbXBEb3VibGVQdHIgJSA4ID09IDApO1xyXG5cclxuZnVuY3Rpb24gY29weVRlbXBGbG9hdChwdHIpIHsgLy8gZnVuY3Rpb25zLCBiZWNhdXNlIGlubGluaW5nIHRoaXMgY29kZSBpbmNyZWFzZXMgY29kZSBzaXplIHRvbyBtdWNoXHJcblxyXG4gIEhFQVA4W3RlbXBEb3VibGVQdHJdID0gSEVBUDhbcHRyXTtcclxuXHJcbiAgSEVBUDhbdGVtcERvdWJsZVB0cisxXSA9IEhFQVA4W3B0cisxXTtcclxuXHJcbiAgSEVBUDhbdGVtcERvdWJsZVB0cisyXSA9IEhFQVA4W3B0cisyXTtcclxuXHJcbiAgSEVBUDhbdGVtcERvdWJsZVB0ciszXSA9IEhFQVA4W3B0ciszXTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcHlUZW1wRG91YmxlKHB0cikge1xyXG5cclxuICBIRUFQOFt0ZW1wRG91YmxlUHRyXSA9IEhFQVA4W3B0cl07XHJcblxyXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrMV0gPSBIRUFQOFtwdHIrMV07XHJcblxyXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrMl0gPSBIRUFQOFtwdHIrMl07XHJcblxyXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrM10gPSBIRUFQOFtwdHIrM107XHJcblxyXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrNF0gPSBIRUFQOFtwdHIrNF07XHJcblxyXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrNV0gPSBIRUFQOFtwdHIrNV07XHJcblxyXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrNl0gPSBIRUFQOFtwdHIrNl07XHJcblxyXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrN10gPSBIRUFQOFtwdHIrN107XHJcblxyXG59XHJcblxyXG4vLyB7e1BSRV9MSUJSQVJZfX1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIF9fX2xvY2soKSB7fVxyXG5cclxuICBcclxuICB2YXIgU1lTQ0FMTFM9e3ZhcmFyZ3M6MCxnZXQ6ZnVuY3Rpb24gKHZhcmFyZ3MpIHtcclxuICAgICAgICBTWVNDQUxMUy52YXJhcmdzICs9IDQ7XHJcbiAgICAgICAgdmFyIHJldCA9IEhFQVAzMlsoKChTWVNDQUxMUy52YXJhcmdzKS0oNCkpPj4yKV07XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgfSxnZXRTdHI6ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXQgPSBQb2ludGVyX3N0cmluZ2lmeShTWVNDQUxMUy5nZXQoKSk7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgfSxnZXQ2NDpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9IFNZU0NBTExTLmdldCgpLCBoaWdoID0gU1lTQ0FMTFMuZ2V0KCk7XHJcbiAgICAgICAgaWYgKGxvdyA+PSAwKSBhc3NlcnQoaGlnaCA9PT0gMCk7XHJcbiAgICAgICAgZWxzZSBhc3NlcnQoaGlnaCA9PT0gLTEpO1xyXG4gICAgICAgIHJldHVybiBsb3c7XHJcbiAgICAgIH0sZ2V0WmVybzpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYXNzZXJ0KFNZU0NBTExTLmdldCgpID09PSAwKTtcclxuICAgICAgfX07ZnVuY3Rpb24gX19fc3lzY2FsbDE0MCh3aGljaCwgdmFyYXJncykge1NZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xyXG4gIHRyeSB7XHJcbiAgIC8vIGxsc2Vla1xyXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKCksIG9mZnNldF9oaWdoID0gU1lTQ0FMTFMuZ2V0KCksIG9mZnNldF9sb3cgPSBTWVNDQUxMUy5nZXQoKSwgcmVzdWx0ID0gU1lTQ0FMTFMuZ2V0KCksIHdoZW5jZSA9IFNZU0NBTExTLmdldCgpO1xyXG4gICAgICAvLyBOT1RFOiBvZmZzZXRfaGlnaCBpcyB1bnVzZWQgLSBFbXNjcmlwdGVuJ3Mgb2ZmX3QgaXMgMzItYml0XHJcbiAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRfbG93O1xyXG4gICAgICBGUy5sbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSk7XHJcbiAgICAgIEhFQVAzMlsoKHJlc3VsdCk+PjIpXT1zdHJlYW0ucG9zaXRpb247XHJcbiAgICAgIGlmIChzdHJlYW0uZ2V0ZGVudHMgJiYgb2Zmc2V0ID09PSAwICYmIHdoZW5jZSA9PT0gMCkgc3RyZWFtLmdldGRlbnRzID0gbnVsbDsgLy8gcmVzZXQgcmVhZGRpciBzdGF0ZVxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTtcclxuICAgIHJldHVybiAtZS5lcnJubztcclxuICB9XHJcbiAgfVxyXG5cclxuICBcclxuICBmdW5jdGlvbiBmbHVzaF9OT19GSUxFU1lTVEVNKCkge1xyXG4gICAgICAvLyBmbHVzaCBhbnl0aGluZyByZW1haW5pbmcgaW4gdGhlIGJ1ZmZlcnMgZHVyaW5nIHNodXRkb3duXHJcbiAgICAgIHZhciBmZmx1c2ggPSBNb2R1bGVbXCJfZmZsdXNoXCJdO1xyXG4gICAgICBpZiAoZmZsdXNoKSBmZmx1c2goMCk7XHJcbiAgICAgIHZhciBwcmludENoYXIgPSBfX19zeXNjYWxsMTQ2LnByaW50Q2hhcjtcclxuICAgICAgaWYgKCFwcmludENoYXIpIHJldHVybjtcclxuICAgICAgdmFyIGJ1ZmZlcnMgPSBfX19zeXNjYWxsMTQ2LmJ1ZmZlcnM7XHJcbiAgICAgIGlmIChidWZmZXJzWzFdLmxlbmd0aCkgcHJpbnRDaGFyKDEsIDEwKTtcclxuICAgICAgaWYgKGJ1ZmZlcnNbMl0ubGVuZ3RoKSBwcmludENoYXIoMiwgMTApO1xyXG4gICAgfWZ1bmN0aW9uIF9fX3N5c2NhbGwxNDYod2hpY2gsIHZhcmFyZ3MpIHtTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcclxuICB0cnkge1xyXG4gICAvLyB3cml0ZXZcclxuICAgICAgLy8gaGFjayB0byBzdXBwb3J0IHByaW50ZiBpbiBOT19GSUxFU1lTVEVNXHJcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXQoKSwgaW92ID0gU1lTQ0FMTFMuZ2V0KCksIGlvdmNudCA9IFNZU0NBTExTLmdldCgpO1xyXG4gICAgICB2YXIgcmV0ID0gMDtcclxuICAgICAgaWYgKCFfX19zeXNjYWxsMTQ2LmJ1ZmZlcnMpIHtcclxuICAgICAgICBfX19zeXNjYWxsMTQ2LmJ1ZmZlcnMgPSBbbnVsbCwgW10sIFtdXTsgLy8gMSA9PiBzdGRvdXQsIDIgPT4gc3RkZXJyXHJcbiAgICAgICAgX19fc3lzY2FsbDE0Ni5wcmludENoYXIgPSBmdW5jdGlvbihzdHJlYW0sIGN1cnIpIHtcclxuICAgICAgICAgIHZhciBidWZmZXIgPSBfX19zeXNjYWxsMTQ2LmJ1ZmZlcnNbc3RyZWFtXTtcclxuICAgICAgICAgIGFzc2VydChidWZmZXIpO1xyXG4gICAgICAgICAgaWYgKGN1cnIgPT09IDAgfHwgY3VyciA9PT0gMTApIHtcclxuICAgICAgICAgICAgKHN0cmVhbSA9PT0gMSA/IE1vZHVsZVsncHJpbnQnXSA6IE1vZHVsZVsncHJpbnRFcnInXSkoVVRGOEFycmF5VG9TdHJpbmcoYnVmZmVyLCAwKSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2goY3Vycik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHB0ciA9IEhFQVAzMlsoKChpb3YpKyhpKjgpKT4+MildO1xyXG4gICAgICAgIHZhciBsZW4gPSBIRUFQMzJbKCgoaW92KSsoaSo4ICsgNCkpPj4yKV07XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xyXG4gICAgICAgICAgX19fc3lzY2FsbDE0Ni5wcmludENoYXIoc3RyZWFtLCBIRUFQVThbcHRyK2pdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0ICs9IGxlbjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmV0O1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgaWYgKHR5cGVvZiBGUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIGFib3J0KGUpO1xyXG4gICAgcmV0dXJuIC1lLmVycm5vO1xyXG4gIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGw1NCh3aGljaCwgdmFyYXJncykge1NZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xyXG4gIHRyeSB7XHJcbiAgIC8vIGlvY3RsXHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgaWYgKHR5cGVvZiBGUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIGFib3J0KGUpO1xyXG4gICAgcmV0dXJuIC1lLmVycm5vO1xyXG4gIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGw2KHdoaWNoLCB2YXJhcmdzKSB7U1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XHJcbiAgdHJ5IHtcclxuICAgLy8gY2xvc2VcclxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpO1xyXG4gICAgICBGUy5jbG9zZShzdHJlYW0pO1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTtcclxuICAgIHJldHVybiAtZS5lcnJubztcclxuICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfX191bmxvY2soKSB7fVxyXG5cclxuICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9oYXNfdGhyZWFkaW5nX3N1cHBvcnQoKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgXHJcblxyXG4gIFxyXG4gIHZhciBjdHR6X2k4ID0gYWxsb2NhdGUoWzgsMCwxLDAsMiwwLDEsMCwzLDAsMSwwLDIsMCwxLDAsNCwwLDEsMCwyLDAsMSwwLDMsMCwxLDAsMiwwLDEsMCw1LDAsMSwwLDIsMCwxLDAsMywwLDEsMCwyLDAsMSwwLDQsMCwxLDAsMiwwLDEsMCwzLDAsMSwwLDIsMCwxLDAsNiwwLDEsMCwyLDAsMSwwLDMsMCwxLDAsMiwwLDEsMCw0LDAsMSwwLDIsMCwxLDAsMywwLDEsMCwyLDAsMSwwLDUsMCwxLDAsMiwwLDEsMCwzLDAsMSwwLDIsMCwxLDAsNCwwLDEsMCwyLDAsMSwwLDMsMCwxLDAsMiwwLDEsMCw3LDAsMSwwLDIsMCwxLDAsMywwLDEsMCwyLDAsMSwwLDQsMCwxLDAsMiwwLDEsMCwzLDAsMSwwLDIsMCwxLDAsNSwwLDEsMCwyLDAsMSwwLDMsMCwxLDAsMiwwLDEsMCw0LDAsMSwwLDIsMCwxLDAsMywwLDEsMCwyLDAsMSwwLDYsMCwxLDAsMiwwLDEsMCwzLDAsMSwwLDIsMCwxLDAsNCwwLDEsMCwyLDAsMSwwLDMsMCwxLDAsMiwwLDEsMCw1LDAsMSwwLDIsMCwxLDAsMywwLDEsMCwyLDAsMSwwLDQsMCwxLDAsMiwwLDEsMCwzLDAsMSwwLDIsMCwxLDBdLCBcImk4XCIsIEFMTE9DX1NUQVRJQyk7ZnVuY3Rpb24gX2xsdm1fY3R0el9pMzIoeCkge1xyXG4gICAgICB4ID0geHwwO1xyXG4gICAgICB2YXIgcmV0ID0gMDtcclxuICAgICAgcmV0ID0gKChIRUFQOFsoKChjdHR6X2k4KSsoeCAmIDB4ZmYpKT4+MCldKXwwKTtcclxuICAgICAgaWYgKChyZXR8MCkgPCA4KSByZXR1cm4gcmV0fDA7XHJcbiAgICAgIHJldCA9ICgoSEVBUDhbKCgoY3R0el9pOCkrKCh4ID4+IDgpJjB4ZmYpKT4+MCldKXwwKTtcclxuICAgICAgaWYgKChyZXR8MCkgPCA4KSByZXR1cm4gKHJldCArIDgpfDA7XHJcbiAgICAgIHJldCA9ICgoSEVBUDhbKCgoY3R0el9pOCkrKCh4ID4+IDE2KSYweGZmKSk+PjApXSl8MCk7XHJcbiAgICAgIGlmICgocmV0fDApIDwgOCkgcmV0dXJuIChyZXQgKyAxNil8MDtcclxuICAgICAgcmV0dXJuICgoKEhFQVA4WygoKGN0dHpfaTgpKyh4ID4+PiAyNCkpPj4wKV0pfDApICsgMjQpfDA7XHJcbiAgICB9ZnVuY3Rpb24gX2xsdm1fY3R0el9pNjQobCwgaCkge1xyXG4gICAgICB2YXIgcmV0ID0gX2xsdm1fY3R0el9pMzIobCk7XHJcbiAgICAgIGlmIChyZXQgPT0gMzIpIHJldCArPSBfbGx2bV9jdHR6X2kzMihoKTtcclxuICAgICAgcmV0dXJuICgoc2V0VGVtcFJldDAoMCkscmV0KXwwKTtcclxuICAgIH1cclxuXHJcbiAgZnVuY3Rpb24gX2xsdm1fc3RhY2tyZXN0b3JlKHApIHtcclxuICAgICAgdmFyIHNlbGYgPSBfbGx2bV9zdGFja3NhdmU7XHJcbiAgICAgIHZhciByZXQgPSBzZWxmLkxMVk1fU0FWRURTVEFDS1NbcF07XHJcbiAgICAgIHNlbGYuTExWTV9TQVZFRFNUQUNLUy5zcGxpY2UocCwgMSk7XHJcbiAgICAgIHN0YWNrUmVzdG9yZShyZXQpO1xyXG4gICAgfVxyXG5cclxuICBmdW5jdGlvbiBfbGx2bV9zdGFja3NhdmUoKSB7XHJcbiAgICAgIHZhciBzZWxmID0gX2xsdm1fc3RhY2tzYXZlO1xyXG4gICAgICBpZiAoIXNlbGYuTExWTV9TQVZFRFNUQUNLUykge1xyXG4gICAgICAgIHNlbGYuTExWTV9TQVZFRFNUQUNLUyA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHNlbGYuTExWTV9TQVZFRFNUQUNLUy5wdXNoKHN0YWNrU2F2ZSgpKTtcclxuICAgICAgcmV0dXJuIHNlbGYuTExWTV9TQVZFRFNUQUNLUy5sZW5ndGgtMTtcclxuICAgIH1cclxuXHJcbiAgXHJcbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyhkZXN0LCBzcmMsIG51bSkge1xyXG4gICAgICBIRUFQVTguc2V0KEhFQVBVOC5zdWJhcnJheShzcmMsIHNyYytudW0pLCBkZXN0KTtcclxuICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICB9IFxyXG5cclxuICAgXHJcblxyXG4gIGZ1bmN0aW9uIF9wdGhyZWFkX2NyZWF0ZSgpIHtcclxuICAgICAgcmV0dXJuIDExO1xyXG4gICAgfVxyXG5cclxuICBmdW5jdGlvbiBfcHRocmVhZF9qb2luKCkge31cclxuXHJcbiAgZnVuY3Rpb24gX3B0aHJlYWRfbXV0ZXhfaW5pdCgpIHt9XHJcblxyXG4gICBcclxuXHJcbiAgIFxyXG5cclxuICBcclxuICBmdW5jdGlvbiBfX19zZXRFcnJObyh2YWx1ZSkge1xyXG4gICAgICBpZiAoTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddKSBIRUFQMzJbKChNb2R1bGVbJ19fX2Vycm5vX2xvY2F0aW9uJ10oKSk+PjIpXT12YWx1ZTtcclxuICAgICAgZWxzZSBNb2R1bGUucHJpbnRFcnIoJ2ZhaWxlZCB0byBzZXQgZXJybm8gZnJvbSBKUycpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9IFxyXG5cclxuICBcclxuICB2YXIgRVJSTk9fQ09ERVM9e0VQRVJNOjEsRU5PRU5UOjIsRVNSQ0g6MyxFSU5UUjo0LEVJTzo1LEVOWElPOjYsRTJCSUc6NyxFTk9FWEVDOjgsRUJBREY6OSxFQ0hJTEQ6MTAsRUFHQUlOOjExLEVXT1VMREJMT0NLOjExLEVOT01FTToxMixFQUNDRVM6MTMsRUZBVUxUOjE0LEVOT1RCTEs6MTUsRUJVU1k6MTYsRUVYSVNUOjE3LEVYREVWOjE4LEVOT0RFVjoxOSxFTk9URElSOjIwLEVJU0RJUjoyMSxFSU5WQUw6MjIsRU5GSUxFOjIzLEVNRklMRToyNCxFTk9UVFk6MjUsRVRYVEJTWToyNixFRkJJRzoyNyxFTk9TUEM6MjgsRVNQSVBFOjI5LEVST0ZTOjMwLEVNTElOSzozMSxFUElQRTozMixFRE9NOjMzLEVSQU5HRTozNCxFTk9NU0c6NDIsRUlEUk06NDMsRUNIUk5HOjQ0LEVMMk5TWU5DOjQ1LEVMM0hMVDo0NixFTDNSU1Q6NDcsRUxOUk5HOjQ4LEVVTkFUQ0g6NDksRU5PQ1NJOjUwLEVMMkhMVDo1MSxFREVBRExLOjM1LEVOT0xDSzozNyxFQkFERTo1MixFQkFEUjo1MyxFWEZVTEw6NTQsRU5PQU5POjU1LEVCQURSUUM6NTYsRUJBRFNMVDo1NyxFREVBRExPQ0s6MzUsRUJGT05UOjU5LEVOT1NUUjo2MCxFTk9EQVRBOjYxLEVUSU1FOjYyLEVOT1NSOjYzLEVOT05FVDo2NCxFTk9QS0c6NjUsRVJFTU9URTo2NixFTk9MSU5LOjY3LEVBRFY6NjgsRVNSTU5UOjY5LEVDT01NOjcwLEVQUk9UTzo3MSxFTVVMVElIT1A6NzIsRURPVERPVDo3MyxFQkFETVNHOjc0LEVOT1RVTklROjc2LEVCQURGRDo3NyxFUkVNQ0hHOjc4LEVMSUJBQ0M6NzksRUxJQkJBRDo4MCxFTElCU0NOOjgxLEVMSUJNQVg6ODIsRUxJQkVYRUM6ODMsRU5PU1lTOjM4LEVOT1RFTVBUWTozOSxFTkFNRVRPT0xPTkc6MzYsRUxPT1A6NDAsRU9QTk9UU1VQUDo5NSxFUEZOT1NVUFBPUlQ6OTYsRUNPTk5SRVNFVDoxMDQsRU5PQlVGUzoxMDUsRUFGTk9TVVBQT1JUOjk3LEVQUk9UT1RZUEU6OTEsRU5PVFNPQ0s6ODgsRU5PUFJPVE9PUFQ6OTIsRVNIVVRET1dOOjEwOCxFQ09OTlJFRlVTRUQ6MTExLEVBRERSSU5VU0U6OTgsRUNPTk5BQk9SVEVEOjEwMyxFTkVUVU5SRUFDSDoxMDEsRU5FVERPV046MTAwLEVUSU1FRE9VVDoxMTAsRUhPU1RET1dOOjExMixFSE9TVFVOUkVBQ0g6MTEzLEVJTlBST0dSRVNTOjExNSxFQUxSRUFEWToxMTQsRURFU1RBRERSUkVROjg5LEVNU0dTSVpFOjkwLEVQUk9UT05PU1VQUE9SVDo5MyxFU09DS1ROT1NVUFBPUlQ6OTQsRUFERFJOT1RBVkFJTDo5OSxFTkVUUkVTRVQ6MTAyLEVJU0NPTk46MTA2LEVOT1RDT05OOjEwNyxFVE9PTUFOWVJFRlM6MTA5LEVVU0VSUzo4NyxFRFFVT1Q6MTIyLEVTVEFMRToxMTYsRU5PVFNVUDo5NSxFTk9NRURJVU06MTIzLEVJTFNFUTo4NCxFT1ZFUkZMT1c6NzUsRUNBTkNFTEVEOjEyNSxFTk9UUkVDT1ZFUkFCTEU6MTMxLEVPV05FUkRFQUQ6MTMwLEVTVFJQSVBFOjg2fTtmdW5jdGlvbiBfc3lzY29uZihuYW1lKSB7XHJcbiAgICAgIC8vIGxvbmcgc3lzY29uZihpbnQgbmFtZSk7XHJcbiAgICAgIC8vIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy8wMDk2OTUzOTkvZnVuY3Rpb25zL3N5c2NvbmYuaHRtbFxyXG4gICAgICBzd2l0Y2gobmFtZSkge1xyXG4gICAgICAgIGNhc2UgMzA6IHJldHVybiBQQUdFX1NJWkU7XHJcbiAgICAgICAgY2FzZSA4NTpcclxuICAgICAgICAgIHZhciBtYXhIZWFwU2l6ZSA9IDIqMTAyNCoxMDI0KjEwMjQgLSA2NTUzNjtcclxuICAgICAgICAgIG1heEhlYXBTaXplID0gSEVBUFU4Lmxlbmd0aDtcclxuICAgICAgICAgIHJldHVybiBtYXhIZWFwU2l6ZSAvIFBBR0VfU0laRTtcclxuICAgICAgICBjYXNlIDEzMjpcclxuICAgICAgICBjYXNlIDEzMzpcclxuICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgIGNhc2UgMTM3OlxyXG4gICAgICAgIGNhc2UgMTM4OlxyXG4gICAgICAgIGNhc2UgMTU6XHJcbiAgICAgICAgY2FzZSAyMzU6XHJcbiAgICAgICAgY2FzZSAxNjpcclxuICAgICAgICBjYXNlIDE3OlxyXG4gICAgICAgIGNhc2UgMTg6XHJcbiAgICAgICAgY2FzZSAxOTpcclxuICAgICAgICBjYXNlIDIwOlxyXG4gICAgICAgIGNhc2UgMTQ5OlxyXG4gICAgICAgIGNhc2UgMTM6XHJcbiAgICAgICAgY2FzZSAxMDpcclxuICAgICAgICBjYXNlIDIzNjpcclxuICAgICAgICBjYXNlIDE1MzpcclxuICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgY2FzZSAyMTpcclxuICAgICAgICBjYXNlIDIyOlxyXG4gICAgICAgIGNhc2UgMTU5OlxyXG4gICAgICAgIGNhc2UgMTU0OlxyXG4gICAgICAgIGNhc2UgMTQ6XHJcbiAgICAgICAgY2FzZSA3NzpcclxuICAgICAgICBjYXNlIDc4OlxyXG4gICAgICAgIGNhc2UgMTM5OlxyXG4gICAgICAgIGNhc2UgODA6XHJcbiAgICAgICAgY2FzZSA4MTpcclxuICAgICAgICBjYXNlIDgyOlxyXG4gICAgICAgIGNhc2UgNjg6XHJcbiAgICAgICAgY2FzZSA2NzpcclxuICAgICAgICBjYXNlIDE2NDpcclxuICAgICAgICBjYXNlIDExOlxyXG4gICAgICAgIGNhc2UgMjk6XHJcbiAgICAgICAgY2FzZSA0NzpcclxuICAgICAgICBjYXNlIDQ4OlxyXG4gICAgICAgIGNhc2UgOTU6XHJcbiAgICAgICAgY2FzZSA1MjpcclxuICAgICAgICBjYXNlIDUxOlxyXG4gICAgICAgIGNhc2UgNDY6XHJcbiAgICAgICAgICByZXR1cm4gMjAwODA5O1xyXG4gICAgICAgIGNhc2UgNzk6XHJcbiAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICBjYXNlIDI3OlxyXG4gICAgICAgIGNhc2UgMjQ2OlxyXG4gICAgICAgIGNhc2UgMTI3OlxyXG4gICAgICAgIGNhc2UgMTI4OlxyXG4gICAgICAgIGNhc2UgMjM6XHJcbiAgICAgICAgY2FzZSAyNDpcclxuICAgICAgICBjYXNlIDE2MDpcclxuICAgICAgICBjYXNlIDE2MTpcclxuICAgICAgICBjYXNlIDE4MTpcclxuICAgICAgICBjYXNlIDE4MjpcclxuICAgICAgICBjYXNlIDI0MjpcclxuICAgICAgICBjYXNlIDE4MzpcclxuICAgICAgICBjYXNlIDE4NDpcclxuICAgICAgICBjYXNlIDI0MzpcclxuICAgICAgICBjYXNlIDI0NDpcclxuICAgICAgICBjYXNlIDI0NTpcclxuICAgICAgICBjYXNlIDE2NTpcclxuICAgICAgICBjYXNlIDE3ODpcclxuICAgICAgICBjYXNlIDE3OTpcclxuICAgICAgICBjYXNlIDQ5OlxyXG4gICAgICAgIGNhc2UgNTA6XHJcbiAgICAgICAgY2FzZSAxNjg6XHJcbiAgICAgICAgY2FzZSAxNjk6XHJcbiAgICAgICAgY2FzZSAxNzU6XHJcbiAgICAgICAgY2FzZSAxNzA6XHJcbiAgICAgICAgY2FzZSAxNzE6XHJcbiAgICAgICAgY2FzZSAxNzI6XHJcbiAgICAgICAgY2FzZSA5NzpcclxuICAgICAgICBjYXNlIDc2OlxyXG4gICAgICAgIGNhc2UgMzI6XHJcbiAgICAgICAgY2FzZSAxNzM6XHJcbiAgICAgICAgY2FzZSAzNTpcclxuICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBjYXNlIDE3NjpcclxuICAgICAgICBjYXNlIDE3NzpcclxuICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgY2FzZSAxNTU6XHJcbiAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgIGNhc2UgMTU3OlxyXG4gICAgICAgIGNhc2UgMTI1OlxyXG4gICAgICAgIGNhc2UgMTI2OlxyXG4gICAgICAgIGNhc2UgOTI6XHJcbiAgICAgICAgY2FzZSA5MzpcclxuICAgICAgICBjYXNlIDEyOTpcclxuICAgICAgICBjYXNlIDEzMDpcclxuICAgICAgICBjYXNlIDEzMTpcclxuICAgICAgICBjYXNlIDk0OlxyXG4gICAgICAgIGNhc2UgOTE6XHJcbiAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICBjYXNlIDc0OlxyXG4gICAgICAgIGNhc2UgNjA6XHJcbiAgICAgICAgY2FzZSA2OTpcclxuICAgICAgICBjYXNlIDcwOlxyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIHJldHVybiAxMDI0O1xyXG4gICAgICAgIGNhc2UgMzE6XHJcbiAgICAgICAgY2FzZSA0MjpcclxuICAgICAgICBjYXNlIDcyOlxyXG4gICAgICAgICAgcmV0dXJuIDMyO1xyXG4gICAgICAgIGNhc2UgODc6XHJcbiAgICAgICAgY2FzZSAyNjpcclxuICAgICAgICBjYXNlIDMzOlxyXG4gICAgICAgICAgcmV0dXJuIDIxNDc0ODM2NDc7XHJcbiAgICAgICAgY2FzZSAzNDpcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICByZXR1cm4gNDc4Mzk7XHJcbiAgICAgICAgY2FzZSAzODpcclxuICAgICAgICBjYXNlIDM2OlxyXG4gICAgICAgICAgcmV0dXJuIDk5O1xyXG4gICAgICAgIGNhc2UgNDM6XHJcbiAgICAgICAgY2FzZSAzNzpcclxuICAgICAgICAgIHJldHVybiAyMDQ4O1xyXG4gICAgICAgIGNhc2UgMDogcmV0dXJuIDIwOTcxNTI7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gNjU1MzY7XHJcbiAgICAgICAgY2FzZSAyODogcmV0dXJuIDMyNzY4O1xyXG4gICAgICAgIGNhc2UgNDQ6IHJldHVybiAzMjc2NztcclxuICAgICAgICBjYXNlIDc1OiByZXR1cm4gMTYzODQ7XHJcbiAgICAgICAgY2FzZSAzOTogcmV0dXJuIDEwMDA7XHJcbiAgICAgICAgY2FzZSA4OTogcmV0dXJuIDcwMDtcclxuICAgICAgICBjYXNlIDcxOiByZXR1cm4gMjU2O1xyXG4gICAgICAgIGNhc2UgNDA6IHJldHVybiAyNTU7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gMTAwO1xyXG4gICAgICAgIGNhc2UgMTgwOiByZXR1cm4gNjQ7XHJcbiAgICAgICAgY2FzZSAyNTogcmV0dXJuIDIwO1xyXG4gICAgICAgIGNhc2UgNTogcmV0dXJuIDE2O1xyXG4gICAgICAgIGNhc2UgNjogcmV0dXJuIDY7XHJcbiAgICAgICAgY2FzZSA3MzogcmV0dXJuIDQ7XHJcbiAgICAgICAgY2FzZSA4NDoge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnKSByZXR1cm4gbmF2aWdhdG9yWydoYXJkd2FyZUNvbmN1cnJlbmN5J10gfHwgMTtcclxuICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBfX19zZXRFcnJObyhFUlJOT19DT0RFUy5FSU5WQUwpO1xyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbkRZTkFNSUNUT1BfUFRSID0gc3RhdGljQWxsb2MoNCk7XHJcblxyXG5TVEFDS19CQVNFID0gU1RBQ0tUT1AgPSBhbGlnbk1lbW9yeShTVEFUSUNUT1ApO1xyXG5cclxuU1RBQ0tfTUFYID0gU1RBQ0tfQkFTRSArIFRPVEFMX1NUQUNLO1xyXG5cclxuRFlOQU1JQ19CQVNFID0gYWxpZ25NZW1vcnkoU1RBQ0tfTUFYKTtcclxuXHJcbkhFQVAzMltEWU5BTUlDVE9QX1BUUj4+Ml0gPSBEWU5BTUlDX0JBU0U7XHJcblxyXG5zdGF0aWNTZWFsZWQgPSB0cnVlOyAvLyBzZWFsIHRoZSBzdGF0aWMgcG9ydGlvbiBvZiBtZW1vcnlcclxuXHJcbmFzc2VydChEWU5BTUlDX0JBU0UgPCBUT1RBTF9NRU1PUlksIFwiVE9UQUxfTUVNT1JZIG5vdCBiaWcgZW5vdWdoIGZvciBzdGFja1wiKTtcclxuXHJcbnZhciBBU1NFUlRJT05TID0gdHJ1ZTtcclxuXHJcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oc3RyaW5nLCBib29sZWFuPSwgbnVtYmVyPSl9ICovXHJcbmZ1bmN0aW9uIGludEFycmF5RnJvbVN0cmluZyhzdHJpbmd5LCBkb250QWRkTnVsbCwgbGVuZ3RoKSB7XHJcbiAgdmFyIGxlbiA9IGxlbmd0aCA+IDAgPyBsZW5ndGggOiBsZW5ndGhCeXRlc1VURjgoc3RyaW5neSkrMTtcclxuICB2YXIgdThhcnJheSA9IG5ldyBBcnJheShsZW4pO1xyXG4gIHZhciBudW1CeXRlc1dyaXR0ZW4gPSBzdHJpbmdUb1VURjhBcnJheShzdHJpbmd5LCB1OGFycmF5LCAwLCB1OGFycmF5Lmxlbmd0aCk7XHJcbiAgaWYgKGRvbnRBZGROdWxsKSB1OGFycmF5Lmxlbmd0aCA9IG51bUJ5dGVzV3JpdHRlbjtcclxuICByZXR1cm4gdThhcnJheTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW50QXJyYXlUb1N0cmluZyhhcnJheSkge1xyXG4gIHZhciByZXQgPSBbXTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgY2hyID0gYXJyYXlbaV07XHJcbiAgICBpZiAoY2hyID4gMHhGRikge1xyXG4gICAgICBpZiAoQVNTRVJUSU9OUykge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgJ0NoYXJhY3RlciBjb2RlICcgKyBjaHIgKyAnICgnICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpICsgJykgIGF0IG9mZnNldCAnICsgaSArICcgbm90IGluIDB4MDAtMHhGRi4nKTtcclxuICAgICAgfVxyXG4gICAgICBjaHIgJj0gMHhGRjtcclxuICAgIH1cclxuICAgIHJldC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXQuam9pbignJyk7XHJcbn1cclxuXHJcblxyXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc3Ryb3BoZS9zdHJvcGhlanMvYmxvYi9lMDZkMDI3L3NyYy9wb2x5ZmlsbHMuanMjTDE0OVxyXG5cclxuLy8gVGhpcyBjb2RlIHdhcyB3cml0dGVuIGJ5IFR5bGVyIEFraW5zIGFuZCBoYXMgYmVlbiBwbGFjZWQgaW4gdGhlXHJcbi8vIHB1YmxpYyBkb21haW4uICBJdCB3b3VsZCBiZSBuaWNlIGlmIHlvdSBsZWZ0IHRoaXMgaGVhZGVyIGludGFjdC5cclxuLy8gQmFzZTY0IGNvZGUgZnJvbSBUeWxlciBBa2lucyAtLSBodHRwOi8vcnVta2luLmNvbVxyXG5cclxuLyoqXHJcbiAqIERlY29kZXMgYSBiYXNlNjQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyB0byBkZWNvZGUuXHJcbiAqL1xyXG52YXIgZGVjb2RlQmFzZTY0ID0gdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicgPyBhdG9iIDogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgdmFyIGtleVN0ciA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XHJcblxyXG4gIHZhciBvdXRwdXQgPSAnJztcclxuICB2YXIgY2hyMSwgY2hyMiwgY2hyMztcclxuICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcclxuICB2YXIgaSA9IDA7XHJcbiAgLy8gcmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBBLVosIGEteiwgMC05LCArLCAvLCBvciA9XHJcbiAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgJycpO1xyXG4gIGRvIHtcclxuICAgIGVuYzEgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XHJcbiAgICBlbmMyID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xyXG4gICAgZW5jMyA9IGtleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcclxuICAgIGVuYzQgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XHJcbiAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XHJcbiAgICBjaHIzID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xyXG5cclxuICAgIG91dHB1dCA9IG91dHB1dCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMSk7XHJcblxyXG4gICAgaWYgKGVuYzMgIT09IDY0KSB7XHJcbiAgICAgIG91dHB1dCA9IG91dHB1dCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XHJcbiAgICB9XHJcbiAgICBpZiAoZW5jNCAhPT0gNjQpIHtcclxuICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIzKTtcclxuICAgIH1cclxuICB9IHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKTtcclxuICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxuLy8gQ29udmVydHMgYSBzdHJpbmcgb2YgYmFzZTY0IGludG8gYSBieXRlIGFycmF5LlxyXG4vLyBUaHJvd3MgZXJyb3Igb24gaW52YWxpZCBpbnB1dC5cclxuZnVuY3Rpb24gaW50QXJyYXlGcm9tQmFzZTY0KHMpIHtcclxuICBpZiAodHlwZW9mIEVOVklST05NRU5UX0lTX05PREUgPT09ICdib29sZWFuJyAmJiBFTlZJUk9OTUVOVF9JU19OT0RFKSB7XHJcbiAgICB2YXIgYnVmO1xyXG4gICAgdHJ5IHtcclxuICAgICAgYnVmID0gQnVmZmVyLmZyb20ocywgJ2Jhc2U2NCcpO1xyXG4gICAgfSBjYXRjaCAoXykge1xyXG4gICAgICBidWYgPSBuZXcgQnVmZmVyKHMsICdiYXNlNjQnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIHZhciBkZWNvZGVkID0gZGVjb2RlQmFzZTY0KHMpO1xyXG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZC5sZW5ndGgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZGVjb2RlZC5sZW5ndGggOyArK2kpIHtcclxuICAgICAgYnl0ZXNbaV0gPSBkZWNvZGVkLmNoYXJDb2RlQXQoaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnl0ZXM7XHJcbiAgfSBjYXRjaCAoXykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252ZXJ0aW5nIGJhc2U2NCBzdHJpbmcgdG8gYnl0ZXMgZmFpbGVkLicpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gSWYgZmlsZW5hbWUgaXMgYSBiYXNlNjQgZGF0YSBVUkksIHBhcnNlcyBhbmQgcmV0dXJucyBkYXRhIChCdWZmZXIgb24gbm9kZSxcclxuLy8gVWludDhBcnJheSBvdGhlcndpc2UpLiBJZiBmaWxlbmFtZSBpcyBub3QgYSBiYXNlNjQgZGF0YSBVUkksIHJldHVybnMgdW5kZWZpbmVkLlxyXG5mdW5jdGlvbiB0cnlQYXJzZUFzRGF0YVVSSShmaWxlbmFtZSkge1xyXG4gIGlmICghaXNEYXRhVVJJKGZpbGVuYW1lKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGludEFycmF5RnJvbUJhc2U2NChmaWxlbmFtZS5zbGljZShkYXRhVVJJUHJlZml4Lmxlbmd0aCkpO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIG51bGxGdW5jX2lpKHgpIHsgTW9kdWxlW1wicHJpbnRFcnJcIl0oXCJJbnZhbGlkIGZ1bmN0aW9uIHBvaW50ZXIgY2FsbGVkIHdpdGggc2lnbmF0dXJlICdpaScuIFBlcmhhcHMgdGhpcyBpcyBhbiBpbnZhbGlkIHZhbHVlIChlLmcuIGNhdXNlZCBieSBjYWxsaW5nIGEgdmlydHVhbCBtZXRob2Qgb24gYSBOVUxMIHBvaW50ZXIpPyBPciBjYWxsaW5nIGEgZnVuY3Rpb24gd2l0aCBhbiBpbmNvcnJlY3QgdHlwZSwgd2hpY2ggd2lsbCBmYWlsPyAoaXQgaXMgd29ydGggYnVpbGRpbmcgeW91ciBzb3VyY2UgZmlsZXMgd2l0aCAtV2Vycm9yICh3YXJuaW5ncyBhcmUgZXJyb3JzKSwgYXMgd2FybmluZ3MgY2FuIGluZGljYXRlIHVuZGVmaW5lZCBiZWhhdmlvciB3aGljaCBjYW4gY2F1c2UgdGhpcylcIik7ICBNb2R1bGVbXCJwcmludEVyclwiXShcIkJ1aWxkIHdpdGggQVNTRVJUSU9OUz0yIGZvciBtb3JlIGluZm8uXCIpO2Fib3J0KHgpIH1cclxuXHJcbmZ1bmN0aW9uIG51bGxGdW5jX2lpaWkoeCkgeyBNb2R1bGVbXCJwcmludEVyclwiXShcIkludmFsaWQgZnVuY3Rpb24gcG9pbnRlciBjYWxsZWQgd2l0aCBzaWduYXR1cmUgJ2lpaWknLiBQZXJoYXBzIHRoaXMgaXMgYW4gaW52YWxpZCB2YWx1ZSAoZS5nLiBjYXVzZWQgYnkgY2FsbGluZyBhIHZpcnR1YWwgbWV0aG9kIG9uIGEgTlVMTCBwb2ludGVyKT8gT3IgY2FsbGluZyBhIGZ1bmN0aW9uIHdpdGggYW4gaW5jb3JyZWN0IHR5cGUsIHdoaWNoIHdpbGwgZmFpbD8gKGl0IGlzIHdvcnRoIGJ1aWxkaW5nIHlvdXIgc291cmNlIGZpbGVzIHdpdGggLVdlcnJvciAod2FybmluZ3MgYXJlIGVycm9ycyksIGFzIHdhcm5pbmdzIGNhbiBpbmRpY2F0ZSB1bmRlZmluZWQgYmVoYXZpb3Igd2hpY2ggY2FuIGNhdXNlIHRoaXMpXCIpOyAgTW9kdWxlW1wicHJpbnRFcnJcIl0oXCJCdWlsZCB3aXRoIEFTU0VSVElPTlM9MiBmb3IgbW9yZSBpbmZvLlwiKTthYm9ydCh4KSB9XHJcblxyXG5Nb2R1bGVbJ3dhc21UYWJsZVNpemUnXSA9IDE2O1xyXG5cclxuTW9kdWxlWyd3YXNtTWF4VGFibGVTaXplJ10gPSAxNjtcclxuXHJcbmZ1bmN0aW9uIGludm9rZV9paShpbmRleCxhMSkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gTW9kdWxlW1wiZHluQ2FsbF9paVwiXShpbmRleCxhMSk7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZTtcclxuICAgIE1vZHVsZVtcInNldFRocmV3XCJdKDEsIDApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW52b2tlX2lpaWkoaW5kZXgsYTEsYTIsYTMpIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIE1vZHVsZVtcImR5bkNhbGxfaWlpaVwiXShpbmRleCxhMSxhMixhMyk7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZTtcclxuICAgIE1vZHVsZVtcInNldFRocmV3XCJdKDEsIDApO1xyXG4gIH1cclxufVxyXG5cclxuTW9kdWxlLmFzbUdsb2JhbEFyZyA9IHt9O1xyXG5cclxuTW9kdWxlLmFzbUxpYnJhcnlBcmcgPSB7IFwiYWJvcnRcIjogYWJvcnQsIFwiYXNzZXJ0XCI6IGFzc2VydCwgXCJlbmxhcmdlTWVtb3J5XCI6IGVubGFyZ2VNZW1vcnksIFwiZ2V0VG90YWxNZW1vcnlcIjogZ2V0VG90YWxNZW1vcnksIFwiYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnlcIjogYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnksIFwiYWJvcnRTdGFja092ZXJmbG93XCI6IGFib3J0U3RhY2tPdmVyZmxvdywgXCJudWxsRnVuY19paVwiOiBudWxsRnVuY19paSwgXCJudWxsRnVuY19paWlpXCI6IG51bGxGdW5jX2lpaWksIFwiaW52b2tlX2lpXCI6IGludm9rZV9paSwgXCJpbnZva2VfaWlpaVwiOiBpbnZva2VfaWlpaSwgXCJfX19sb2NrXCI6IF9fX2xvY2ssIFwiX19fc2V0RXJyTm9cIjogX19fc2V0RXJyTm8sIFwiX19fc3lzY2FsbDE0MFwiOiBfX19zeXNjYWxsMTQwLCBcIl9fX3N5c2NhbGwxNDZcIjogX19fc3lzY2FsbDE0NiwgXCJfX19zeXNjYWxsNTRcIjogX19fc3lzY2FsbDU0LCBcIl9fX3N5c2NhbGw2XCI6IF9fX3N5c2NhbGw2LCBcIl9fX3VubG9ja1wiOiBfX191bmxvY2ssIFwiX2Vtc2NyaXB0ZW5faGFzX3RocmVhZGluZ19zdXBwb3J0XCI6IF9lbXNjcmlwdGVuX2hhc190aHJlYWRpbmdfc3VwcG9ydCwgXCJfZW1zY3JpcHRlbl9tZW1jcHlfYmlnXCI6IF9lbXNjcmlwdGVuX21lbWNweV9iaWcsIFwiX2xsdm1fY3R0el9pMzJcIjogX2xsdm1fY3R0el9pMzIsIFwiX2xsdm1fY3R0el9pNjRcIjogX2xsdm1fY3R0el9pNjQsIFwiX2xsdm1fc3RhY2tyZXN0b3JlXCI6IF9sbHZtX3N0YWNrcmVzdG9yZSwgXCJfbGx2bV9zdGFja3NhdmVcIjogX2xsdm1fc3RhY2tzYXZlLCBcIl9wdGhyZWFkX2NyZWF0ZVwiOiBfcHRocmVhZF9jcmVhdGUsIFwiX3B0aHJlYWRfam9pblwiOiBfcHRocmVhZF9qb2luLCBcIl9wdGhyZWFkX211dGV4X2luaXRcIjogX3B0aHJlYWRfbXV0ZXhfaW5pdCwgXCJfc3lzY29uZlwiOiBfc3lzY29uZiwgXCJmbHVzaF9OT19GSUxFU1lTVEVNXCI6IGZsdXNoX05PX0ZJTEVTWVNURU0sIFwiRFlOQU1JQ1RPUF9QVFJcIjogRFlOQU1JQ1RPUF9QVFIsIFwidGVtcERvdWJsZVB0clwiOiB0ZW1wRG91YmxlUHRyLCBcIkFCT1JUXCI6IEFCT1JULCBcIlNUQUNLVE9QXCI6IFNUQUNLVE9QLCBcIlNUQUNLX01BWFwiOiBTVEFDS19NQVgsIFwiY3R0el9pOFwiOiBjdHR6X2k4IH07XHJcbi8vIEVNU0NSSVBURU5fU1RBUlRfQVNNXHJcbnZhciBhc20gPU1vZHVsZVtcImFzbVwiXS8vIEVNU0NSSVBURU5fRU5EX0FTTVxyXG4oTW9kdWxlLmFzbUdsb2JhbEFyZywgTW9kdWxlLmFzbUxpYnJhcnlBcmcsIGJ1ZmZlcik7XHJcblxyXG52YXIgcmVhbF9fX19lcnJub19sb2NhdGlvbiA9IGFzbVtcIl9fX2Vycm5vX2xvY2F0aW9uXCJdOyBhc21bXCJfX19lcnJub19sb2NhdGlvblwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfX19fZXJybm9fbG9jYXRpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbnZhciByZWFsX19jY3VybF9wb3cgPSBhc21bXCJfY2N1cmxfcG93XCJdOyBhc21bXCJfY2N1cmxfcG93XCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gcmVhbF9fY2N1cmxfcG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgcmVhbF9fZmZsdXNoID0gYXNtW1wiX2ZmbHVzaFwiXTsgYXNtW1wiX2ZmbHVzaFwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfX2ZmbHVzaC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudmFyIHJlYWxfX2ZyZWUgPSBhc21bXCJfZnJlZVwiXTsgYXNtW1wiX2ZyZWVcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiByZWFsX19mcmVlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgcmVhbF9fbGx2bV9ic3dhcF9pMzIgPSBhc21bXCJfbGx2bV9ic3dhcF9pMzJcIl07IGFzbVtcIl9sbHZtX2Jzd2FwX2kzMlwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfX2xsdm1fYnN3YXBfaTMyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgcmVhbF9fbWFsbG9jID0gYXNtW1wiX21hbGxvY1wiXTsgYXNtW1wiX21hbGxvY1wiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfX21hbGxvYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudmFyIHJlYWxfX3B0aHJlYWRfbXV0ZXhfbG9jayA9IGFzbVtcIl9wdGhyZWFkX211dGV4X2xvY2tcIl07IGFzbVtcIl9wdGhyZWFkX211dGV4X2xvY2tcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiByZWFsX19wdGhyZWFkX211dGV4X2xvY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbnZhciByZWFsX19wdGhyZWFkX211dGV4X3VubG9jayA9IGFzbVtcIl9wdGhyZWFkX211dGV4X3VubG9ja1wiXTsgYXNtW1wiX3B0aHJlYWRfbXV0ZXhfdW5sb2NrXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gcmVhbF9fcHRocmVhZF9tdXRleF91bmxvY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbnZhciByZWFsX19zYnJrID0gYXNtW1wiX3NicmtcIl07IGFzbVtcIl9zYnJrXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gcmVhbF9fc2Jyay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudmFyIHJlYWxfZXN0YWJsaXNoU3RhY2tTcGFjZSA9IGFzbVtcImVzdGFibGlzaFN0YWNrU3BhY2VcIl07IGFzbVtcImVzdGFibGlzaFN0YWNrU3BhY2VcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiByZWFsX2VzdGFibGlzaFN0YWNrU3BhY2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbnZhciByZWFsX2dldFRlbXBSZXQwID0gYXNtW1wiZ2V0VGVtcFJldDBcIl07IGFzbVtcImdldFRlbXBSZXQwXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gcmVhbF9nZXRUZW1wUmV0MC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudmFyIHJlYWxfc2V0VGVtcFJldDAgPSBhc21bXCJzZXRUZW1wUmV0MFwiXTsgYXNtW1wic2V0VGVtcFJldDBcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiByZWFsX3NldFRlbXBSZXQwLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgcmVhbF9zZXRUaHJldyA9IGFzbVtcInNldFRocmV3XCJdOyBhc21bXCJzZXRUaHJld1wiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfc2V0VGhyZXcuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbnZhciByZWFsX3N0YWNrQWxsb2MgPSBhc21bXCJzdGFja0FsbG9jXCJdOyBhc21bXCJzdGFja0FsbG9jXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gcmVhbF9zdGFja0FsbG9jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgcmVhbF9zdGFja1Jlc3RvcmUgPSBhc21bXCJzdGFja1Jlc3RvcmVcIl07IGFzbVtcInN0YWNrUmVzdG9yZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfc3RhY2tSZXN0b3JlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgcmVhbF9zdGFja1NhdmUgPSBhc21bXCJzdGFja1NhdmVcIl07IGFzbVtcInN0YWNrU2F2ZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfc3RhY2tTYXZlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcbk1vZHVsZVtcImFzbVwiXSA9IGFzbTtcclxudmFyIF9fX2Vycm5vX2xvY2F0aW9uID0gTW9kdWxlW1wiX19fZXJybm9fbG9jYXRpb25cIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfX19lcnJub19sb2NhdGlvblwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBfY2N1cmxfcG93ID0gTW9kdWxlW1wiX2NjdXJsX3Bvd1wiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9jY3VybF9wb3dcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgX2ZmbHVzaCA9IE1vZHVsZVtcIl9mZmx1c2hcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfZmZsdXNoXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIF9mcmVlID0gTW9kdWxlW1wiX2ZyZWVcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfZnJlZVwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBfbGx2bV9ic3dhcF9pMzIgPSBNb2R1bGVbXCJfbGx2bV9ic3dhcF9pMzJcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfbGx2bV9ic3dhcF9pMzJcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgX21hbGxvYyA9IE1vZHVsZVtcIl9tYWxsb2NcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfbWFsbG9jXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIF9tZW1jcHkgPSBNb2R1bGVbXCJfbWVtY3B5XCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX21lbWNweVwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBfbWVtc2V0ID0gTW9kdWxlW1wiX21lbXNldFwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9tZW1zZXRcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgX3B0aHJlYWRfbXV0ZXhfbG9jayA9IE1vZHVsZVtcIl9wdGhyZWFkX211dGV4X2xvY2tcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfcHRocmVhZF9tdXRleF9sb2NrXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIF9wdGhyZWFkX211dGV4X3VubG9jayA9IE1vZHVsZVtcIl9wdGhyZWFkX211dGV4X3VubG9ja1wiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9wdGhyZWFkX211dGV4X3VubG9ja1wiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBfc2JyayA9IE1vZHVsZVtcIl9zYnJrXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX3NicmtcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgZXN0YWJsaXNoU3RhY2tTcGFjZSA9IE1vZHVsZVtcImVzdGFibGlzaFN0YWNrU3BhY2VcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJlc3RhYmxpc2hTdGFja1NwYWNlXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIGdldFRlbXBSZXQwID0gTW9kdWxlW1wiZ2V0VGVtcFJldDBcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJnZXRUZW1wUmV0MFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBydW5Qb3N0U2V0cyA9IE1vZHVsZVtcInJ1blBvc3RTZXRzXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wicnVuUG9zdFNldHNcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgc2V0VGVtcFJldDAgPSBNb2R1bGVbXCJzZXRUZW1wUmV0MFwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcInNldFRlbXBSZXQwXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIHNldFRocmV3ID0gTW9kdWxlW1wic2V0VGhyZXdcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJzZXRUaHJld1wiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBzdGFja0FsbG9jID0gTW9kdWxlW1wic3RhY2tBbGxvY1wiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcInN0YWNrQWxsb2NcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgc3RhY2tSZXN0b3JlID0gTW9kdWxlW1wic3RhY2tSZXN0b3JlXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wic3RhY2tSZXN0b3JlXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIHN0YWNrU2F2ZSA9IE1vZHVsZVtcInN0YWNrU2F2ZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcInN0YWNrU2F2ZVwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBkeW5DYWxsX2lpID0gTW9kdWxlW1wiZHluQ2FsbF9paVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfaWlcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgZHluQ2FsbF9paWlpID0gTW9kdWxlW1wiZHluQ2FsbF9paWlpXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiZHluQ2FsbF9paWlpXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxuO1xyXG5cclxuXHJcblxyXG4vLyA9PT0gQXV0by1nZW5lcmF0ZWQgcG9zdGFtYmxlIHNldHVwIGVudHJ5IHN0dWZmID09PVxyXG5cclxuTW9kdWxlWydhc20nXSA9IGFzbTtcclxuXHJcbmlmICghTW9kdWxlW1wiaW50QXJyYXlGcm9tU3RyaW5nXCJdKSBNb2R1bGVbXCJpbnRBcnJheUZyb21TdHJpbmdcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInaW50QXJyYXlGcm9tU3RyaW5nJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJpbnRBcnJheVRvU3RyaW5nXCJdKSBNb2R1bGVbXCJpbnRBcnJheVRvU3RyaW5nXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2ludEFycmF5VG9TdHJpbmcnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5Nb2R1bGVbXCJjY2FsbFwiXSA9IGNjYWxsO1xyXG5Nb2R1bGVbXCJjd3JhcFwiXSA9IGN3cmFwO1xyXG5pZiAoIU1vZHVsZVtcInNldFZhbHVlXCJdKSBNb2R1bGVbXCJzZXRWYWx1ZVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidzZXRWYWx1ZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiZ2V0VmFsdWVcIl0pIE1vZHVsZVtcImdldFZhbHVlXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2dldFZhbHVlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJhbGxvY2F0ZVwiXSkgTW9kdWxlW1wiYWxsb2NhdGVcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInYWxsb2NhdGUnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImdldE1lbW9yeVwiXSkgTW9kdWxlW1wiZ2V0TWVtb3J5XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2dldE1lbW9yeScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIlBvaW50ZXJfc3RyaW5naWZ5XCJdKSBNb2R1bGVbXCJQb2ludGVyX3N0cmluZ2lmeVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidQb2ludGVyX3N0cmluZ2lmeScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiQXNjaWlUb1N0cmluZ1wiXSkgTW9kdWxlW1wiQXNjaWlUb1N0cmluZ1wiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidBc2NpaVRvU3RyaW5nJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJzdHJpbmdUb0FzY2lpXCJdKSBNb2R1bGVbXCJzdHJpbmdUb0FzY2lpXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3N0cmluZ1RvQXNjaWknIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIlVURjhBcnJheVRvU3RyaW5nXCJdKSBNb2R1bGVbXCJVVEY4QXJyYXlUb1N0cmluZ1wiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidVVEY4QXJyYXlUb1N0cmluZycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiVVRGOFRvU3RyaW5nXCJdKSBNb2R1bGVbXCJVVEY4VG9TdHJpbmdcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInVVRGOFRvU3RyaW5nJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJzdHJpbmdUb1VURjhBcnJheVwiXSkgTW9kdWxlW1wic3RyaW5nVG9VVEY4QXJyYXlcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInc3RyaW5nVG9VVEY4QXJyYXknIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcInN0cmluZ1RvVVRGOFwiXSkgTW9kdWxlW1wic3RyaW5nVG9VVEY4XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3N0cmluZ1RvVVRGOCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wibGVuZ3RoQnl0ZXNVVEY4XCJdKSBNb2R1bGVbXCJsZW5ndGhCeXRlc1VURjhcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInbGVuZ3RoQnl0ZXNVVEY4JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJVVEYxNlRvU3RyaW5nXCJdKSBNb2R1bGVbXCJVVEYxNlRvU3RyaW5nXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ1VURjE2VG9TdHJpbmcnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcInN0cmluZ1RvVVRGMTZcIl0pIE1vZHVsZVtcInN0cmluZ1RvVVRGMTZcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInc3RyaW5nVG9VVEYxNicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wibGVuZ3RoQnl0ZXNVVEYxNlwiXSkgTW9kdWxlW1wibGVuZ3RoQnl0ZXNVVEYxNlwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidsZW5ndGhCeXRlc1VURjE2JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJVVEYzMlRvU3RyaW5nXCJdKSBNb2R1bGVbXCJVVEYzMlRvU3RyaW5nXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ1VURjMyVG9TdHJpbmcnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcInN0cmluZ1RvVVRGMzJcIl0pIE1vZHVsZVtcInN0cmluZ1RvVVRGMzJcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInc3RyaW5nVG9VVEYzMicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wibGVuZ3RoQnl0ZXNVVEYzMlwiXSkgTW9kdWxlW1wibGVuZ3RoQnl0ZXNVVEYzMlwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidsZW5ndGhCeXRlc1VURjMyJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJhbGxvY2F0ZVVURjhcIl0pIE1vZHVsZVtcImFsbG9jYXRlVVRGOFwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidhbGxvY2F0ZVVURjgnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcInN0YWNrVHJhY2VcIl0pIE1vZHVsZVtcInN0YWNrVHJhY2VcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInc3RhY2tUcmFjZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiYWRkT25QcmVSdW5cIl0pIE1vZHVsZVtcImFkZE9uUHJlUnVuXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2FkZE9uUHJlUnVuJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJhZGRPbkluaXRcIl0pIE1vZHVsZVtcImFkZE9uSW5pdFwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidhZGRPbkluaXQnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImFkZE9uUHJlTWFpblwiXSkgTW9kdWxlW1wiYWRkT25QcmVNYWluXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2FkZE9uUHJlTWFpbicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiYWRkT25FeGl0XCJdKSBNb2R1bGVbXCJhZGRPbkV4aXRcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInYWRkT25FeGl0JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJhZGRPblBvc3RSdW5cIl0pIE1vZHVsZVtcImFkZE9uUG9zdFJ1blwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidhZGRPblBvc3RSdW4nIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIndyaXRlU3RyaW5nVG9NZW1vcnlcIl0pIE1vZHVsZVtcIndyaXRlU3RyaW5nVG9NZW1vcnlcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInd3JpdGVTdHJpbmdUb01lbW9yeScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wid3JpdGVBcnJheVRvTWVtb3J5XCJdKSBNb2R1bGVbXCJ3cml0ZUFycmF5VG9NZW1vcnlcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInd3JpdGVBcnJheVRvTWVtb3J5JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJ3cml0ZUFzY2lpVG9NZW1vcnlcIl0pIE1vZHVsZVtcIndyaXRlQXNjaWlUb01lbW9yeVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIid3cml0ZUFzY2lpVG9NZW1vcnknIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImFkZFJ1bkRlcGVuZGVuY3lcIl0pIE1vZHVsZVtcImFkZFJ1bkRlcGVuZGVuY3lcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInYWRkUnVuRGVwZW5kZW5jeScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcInJlbW92ZVJ1bkRlcGVuZGVuY3lcIl0pIE1vZHVsZVtcInJlbW92ZVJ1bkRlcGVuZGVuY3lcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCIncmVtb3ZlUnVuRGVwZW5kZW5jeScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIkZTXCJdKSBNb2R1bGVbXCJGU1wiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidGUycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiRlNfY3JlYXRlRm9sZGVyXCJdKSBNb2R1bGVbXCJGU19jcmVhdGVGb2xkZXJcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInRlNfY3JlYXRlRm9sZGVyJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCIpIH07XHJcbmlmICghTW9kdWxlW1wiRlNfY3JlYXRlUGF0aFwiXSkgTW9kdWxlW1wiRlNfY3JlYXRlUGF0aFwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidGU19jcmVhdGVQYXRoJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCIpIH07XHJcbmlmICghTW9kdWxlW1wiRlNfY3JlYXRlRGF0YUZpbGVcIl0pIE1vZHVsZVtcIkZTX2NyZWF0ZURhdGFGaWxlXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ0ZTX2NyZWF0ZURhdGFGaWxlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCIpIH07XHJcbmlmICghTW9kdWxlW1wiRlNfY3JlYXRlUHJlbG9hZGVkRmlsZVwiXSkgTW9kdWxlW1wiRlNfY3JlYXRlUHJlbG9hZGVkRmlsZVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidGU19jcmVhdGVQcmVsb2FkZWRGaWxlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCIpIH07XHJcbmlmICghTW9kdWxlW1wiRlNfY3JlYXRlTGF6eUZpbGVcIl0pIE1vZHVsZVtcIkZTX2NyZWF0ZUxhenlGaWxlXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ0ZTX2NyZWF0ZUxhenlGaWxlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCIpIH07XHJcbmlmICghTW9kdWxlW1wiRlNfY3JlYXRlTGlua1wiXSkgTW9kdWxlW1wiRlNfY3JlYXRlTGlua1wiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidGU19jcmVhdGVMaW5rJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCIpIH07XHJcbmlmICghTW9kdWxlW1wiRlNfY3JlYXRlRGV2aWNlXCJdKSBNb2R1bGVbXCJGU19jcmVhdGVEZXZpY2VcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInRlNfY3JlYXRlRGV2aWNlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCIpIH07XHJcbmlmICghTW9kdWxlW1wiRlNfdW5saW5rXCJdKSBNb2R1bGVbXCJGU191bmxpbmtcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInRlNfdW5saW5rJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCIpIH07XHJcbmlmICghTW9kdWxlW1wiR0xcIl0pIE1vZHVsZVtcIkdMXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ0dMJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJzdGF0aWNBbGxvY1wiXSkgTW9kdWxlW1wic3RhdGljQWxsb2NcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInc3RhdGljQWxsb2MnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImR5bmFtaWNBbGxvY1wiXSkgTW9kdWxlW1wiZHluYW1pY0FsbG9jXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2R5bmFtaWNBbGxvYycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wid2Fybk9uY2VcIl0pIE1vZHVsZVtcIndhcm5PbmNlXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3dhcm5PbmNlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJsb2FkRHluYW1pY0xpYnJhcnlcIl0pIE1vZHVsZVtcImxvYWREeW5hbWljTGlicmFyeVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidsb2FkRHluYW1pY0xpYnJhcnknIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImxvYWRXZWJBc3NlbWJseU1vZHVsZVwiXSkgTW9kdWxlW1wibG9hZFdlYkFzc2VtYmx5TW9kdWxlXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2xvYWRXZWJBc3NlbWJseU1vZHVsZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiZ2V0TEVCXCJdKSBNb2R1bGVbXCJnZXRMRUJcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInZ2V0TEVCJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJnZXRGdW5jdGlvblRhYmxlc1wiXSkgTW9kdWxlW1wiZ2V0RnVuY3Rpb25UYWJsZXNcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInZ2V0RnVuY3Rpb25UYWJsZXMnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImFsaWduRnVuY3Rpb25UYWJsZXNcIl0pIE1vZHVsZVtcImFsaWduRnVuY3Rpb25UYWJsZXNcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInYWxpZ25GdW5jdGlvblRhYmxlcycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wicmVnaXN0ZXJGdW5jdGlvbnNcIl0pIE1vZHVsZVtcInJlZ2lzdGVyRnVuY3Rpb25zXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3JlZ2lzdGVyRnVuY3Rpb25zJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJhZGRGdW5jdGlvblwiXSkgTW9kdWxlW1wiYWRkRnVuY3Rpb25cIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInYWRkRnVuY3Rpb24nIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcInJlbW92ZUZ1bmN0aW9uXCJdKSBNb2R1bGVbXCJyZW1vdmVGdW5jdGlvblwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidyZW1vdmVGdW5jdGlvbicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiZ2V0RnVuY1dyYXBwZXJcIl0pIE1vZHVsZVtcImdldEZ1bmNXcmFwcGVyXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2dldEZ1bmNXcmFwcGVyJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJwcmV0dHlQcmludFwiXSkgTW9kdWxlW1wicHJldHR5UHJpbnRcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCIncHJldHR5UHJpbnQnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIm1ha2VCaWdJbnRcIl0pIE1vZHVsZVtcIm1ha2VCaWdJbnRcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInbWFrZUJpZ0ludCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiZHluQ2FsbFwiXSkgTW9kdWxlW1wiZHluQ2FsbFwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidkeW5DYWxsJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJnZXRDb21waWxlclNldHRpbmdcIl0pIE1vZHVsZVtcImdldENvbXBpbGVyU2V0dGluZ1wiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidnZXRDb21waWxlclNldHRpbmcnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImludEFycmF5RnJvbUJhc2U2NFwiXSkgTW9kdWxlW1wiaW50QXJyYXlGcm9tQmFzZTY0XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2ludEFycmF5RnJvbUJhc2U2NCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1widHJ5UGFyc2VBc0RhdGFVUklcIl0pIE1vZHVsZVtcInRyeVBhcnNlQXNEYXRhVVJJXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3RyeVBhcnNlQXNEYXRhVVJJJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtpZiAoIU1vZHVsZVtcIkFMTE9DX05PUk1BTFwiXSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgXCJBTExPQ19OT1JNQUxcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidBTExPQ19OT1JNQUwnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9IH0pO1xyXG5pZiAoIU1vZHVsZVtcIkFMTE9DX1NUQUNLXCJdKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlLCBcIkFMTE9DX1NUQUNLXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoXCInQUxMT0NfU1RBQ0snIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9IH0pO1xyXG5pZiAoIU1vZHVsZVtcIkFMTE9DX1NUQVRJQ1wiXSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgXCJBTExPQ19TVEFUSUNcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidBTExPQ19TVEFUSUMnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9IH0pO1xyXG5pZiAoIU1vZHVsZVtcIkFMTE9DX0RZTkFNSUNcIl0pIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGUsIFwiQUxMT0NfRFlOQU1JQ1wiLCB7IGdldDogZnVuY3Rpb24oKSB7IGFib3J0KFwiJ0FMTE9DX0RZTkFNSUMnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9IH0pO1xyXG5pZiAoIU1vZHVsZVtcIkFMTE9DX05PTkVcIl0pIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGUsIFwiQUxMT0NfTk9ORVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IGFib3J0KFwiJ0FMTE9DX05PTkUnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9IH0pO1xyXG5cclxuXHJcblxyXG4vLyBNb2R1bGFyaXplIG1vZGUgcmV0dXJucyBhIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgY2FsbGVkIHRvXHJcbi8vIGNyZWF0ZSBpbnN0YW5jZXMuIFRoZSBpbnN0YW5jZXMgcHJvdmlkZSBhIHRoZW4oKSBtZXRob2QsXHJcbi8vIG11c3QgbGlrZSBhIFByb21pc2UsIHRoYXQgcmVjZWl2ZXMgYSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrXHJcbi8vIGlzIGNhbGxlZCB3aGVuIHRoZSBtb2R1bGUgaXMgcmVhZHkgdG8gcnVuLCB3aXRoIHRoZSBtb2R1bGVcclxuLy8gYXMgYSBwYXJhbWV0ZXIuIChMaWtlIGEgUHJvbWlzZSwgaXQgYWxzbyByZXR1cm5zIHRoZSBtb2R1bGVcclxuLy8gc28geW91IGNhbiB1c2UgdGhlIG91dHB1dCBvZiAudGhlbiguLikpLlxyXG5Nb2R1bGVbJ3RoZW4nXSA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICAvLyBXZSBtYXkgYWxyZWFkeSBiZSByZWFkeSB0byBydW4gY29kZSBhdCB0aGlzIHRpbWUuIGlmXHJcbiAgLy8gc28sIGp1c3QgcXVldWUgYSBjYWxsIHRvIHRoZSBjYWxsYmFjay5cclxuICBpZiAoTW9kdWxlWydjYWxsZWRSdW4nXSkge1xyXG4gICAgZnVuYyhNb2R1bGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyB3ZSBhcmUgbm90IHJlYWR5IHRvIGNhbGwgdGhlbigpIHlldC4gd2UgbXVzdCBjYWxsIGl0XHJcbiAgICAvLyBhdCB0aGUgc2FtZSB0aW1lIHdlIHdvdWxkIGNhbGwgb25SdW50aW1lSW5pdGlhbGl6ZWQuXHJcbiAgICB2YXIgb2xkID0gTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddO1xyXG4gICAgTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChvbGQpIG9sZCgpO1xyXG4gICAgICBmdW5jKE1vZHVsZSk7XHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gTW9kdWxlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XHJcbiAqIEB0aGlzIHtFeGl0U3RhdHVzfVxyXG4gKi9cclxuZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpIHtcclxuICB0aGlzLm5hbWUgPSBcIkV4aXRTdGF0dXNcIjtcclxuICB0aGlzLm1lc3NhZ2UgPSBcIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIgKyBzdGF0dXMgKyBcIilcIjtcclxuICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcclxufTtcclxuRXhpdFN0YXR1cy5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuRXhpdFN0YXR1cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeGl0U3RhdHVzO1xyXG5cclxudmFyIGluaXRpYWxTdGFja1RvcDtcclxudmFyIGNhbGxlZE1haW4gPSBmYWxzZTtcclxuXHJcbmRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uIHJ1bkNhbGxlcigpIHtcclxuICAvLyBJZiBydW4gaGFzIG5ldmVyIGJlZW4gY2FsbGVkLCBhbmQgd2Ugc2hvdWxkIGNhbGwgcnVuIChJTlZPS0VfUlVOIGlzIHRydWUsIGFuZCBNb2R1bGUubm9Jbml0aWFsUnVuIGlzIG5vdCBmYWxzZSlcclxuICBpZiAoIU1vZHVsZVsnY2FsbGVkUnVuJ10pIHJ1bigpO1xyXG4gIGlmICghTW9kdWxlWydjYWxsZWRSdW4nXSkgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gcnVuQ2FsbGVyOyAvLyB0cnkgdGhpcyBhZ2FpbiBsYXRlciwgYWZ0ZXIgbmV3IGRlcHMgYXJlIGZ1bGZpbGxlZFxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqIEB0eXBlIHtmdW5jdGlvbihBcnJheT0pfSAqL1xyXG5mdW5jdGlvbiBydW4oYXJncykge1xyXG4gIGFyZ3MgPSBhcmdzIHx8IE1vZHVsZVsnYXJndW1lbnRzJ107XHJcblxyXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB3cml0ZVN0YWNrQ29va2llKCk7XHJcblxyXG4gIHByZVJ1bigpO1xyXG5cclxuICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkgcmV0dXJuOyAvLyBhIHByZVJ1biBhZGRlZCBhIGRlcGVuZGVuY3ksIHJ1biB3aWxsIGJlIGNhbGxlZCBsYXRlclxyXG4gIGlmIChNb2R1bGVbJ2NhbGxlZFJ1biddKSByZXR1cm47IC8vIHJ1biBtYXkgaGF2ZSBqdXN0IGJlZW4gY2FsbGVkIHRocm91Z2ggZGVwZW5kZW5jaWVzIGJlaW5nIGZ1bGZpbGxlZCBqdXN0IGluIHRoaXMgdmVyeSBmcmFtZVxyXG5cclxuICBmdW5jdGlvbiBkb1J1bigpIHtcclxuICAgIGlmIChNb2R1bGVbJ2NhbGxlZFJ1biddKSByZXR1cm47IC8vIHJ1biBtYXkgaGF2ZSBqdXN0IGJlZW4gY2FsbGVkIHdoaWxlIHRoZSBhc3luYyBzZXRTdGF0dXMgdGltZSBiZWxvdyB3YXMgaGFwcGVuaW5nXHJcbiAgICBNb2R1bGVbJ2NhbGxlZFJ1biddID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoQUJPUlQpIHJldHVybjtcclxuXHJcbiAgICBlbnN1cmVJbml0UnVudGltZSgpO1xyXG5cclxuICAgIHByZU1haW4oKTtcclxuXHJcbiAgICBpZiAoTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddKSBNb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10oKTtcclxuXHJcbiAgICBhc3NlcnQoIU1vZHVsZVsnX21haW4nXSwgJ2NvbXBpbGVkIHdpdGhvdXQgYSBtYWluLCBidXQgb25lIGlzIHByZXNlbnQuIGlmIHlvdSBhZGRlZCBpdCBmcm9tIEpTLCB1c2UgTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0nKTtcclxuXHJcbiAgICBwb3N0UnVuKCk7XHJcbiAgfVxyXG5cclxuICBpZiAoTW9kdWxlWydzZXRTdGF0dXMnXSkge1xyXG4gICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnUnVubmluZy4uLicpO1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCcnKTtcclxuICAgICAgfSwgMSk7XHJcbiAgICAgIGRvUnVuKCk7XHJcbiAgICB9LCAxKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZG9SdW4oKTtcclxuICB9XHJcbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xyXG59XHJcbk1vZHVsZVsncnVuJ10gPSBydW47XHJcblxyXG5mdW5jdGlvbiBjaGVja1VuZmx1c2hlZENvbnRlbnQoKSB7XHJcbiAgLy8gQ29tcGlsZXIgc2V0dGluZ3MgZG8gbm90IGFsbG93IGV4aXRpbmcgdGhlIHJ1bnRpbWUsIHNvIGZsdXNoaW5nXHJcbiAgLy8gdGhlIHN0cmVhbXMgaXMgbm90IHBvc3NpYmxlLiBidXQgaW4gQVNTRVJUSU9OUyBtb2RlIHdlIGNoZWNrXHJcbiAgLy8gaWYgdGhlcmUgd2FzIHNvbWV0aGluZyB0byBmbHVzaCwgYW5kIGlmIHNvIHRlbGwgdGhlIHVzZXIgdGhleVxyXG4gIC8vIHNob3VsZCByZXF1ZXN0IHRoYXQgdGhlIHJ1bnRpbWUgYmUgZXhpdGFibGUuXHJcbiAgLy8gTm9ybWFsbHkgd2Ugd291bGQgbm90IGV2ZW4gaW5jbHVkZSBmbHVzaCgpIGF0IGFsbCwgYnV0IGluIEFTU0VSVElPTlNcclxuICAvLyBidWlsZHMgd2UgZG8gc28ganVzdCBmb3IgdGhpcyBjaGVjaywgYW5kIGhlcmUgd2Ugc2VlIGlmIHRoZXJlIGlzIGFueVxyXG4gIC8vIGNvbnRlbnQgdG8gZmx1c2gsIHRoYXQgaXMsIHdlIGNoZWNrIGlmIHRoZXJlIHdvdWxkIGhhdmUgYmVlblxyXG4gIC8vIHNvbWV0aGluZyBhIG5vbi1BU1NFUlRJT05TIGJ1aWxkIHdvdWxkIGhhdmUgbm90IHNlZW4uXHJcbiAgLy8gSG93IHdlIGZsdXNoIHRoZSBzdHJlYW1zIGRlcGVuZHMgb24gd2hldGhlciB3ZSBhcmUgaW4gTk9fRklMRVNZU1RFTVxyXG4gIC8vIG1vZGUgKHdoaWNoIGhhcyBpdHMgb3duIHNwZWNpYWwgZnVuY3Rpb24gZm9yIHRoaXM7IG90aGVyd2lzZSwgYWxsXHJcbiAgLy8gdGhlIGNvZGUgaXMgaW5zaWRlIGxpYmMpXHJcbiAgdmFyIHByaW50ID0gTW9kdWxlWydwcmludCddO1xyXG4gIHZhciBwcmludEVyciA9IE1vZHVsZVsncHJpbnRFcnInXTtcclxuICB2YXIgaGFzID0gZmFsc2U7XHJcbiAgTW9kdWxlWydwcmludCddID0gTW9kdWxlWydwcmludEVyciddID0gZnVuY3Rpb24oeCkge1xyXG4gICAgaGFzID0gdHJ1ZTtcclxuICB9XHJcbiAgdHJ5IHsgLy8gaXQgZG9lc24ndCBtYXR0ZXIgaWYgaXQgZmFpbHNcclxuICAgIHZhciBmbHVzaCA9IGZsdXNoX05PX0ZJTEVTWVNURU07XHJcbiAgICBpZiAoZmx1c2gpIGZsdXNoKDApO1xyXG4gIH0gY2F0Y2goZSkge31cclxuICBNb2R1bGVbJ3ByaW50J10gPSBwcmludDtcclxuICBNb2R1bGVbJ3ByaW50RXJyJ10gPSBwcmludEVycjtcclxuICBpZiAoaGFzKSB7XHJcbiAgICB3YXJuT25jZSgnc3RkaW8gc3RyZWFtcyBoYWQgY29udGVudCBpbiB0aGVtIHRoYXQgd2FzIG5vdCBmbHVzaGVkLiB5b3Ugc2hvdWxkIHNldCBOT19FWElUX1JVTlRJTUUgdG8gMCAoc2VlIHRoZSBGQVEpLCBvciBtYWtlIHN1cmUgdG8gZW1pdCBhIG5ld2xpbmUgd2hlbiB5b3UgcHJpbnRmIGV0Yy4nKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4aXQoc3RhdHVzLCBpbXBsaWNpdCkge1xyXG4gIGNoZWNrVW5mbHVzaGVkQ29udGVudCgpO1xyXG5cclxuICAvLyBpZiB0aGlzIGlzIGp1c3QgbWFpbiBleGl0LWluZyBpbXBsaWNpdGx5LCBhbmQgdGhlIHN0YXR1cyBpcyAwLCB0aGVuIHdlXHJcbiAgLy8gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBoZXJlIGFuZCBjYW4ganVzdCBsZWF2ZS4gaWYgdGhlIHN0YXR1cyBpc1xyXG4gIC8vIG5vbi16ZXJvLCB0aG91Z2gsIHRoZW4gd2UgbmVlZCB0byByZXBvcnQgaXQuXHJcbiAgLy8gKHdlIG1heSBoYXZlIHdhcm5lZCBhYm91dCB0aGlzIGVhcmxpZXIsIGlmIGEgc2l0dWF0aW9uIGp1c3RpZmllcyBkb2luZyBzbylcclxuICBpZiAoaW1wbGljaXQgJiYgTW9kdWxlWydub0V4aXRSdW50aW1lJ10gJiYgc3RhdHVzID09PSAwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoTW9kdWxlWydub0V4aXRSdW50aW1lJ10pIHtcclxuICAgIC8vIGlmIGV4aXQoKSB3YXMgY2FsbGVkLCB3ZSBtYXkgd2FybiB0aGUgdXNlciBpZiB0aGUgcnVudGltZSBpc24ndCBhY3R1YWxseSBiZWluZyBzaHV0IGRvd25cclxuICAgIGlmICghaW1wbGljaXQpIHtcclxuICAgICAgTW9kdWxlLnByaW50RXJyKCdleGl0KCcgKyBzdGF0dXMgKyAnKSBjYWxsZWQsIGJ1dCBOT19FWElUX1JVTlRJTUUgaXMgc2V0LCBzbyBoYWx0aW5nIGV4ZWN1dGlvbiBidXQgbm90IGV4aXRpbmcgdGhlIHJ1bnRpbWUgb3IgcHJldmVudGluZyBmdXJ0aGVyIGFzeW5jIGV4ZWN1dGlvbiAoYnVpbGQgd2l0aCBOT19FWElUX1JVTlRJTUU9MCwgaWYgeW91IHdhbnQgYSB0cnVlIHNodXRkb3duKScpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgQUJPUlQgPSB0cnVlO1xyXG4gICAgRVhJVFNUQVRVUyA9IHN0YXR1cztcclxuICAgIFNUQUNLVE9QID0gaW5pdGlhbFN0YWNrVG9wO1xyXG5cclxuICAgIGV4aXRSdW50aW1lKCk7XHJcblxyXG4gICAgaWYgKE1vZHVsZVsnb25FeGl0J10pIE1vZHVsZVsnb25FeGl0J10oc3RhdHVzKTtcclxuICB9XHJcblxyXG4gIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7XHJcbiAgICBwcm9jZXNzWydleGl0J10oc3RhdHVzKTtcclxuICB9XHJcbiAgTW9kdWxlWydxdWl0J10oc3RhdHVzLCBuZXcgRXhpdFN0YXR1cyhzdGF0dXMpKTtcclxufVxyXG5Nb2R1bGVbJ2V4aXQnXSA9IGV4aXQ7XHJcblxyXG52YXIgYWJvcnREZWNvcmF0b3JzID0gW107XHJcblxyXG5mdW5jdGlvbiBhYm9ydCh3aGF0KSB7XHJcbiAgaWYgKE1vZHVsZVsnb25BYm9ydCddKSB7XHJcbiAgICBNb2R1bGVbJ29uQWJvcnQnXSh3aGF0KTtcclxuICB9XHJcblxyXG4gIGlmICh3aGF0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgIE1vZHVsZS5wcmludCh3aGF0KTtcclxuICAgIE1vZHVsZS5wcmludEVycih3aGF0KTtcclxuICAgIHdoYXQgPSBKU09OLnN0cmluZ2lmeSh3aGF0KVxyXG4gIH0gZWxzZSB7XHJcbiAgICB3aGF0ID0gJyc7XHJcbiAgfVxyXG5cclxuICBBQk9SVCA9IHRydWU7XHJcbiAgRVhJVFNUQVRVUyA9IDE7XHJcblxyXG4gIHZhciBleHRyYSA9ICcnO1xyXG4gIHZhciBvdXRwdXQgPSAnYWJvcnQoJyArIHdoYXQgKyAnKSBhdCAnICsgc3RhY2tUcmFjZSgpICsgZXh0cmE7XHJcbiAgaWYgKGFib3J0RGVjb3JhdG9ycykge1xyXG4gICAgYWJvcnREZWNvcmF0b3JzLmZvckVhY2goZnVuY3Rpb24oZGVjb3JhdG9yKSB7XHJcbiAgICAgIG91dHB1dCA9IGRlY29yYXRvcihvdXRwdXQsIHdoYXQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHRocm93IG91dHB1dDtcclxufVxyXG5Nb2R1bGVbJ2Fib3J0J10gPSBhYm9ydDtcclxuXHJcbi8vIHt7UFJFX1JVTl9BRERJVElPTlN9fVxyXG5cclxuaWYgKE1vZHVsZVsncHJlSW5pdCddKSB7XHJcbiAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZUluaXQnXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZUluaXQnXSA9IFtNb2R1bGVbJ3ByZUluaXQnXV07XHJcbiAgd2hpbGUgKE1vZHVsZVsncHJlSW5pdCddLmxlbmd0aCA+IDApIHtcclxuICAgIE1vZHVsZVsncHJlSW5pdCddLnBvcCgpKCk7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuTW9kdWxlW1wibm9FeGl0UnVudGltZVwiXSA9IHRydWU7XHJcblxyXG5ydW4oKTtcclxuXHJcbi8vIHt7UE9TVF9SVU5fQURESVRJT05TfX1cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyB7e01PRFVMRV9BRERJVElPTlN9fVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgcmV0dXJuIE1vZHVsZTtcclxufTtcclxuaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcclxuICBtb2R1bGUuZXhwb3J0cyA9IE1vZHVsZTtcclxuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKVxyXG4gIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBNb2R1bGU7IH0pO1xyXG5lbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcbiAgZXhwb3J0c1tcIk1vZHVsZVwiXSA9IE1vZHVsZTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vLi4vaW90YS1waWNvLXBvdy13YXNtL3dhc20vaW90YS1waWNvLXBvdy13YXNtLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGFycmF5SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlclwiKTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBjcnlwdG9FcnJvcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvZXJyb3IvY3J5cHRvRXJyb3JcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJ5dGVzXCIpO1xyXG5jb25zdCBwZWFybERpdmVyXzEgPSByZXF1aXJlKFwiLi9wZWFybERpdmVyL3BlYXJsRGl2ZXJcIik7XHJcbi8qKlxyXG4gKiBQcm9vZk9mV29yayBpbXBsZW1lbnRhdGlvbiB1c2luZyBXZWJHTC5cclxuICovXHJcbmNsYXNzIFByb29mT2ZXb3JrV2ViR2wge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgUHJvb2ZPZldvcmsuXHJcbiAgICAgKiBAcGFyYW0gd2ViR0xQbGF0Zm9ybSBQcm92aWRlcyBwbGF0Zm9ybSBzcGVjaWZpYyBmdW5jdGlvbnMsIG9wdGlvbmFsIG1vc3RseSB1c2VkIGZvciB0ZXN0aW5nLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih3ZWJHTFBsYXRmb3JtKSB7XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHdlYkdMUGxhdGZvcm0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlYkdMUGxhdGZvcm0gPSB7XHJcbiAgICAgICAgICAgICAgICBnZXRXaW5kb3c6ICgpID0+IHdpbmRvdyxcclxuICAgICAgICAgICAgICAgIGdldERvY3VtZW50OiAod2luZG93KSA9PiB3aW5kb3cuZG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICBnZXRDYW52YXM6IChkb2N1bWVudCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcclxuICAgICAgICAgICAgICAgIGdldFdlYkdMOiAoY2FudmFzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IHsgYWxwaGE6IGZhbHNlLCBhbnRpYWxpYXM6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBhdHRyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl93ZWJHTFBsYXRmb3JtID0gd2ViR0xQbGF0Zm9ybTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsbG93IHRoZSBwcm9vZiBvZiB3b3JrIHRvIHBlcmZvcm0gYW55IGluaXRpYWxpemF0aW9uLlxyXG4gICAgICogV2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIGltcGxlbWVudGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHBlYXJsRGl2ZXJfMS5QZWFybERpdmVyLmluaXRpYWxpemUodGhpcy5fd2ViR0xQbGF0Zm9ybSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBzaW5nbGUgY29udmVyc2lvbiBwZXIgcG93IGNhbGwuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHBvdyBvbmx5IGRvZXMgb25lIGNvbnZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIHBlcmZvcm1zU2luZ2xlKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtIGEgcHJvb2Ygb2Ygd29yayBvbiB0aGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSB0cnVua1RyYW5zYWN0aW9uIFRoZSB0cnVua1RyYW5zYWN0aW9uIHRvIHVzZSBmb3IgdGhlIHBvdy5cclxuICAgICAqIEBwYXJhbSBicmFuY2hUcmFuc2FjdGlvbiBUaGUgYnJhbmNoVHJhbnNhY3Rpb24gdG8gdXNlIGZvciB0aGUgcG93LlxyXG4gICAgICogQHBhcmFtIHRyeXRlcyBUaGUgdHJ5dGVzIHRvIHBlcmZvcm0gdGhlIHBvdyBvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgcHJvZHVjZWQgYnkgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHBvdyh0cnVua1RyYW5zYWN0aW9uLCBicmFuY2hUcmFuc2FjdGlvbiwgdHJ5dGVzLCBtaW5XZWlnaHRNYWduaXR1ZGUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJXZWJHTCBpcyBub3QgaW5pdGlhbGl6ZWQsIGhhdmUgeW91IGNhbGxlZCBpbml0aWFsaXplXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZCh0cnl0ZXMsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgdHJ5dGVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHlwZSBUcnl0ZXNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihtaW5XZWlnaHRNYWduaXR1ZGUpIHx8IG1pbldlaWdodE1hZ25pdHVkZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG1pbldlaWdodE1hZ25pdHVkZSBtdXN0IGJlID4gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2luZ2xlVHJ5dGVzID0gdHJ5dGVzWzBdO1xyXG4gICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgcGVhcmxEaXZlcl8xLlBlYXJsRGl2ZXIuaW5zdGFuY2Uuc2VhcmNoV2l0aFRyeXRlcyhzaW5nbGVUcnl0ZXMsIG1pbldlaWdodE1hZ25pdHVkZSk7XHJcbiAgICAgICAgY29uc3QgdHJ5dGVzU3RyaW5nID0gc2luZ2xlVHJ5dGVzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3Qgbm9uY2VTdHJpbmcgPSBub25jZS50b1N0cmluZygpO1xyXG4gICAgICAgIHJldHVybiBbdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodHJ5dGVzU3RyaW5nLnN1YnN0cigwLCB0cnl0ZXNTdHJpbmcubGVuZ3RoIC0gbm9uY2VTdHJpbmcubGVuZ3RoKS5jb25jYXQobm9uY2VTdHJpbmcpKV07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Qcm9vZk9mV29ya1dlYkdsID0gUHJvb2ZPZldvcmtXZWJHbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0hKdmIyWlBabGR2Y210WFpXSkhiQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMM055WXk5d2NtOXZaazltVjI5eWExZGxZa2RzTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3d3UlVGQmRVVTdRVUZEZGtVc05FVkJRWGxGTzBGQlEzcEZMRFJGUVVGNVJUdEJRVU42UlN3d1JVRkJkVVU3UVVGSGRrVXNOa1JCUVRCRU8wRkJSVEZFTEhkRVFVRnhSRHRCUVVkeVJEczdSMEZGUnp0QlFVTklPMGxCVDBrN096dFBRVWRITzBsQlEwZ3NXVUZCV1N4aFFVRTRRanRSUVVOMFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl3eVFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRkRU1zU1VGQlNTeERRVUZETEdOQlFXTXNSMEZCUnp0blFrRkRiRUlzVTBGQlV5eEZRVUZGTEVkQlFVY3NSVUZCUlN4RFFVRkRMRTFCUVUwN1owSkJRM1pDTEZkQlFWY3NSVUZCUlN4RFFVRkRMRTFCUVUwc1JVRkJSU3hGUVVGRkxFTkJRVU1zVFVGQlRTeERRVUZETEZGQlFWRTdaMEpCUTNoRExGTkJRVk1zUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlN4RlFVRkZMRU5CUVVNc1VVRkJVU3hEUVVGRExHRkJRV0VzUTBGQlF5eFJRVUZSTEVOQlFVTTdaMEpCUTNwRUxGRkJRVkVzUlVGQlJTeERRVUZETEUxQlFVMHNSVUZCUlN4RlFVRkZPMjlDUVVOcVFpeE5RVUZOTEVsQlFVa3NSMEZCUnl4RlFVRkZMRXRCUVVzc1JVRkJSU3hMUVVGTExFVkJRVVVzVTBGQlV5eEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRPMjlDUVVOb1JDeE5RVUZOTEVWQlFVVXNSMEZCUnl4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExGRkJRVkVzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0dlFrRkROME1zVFVGQlRTeERRVUV5UWl4RlFVRkZMRU5CUVVNN1owSkJRM2hETEVOQlFVTTdZVUZEU2l4RFFVRkRPMUZCUTA0c1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEwb3NTVUZCU1N4RFFVRkRMR05CUVdNc1IwRkJSeXhoUVVGaExFTkJRVU03VVVGRGVFTXNRMEZCUXp0SlFVTk1MRU5CUVVNN1NVRkZSRHM3TzA5QlIwYzdTVUZEU1N4TFFVRkxMRU5CUVVNc1ZVRkJWVHRSUVVOdVFpeE5RVUZOTEVOQlFVTXNTVUZCU1N4UFFVRlBMRU5CUVU4c1EwRkJReXhQUVVGUExFVkJRVVVzVFVGQlRTeEZRVUZGTEVWQlFVVTdXVUZEZWtNc1NVRkJTU3hEUVVGRE8yZENRVU5FTEhWQ1FVRlZMRU5CUVVNc1ZVRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTXNRMEZCUXp0blFrRkRNME1zU1VGQlNTeERRVUZETEdOQlFXTXNSMEZCUnl4SlFVRkpMRU5CUVVNN1owSkJRek5DTEU5QlFVOHNSVUZCUlN4RFFVRkRPMWxCUTJRc1EwRkJRenRaUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMWdzVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUTJoQ0xFTkJRVU03VVVGRFRDeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTlFMRU5CUVVNN1NVRkZSRHM3TzA5QlIwYzdTVUZEU1N4alFVRmpPMUZCUTJwQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZEYUVJc1EwRkJRenRKUVVWRU96czdPenM3TzA5QlQwYzdTVUZEU1N4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExHZENRVUZ6UWl4RlFVRkZMR2xDUVVGMVFpeEZRVUZGTEUxQlFXZENMRVZCUVVVc2EwSkJRVEJDTzFGQlF6RkhMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRka0lzVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2MwUkJRWE5FTEVOQlFVTXNRMEZCUXp0UlFVTnNSaXhEUVVGRE8xRkJRMFFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVWQlFVVXNaVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM1pETEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExEUkRRVUUwUXl4RFFVRkRMRU5CUVVNN1VVRkRlRVVzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zU1VGQlNTeHJRa0ZCYTBJc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzcEZMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEc5RFFVRnZReXhEUVVGRExFTkJRVU03VVVGRGFFVXNRMEZCUXp0UlFVVkVMRTFCUVUwc1dVRkJXU3hIUVVGSExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVXZRaXhOUVVGTkxFdEJRVXNzUjBGQlJ5eE5RVUZOTEhWQ1FVRlZMRU5CUVVNc1VVRkJVU3hEUVVGRExHZENRVUZuUWl4RFFVRkRMRmxCUVZrc1JVRkJSU3hyUWtGQmEwSXNRMEZCUXl4RFFVRkRPMUZCUlROR0xFMUJRVTBzV1VGQldTeEhRVUZITEZsQlFWa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRSUVVNM1F5eE5RVUZOTEZkQlFWY3NSMEZCUnl4TFFVRkxMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU03VVVGRGNrTXNUVUZCVFN4RFFVRkRMRU5CUVVVc1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eFpRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1JVRkJSU3haUVVGWkxFTkJRVU1zVFVGQlRTeEhRVUZITEZkQlFWY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUlN4RFFVRkRPMGxCUTNaSUxFTkJRVU03UTBGRFNqdEJRUzlGUkN3MFEwRXJSVU1pZlE9PVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zcmMvcHJvb2ZPZldvcmtXZWJHbC50cyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcblxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXCJyZWdlbmVyYXRvclJ1bnRpbWVcIikgPj0gMDtcblxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuXG5pZiAoaGFkUnVudGltZSkge1xuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XG59IGVsc2Uge1xuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxuICB0cnkge1xuICAgIGRlbGV0ZSBnLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lvdGEtcGljby1wb3ctd2ViZ2wvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pb3RhLXBpY28tcG93LXdlYmdsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFNoYWRlcnMgYWRkLlxyXG4gKi9cclxuZXhwb3J0cy5kZWZhdWx0ID0gYFxuaW50IHN1bSAoaW50IGEsIGludCBiKSB7XG4gIGludCBteV9zdW0gPSBhICsgYjtcbiAgcmV0dXJuIG15X3N1bSA9PSAyID8gLTEgOiAobXlfc3VtID09IC0yKSA/IDEgOiBteV9zdW07XG59XG5pbnQgY29ucyAoaW50IGEsIGludCBiKSB7XG4gIHJldHVybiAoYSA9PSAxICYmIGIgPT0gMSk/IDEgOiAoYSA9PSAtMSAmJiBiID09IC0xKSA/IC0xIDogMDtcbn1cbmludCBhbnlfdCAoaW50IGEsIGludCBiKSB7XG4gIGludCBteV9hbnkgPSBhICsgYjtcbiAgcmV0dXJuIG15X2FueSA9PSAwID8gMCA6IChteV9hbnkgPiAwKSA/IDEgOiAtMTtcbn1cbml2ZWMyIGZ1bGxfYWRkZXIoaW50IGEsIGludCBiLCBpbnQgYykge1xuICBpbnQgY19hLCBjX2IsIHN1bV9hYiwgY19zO1xuXG4gIGNfYSAgICA9IGNvbnMoYSxiKTtcbiAgc3VtX2FiID0gc3VtKGEsYik7XG4gIGNfYiAgICA9IGNvbnMoc3VtX2FiLGMpO1xuICBjX3MgICAgPSBhbnlfdChjX2EsIGNfYik7XG5cbiAgcmV0dXJuIGl2ZWMyKHN1bShzdW1fYWIsIGMpLCBjX3MpO1xufVxuaXZlYzIgZ2V0X3N1bV90b19pbmRleChpbnQgZnJvbSwgaW50IHRvLCBpbnQgbnVtYmVyX3RvX2FkZCwgaW50IHJvdykge1xuICBpbnQgdHJpdF90b19hZGQsIHRyaXRfYXRfaW5kZXgsIHBvdywgY2FycnksIG51bV9jYXJyeTtcbiAgaXZlYzIgcmVhZF9pbiwgc3VtX291dCwgb3V0X3RyaXQ7XG4gIHBvdyA9IDE7XG4gIGNhcnJ5ID0gMDtcbiAgbnVtX2NhcnJ5ID0gMDtcblxuICBmb3IoaW50IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgIC8vaWYodHJpdF90b19hZGQgPT0gMCAmJiBzdW1fb3V0LnQgPT0gMCkgY29udGludWU7XG5cbiAgICByZWFkX2luID0gcmVhZF9hdCAoIGl2ZWMyIChpLCByb3cpKS5yZztcblxuICAgIHRyaXRfdG9fYWRkID0gKChudW1iZXJfdG9fYWRkIC8gcG93KSAlIDMpICsgbnVtX2NhcnJ5O1xuICAgIG51bV9jYXJyeSA9IHRyaXRfdG9fYWRkID4gMSA/IDEgOiAwO1xuICAgIHRyaXRfdG9fYWRkID0gKHRyaXRfdG9fYWRkID09IDIgPyAtMSA6ICh0cml0X3RvX2FkZCA9PSAzID8gMCA6IHRyaXRfdG9fYWRkKSk7XG5cbiAgICBzdW1fb3V0ID0gZnVsbF9hZGRlcihcbiAgICAgIChyZWFkX2luLnMgPT0gTE9XX0JJVFMgPyAxIDogcmVhZF9pbi50ID09IExPV19CSVRTPyAtMSA6IDApLFxuICAgICAgdHJpdF90b19hZGQsXG4gICAgICBjYXJyeVxuICAgICk7XG5cbiAgICBpZihteV9jb29yZC54ID09IGkpIGJyZWFrO1xuICAgIGNhcnJ5ID0gc3VtX291dC50O1xuICAgIHBvdyAqPTM7XG4gIH1cbiAgaWYoc3VtX291dC5zID09IDApIHtcbiAgICByZXR1cm4gaXZlYzIoSElHSF9CSVRTKTtcbiAgfSBlbHNlIGlmIChzdW1fb3V0LnMgPT0gMSkge1xuICAgIHJldHVybiBpdmVjMihMT1dfQklUUywgSElHSF9CSVRTKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXZlYzIoSElHSF9CSVRTLCBMT1dfQklUUyk7XG4gIH1cbn1cbmA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVlXUmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwzTm9ZV1JsY25NdllXUmtMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUczdSMEZGUnp0QlFVTklMR3RDUVVGbE96czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096dERRWGRFWkN4RFFVRkRJbjA9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9zaGFkZXJzL2FkZC50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFNoYWRlcnMgY2hlY2tfY29sLlxyXG4gKi9cclxuZXhwb3J0cy5kZWZhdWx0ID0gYFxudm9pZCBtYWluKCkge1xuICBpbml0KCk7XG4gIGl2ZWM0IG15X3ZlYyA9IHJlYWQoKTtcbiAgaW50IGk7XG4gIGlmKG15X2Nvb3JkLnggPT0gU1RBVEVfTEVOR1RIICYmIG15X2Nvb3JkLnkgPT0gMCkge1xuICAgIG15X3ZlYy5iID0gMDtcbiAgICBpZihteV92ZWMuYSA9PSAwKSB7XG4gICAgICBpdmVjNCByZWFkX3ZlYztcbiAgICAgIG15X3ZlYy5iID0gLTE7XG4gICAgICBmb3IoaSA9IDE7IGkgPCBpbnQoc2l6ZS55KTsgaSsrKSB7XG4gICAgICAgIHJlYWRfdmVjID0gcmVhZF9hdCggaXZlYzIoIFNUQVRFX0xFTkdUSCwgaSkpO1xuICAgICAgICBpZihyZWFkX3ZlYy5hICE9IDApIHtcbiAgICAgICAgICBteV92ZWMuYSA9IHJlYWRfdmVjLmE7XG4gICAgICAgICAgbXlfdmVjLmIgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbW1pdChteV92ZWMpO1xufVxuYDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWTJobFkydERiMnd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZjMmhoWkdWeWN5OWphR1ZqYTBOdmJDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN08wZEJSVWM3UVVGRFNDeHJRa0ZCWlRzN096czdPenM3T3pzN096czdPenM3T3pzN096dERRWE5DWkN4RFFVRkRJbjA9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9zaGFkZXJzL2NoZWNrQ29sLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogU2hhZGVycyBjaGVja19kby5cclxuICovXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGBcbmludCBjaGVjayhpbnQgcm93LCBpbnQgbWluX3dlaWdodF9tYWduaXR1ZGUpIHtcbiAgaW50IG5vbmNlX3Byb2JlLCBpO1xuICBpdmVjMiByX3RleGVsO1xuICBub25jZV9wcm9iZSA9IEhJR0hfQklUUztcbiAgZm9yKGkgPSBtaW5fd2VpZ2h0X21hZ25pdHVkZTsgaS0tID4gMDsgKSB7XG4gICAgcl90ZXhlbCA9IHJlYWRfYXQoaXZlYzIoSEFTSF9MRU5HVEggLSAxIC0gaSwgcm93KSkuYmE7XG4gICAgbm9uY2VfcHJvYmUgJj0gfihyX3RleGVsLnMgXiByX3RleGVsLnQpO1xuICAgIGlmKG5vbmNlX3Byb2JlID09IDApIGJyZWFrO1xuICB9XG4gIHJldHVybiBub25jZV9wcm9iZTtcbn1cbmA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkyaGxZMnRFYnk1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl6YUdGa1pYSnpMMk5vWldOclJHOHVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk96dEhRVVZITzBGQlEwZ3NhMEpCUVdVN096czdPenM3T3pzN096dERRVmxrTEVOQlFVTWlmUT09XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9zaGFkZXJzL2NoZWNrRG8udHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBTaGFkZXJzIGNoZWNrX2suXHJcbiAqL1xyXG5leHBvcnRzLmRlZmF1bHQgPSBgXG51bmlmb3JtIGludCBtaW5XZWlnaHRNYWduaXR1ZGU7XG52b2lkIG1haW4oKSB7XG4gIGluaXQoKTtcbiAgaXZlYzQgbXlfdmVjID0gcmVhZCgpO1xuICBpZihteV9jb29yZC54ID09IFNUQVRFX0xFTkdUSCkge1xuICAgIG15X3ZlYy5yID0gbWluV2VpZ2h0TWFnbml0dWRlO1xuICAgIG15X3ZlYy5hID0gY2hlY2sobXlfY29vcmQueSwgbWluV2VpZ2h0TWFnbml0dWRlKTtcbiAgfVxuICBjb21taXQobXlfdmVjKTtcbn1cbmA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkyaGxZMnRMTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMM05vWVdSbGNuTXZZMmhsWTJ0TExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVRzN1IwRkZSenRCUVVOSUxHdENRVUZsT3pzN096czdPenM3T3p0RFFWZGtMRU5CUVVNaWZRPT1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL3NoYWRlcnMvY2hlY2tLLnRzIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogU2hhZGVycyBmaW5hbGl6ZS5cclxuICovXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGBcbnZvaWQgbWFpbigpIHtcbiAgaW5pdCgpO1xuICBpdmVjNCBteV92ZWMgPSByZWFkKCk7XG4gIGlmKG15X2Nvb3JkLnkgPT0gMCAmJiBteV9jb29yZC54ID09IFNUQVRFX0xFTkdUSCkge1xuICAgIG15X3ZlYy5nID0gY2hlY2sobXlfdmVjLmIsIG15X3ZlYy5yKTtcbiAgfVxuICBpZihteV9jb29yZC55ID09IDAgJiYgbXlfY29vcmQueCA8IEhBU0hfTEVOR1RIKSB7XG4gICAgaXZlYzQgaW5mb192ZWMgPSByZWFkX2F0KGl2ZWMyKFNUQVRFX0xFTkdUSCwgMCkpO1xuICAgIGludCBub25jZV9wcm9iZSA9IGluZm9fdmVjLmE7XG4gICAgaW50IHJvdyA9IGluZm9fdmVjLmI7XG4gICAgaXZlYzQgaGFzaF92ZWMgPSByZWFkX2F0KGl2ZWMyKG15X2Nvb3JkLngsIHJvdykpO1xuICAgIG15X3ZlYy5hID0gKGhhc2hfdmVjLnIgJiBub25jZV9wcm9iZSkgPT0gMD8gMSA6ICgoaGFzaF92ZWMuZyAmIG5vbmNlX3Byb2JlKSA9PSAwPyAtMSA6IDApO1xuICB9XG4gIGNvbW1pdChteV92ZWMpO1xufVxuYDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWm1sdVlXeHBlbVV1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZjMmhoWkdWeWN5OW1hVzVoYkdsNlpTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN08wZEJSVWM3UVVGRFNDeHJRa0ZCWlRzN096czdPenM3T3pzN096czdPenREUVdkQ1pDeERRVUZESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvc2hhZGVycy9maW5hbGl6ZS50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFNoYWRlcnMgYWRkLlxyXG4gKi9cclxuZXhwb3J0cy5kZWZhdWx0ID0gYFxuI2RlZmluZSBIQVNIX0xFTkdUSCAyNDNcbiNkZWZpbmUgTlVNQkVSX09GX1JPVU5EUyA4MVxuI2RlZmluZSBJTkNSRU1FTlRfU1RBUlQgSEFTSF9MRU5HVEggLSA2NFxuI2RlZmluZSBTVEFURV9MRU5HVEggMyAqIEhBU0hfTEVOR1RIXG4jZGVmaW5lIEhBTEZfTEVOR1RIIDM2NFxuI2RlZmluZSBISUdIX0JJVFMgMHhGRkZGRkZGRlxuI2RlZmluZSBMT1dfQklUUyAweDAwMDAwMDAwXG5gO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhR1ZoWkdWeWN5NXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5emFHRmtaWEp6TDJobFlXUmxjbk11ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPenRIUVVWSE8wRkJRMGdzYTBKQlFXVTdPenM3T3pzN08wTkJVV1FzUTBGQlF5SjlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL3NoYWRlcnMvaGVhZGVycy50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFNoYWRlcnMgaW5jcmVtZW50LlxyXG4gKi9cclxuZXhwb3J0cy5kZWZhdWx0ID0gYFxudm9pZCBtYWluKCkge1xuICBpbml0KCk7XG4gIGl2ZWM0IG15X3ZlYyA9IHJlYWQoKTtcbiAgaWYobXlfY29vcmQueCA+PSBJTkNSRU1FTlRfU1RBUlQgJiYgbXlfY29vcmQueCA8IEhBU0hfTEVOR1RIICkge1xuICAgIG15X3ZlYy5yZyA9IGdldF9zdW1fdG9faW5kZXgoSU5DUkVNRU5UX1NUQVJULCBIQVNIX0xFTkdUSCwgMSwgbXlfY29vcmQueSk7XG4gIH1cbiAgaWYobXlfY29vcmQueCA9PSBTVEFURV9MRU5HVEggKSB7XG4gICAgbXlfdmVjLnJnID0gaXZlYzIoMCk7XG4gIH1cbiAgbXlfdmVjLmJhID0gbXlfdmVjLnJnO1xuICBjb21taXQobXlfdmVjKTtcbn1cbmA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWpjbVZ0Wlc1MExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDNOb1lXUmxjbk12YVc1amNtVnRaVzUwTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHM3UjBGRlJ6dEJRVU5JTEd0Q1FVRmxPenM3T3pzN096czdPenM3TzBOQllXUXNRMEZCUXlKOVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvc2hhZGVycy9pbmNyZW1lbnQudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBTaGFkZXJzIGluaXQuXHJcbiAqL1xyXG5leHBvcnRzLmRlZmF1bHQgPSBgXG51bmlmb3JtIGludCBncl9vZmZzZXQ7XG5pdmVjNCBvZmZzZXQoKSB7XG4gIGlmKG15X2Nvb3JkLnggPj0gSEFTSF9MRU5HVEggLyAzICYmIG15X2Nvb3JkLnggPCBIQVNIX0xFTkdUSCAvIDMgKiAyICkge1xuICAgIGl2ZWM0IG15X3ZlYztcbiAgICBteV92ZWMucmcgPSBnZXRfc3VtX3RvX2luZGV4KEhBU0hfTEVOR1RIIC8gMywgSEFTSF9MRU5HVEggLyAzICogMiwgbXlfY29vcmQueSArIGdyX29mZnNldCwgMCk7XG4gICAgcmV0dXJuIG15X3ZlYztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVhZF9hdChpdmVjMihteV9jb29yZC54LDApKTtcbiAgfVxufVxudm9pZCBtYWluKCkge1xuICBpbml0KCk7XG4gIGNvbW1pdChvZmZzZXQoKSk7XG59XG5gO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVwZEM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl6YUdGa1pYSnpMMmx1YVhRdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCT3p0SFFVVkhPMEZCUTBnc2EwSkJRV1U3T3pzN096czdPenM3T3pzN096dERRV1ZrTEVOQlFVTWlmUT09XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy9zaGFkZXJzL2luaXQudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBTaGFkZXJzIHRyYW5zZm9ybS5cclxuICovXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGBcbml2ZWMyIHR3aXN0KCkge1xuICBpbnQgYWxwaGEsIGJldGEsIGdhbW1hLCBkZWx0YTtcbiAgaXZlYzQgdjEsIHYyO1xuICBpbnQgaiA9IG15X2Nvb3JkLng7XG5cbiAgdjEgPSByZWFkX2F0KGl2ZWMyKGogPT0gMD8gMDooKChqIC0gMSklMikrMSkqSEFMRl9MRU5HVEggLSAoKGotMSk+PjEpLCBteV9jb29yZC55KSk7XG4gIHYyID0gcmVhZF9hdChpdmVjMigoKGolMikrMSkqSEFMRl9MRU5HVEggLSAoKGopPj4xKSwgbXlfY29vcmQueSkpO1xuICBhbHBoYSA9IHYxLmI7XG4gIGJldGEgPSB2MS5hO1xuICBnYW1tYSA9IHYyLmE7XG4gIGRlbHRhID0gKGFscGhhIHwgKH5nYW1tYSkpICYgKHYyLmIgXiBiZXRhKTsvL3YyLmIgPT09IHN0YXRlX2xvd1t0Ml1cblxuICByZXR1cm4gaXZlYzIofmRlbHRhLCAoYWxwaGEgXiBnYW1tYSkgfCBkZWx0YSk7XG59XG52b2lkIG1haW4oKSB7XG4gIGluaXQoKTtcbiAgaXZlYzQgbXlfdmVjID0gcmVhZCgpO1xuICBpZihteV9jb29yZC54IDwgU1RBVEVfTEVOR1RIKVxuICAgIG15X3ZlYy5iYSA9IHR3aXN0KCk7XG4gIGNvbW1pdChteV92ZWMpO1xufVxuYDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEhKaGJuTm1iM0p0TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMM05vWVdSbGNuTXZkSEpoYm5ObWIzSnRMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUczdSMEZGUnp0QlFVTklMR3RDUVVGbE96czdPenM3T3pzN096czdPenM3T3pzN096czdPME5CYzBKa0xFTkJRVU1pZlE9PVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvc2hhZGVycy90cmFuc2Zvcm0udHMiLCJ2YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY3J5cHRvRXJyb3JfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NyeXB0by9kaXN0L2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG5jb25zdCBzdGRsaWJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zdGRsaWJcIikpO1xyXG5jb25zdCB2ZXJ0ZXhTaGFkZXJDb2RlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdmVydGV4U2hhZGVyQ29kZVwiKSk7XHJcbmNvbnN0IHdlYkdMSGVscGVyXzEgPSByZXF1aXJlKFwiLi93ZWJHTEhlbHBlclwiKTtcclxuLyoqXHJcbiAqIFdlYkdMV29ya2VyLlxyXG4gKi9cclxuY2xhc3MgV2ViR0xXb3JrZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSB3ZWIgR0wgV29ya2VyLlxyXG4gICAgICogQHBhcmFtIHdlYkdMUGxhdGZvcm0gVGhlIHdlYkdMIHBsYXRmb3JtLlxyXG4gICAgICogQHBhcmFtIHN0YXRlTGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHN0YXRlLlxyXG4gICAgICogQHBhcmFtIHRleGVsU2l6ZSBUaGUgdGV4ZWwgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgaW5pdGlhbGl6ZSh3ZWJHTFBsYXRmb3JtLCBzdGF0ZUxlbmd0aCwgdGV4ZWxTaXplKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IHdlYkdMSGVscGVyXzEuV2ViR0xIZWxwZXIuY3JlYXRlQ29udGV4dCh3ZWJHTFBsYXRmb3JtKTtcclxuICAgICAgICB0aGlzLl9kaW1lbnNpb25zID0geyB4OiBzdGF0ZUxlbmd0aCwgeTogMCB9O1xyXG4gICAgICAgIGNvbnN0IG1heEltYWdlU2l6ZSA9IE1hdGgucG93KHRoaXMuX2NvbnRleHQuTUFYX1RFWFRVUkVfU0laRSwgMikgKiAwLjU7XHJcbiAgICAgICAgY29uc3QgaW1hZ2VTaXplID0gTWF0aC5mbG9vcihtYXhJbWFnZVNpemUgLyB0aGlzLl9kaW1lbnNpb25zLnggLyB0ZXhlbFNpemUpICogdGhpcy5fZGltZW5zaW9ucy54ICogdGV4ZWxTaXplO1xyXG4gICAgICAgIHRoaXMuX2RpbWVuc2lvbnMueSA9IGltYWdlU2l6ZSAvIHRoaXMuX2RpbWVuc2lvbnMueCAvIHRleGVsU2l6ZTtcclxuICAgICAgICB0aGlzLl9wcm9ncmFtcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9pcHQgPSB7XHJcbiAgICAgICAgICAgIGRhdGE6IG5ldyBJbnQzMkFycmF5KGltYWdlU2l6ZSksXHJcbiAgICAgICAgICAgIGxlbmd0aDogaW1hZ2VTaXplXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHUFUgdGV4dHVyZSBidWZmZXIgPSBmcm9tIEpTIHR5cGVkIGFycmF5XHJcbiAgICAgICAgdGhpcy5fYnVmZmVycyA9IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IHdlYkdMSGVscGVyXzEuV2ViR0xIZWxwZXIuY3JlYXRlQnVmZmVyKHRoaXMuX2NvbnRleHQsIFstMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgMV0pLFxyXG4gICAgICAgICAgICB0ZXh0dXJlOiB3ZWJHTEhlbHBlcl8xLldlYkdMSGVscGVyLmNyZWF0ZUJ1ZmZlcih0aGlzLl9jb250ZXh0LCBbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pLFxyXG4gICAgICAgICAgICBpbmRleDogd2ViR0xIZWxwZXJfMS5XZWJHTEhlbHBlci5jcmVhdGVCdWZmZXIodGhpcy5fY29udGV4dCwgWzEsIDIsIDAsIDMsIDAsIDJdLCBVaW50MTZBcnJheSwgdGhpcy5fY29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUilcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2F0dHJpYiA9IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IDAsXHJcbiAgICAgICAgICAgIHRleHR1cmU6IDFcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEFycmF5ID0gdGhpcy5fY29udGV4dC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFZlcnRleEFycmF5KHRoaXMuX3ZlcnRleEFycmF5KTtcclxuICAgICAgICB0aGlzLmJpbmRCdWZmZXJzKCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVWZXJ0ZXhTaGFkZXIoKTtcclxuICAgICAgICB0aGlzLl9mcmFtZUJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlMCA9IHdlYkdMSGVscGVyXzEuV2ViR0xIZWxwZXIuY3JlYXRlVGV4dHVyZSh0aGlzLl9jb250ZXh0LCB0aGlzLl9pcHQuZGF0YSwgdGhpcy5fZGltZW5zaW9ucyk7XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZTEgPSB3ZWJHTEhlbHBlcl8xLldlYkdMSGVscGVyLmNyZWF0ZVRleHR1cmUodGhpcy5fY29udGV4dCwgbmV3IEludDMyQXJyYXkoaW1hZ2VTaXplKSwgdGhpcy5fZGltZW5zaW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGltZW5zaW9ucyBmcm9tIHRoZSB3b3JrZXIuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGltZW5zaW9ucy5cclxuICAgICAqL1xyXG4gICAgZ2V0RGltZW5zaW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGltZW5zaW9ucztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBJUFQgZnJvbSB0aGUgd29ya2VyLlxyXG4gICAgICogQHJldHVybiBUaGUgaXB0LlxyXG4gICAgICovXHJcbiAgICBnZXRJcHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lwdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgcHJvZ3JhbSB0byB0aGUgd29ya2VyLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb2dyYW0gdG8gYWRkLlxyXG4gICAgICogQHBhcmFtIGNvZGUgVGhlIGNvZGUgZm9yIHRoZSBwcm9ncmFtLlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1zIEFkZGl0aW9uYWwgdW5pZm9ybSBsb2NhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGFkZFByb2dyYW0obmFtZSwgY29kZSwgLi4udW5pZm9ybXMpIHtcclxuICAgICAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IHRoaXMuY3JlYXRlRnJhZ21lbnRTaGFkZXIoY29kZSk7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHRoaXMuX3ZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIHRoaXMuX2F0dHJpYi5wb3NpdGlvbiwgXCJwb3NpdGlvblwiKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCB0aGlzLl9hdHRyaWIudGV4dHVyZSwgXCJ0ZXh0dXJlXCIpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgY29uc3QgdW5pZm9ybVZhcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiB1bmlmb3Jtcykge1xyXG4gICAgICAgICAgICB1bmlmb3JtVmFycy5zZXQodmFyaWFibGUsIHRoaXMuX2NvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHZhcmlhYmxlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Byb2dyYW1zLnNldChuYW1lLCB7IHByb2dyYW0sIHVuaWZvcm1WYXJzIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW4gdGhlIHByb2dyYW0gaW4gdGhlIHdlYiB3b3JrZXIuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvZ3JhbSB0byBydW4uXHJcbiAgICAgKiBAcGFyYW0gY291bnQgVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gaXQuXHJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybXMgQWRkaXRpb25hbCB1bmlmb3JtIGxvY2F0aW9ucyB0byB1c2UuXHJcbiAgICAgKi9cclxuICAgIHJ1blByb2dyYW0obmFtZSwgY291bnQsIC4uLnVuaWZvcm1zKSB7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuX3Byb2dyYW1zLmdldChuYW1lKTtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gaW5mby5wcm9ncmFtO1xyXG4gICAgICAgIGlmICghdGhpcy5fY29udGV4dC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHRoaXMuX2NvbnRleHQuTElOS19TVEFUVVMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiRmFpbGVkIHRvIGxpbmsgR0xTTCBwcm9ncmFtIGNvZGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuaWZvcm1WYXJzID0gaW5mby51bmlmb3JtVmFycztcclxuICAgICAgICBjb25zdCB1VGV4dHVyZSA9IHRoaXMuX2NvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV90ZXh0dXJlXCIpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBsZXQgbG9jYWxDb3VudCA9IGNvdW50O1xyXG4gICAgICAgIHdoaWxlIChsb2NhbENvdW50LS0gPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUodGhpcy5fY29udGV4dC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYWN0aXZlVGV4dHVyZSh0aGlzLl9jb250ZXh0LlRFWFRVUkUwKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC51bmlmb3JtMWkodVRleHR1cmUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnZpZXdwb3J0KDAsIDAsIHRoaXMuX2RpbWVuc2lvbnMueCwgdGhpcy5fZGltZW5zaW9ucy55KTtcclxuICAgICAgICAgICAgd2ViR0xIZWxwZXJfMS5XZWJHTEhlbHBlci5mcmFtZUJ1ZmZlclNldFRleHR1cmUodGhpcy5fY29udGV4dCwgdGhpcy5fZnJhbWVCdWZmZXIsIHRoaXMuX3RleHR1cmUxKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmVydGV4QXJyYXkodGhpcy5fdmVydGV4QXJyYXkpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVWYXJzIG9mIHVuaWZvcm1zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LnVuaWZvcm0xaSh1bmlmb3JtVmFycy5nZXQodVZhcnMubmFtZSksIHVWYXJzLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdFbGVtZW50cyh0aGlzLl9jb250ZXh0LlRSSUFOR0xFUywgNiwgdGhpcy5fY29udGV4dC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleDAgPSB0aGlzLl90ZXh0dXJlMDtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZTAgPSB0aGlzLl90ZXh0dXJlMTtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZTEgPSB0ZXgwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZpbmlzaFJ1bigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGRhdGEgZnJvbSB0aGUgd29ya2VyLlxyXG4gICAgICogQHBhcmFtIHggVGhlIHggcG9zaXRpb24gdG8gcmVhZCBmcm9tLlxyXG4gICAgICogQHBhcmFtIHkgVGhlIHkgcG9zaXRpb24gdG8gcmVhZCBmcm9tLlxyXG4gICAgICogQHBhcmFtIG4gVGhlIHdpZHRoIHBvc2l0aW9uIHRvIHJlYWQgZnJvbS5cclxuICAgICAqIEBwYXJhbSBtIFRoZSBoZWlnaHQgcG9zaXRpb24gdG8gcmVhZCBmcm9tLlxyXG4gICAgICovXHJcbiAgICByZWFkRGF0YSh4LCB5LCBuLCBtKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY29udGV4dC5GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQucmVhZFBpeGVscyh4LCB5LCBuLCBtLCB0aGlzLl9jb250ZXh0LlJHQkFfSU5URUdFUiwgdGhpcy5fY29udGV4dC5JTlQsIHRoaXMuX2lwdC5kYXRhKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jb250ZXh0LkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXB0LmRhdGEuc3ViYXJyYXkoMCwgdGhpcy5faXB0Lmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlIGRhdGEgdG8gdGhlIHdvcmtlci5cclxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHdyaXRlLlxyXG4gICAgICovXHJcbiAgICB3cml0ZURhdGEoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUodGhpcy5fY29udGV4dC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC50ZXhJbWFnZTJEKHRoaXMuX2NvbnRleHQuVEVYVFVSRV8yRCwgMCwgdGhpcy5fY29udGV4dC5SR0JBMzJJLCB0aGlzLl9kaW1lbnNpb25zLngsIHRoaXMuX2RpbWVuc2lvbnMueSwgMCwgdGhpcy5fY29udGV4dC5SR0JBX0lOVEVHRVIsIHRoaXMuX2NvbnRleHQuSU5ULCBkYXRhKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHRoaXMuX2NvbnRleHQuVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGJpbmRCdWZmZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZEJ1ZmZlcih0aGlzLl9jb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5fYnVmZmVycy50ZXh0dXJlKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYi50ZXh0dXJlKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmliLnRleHR1cmUsIDIsIHRoaXMuX2NvbnRleHQuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRCdWZmZXIodGhpcy5fY29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMuX2J1ZmZlcnMucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliLnBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmliLnBvc2l0aW9uLCAyLCB0aGlzLl9jb250ZXh0LkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kQnVmZmVyKHRoaXMuX2NvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2J1ZmZlcnMuaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBjcmVhdGVWZXJ0ZXhTaGFkZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4U2hhZGVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVTaGFkZXIodGhpcy5fY29udGV4dC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRlclNvdXJjZSh0aGlzLl92ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlckNvZGVfMS5kZWZhdWx0KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNvbXBpbGVTaGFkZXIodGhpcy5fdmVydGV4U2hhZGVyKTtcclxuICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgZmFpbC5cclxuICAgICAgICBpZiAoIXRoaXMuX2NvbnRleHQuZ2V0U2hhZGVyUGFyYW1ldGVyKHRoaXMuX3ZlcnRleFNoYWRlciwgdGhpcy5fY29udGV4dC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoYENvdWxkIG5vdCBidWlsZCB2ZXJ0ZXggc2hhZGVyLlxuXG4tLS0gQ09ERSBEVU1QIC0tLSR7dmVydGV4U2hhZGVyQ29kZV8xLmRlZmF1bHR9XG5cbi0tLSBFUlJPUiBMT0cgLS0tXG4ke3RoaXMuX2NvbnRleHQuZ2V0U2hhZGVySW5mb0xvZyh0aGlzLl92ZXJ0ZXhTaGFkZXIpfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgY3JlYXRlRnJhZ21lbnRTaGFkZXIoY29kZSkge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVTaGFkZXIodGhpcy5fY29udGV4dC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBzdGRsaWJfMS5kZWZhdWx0ICsgY29kZSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICAvLyBVc2UgdGhpcyBvdXRwdXQgdG8gZGVidWcgdGhlIHNoYWRlclxyXG4gICAgICAgIC8vIEtlZXAgaW4gbWluZCB0aGF0IFdlYkdMIEdMU0wgaXMgKiptdWNoKiogc3RyaWN0ZXIgdGhhbiBlLmcuIE9wZW5HTCBHTFNMXHJcbiAgICAgICAgaWYgKCF0aGlzLl9jb250ZXh0LmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgdGhpcy5fY29udGV4dC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZUxpbmVzID0gY29kZS5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICAgICAgbGV0IGRiZ01zZyA9IFwiQ291bGQgbm90IGJ1aWxkIGZyYWdtZW50IHNoYWRlci5cXG5cXG4tLS0tLS0tLS0tLS0tLS0tLS0gS0VSTkVMIENPREUgRFVNUCAtLS0tLS0tLS0tLS0tLS0tLS1cXG5cIjtcclxuICAgICAgICAgICAgZm9yIChsZXQgbmwgPSAwOyBubCA8IGNvZGVMaW5lcy5sZW5ndGg7IG5sKyspIHtcclxuICAgICAgICAgICAgICAgIGRiZ01zZyArPSBgJHtzdGRsaWJfMS5kZWZhdWx0LnNwbGl0KFwiXFxuXCIpLmxlbmd0aCArIG5sfT4gJHtjb2RlTGluZXNbbmxdfVxcbmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGJnTXNnICs9IGBcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVJST1IgIExPRyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4ke3RoaXMuX2NvbnRleHQuZ2V0U2hhZGVySW5mb0xvZyhmcmFnbWVudFNoYWRlcil9YDtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoZGJnTXNnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBmaW5pc2hSdW4oKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZSh0aGlzLl9jb250ZXh0LlRFWFRVUkVfMkQsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NvbnRleHQuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuV2ViR0xXb3JrZXIgPSBXZWJHTFdvcmtlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZDJWaVIweFhiM0pyWlhJdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12ZDJWaVIwd3ZkMlZpUjB4WGIzSnJaWEl1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN096dEJRVUZCTERCRlFVRjFSVHRCUVVWMlJTeHpSRUZCT0VJN1FVRkRPVUlzTUVWQlFXdEVPMEZCUTJ4RUxDdERRVUUwUXp0QlFVazFRenM3UjBGRlJ6dEJRVU5JTzBsQmQwSkpPenM3T3p0UFFVdEhPMGxCUTBrc1ZVRkJWU3hEUVVGRExHRkJRVFpDTEVWQlFVVXNWMEZCYlVJc1JVRkJSU3hUUVVGcFFqdFJRVU51Uml4SlFVRkpMRU5CUVVNc1VVRkJVU3hIUVVGSExIbENRVUZYTEVOQlFVTXNZVUZCWVN4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRE8xRkJRM3BFTEVsQlFVa3NRMEZCUXl4WFFVRlhMRWRCUVVjc1JVRkJSU3hEUVVGRExFVkJRVVVzVjBGQlZ5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJRenRSUVVVMVF5eE5RVUZOTEZsQlFWa3NSMEZCUnl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNaMEpCUVdkQ0xFVkJRVVVzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRPMUZCUTNaRkxFMUJRVTBzVTBGQlV5eEhRVUZITEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1dVRkJXU3hIUVVGSExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXl4SFFVRkhMRk5CUVZNc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXl4SFFVRkhMRk5CUVZNc1EwRkJRenRSUVVNM1J5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhUUVVGVExFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1UwRkJVeXhEUVVGRE8xRkJSV2hGTEVsQlFVa3NRMEZCUXl4VFFVRlRMRWRCUVVjc1NVRkJTU3hIUVVGSExFVkJRVVVzUTBGQlF6dFJRVU16UWl4SlFVRkpMRU5CUVVNc1NVRkJTU3hIUVVGSE8xbEJRMUlzU1VGQlNTeEZRVUZGTEVsQlFVa3NWVUZCVlN4RFFVRkRMRk5CUVZNc1EwRkJRenRaUVVNdlFpeE5RVUZOTEVWQlFVVXNVMEZCVXp0VFFVTndRaXhEUVVGRE8xRkJSVVlzTWtOQlFUSkRPMUZCUXpORExFbEJRVWtzUTBGQlF5eFJRVUZSTEVkQlFVYzdXVUZEV2l4UlFVRlJMRVZCUVVVc2VVSkJRVmNzUTBGQlF5eFpRVUZaTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF5OUZMRTlCUVU4c1JVRkJSU3g1UWtGQlZ5eERRVUZETEZsQlFWa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRekZGTEV0QlFVc3NSVUZCUlN4NVFrRkJWeXhEUVVGRExGbEJRVmtzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUlVGQlJTeFhRVUZYTEVWQlFVVXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXh2UWtGQmIwSXNRMEZCUXp0VFFVTjBTQ3hEUVVGRE8xRkJSVVlzU1VGQlNTeERRVUZETEU5QlFVOHNSMEZCUnp0WlFVTllMRkZCUVZFc1JVRkJSU3hEUVVGRE8xbEJRMWdzVDBGQlR5eEZRVUZGTEVOQlFVTTdVMEZEWWl4RFFVRkRPMUZCUlVZc1NVRkJTU3hEUVVGRExGbEJRVmtzUjBGQlJ5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMR2xDUVVGcFFpeEZRVUZGTEVOQlFVTTdVVUZEZEVRc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eGxRVUZsTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRE8xRkJRMnBFTEVsQlFVa3NRMEZCUXl4WFFVRlhMRVZCUVVVc1EwRkJRenRSUVVOdVFpeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMR1ZCUVdVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU53UXl4SlFVRkpMRU5CUVVNc2EwSkJRV3RDTEVWQlFVVXNRMEZCUXp0UlFVTXhRaXhKUVVGSkxFTkJRVU1zV1VGQldTeEhRVUZITEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc2FVSkJRV2xDTEVWQlFVVXNRMEZCUXp0UlFVTjBSQ3hKUVVGSkxFTkJRVU1zVTBGQlV5eEhRVUZITEhsQ1FVRlhMRU5CUVVNc1lVRkJZU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVWQlFVVXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMUZCUXpWR0xFbEJRVWtzUTBGQlF5eFRRVUZUTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhoUVVGaExFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNSVUZCUlN4SlFVRkpMRlZCUVZVc1EwRkJReXhUUVVGVExFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNN1NVRkRNMGNzUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxHRkJRV0U3VVVGRGFFSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVU03U1VGRE5VSXNRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5KTEUxQlFVMDdVVUZEVkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF6dEpRVU55UWl4RFFVRkRPMGxCUlVRN096czdPMDlCUzBjN1NVRkRTU3hWUVVGVkxFTkJRVU1zU1VGQldTeEZRVUZGTEVsQlFWa3NSVUZCUlN4SFFVRkhMRkZCUVd0Q08xRkJReTlFTEUxQlFVMHNZMEZCWXl4SFFVRkhMRWxCUVVrc1EwRkJReXh2UWtGQmIwSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOMlJDeE5RVUZOTEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExHRkJRV0VzUlVGQlJTeERRVUZETzFGQlJUbERMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zV1VGQldTeERRVUZETEU5QlFVOHNSVUZCUlN4SlFVRkpMRU5CUVVNc1lVRkJZU3hEUVVGRExFTkJRVU03VVVGRGVFUXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhaUVVGWkxFTkJRVU1zVDBGQlR5eEZRVUZGTEdOQlFXTXNRMEZCUXl4RFFVRkRPMUZCUTNCRUxFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETzFGQlF6ZEZMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1QwRkJUeXhGUVVGRkxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8xRkJRek5GTEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1YwRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzFGQlEyNURMRTFCUVUwc1YwRkJWeXhIUVVGSExFbEJRVWtzUjBGQlJ5eEZRVUZuUXl4RFFVRkRPMUZCUXpWRUxFZEJRVWNzUTBGQlF5eERRVUZETEUxQlFVMHNVVUZCVVN4SlFVRkpMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE9VSXNWMEZCVnl4RFFVRkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFVkJRVVVzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4clFrRkJhMElzUTBGQlF5eFBRVUZQTEVWQlFVVXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOdVJpeERRVUZETzFGQlEwUXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhIUVVGSExFTkJRVU1zU1VGQlNTeEZRVUZGTEVWQlFVVXNUMEZCVHl4RlFVRkZMRmRCUVZjc1JVRkJSU3hEUVVGRExFTkJRVU03U1VGRGRrUXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1ZVRkJWU3hEUVVGRExFbEJRVmtzUlVGQlJTeExRVUZoTEVWQlFVVXNSMEZCUnl4UlFVRjFRenRSUVVOeVJpeE5RVUZOTEVsQlFVa3NSMEZCUnl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTjBReXhOUVVGTkxFOUJRVThzUjBGQlJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRPMUZCUlRkQ0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRla1VzVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2EwTkJRV3RETEVOQlFVTXNRMEZCUXp0UlFVTTVSQ3hEUVVGRE8xRkJSVVFzVFVGQlRTeFhRVUZYTEVkQlFVY3NTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJRenRSUVVOeVF5eE5RVUZOTEZGQlFWRXNSMEZCUnl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExHdENRVUZyUWl4RFFVRkRMRTlCUVU4c1JVRkJSU3hYUVVGWExFTkJRVU1zUTBGQlF6dFJRVU40UlN4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExGVkJRVlVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVVnNReXhKUVVGSkxGVkJRVlVzUjBGQlJ5eExRVUZMTEVOQlFVTTdVVUZEZGtJc1QwRkJUeXhWUVVGVkxFVkJRVVVzUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXp0WlFVTjBRaXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEZkQlFWY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExGVkJRVlVzUlVGQlJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNN1dVRkRjRVVzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4aFFVRmhMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0WlFVTndSQ3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRmNrTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0pGTEhsQ1FVRlhMRU5CUVVNc2NVSkJRWEZDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJSU3hKUVVGSkxFTkJRVU1zV1VGQldTeEZRVUZGTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJRenRaUVVOd1JpeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMR1ZCUVdVc1EwRkJReXhKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTTdXVUZEYWtRc1IwRkJSeXhEUVVGRExFTkJRVU1zVFVGQlRTeExRVUZMTEVsQlFVa3NVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE0wSXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhUUVVGVExFTkJRVU1zVjBGQlZ5eERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMWxCUTNSRkxFTkJRVU03V1VGRFJDeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRmxCUVZrc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEZOQlFWTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eGpRVUZqTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkZlRVlzVFVGQlRTeEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJRenRaUVVNMVFpeEpRVUZKTEVOQlFVTXNVMEZCVXl4SFFVRkhMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU03V1VGRGFFTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1IwRkJSeXhKUVVGSkxFTkJRVU03VVVGRE1VSXNRMEZCUXp0UlFVVkVMRWxCUVVrc1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF6dEpRVU55UWl4RFFVRkRPMGxCUlVRN096czdPenRQUVUxSE8wbEJRMGtzVVVGQlVTeERRVUZETEVOQlFWTXNSVUZCUlN4RFFVRlRMRVZCUVVVc1EwRkJVeXhGUVVGRkxFTkJRVk03VVVGRGRFUXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhsUVVGbExFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4WFFVRlhMRVZCUVVVc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETzFGQlF6VkZMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRmxCUVZrc1JVRkJSU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NSVUZCUlN4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEzQkhMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zWlVGQlpTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1YwRkJWeXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzFGQlF5OUVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhGUVVGRkxFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRlRVFzUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxGTkJRVk1zUTBGQlF5eEpRVUZ4UWp0UlFVTnNReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEZkQlFWY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExGVkJRVlVzUlVGQlJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNN1VVRkRjRVVzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4VlFVRlZMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFZRVUZWTEVWQlFVVXNRMEZCUXl4RlFVRkZMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJReXhGUVVGRkxFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEZsQlFWa3NSVUZCUlN4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTTNTeXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEZkQlFWY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExGVkJRVlVzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTTVSQ3hEUVVGRE8wbEJSVVFzWlVGQlpUdEpRVU5RTEZkQlFWYzdVVUZEWml4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRmxCUVZrc1JVRkJSU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMUZCUXpWRkxFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNkVUpCUVhWQ0xFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVNMVJDeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRzFDUVVGdFFpeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1JVRkJSU3hMUVVGTExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpkR0xFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zV1VGQldTeEZRVUZGTEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03VVVGRE4wVXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXgxUWtGQmRVSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETzFGQlF6ZEVMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RlFVRkZMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUzBGQlN5eEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE9VWXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4dlFrRkJiMElzUlVGQlJTeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRM1JHTEVOQlFVTTdTVUZGUkN4bFFVRmxPMGxCUTFBc2EwSkJRV3RDTzFGQlEzUkNMRWxCUVVrc1EwRkJReXhoUVVGaExFZEJRVWNzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4WlFVRlpMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXp0UlFVTTNSU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEZsQlFWa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1lVRkJZU3hGUVVGRkxEQkNRVUZuUWl4RFFVRkRMRU5CUVVNN1VVRkRha1VzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4aFFVRmhMRU5CUVVNc1NVRkJTU3hEUVVGRExHRkJRV0VzUTBGQlF5eERRVUZETzFGQlJXaEVMSGRDUVVGM1FqdFJRVU40UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zU1VGQlNTeERRVUZETEdGQlFXRXNSVUZCUlN4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjBSaXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZEYWtJN08yMUNRVVZITERCQ1FVRm5RanM3TzBWQlIycERMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1NVRkJTU3hEUVVGRExHRkJRV0VzUTBGQlF5eEZRVUZGTEVOQlEzcERMRU5CUVVNN1VVRkRUaXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVVZFTEdWQlFXVTdTVUZEVUN4dlFrRkJiMElzUTBGQlF5eEpRVUZaTzFGQlEzSkRMRTFCUVUwc1kwRkJZeXhIUVVGSExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNXVUZCV1N4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zWlVGQlpTeERRVUZETEVOQlFVTTdVVUZGYWtZc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFpRVUZaTEVOQlFVTXNZMEZCWXl4RlFVRkZMR2RDUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETEVOQlFVTTdVVUZGTVVRc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eGhRVUZoTEVOQlFVTXNZMEZCWXl4RFFVRkRMRU5CUVVNN1VVRkZOVU1zYzBOQlFYTkRPMUZCUTNSRExEQkZRVUV3UlR0UlFVTXhSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc2EwSkJRV3RDTEVOQlFVTXNZMEZCWXl4RlFVRkZMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4R0xFMUJRVTBzVTBGQlV5eEhRVUZITEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRGJrTXNTVUZCU1N4TlFVRk5MRWRCUVVjc09FWkJRVGhHTEVOQlFVTTdXVUZGTlVjc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeEZRVUZGTEVkQlFVY3NRMEZCUXl4RlFVRkZMRVZCUVVVc1IwRkJSeXhUUVVGVExFTkJRVU1zVFVGQlRTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRU5CUVVNN1owSkJRek5ETEUxQlFVMHNTVUZCU1N4SFFVRkhMR2RDUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhGUVVGRkxFdEJRVXNzVTBGQlV5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNN1dVRkRkRVVzUTBGQlF6dFpRVVZFTEUxQlFVMHNTVUZCU1N3MlJFRkJOa1FzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4blFrRkJaMElzUTBGQlF5eGpRVUZqTEVOQlFVTXNSVUZCUlN4RFFVRkRPMWxCUlhoSUxFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJRMnhETEVOQlFVTTdVVUZEUkN4TlFVRk5MRU5CUVVNc1kwRkJZeXhEUVVGRE8wbEJRekZDTEVOQlFVTTdTVUZGUkN4bFFVRmxPMGxCUTFBc1UwRkJVenRSUVVOaUxFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNaVUZCWlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRM0JETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1YwRkJWeXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNWVUZCVlN4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRekZFTEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1pVRkJaU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNWMEZCVnl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRMjVGTEVOQlFVTTdRMEZEU2p0QlFYSlBSQ3hyUTBGeFQwTWlmUT09XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uL3NyYy93ZWJHTC93ZWJHTFdvcmtlci50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFN0ZGxpYi5cclxuICovXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGAjdmVyc2lvbiAzMDAgZXNcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbnByZWNpc2lvbiBoaWdocCBpbnQ7XG5wcmVjaXNpb24gaGlnaHAgaXNhbXBsZXIyRDtcbnVuaWZvcm0gaXNhbXBsZXIyRCB1X3RleHR1cmU7XG5pbiB2ZWMyIHBvcztcbm91dCBpdmVjNCBjb2xvcjtcbi8vb3V0IGludCBpc0ZpbmlzaGVkO1xuXG52ZWMyIHNpemU7XG5pdmVjMiBteV9jb29yZDtcblxudm9pZCBpbml0KHZvaWQpIHtcbiAgLy9zaXplID0gdmVjMih0ZXh0dXJlU2l6ZSh1X3RleHR1cmUsIDApIC0gMSk7XG4gIHNpemUgPSB2ZWMyKHRleHR1cmVTaXplKHVfdGV4dHVyZSwgMCkpO1xuICBteV9jb29yZCA9IGl2ZWMyKHBvcyAqIHNpemUpO1xufVxuXG5pdmVjNCByZWFkKHZvaWQpIHtcbiAgcmV0dXJuIHRleHR1cmUodV90ZXh0dXJlLCBwb3MpO1xufVxuXG5pdmVjNCByZWFkX2F0KGl2ZWMyIGNvb3JkKSB7XG4gIHJldHVybiB0ZXhlbEZldGNoKHVfdGV4dHVyZSwgY29vcmQsIDApO1xufVxuXG52b2lkIGNvbW1pdChpdmVjNCB2YWwpIHtcbiAgY29sb3IgPSB2YWw7XG59XG5gO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljM1JrYkdsaUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDNkbFlrZE1MM04wWkd4cFlpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN08wZEJSVWM3UVVGRFNDeHJRa0ZEUVRzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN1EwRTJRa01zUTBGQlF5SjlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vc3JjL3dlYkdML3N0ZGxpYi50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFZlcnRleCBTaGFkZXIgY29kZS5cclxuICovXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGAjdmVyc2lvbiAzMDAgZXNcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzIgcG9zaXRpb247XG5sYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWMyIHRleHR1cmU7XG5vdXQgdmVjMiBwb3M7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIHBvcyA9IHRleHR1cmU7XG4gIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbi54eSwgMC4wLCAxLjApO1xufWA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRtVnlkR1Y0VTJoaFpHVnlRMjlrWlM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTkzWldKSFRDOTJaWEowWlhoVGFHRmtaWEpEYjJSbExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVRzN1IwRkZSenRCUVVOSUxHdENRVU5CT3pzN096czdPenRGUVZGRkxFTkJRVU1pZlE9PVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvd2ViR0wvdmVydGV4U2hhZGVyQ29kZS50cyIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IGNyeXB0b0Vycm9yXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jcnlwdG8vZGlzdC9lcnJvci9jcnlwdG9FcnJvclwiKTtcclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIHVzZSB3aXRoIFdlYkdMLlxyXG4gKi9cclxuY2xhc3MgV2ViR0xIZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBXZWJHTCBDb250ZXh0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbnRleHQgaWYgc3VjY2Vzc2Z1bHkgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGl0IGNhbm5vdCBiZSBjcmVhdGVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlQ29udGV4dCh3ZWJHTFBsYXRmb3JtKSB7XHJcbiAgICAgICAgY29uc3Qgd2luZG93ID0gd2ViR0xQbGF0Zm9ybS5nZXRXaW5kb3coKTtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHdpbmRvdykgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IHdlYkdMUGxhdGZvcm0uZ2V0RG9jdW1lbnQod2luZG93KTtcclxuICAgICAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShkb2N1bWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IHdlYkdMUGxhdGZvcm0uZ2V0Q2FudmFzKGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkoY2FudmFzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdsID0gd2ViR0xQbGF0Zm9ybS5nZXRXZWJHTChjYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShnbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJDYW4gbm90IGNyZWF0ZSBhIFdlYkdMIGNvbnRleHQgb24gYSA8Y2FudmFzPiBlbGVtZW50LlwiLCB7IHVzZXJBZ2VudDogd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIEhUTUw1IDxjYW52YXM+IGVsZW1lbnQgaXMgbm90IGF2YWlsYWJsZSBpbiB5b3VyIGJyb3dzZXIuXCIsIHsgdXNlckFnZW50OiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwid2luZG93LmRvY3VtZW50IGlzIG5vdCBhdmFpbGFibGUsIHlvdSBtdXN0IGJlIHJ1bm5pbmcgaW4gYW4gZW52aXJvbm1lbnQgd2l0aCBXZWJHTC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwid2luZG93IGlzIG5vdCBhdmFpbGFibGUsIHlvdSBtdXN0IGJlIHJ1bm5pbmcgaW4gYW4gZW52aXJvbm1lbnQgd2l0aCBXZWJHTC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgV2ViR0wgYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIGdsIFRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGFkZCB0byB0aGUgYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIGFycmF5VHlwZSBUaGUgZGF0YSB0eXBlIGZvciB0aGUgYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBBIEdMIEVudW0gc3BlY2lmeWluZyB0aGUgYmluZGluZyBwb2ludCAodGFyZ2V0KS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBXZWJHTCBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVCdWZmZXIoZ2wsIGRhdGEsIGFycmF5VHlwZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3QgYnVmID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcigodGFyZ2V0IHx8IGdsLkFSUkFZX0JVRkZFUiksIGJ1Zik7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSgodGFyZ2V0IHx8IGdsLkFSUkFZX0JVRkZFUiksIG5ldyAoYXJyYXlUeXBlIHx8IEZsb2F0MzJBcnJheSkoZGF0YSksIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICByZXR1cm4gYnVmO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2ZlciBkYXRhIG9udG8gY2xhbXBlZCB0ZXh0dXJlIGFuZCB0dXJuIG9mZiBhbnkgZmlsdGVyaW5nXHJcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIHBpeGVsRGF0YSBUaGUgcGl4ZWwgZGF0YSB0byBjcmVhdGUgdGhlIHZpZXcgZnJvbS5cclxuICAgICAqIEBwYXJhbSBkaW1lbnNpb25zIFRoZSBkaW1lbnNpb25zIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlVGV4dHVyZShnbCwgcGl4ZWxEYXRhLCBkaW1lbnNpb25zKSB7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMySSwgZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLnksIDAsIGdsLlJHQkFfSU5URUdFUiwgZ2wuSU5ULCBwaXhlbERhdGEpO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRleHVyZSBpbnRvIHRoZSBmcmFtZWJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gZnJhbWVCdWZmZXIgVGhlIGZyYW1lIGJ1ZmZlciB0byBzZXQgdGhlIHRleHQgaW4gdG8uXHJcbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBUaGUgdGV4dHVyZSB0byBzZXQgaW4gdG8gdGhlIGZyYW1lYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJhbWVCdWZmZXJTZXRUZXh0dXJlKGdsLCBmcmFtZUJ1ZmZlciwgdGV4dHVyZSkge1xyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XHJcbiAgICAgICAgLy8gVGVzdCBmb3IgbW9iaWxlIGJ1ZyBNRE4tPldlYkdMX2Jlc3RfcHJhY3RpY2VzLCBidWxsZXQgN1xyXG4gICAgICAgIGNvbnN0IGZyYW1lQnVmZmVyU3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XHJcbiAgICAgICAgaWYgKGZyYW1lQnVmZmVyU3RhdHVzICE9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIkVycm9yIGF0dGFjaGluZyBmbG9hdCB0ZXh0dXJlIHRvIGZyYW1lYnVmZmVyLiBZb3VyIGRldmljZSBpcyBwcm9iYWJseSBpbmNvbXBhdGlibGUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLldlYkdMSGVscGVyID0gV2ViR0xIZWxwZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWQyVmlSMHhJWld4d1pYSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdmQyVmlSMHd2ZDJWaVIweElaV3h3WlhJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTERSRlFVRjVSVHRCUVVONlJTd3dSVUZCZFVVN1FVRkpka1U3TzBkQlJVYzdRVUZEU0R0SlFVTkpPenM3VDBGSFJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNc1lVRkJOa0k3VVVGRGNrUXNUVUZCVFN4TlFVRk5MRWRCUVVjc1lVRkJZU3hEUVVGRExGTkJRVk1zUlVGQlJTeERRVUZETzFGQlJYcERMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzVDBGQlR5eE5RVUZOTEV0QlFVc3NWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOcVJTeE5RVUZOTEZGQlFWRXNSMEZCUnl4aFFVRmhMRU5CUVVNc1YwRkJWeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFsQlJXNUVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTnNReXhOUVVGTkxFMUJRVTBzUjBGQlJ5eGhRVUZoTEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8yZENRVVZxUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZEYUVNc1RVRkJUU3hGUVVGRkxFZEJRVWNzWVVGQllTeERRVUZETEZGQlFWRXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenR2UWtGRk1VTXNSVUZCUlN4RFFVRkRMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8zZENRVU16UWl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eDFSRUZCZFVRc1JVRkJSU3hGUVVGRkxGTkJRVk1zUlVGQlJTeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRk5CUVZNc1JVRkJSU3hEUVVGRExFTkJRVU03YjBKQlF6bElMRU5CUVVNN2IwSkJSVVFzVFVGQlRTeERRVUZETEVWQlFVVXNRMEZCUXp0blFrRkRaQ3hEUVVGRE8yZENRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMjlDUVVOS0xFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMRGhFUVVFNFJDeEZRVUZGTEVWQlFVVXNVMEZCVXl4RlFVRkZMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU1zVTBGQlV5eEZRVUZGTEVOQlFVTXNRMEZCUXp0blFrRkRja2tzUTBGQlF6dFpRVU5NTEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRFNpeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXh4UmtGQmNVWXNRMEZCUXl4RFFVRkRPMWxCUTJwSUxFTkJRVU03VVVGRFRDeERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRTaXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl3MFJVRkJORVVzUTBGQlF5eERRVUZETzFGQlEzaEhMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJSVVE3T3pzN096czdUMEZQUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUlVGQk5FSXNSVUZCUlN4SlFVRnBRaXhGUVVGRkxGTkJRV1VzUlVGQlJTeE5RVUZsTzFGQlEzaEhMRTFCUVUwc1IwRkJSeXhIUVVGSExFVkJRVVVzUTBGQlF5eFpRVUZaTEVWQlFVVXNRMEZCUXp0UlFVVTVRaXhGUVVGRkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNUVUZCVFN4SlFVRkpMRVZCUVVVc1EwRkJReXhaUVVGWkxFTkJRVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVTm9SQ3hGUVVGRkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNUVUZCVFN4SlFVRkpMRVZCUVVVc1EwRkJReXhaUVVGWkxFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4SlFVRkpMRmxCUVZrc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJRenRSUVVWc1J5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRPMGxCUTJZc1EwRkJRenRKUVVWRU96czdPenM3VDBGTlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNc1JVRkJORUlzUlVGQlJTeFRRVUV3UWl4RlFVRkZMRlZCUVc5RE8xRkJRM1JJTEUxQlFVMHNUMEZCVHl4SFFVRkhMRVZCUVVVc1EwRkJReXhoUVVGaExFVkJRVVVzUTBGQlF6dFJRVVZ1UXl4RlFVRkZMRU5CUVVNc1YwRkJWeXhEUVVGRExFVkJRVVVzUTBGQlF5eFZRVUZWTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkRka01zUlVGQlJTeERRVUZETEdGQlFXRXNRMEZCUXl4RlFVRkZMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFVkJRVVVzUTBGQlF5eGpRVUZqTEVWQlFVVXNSVUZCUlN4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRE8xRkJRM0pGTEVWQlFVVXNRMEZCUXl4aFFVRmhMRU5CUVVNc1JVRkJSU3hEUVVGRExGVkJRVlVzUlVGQlJTeEZRVUZGTEVOQlFVTXNZMEZCWXl4RlFVRkZMRVZCUVVVc1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlF6dFJRVU55UlN4RlFVRkZMRU5CUVVNc1lVRkJZU3hEUVVGRExFVkJRVVVzUTBGQlF5eFZRVUZWTEVWQlFVVXNSVUZCUlN4RFFVRkRMR3RDUVVGclFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVOdVJTeEZRVUZGTEVOQlFVTXNZVUZCWVN4RFFVRkRMRVZCUVVVc1EwRkJReXhWUVVGVkxFVkJRVVVzUlVGQlJTeERRVUZETEd0Q1FVRnJRaXhGUVVGRkxFVkJRVVVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTnVSU3hGUVVGRkxFTkJRVU1zVlVGQlZTeERRVUZETEVWQlFVVXNRMEZCUXl4VlFVRlZMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF5eFBRVUZQTEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNc1JVRkJSU3hWUVVGVkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNc1dVRkJXU3hGUVVGRkxFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1VVRkRMMGNzUlVGQlJTeERRVUZETEZkQlFWY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzFGQlJYQkRMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU03U1VGRGJrSXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1RVRkJUU3hEUVVGRExIRkNRVUZ4UWl4RFFVRkRMRVZCUVRSQ0xFVkJRVVVzVjBGQk5rSXNSVUZCUlN4UFFVRnhRanRSUVVOc1NDeEZRVUZGTEVOQlFVTXNaVUZCWlN4RFFVRkRMRVZCUVVVc1EwRkJReXhYUVVGWExFVkJRVVVzVjBGQlZ5eERRVUZETEVOQlFVTTdVVUZGYUVRc1JVRkJSU3hEUVVGRExHOUNRVUZ2UWl4RFFVRkRMRVZCUVVVc1EwRkJReXhYUVVGWExFVkJRVVVzUlVGQlJTeERRVUZETEdsQ1FVRnBRaXhGUVVGRkxFVkJRVVVzUTBGQlF5eFZRVUZWTEVWQlFVVXNUMEZCVHl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSWHBHTERCRVFVRXdSRHRSUVVNeFJDeE5RVUZOTEdsQ1FVRnBRaXhIUVVGSExFVkJRVVVzUTBGQlF5eHpRa0ZCYzBJc1EwRkJReXhGUVVGRkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTTdVVUZGY0VVc1JVRkJSU3hEUVVGRExFTkJRVU1zYVVKQlFXbENMRXRCUVVzc1JVRkJSU3hEUVVGRExHOUNRVUZ2UWl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOb1JDeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXh4UmtGQmNVWXNRMEZCUXl4RFFVRkRPMUZCUTJwSUxFTkJRVU03U1VGRFRDeERRVUZETzBOQlEwbzdRVUY2UmtRc2EwTkJlVVpESW4wPVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvd2ViR0wvd2ViR0xIZWxwZXIudHMiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBQZWFybERpdmVyIFN0YXRlLlxyXG4gKi9cclxudmFyIFBlYXJsRGl2ZXJTdGF0ZTtcclxuKGZ1bmN0aW9uIChQZWFybERpdmVyU3RhdGUpIHtcclxuICAgIFBlYXJsRGl2ZXJTdGF0ZVtQZWFybERpdmVyU3RhdGVbXCJyZWFkeVwiXSA9IDBdID0gXCJyZWFkeVwiO1xyXG4gICAgUGVhcmxEaXZlclN0YXRlW1BlYXJsRGl2ZXJTdGF0ZVtcInNlYXJjaGluZ1wiXSA9IDFdID0gXCJzZWFyY2hpbmdcIjtcclxuICAgIFBlYXJsRGl2ZXJTdGF0ZVtQZWFybERpdmVyU3RhdGVbXCJpbnRlcnJ1cHRlZFwiXSA9IC0xXSA9IFwiaW50ZXJydXB0ZWRcIjtcclxufSkoUGVhcmxEaXZlclN0YXRlID0gZXhwb3J0cy5QZWFybERpdmVyU3RhdGUgfHwgKGV4cG9ydHMuUGVhcmxEaXZlclN0YXRlID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0dWaGNteEVhWFpsY2xOMFlYUmxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwzQmxZWEpzUkdsMlpYSXZjR1ZoY214RWFYWmxjbE4wWVhSbExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVRzN1IwRkZSenRCUVVOSUxFbEJRVmtzWlVGSldEdEJRVXBFTEZkQlFWa3NaVUZCWlR0SlFVTjJRaXgxUkVGQlV5eERRVUZCTzBsQlExUXNLMFJCUVdFc1EwRkJRVHRKUVVOaUxHOUZRVUZuUWl4RFFVRkJPMEZCUTNCQ0xFTkJRVU1zUlVGS1Z5eGxRVUZsTEVkQlFXWXNkVUpCUVdVc1MwRkJaaXgxUWtGQlpTeFJRVWt4UWlKOVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi9zcmMvcGVhcmxEaXZlci9wZWFybERpdmVyU3RhdGUudHMiXSwic291cmNlUm9vdCI6IiJ9